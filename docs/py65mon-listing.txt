
; 64tass Turbo Assembler Macro V1.59.3120 listing file
; 64tass --nostart --list=docs/py65mon-listing.txt --labels=docs/py65mon-labelmap.txt --output TaliForth-py65mon.bin platform/platform-py65mon.asm
; Sat Jun 07 15:13:07 2025

;Offset	;Hex		;Monitor	;Source

;******  Processing input file: platform/platform-py65mon.asm

=$0100					RStack = $0100 ; begin of 6502 Return stack
=$ff					rsp0      = $ff		; initial Return Stack Pointer (6502 stack)
=$8000					cp_end = $8000 ; LastRAM byte available for Data
=84					PadOffset = 84	; offset from CP to PAD (holds number strings)
=79					MAX_LINE_LENGTH  = 79      ; output line size
=20					DDim = 20	; # of cells in data stack
=10					FDim = 10	; # of entries in floating-point stack
=8					DoStkDim = 8	; # of entries in Do stack
=["lf"]					TALI_OPTION_CR_EOL := [ "lf" ]
=$ff					bsize     = $ff		; size of input/output buffers
>0200					buffer0: .fill bsize	; input buffer

;******  Processing file: platform/../taliforth.asm

=					TALI_OPTIONAL_WORDS := ["fp","fpe","fpe2", "fpieee","fptrancendentals", "fphyperbolic", "ed", "editor", "ramdrive", "block", "environment?", "assembler", "wordlist" ]
=-1					err_Abort		= -1
=-2					err_AbortQuote		= -2
=-3					err_Stack_Overflow	= -3
=-4					err_Stack_Underflow	= -4
=-5					err_Return_Stack_Overflow = -5
=-6					err_Return_Stack_Underflow = -6
=-7					err_DoLoop_TooDeep	= -7	; do-loops nested too deeply during execution
=-8					err_Dictionary_Overflow	= -8
=-9					err_InvalidMemoryAddr	= -9	; invalid memory address
=-10					err_DivideBy0		= -10	; division by zero
=-11					err_OutOfRange		= -11	; result out of range
=-12					err_ArgTypeMismatch	= -12	; argument type mismatch
=-13					err_UndefinedWord	= -13
=-14					err_CompileOnly		= -14	; interpreting a compile-only word
=-15					err_Forget		= -15	; invalid FORGET
=-16					err_EmptyName		= -16	; attempt to use zero-length string as a name
=-17					err_PicStringOverflow	= -17	; pictured numeric output string overflow
=-18					err_ParsedStringOverflow = -18	; parsed string overflow
=-19					err_NameTooLong		= -19	; definition name too long
=-20					err_WriteToRO		= -20	; write to a read-only location
=-21					err_Unsupported		= -21	; unsupported operation  (e.g., AT-XY on a too-dumb terminal)
=-22					err_ControlMismatch	= -22	; control structure mismatch
=-23					err_AddrAlignment	= -23	; address alignment exception
=-24					err_InvalidNumericArg	= -24	; invalid numeric argument
=-25					err_ReturnStackImbalance = -25	; return stack imbalance
=-26					err_LoopParmUnavailable = -26	; loop parameters unavailable
=-27					err_InvalidRecursion	= -27	; invalid recursion
=-28					err_UserInterrupt	= -28	; user interrupt
=-29					err_CompilerNesting	= -29	; compiler nesting
=-30					err_Obsolete		= -30	; obsolescent feature
=-31					err_NoBody		= -31	; >BODY used on non-CREATEd definition
=-32					err_InvalidName		= -32	; invalid name argument (e.g., TO name)
=-33					err_BlockRead		= -33	; block read exception
=-34					err_BlockWrite		= -34	; block write exception
=-35					err_InvalidBlock	= -35	; invalid block number
=-36					err_InvalidFilePosition = -36	; invalid file position
=-37					err_FileIO		= -37	; file I/O exception
=-38					err_FileMissing		= -38	; non-existent file
=-39					err_EndOfFile		= -39	; unexpected end of file
=-40					err_InvalidBase		= -40	; invalid BASE for floating point conversion
=-41					err_LossOfPrecision	= -41	; loss of precision
=-42					err_FPDivideBy0		= -42	; floating-point divide by zero
=-43					err_FPOutOfRange	= -43	; floating-point result out of range
=-44					err_FPStackOverflow	= -44	; floating-point stack overflow
=-45					err_FPStackUnderflow	= -45	; floating-point stack underflow
=-46					err_FPInvalidArg	= -46	; floating-point invalid argument
=-47					err_CompileWordsDeleted = -47	; compilation word list deleted
=-48					err_PostponeInvalid	= -48	; invalid POSTPONE
=-49					err_SearchOrderOverflow = -49	; search-order overflow
=-50					err_SearchOrderUnderflow = -50	; search-order underflow
=-51					err_CompileWordlistChanged = -51 ; compilation word list changed
=-52					err_ControlStackOverflow = -52	; control-flow stack overflow
=-53					err_ExceptionStackOverflow = -53 ; exception stack overflow
=-54					err_FPUnderflow		= -54	; floating-point underflow
=-55					err_FPFault		= -55	; floating-point unidentified fault
=-56					err_Quit		= -56	; QUIT
=-57					err_ConsoleIO		= -57	; exception in sending or receiving a character
=-58					err_BracketIf		= -58	; [IF], [ELSE], or [THEN] exception
=-59					err_Allocate		= -59	; ALLOCATE
=-60					err_Free		= -60	; FREE
=-61					err_Resize		= -61	; RESIZE
=-62					err_CloseFile		= -62	; CLOSE-FILE
=-63					err_CreateFile		= -63	; CREATE-FILE
=-64					err_DeleteFile		= -64	; DELETE-FILE
=-65					err_FilePosition	= -65	; FILE-POSITION
=-66					err_FileSize		= -66	; FILE-SIZE
=-67					err_FileStatus		= -67	; FILE-STATUS
=-68					err_FlushFile		= -68	; FLUSH-FILE
=-69					err_OpenFile		= -69	; OPEN-FILE
=-70					err_ReadFile		= -70	; READ-FILE
=-71					err_ReadLine		= -71	; READ-LINE
=-72					err_RenameFile		= -72	; RENAME-FILE
=-73					err_RepositionFile	= -73	; REPOSITION-FILE
=-74					err_ResizeFile		= -74	; RESIZE-FILE
=-75					err_WriteFile		= -75	; WRITE-FILE
=-76					err_WriteLine		= -76	; WRITE-LINE
=-77					err_MalformedXChar	= -77	; Malformed xchar
=-78					err_Substitute		= -78	; SUBSTITUTE
=-79					err_Replaces		= -79	; REPLACES
=-149					err_Refill		= -149	; Refill failed
=-150					err_Defer		= -150	; Defer not set
=-151					err_AlreadyInterpreting	= -151	; entering interpret when already interpreting
=-152					err_AlreadyCompiling	= -152	; entering compile when already compiling
=-154					err_TooManyWordlists   	= -154
.0000					zp0:
>0000					cp:	.word ?		; Compiler Pointer (see HERE)
>0002					InSrc:	.word ?		; input Source for SOURCE-ID
>0004					Cib:	.word ?		; address of current input buffer
>0006					CibLen:	.word ?		; length of current input buffer
>0008					ToIn:	.word ?		; pointer to CIB (>IN in Forth)
>000a					state:	.word ?		; STATE: -1 compile, 0 interpret
>000c					status: .word ?		; internal status flags
>000e					WorkWord: .word ?	; nt or xt of word being compiled (see status)
>0010					dp:	.word ?		; Dictionary Pointer temp
>0012					DoIndex: .word ?	; current Do index
>0014					tmp1:	.word ?		; temporary storage
>0016					tmp2:	.word ?		; temporary storage
>0018					tmp3:	.word ?		; temporary storage
>001a					tmp4:	.word ?		; temporary storage (tmpdsp)
>001c					tmp5:	.word ?		; temporary storage (tmptos)
>001e					editor1: .word ?	; temporary for editors
>0020					editor2: .word ?	; temporary for editors
>0022					editor3: .word ?	; temporary for editors
>0024					DStack:	.fill DDim*2	; data stack
.8000					Cold_zp_table:
>8000	66 0b					.word cp0		; cp
>8002	00 00					.word 0			; insrc (SOURCE-ID is 0 for keyboard)
>8004	00 02					.word buffer0		; cib
>8006	00 00					.word 0			; ciblen
>8008	00 00					.word 0			; toin
>800a	00 00					.word 0			; state (0 = interpret)
>800c	00 00					.word 0			; status
=14					Cold_zp_table_length = *-Cold_zp_table
.02ff					User0:
>02ff					PrecisionV: .byte ?	; # of decimal places for FP print
>0300					base:	.word ?		; number radix, default decimal
>0302					nc_limit: .word ?	; limit for Native Compile size
>0304					uf_strip: .word ?	; flag to strip underflow detection code
>0306					output:	.word ?		; vector for EMIT
>0308					input:	.word ?		; vector for KEY
>030a					HaveKey: .word ?	; vector for KEY?
>030c					BlkV:	.word ?		; BLK
>030e					ScrV:	.word ?		; SCR
>0310					CurrentV: .byte ?	; CURRENT (byte) (Compilation wordlist)
>0311					Num_WordlistsV: .byte ?	; #WORDLISTS (byte)
=12					max_wordlists = 12	; Maximum number of wordlists supported
>0312					WordlistsV: .fill 2*max_wordlists	; WORDLISTS (cells)
>032a					Num_OrderV: .byte ?	; #ORDER (byte)
>032b					Search_OrderV: .fill 9	; SEARCH-ORDER (bytes)
.0334					MarkEnd:
>0334					ToHold:	.byte ?		; pad buffer index for formatted output
>0335					RndState: .dword ?	; random # state
=0					wid_Forth = 0
=1					wid_Editor = 1
=2					wid_Assembler = 2
=3					wid_Root = 3
.800e					Cold_user_table:
>800e	08					.byte 8			; PrecisionV
>800f	0a 00					.word 10		; base
>8011	08 00					.word 8			; nc-limit
>8013	00 00					.word 0			; uf_strip (off by default)
>8015	21 f1					.word kernel_putc	; output
>8017	14 f1					.word kernel_getc	; input
>8019	1d f1					.word kernel_havekey	; havekey
>801b	00 00					.word 0				; BLK
>801d	00 00					.word 0				; SCR
>801f	00					.byte 0				; CURRENT = FORTH-WORDLIST
>8020	04					.byte 4				; #WORDLISTS (FORTH EDITOR ASSEMBLER ROOT)
>8021	87 df					.word forth_dictionary_start	; FORTH-WORDLIST
>8023	ec e9					.word editor_dictionary_start	; EDITOR-WORDLIST
>8025	d6 e7					.word assembler_dictionary_start ; ASSEMBLER-WORDLIST
>8027	c6 df					.word root_dictionary_start	; ROOT-WORDLIST
>8029	00 00 00 00 00 00 00 00			.word 0,0,0,0,0,0,0,0		; User wordlists
>8031	00 00 00 00 00 00 00 00
>8039	02					.byte 2				; #ORDER
>803a	00 02 00 00 00 00 00 00			.byte wid_Forth,wid_Assembler,0,0,0,0,0,0,0	; search-order
>8042	00
=53					Cold_user_table_length = *-Cold_user_table
=$03					AscCC   = $03	; break (CTRL-c)
=$07					AscBELL = $07	; bell sound
=$08					AscBS   = $08	; backspace
=$09					AscHT	= $09	; tab
=$0a					AscLF   = $0a	; line feed
=$0b					AScVT	= $0b	; vertical tab
=$0c					AscFF	= $0c	; form feed
=$0d					AscCR   = $0d	; carriage return
=$0e					AscCN   = $0e	; CTRL-n (used to recall next input history)
=$10					AscCP   = $10	; CTRL-p (used to recall previous input history)
=$1b					AscESC  = $1b	; escape
=$20					AscSP   = $20	; space
=$22					AscDQuote = $22	; double quote
=$5c					AscBackslash = $5c ; backslash
=$7f					AscDEL  = $7f	; delete (CTRL-h)
>0000							.fill $80	; |  unused space |   To align the last char of name.
=127					wh_NameLastChar	= *-1		; |		  |   Last char of name.
>0080					wh_HashNameLen:			    .byte ?	; |
=$e0					wh_HashMask		=	    %11100000	; |      lo 3 bits of last char of name
=$1f					wh_NameLengthMask	=	    %00011111	; |      length of name
>0081					wh_Flags:			    .byte ?	; |  flag bits
=$01					FP	=			    %00000001	; |	Far previous NT (two byte pointer rather than one byte offset)
=$02					DB	=			    %00000010	; |	Disjoint body (two byte pointer rather than adjoining body code)
=$04					CO	=			    %00000100	; |	Compile Only
=$08					IM	=			    %00001000	; |     Immediate Word
=$10					NN	=			    %00010000	; |	    | 1 | 0 |  NN : Word can only be called by JSR (never native)
=$20					AN	=			    %00100000  	; |	    | 0 | 1 |  AN : Word can only be inlined (always native)
=$30					ST	=			    %00110000	; |	    | 1 | 1 |  ST : Normal word with return stack juggling that
=3					wh_HeaderExtendMask =		     FP+DB	; |	of the header length directly by adding 4 to `flags & %00000011`.
=$40					UF	=			    %01000000   ; |     strippable underflow
>0082					wh_CodeLength:			   .byte ?	; |  Code length  |   Code length for native compile, max 255
.0083					wh_LinkNt:
=0					WordFlags .var 0 ; initialize for macro
=0					XtPtr1  .var 0  ; initialize for macro
=0					WordListLink .var 0	 ; start of FORTH wordlist
>8043	43 6f 6c 64			Name0:	.text "Cold"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=32711					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>8047	84					.byte (("Cold"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=32711					LinkDisplacement = Nt0-WordListLink
=$11						  WordFlags ::= WordFlags | FP
>8048	11					.byte WordFlags	;wh_Flags
>8049	03					.byte 3	;wh_CodeLength
>804a	00 00					  .word WordListLink
=$804c					XtPtr1 ::= *
=32711					WordListLink ::= Nt0 ; remember the nt of this word for later
.804c					Cold:
.804c	d8		cld				cld
.804d	a2 ff		ldx #$ff			ldx #rsp0		; Initialize 6502 stack (Return Stack)
.804f	9a		txs				txs
.8050	a2 0d		ldx #$0d			ldx #Cold_zp_table_length-1 ; Initialize important zero page variables from ROM
.8052	bd 00 80	lda $8000,x	-		lda Cold_zp_table,x	;   We can use X here
.8055	95 00		sta $00,x			sta zp0,x		;   because Tali hasn't set up the param stack yet.
.8057	ca		dex				dex
.8058	10 f8		bpl $8052			bpl -
.805a	a0 34		ldy #$34			ldy #Cold_user_table_length-1	; Initialize the user variables.
.805c	b9 0e 80	lda $800e,y	-		lda Cold_user_table,y
.805f	99 ff 02	sta $02ff,y			sta User0,y
.8062	88		dey				dey
.8063	10 f7		bpl $805c			bpl -
.8065	20 d1 c4	jsr $c4d1			jsr Empty_Stack		; Clear Data Stack. This is repeated in ABORT, but this way we
.8068	20 de b1	jsr $b1de			jsr BlockInit
.806b	20 4c bb	jsr $bb4c			jsr CR
.806e	a9 9c		lda #$9c			lda #<forth_words_start		; push start address
.8070	a0 80		ldy #$80			ldy #>forth_words_start
.8072	20 b5 c7	jsr $c7b5			jsr PushYA
.8075	a9 d1		lda #$d1			lda #<forth_words_len		; push length
.8077	a0 00		ldy #$00			ldy #>forth_words_len
.8079	20 b5 c7	jsr $c7b5			jsr PushYA
.807c	20 e7 bf	jsr $bfe7			jsr Evaluate
.807f	a9 00		lda #$00			lda #0
.8081	8d 66 07	sta $0766			sta hist_buff
.8084	8d e6 07	sta $07e6			sta hist_buff+$80
.8087	8d 66 08	sta $0866			sta hist_buff+$100
.808a	8d e6 08	sta $08e6			sta hist_buff+$180
.808d	8d 66 09	sta $0966			sta hist_buff+$200
.8090	8d e6 09	sta $09e6			sta hist_buff+$280
.8093	8d 66 0a	sta $0a66			sta hist_buff+$300
.8096	8d e6 0a	sta $0ae6			sta hist_buff+$380
.8099	4c 83 c4	jmp $c483			jmp Abort_Core2	;Quit
=80					CodeLen	.var *-XtPtr1
=$809c					Here1 = *	; remember here
>8049	50					.byte CodeLen	;patch wh_CodeLength
>809c	20 63 72 20 2e 28 20 54		forth_words_start: .binary "forth_words.asc" ; High-level Forth words, see forth_code/README.md
>80a4	61 6c 69 20 46 6f 72 74 68 20 32 20 72 65 6d 69
>80b4	78 20 66 6f 72 20 74 68 65 20 36 35 30 32 29 20
>80c4	63 72 20 2e 28 20 56 65 72 73 69 6f 6e 20 32 38
>80d4	20 4d 61 79 20 32 30 32 35 20 29 20 63 72 20 2e
>80e4	28 20 43 6f 70 79 72 69 67 68 74 20 32 30 31 34
>80f4	2d 32 30 32 34 20 53 63 6f 74 20 57 2e 20 53 74
>8104	65 76 65 6e 73 6f 6e 2c 20 53 61 6d 20 43 6f 6c
>8114	77 65 6c 6c 29 20 63 72 20 2e 28 20 54 61 6c 69
>8124	20 46 6f 72 74 68 20 32 20 63 6f 6d 65 73 20 77
>8134	69 74 68 20 61 62 73 6f 6c 75 74 65 6c 79 20 4e
>8144	4f 20 57 41 52 52 41 4e 54 59 29 20 63 72 20 2e
>8154	28 20 54 79 70 65 20 27 62 79 65 27 20 74 6f 20
>8164	65 78 69 74 29 20 63 72 20
=209					forth_words_len = *-forth_words_start
>816d					user_words_start: .binary "user_words.asc" ; User-defined Forth words, see forth_code/README.md
=0					user_words_len = *-user_words_start
>816d	4e 6f 4f 70			Name0:	.text "NoOp"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=33009					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>8171	04					.byte (("NoOp"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=0					WordFlags ::= 0	; modifiable copy, remember for later
=298					LinkDisplacement = Nt0-WordListLink
=1						  WordFlags ::= WordFlags | FP
>8172	01					.byte WordFlags	;wh_Flags
>8173	03					.byte 3	;wh_CodeLength
>8174	c7 7f					  .word WordListLink
=$8176					XtPtr1 ::= *
=33009					WordListLink ::= Nt0 ; remember the nt of this word for later
.8176	ea		nop				nop
=1					CodeLen	.var *-XtPtr1
=$8177					Here1 = *	; remember here
>8173	01					.byte CodeLen	;patch wh_CodeLength
.8177	60		rts				rts
>8178	43 43 40			Name0:	.text "CC@"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=33019					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>817b	03					.byte (("CC@"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=10					LinkDisplacement = Nt0-WordListLink
=$12						  WordFlags ::= WordFlags | DB
>817c	12					.byte WordFlags	;wh_Flags
>817d	08					.byte 8	;wh_CodeLength
>817e	0a					  .byte LinkDisplacement	; offset to previous nt
>817f	26 f1					  .word platform_CCAT		; pointer to xt
=0					XtPtr1 ::= 0
=33019					WordListLink ::= Nt0 ; remember the nt of this word for later
>8181	42 79 65			Name0:	.text "Bye"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=33028					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>8184	a3					.byte (("Bye"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=9					LinkDisplacement = Nt0-WordListLink
=$12						  WordFlags ::= WordFlags | DB
>8185	12					.byte WordFlags	;wh_Flags
>8186	08					.byte 8	;wh_CodeLength
>8187	09					  .byte LinkDisplacement	; offset to previous nt
>8188	25 f1					  .word platform_bye		; pointer to xt
=0					XtPtr1 ::= 0
=33028					WordListLink ::= Nt0 ; remember the nt of this word for later
>818a	54 79 70 65 53 79 6d 62		Name0:	.text "TypeSymbol"	;  name of word as a string, ending at wh_NameLastChar
>8192	6f 6c
=10					NameLength = *-Name0
=33044					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>8194	8a					.byte (("TypeSymbol"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=16					LinkDisplacement = Nt0-WordListLink
>8195	10					.byte WordFlags	;wh_Flags
>8196	03					.byte 3	;wh_CodeLength
>8197	10					  .byte LinkDisplacement	; offset to previous nt
=$8198					XtPtr1 ::= *
=33044					WordListLink ::= Nt0 ; remember the nt of this word for later
.8198	20 b8 c8	jsr $c8b8	TypeSymbol:	jsr SLiteral_runtime
.819b	4c a3 81	jmp $81a3			  jmp +
>819e	20 20 28 20 24					  .text "  ( $"
.81a3	20 34 de	jsr $de34	+		jsr Type
.81a6	20 cd df	jsr $dfcd			jsr Dup
.81a9	20 ec b8	jsr $b8ec			jsr Dot_Hex
.81ac	20 28 de	jsr $de28			jsr Space
.81af	20 d6 81	jsr $81d6			jsr DictSearchXt	; ( addr_end addr operand offset nt )
.81b2	20 f2 cd	jsr $cdf2			jsr Name_To_String	; Change nt into the name
.81b5	20 34 de	jsr $de34			jsr Type		; print it.
.81b8	20 28 de	jsr $de28			jsr Space
.81bb	b5 24		lda $24,x			lda DStack+0,x		; if non-zero offset
.81bd	15 25		ora $25,x			ora DStack+1,x
.81bf	f0 0b		beq $81cc			beq +
.81c1	a9 2b		lda #$2b			lda #'+'		;   print offset
.81c3	20 1c de	jsr $de1c			jsr Emit_A
.81c6	20 cd df	jsr $dfcd			jsr Dup
.81c9	20 4d dc	jsr $dc4d			jsr U_Dot
.81cc	e8		inx		+		inx
.81cd	e8		inx				inx
.81ce	a9 29		lda #$29			lda #')'
.81d0	20 1c de	jsr $de1c			jsr Emit_A
.81d3	4c 28 de	jmp $de28			jmp Space
=62					CodeLen	.var *-XtPtr1
=$81d6					Here1 = *	; remember here
>8196	3e					.byte CodeLen	;patch wh_CodeLength
.81d6					DictSearchXt:
.81d6	ca		dex				dex			; alloc nt
.81d7	ca		dex				dex
.81d8	20 a4 df	jsr $dfa4			jsr Over		; alloc xt
.81db	a9 ff		lda #$ff			lda #$ff		; init best offset
.81dd	95 29		sta $29,x			sta DStack+5,x		; ( offset nt xt )
.81df	a9 fe		lda #$fe			lda #$100-2		; for each wordlist
.81e1	48		pha				pha
.81e2	68		pla		_ListNext:	pla
.81e3	18		clc				clc
.81e4	69 02		adc #$02			adc #2			; to next wordlist
.81e6	c9 18		cmp #$18			cmp #max_wordlists*2
.81e8	b0 10		bcs $81fa			bcs _ListDone
.81ea	48		pha				pha
.81eb	a8		tay				tay
.81ec	b9 12 03	lda $0312,y			lda WordlistsV+0,y	; Get the DP for that wordlist.
.81ef	85 14		sta $14				sta tmp1+0
.81f1	b9 13 03	lda $0313,y			lda WordlistsV+1,y
.81f4	85 15		sta $15				sta tmp1+1
.81f6	d0 0a		bne $8202			bne _WordTest
.81f8	f0 e8		beq $81e2			beq _ListNext		;   empty list
.81fa	e8		inx		_ListDone:	inx			; Drop pattern xt
.81fb	e8		inx				inx			; ( offset nt )
.81fc	60		rts				rts
.81fd	20 95 82	jsr $8295	_WordNext:	jsr LinkNext		; tmp1= next nt in list
.8200	f0 e0		beq $81e2			beq _ListNext		; end of Dictionary?
.8202	20 b6 cd	jsr $cdb6	_WordTest:	jsr NameToIntTmp	; tmp2 = xt of this word
.8205	38		sec				sec			; tmp3 = xt offset for this word
.8206	b5 24		lda $24,x			lda DStack+0,x
.8208	e5 16		sbc $16				sbc tmp2+0
.820a	85 18		sta $18				sta tmp3+0
.820c	b5 25		lda $25,x			lda DStack+1,x
.820e	e5 17		sbc $17				sbc tmp2+1
.8210	85 19		sta $19				sta tmp3+1
.8212	20 7a 82	jsr $827a			jsr _test
.8215	a0 00		ldy #$00			ldy #0			; is this word a constant?
.8217	b1 16		lda ($16),y			lda (tmp2),y
.8219	c9 a0		cmp #$a0			cmp #$a0
.821b	f0 2a		beq $8247			beq _PushYA
.821d	c9 a9		cmp #$a9			cmp #$a9
.821f	f0 02		beq $8223			beq _PushZA
.8221	d0 da		bne $81fd			bne _WordNext
.8223	c8		iny		_PushZA:	iny			; get lda # operand
.8224	b5 24		lda $24,x			lda DStack+0,x
.8226	f1 16		sbc ($16),y			sbc (tmp2),y
.8228	85 18		sta $18				sta tmp3+0
.822a	b5 25		lda $25,x			lda DStack+1,x
.822c	e9 00		sbc #$00			sbc #0
.822e	85 19		sta $19				sta tmp3+1
.8230	c8		iny				iny			; check jmp opcode
.8231	b1 16		lda ($16),y			lda (tmp2),y
.8233	c9 4c		cmp #$4c			cmp #$4c
.8235	d0 c6		bne $81fd			bne _WordNext
.8237	c8		iny				iny			; check jmp operand lo
.8238	b1 16		lda ($16),y			lda (tmp2),y
.823a	c9 e4		cmp #$e4			cmp #<PushZA
.823c	d0 bf		bne $81fd			bne _WordNext
.823e	c8		iny				iny			; check jmp operand hi
.823f	b1 16		lda ($16),y			lda (tmp2),y
.8241	c9 c7		cmp #$c7			cmp #>PushZA
.8243	f0 2f		beq $8274			beq _KTest
.8245	d0 b6		bne $81fd			bne _WordNext
.8247	a0 02		ldy #$02	_PushYA:	ldy #2			; check LDA # opcode
.8249	b1 16		lda ($16),y			lda (tmp2),y
.824b	c9 a9		cmp #$a9			cmp #$a9
.824d	d0 ae		bne $81fd			bne _WordNext
.824f	c8		iny				iny			; get lda # operand
.8250	b5 24		lda $24,x			lda DStack+0,x
.8252	f1 16		sbc ($16),y			sbc (tmp2),y
.8254	85 18		sta $18				sta tmp3+0
.8256	a0 01		ldy #$01			ldy #1			; get LDY # operand
.8258	b5 25		lda $25,x			lda DStack+1,x
.825a	f1 16		sbc ($16),y			sbc (tmp2),y
.825c	85 19		sta $19				sta tmp3+1
.825e	a0 04		ldy #$04			ldy #4			; check JMP opcode
.8260	b1 16		lda ($16),y			lda (tmp2),y
.8262	c9 4c		cmp #$4c			cmp #$4c
.8264	d0 97		bne $81fd			bne _WordNext
.8266	c8		iny				iny			; check JMP operand lo
.8267	b1 16		lda ($16),y			lda (tmp2),y
.8269	c9 b5		cmp #$b5			cmp #<PushYA
.826b	d0 0a		bne $8277			bne _WordNext3
.826d	c8		iny				iny			; check JMP operand hi
.826e	b1 16		lda ($16),y			lda (tmp2),y
.8270	c9 c7		cmp #$c7			cmp #>PushYA
.8272	d0 03		bne $8277			bne _WordNext3
.8274	20 7a 82	jsr $827a	_KTest:		jsr _test
.8277	4c fd 81	jmp $81fd	_WordNext3:	jmp _WordNext
.827a					_test:
.827a	a5 18		lda $18				lda tmp3+0		; this word have smaller offset?
.827c	d5 28		cmp $28,x			cmp DStack+4,x
.827e	a5 19		lda $19				lda tmp3+1
.8280	f5 29		sbc $29,x			sbc DStack+5,x
.8282	b0 10		bcs $8294			bcs _trts
.8284	a5 18		lda $18				lda tmp3+0		;   save this better offset
.8286	a4 19		ldy $19				ldy tmp3+1
.8288	95 28		sta $28,x			sta DStack+4,x
.828a	94 29		sty $29,x			sty DStack+5,x
.828c	a5 14		lda $14				lda tmp1+0		;   save this better nt
.828e	a4 15		ldy $15				ldy tmp1+1
.8290	95 26		sta $26,x			sta DStack+2,x
.8292	94 27		sty $27,x			sty DStack+3,x
.8294	60		rts		_trts:		rts
.8295					LinkNext:
.8295	a0 81		ldy #$81			ldy #wh_Flags		; which kind of wh_LinkNt?
.8297	b1 14		lda ($14),y			lda (tmp1),y
.8299	29 01		and #$01			and #FP
.829b	f0 0e		beq $82ab			beq _LinkShort
.829d	a0 84		ldy #$84	_LinkLong:	ldy #wh_LinkNt+1	; tmp1 = tmp1->LinkNt (ptr)
.829f	b1 14		lda ($14),y			lda (tmp1),y
.82a1	48		pha				pha
.82a2	88		dey				dey
.82a3	b1 14		lda ($14),y			lda (tmp1),y
.82a5	85 14		sta $14				sta tmp1+0
.82a7	68		pla				pla
.82a8	85 15		sta $15				sta tmp1+1
.82aa	60		rts				rts
.82ab	a0 83		ldy #$83	_LinkShort:	ldy #wh_LinkNt		; tmp1 -= tmp1->LinkNt byte offset
.82ad	38		sec				sec
.82ae	a5 14		lda $14				lda tmp1+0
.82b0	f1 14		sbc ($14),y			sbc (tmp1),y
.82b2	85 14		sta $14				sta tmp1+0
.82b4	a5 15		lda $15				lda tmp1+1
.82b6	e9 00		sbc #$00			sbc #0
.82b8	85 15		sta $15				sta tmp1+1
.82ba	60		rts				rts
>82bb	44 53 74 61 63 6b		Name0:	.text "DStack"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=33345					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>82c1	66					.byte (("DStack"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=301					LinkDisplacement = Nt0-WordListLink
=$11						  WordFlags ::= WordFlags | FP
>82c2	11					.byte WordFlags	;wh_Flags
>82c3	03					.byte 3	;wh_CodeLength
>82c4	14 81					  .word WordListLink
=$82c6					XtPtr1 ::= *
=33345					WordListLink ::= Nt0 ; remember the nt of this word for later
.82c6	a9 24		lda #$24			lda #DStack
.82c8	4c e4 c7	jmp $c7e4			jmp PushZA
=5					CodeLen	.var *-XtPtr1
=$82cb					Here1 = *	; remember here
>82c3	05					.byte CodeLen	;patch wh_CodeLength
>82cb	52 53 74 61 63 6b		Name0:	.text "RStack"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=33361					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>82d1	66					.byte (("RStack"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=16					LinkDisplacement = Nt0-WordListLink
>82d2	10					.byte WordFlags	;wh_Flags
>82d3	03					.byte 3	;wh_CodeLength
>82d4	10					  .byte LinkDisplacement	; offset to previous nt
=$82d5					XtPtr1 ::= *
=33361					WordListLink ::= Nt0 ; remember the nt of this word for later
.82d5	a0 01		ldy #$01			ldy #>RStack
.82d7	a9 00		lda #$00			lda #<RStack
.82d9	4c b5 c7	jmp $c7b5			jmp PushYA
=7					CodeLen	.var *-XtPtr1
=$82dc					Here1 = *	; remember here
>82d3	07					.byte CodeLen	;patch wh_CodeLength
>82dc	52 6e 64 53 74 61 74 65		Name0:	.text "RndState"	;  name of word as a string, ending at wh_NameLastChar
=8					NameLength = *-Name0
=33380					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>82e4	a8					.byte (("RndState"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=19					LinkDisplacement = Nt0-WordListLink
>82e5	10					.byte WordFlags	;wh_Flags
>82e6	03					.byte 3	;wh_CodeLength
>82e7	13					  .byte LinkDisplacement	; offset to previous nt
=$82e8					XtPtr1 ::= *
=33380					WordListLink ::= Nt0 ; remember the nt of this word for later
.82e8	a0 03		ldy #$03			ldy #>RndState
.82ea	a9 35		lda #$35			lda #<RndState
.82ec	4c b5 c7	jmp $c7b5			jmp PushYA
=7					CodeLen	.var *-XtPtr1
=$82ef					Here1 = *	; remember here
>82e6	07					.byte CodeLen	;patch wh_CodeLength
>82ef	52 61 6e 64			Name0:	.text "Rand"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=33395					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>82f3	84					.byte (("Rand"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=0					WordFlags ::= 0	; modifiable copy, remember for later
=15					LinkDisplacement = Nt0-WordListLink
>82f4	00					.byte WordFlags	;wh_Flags
>82f5	03					.byte 3	;wh_CodeLength
>82f6	0f					  .byte LinkDisplacement	; offset to previous nt
=$82f7					XtPtr1 ::= *
=33395					WordListLink ::= Nt0 ; remember the nt of this word for later
.82f7					Rand:
.82f7	4e 36 03	lsr $0336			lsr RndState+1
.82fa	6e 35 03	ror $0335			ror RndState+0
.82fd	6e 38 03	ror $0338			ror RndState+3
.8300	6e 37 03	ror $0337			ror RndState+2
.8303	90 10		bcc $8315			bcc _19			;  IfCs,
.8305	ad 36 03	lda $0336			lda RndState+1
.8308	49 d0		eor #$d0			eor #$d0
.830a	8d 36 03	sta $0336			sta RndState+1
.830d	ad 37 03	lda $0337			lda RndState+2
.8310	49 01		eor #$01			eor #$01
.8312	8d 37 03	sta $0337			sta RndState+2
.8315					_19:
.8315	ad 37 03	lda $0337			lda RndState+2
.8318	ac 38 03	ldy $0338			ldy RndState+3
=36					CodeLen	.var *-XtPtr1
=$831b					Here1 = *	; remember here
>82f5	24					.byte CodeLen	;patch wh_CodeLength
.831b	60		rts				rts
>831c	52 61 6e 64 4d			Name0:	.text "RandM"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=33441					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>8321	a5					.byte (("RandM"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=46					LinkDisplacement = Nt0-WordListLink
>8322	10					.byte WordFlags	;wh_Flags
>8323	03					.byte 3	;wh_CodeLength
>8324	2e					  .byte LinkDisplacement	; offset to previous nt
=$8325					XtPtr1 ::= *
=33441					WordListLink ::= Nt0 ; remember the nt of this word for later
.8325	20 cd df	jsr $dfcd	RandM:		jsr Dup		; ( umod umod )
.8328	20 f7 82	jsr $82f7			jsr Rand
.832b	4a		lsr a				lsr a		; make positive
.832c	95 27		sta $27,x			sta DStack+3,x
.832e	94 26		sty $26,x			sty DStack+2,x	; ( rand umod )
.8330	4c 5d bf	jmp $bf5d			jmp Mod
=14					CodeLen	.var *-XtPtr1
=$8333					Here1 = *	; remember here
>8323	0e					.byte CodeLen	;patch wh_CodeLength
>004c					FIndex:	.byte ?		; floating-point stack index. empty=FDim, full=0
>004d					FSExp:   .fill FDim	; byte array[FDim] FP stack exponent
>0057					FSMant0: .fill FDim	; byte array[FDim] FP stack mantissa MSByte
>0061					FSMant1: .fill FDim	; byte array[FDim] FP stack mantissa 2nd
>006b					FSMant2: .fill FDim	; byte array[FDim] FP stack mantissa 3rd
>0075					FSMant3: .fill FDim	; byte array[FDim] FP stack mantissa 4th
>8333	46 49 6e 64 65 78		Name0:	.text "FIndex"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=33465					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>8339	06					.byte (("FIndex"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=24					LinkDisplacement = Nt0-WordListLink
>833a	10					.byte WordFlags	;wh_Flags
>833b	03					.byte 3	;wh_CodeLength
>833c	18					  .byte LinkDisplacement	; offset to previous nt
=$833d					XtPtr1 ::= *
=33465					WordListLink ::= Nt0 ; remember the nt of this word for later
.833d	a9 4c		lda #$4c			lda #FIndex
.833f	4c e4 c7	jmp $c7e4			jmp PushZA
=5					CodeLen	.var *-XtPtr1
=$8342					Here1 = *	; remember here
>833b	05					.byte CodeLen	;patch wh_CodeLength
>8342	46 44 69 6d			Name0:	.text "FDim"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=33478					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>8346	a4					.byte (("FDim"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>8347	10					.byte WordFlags	;wh_Flags
>8348	03					.byte 3	;wh_CodeLength
>8349	0d					  .byte LinkDisplacement	; offset to previous nt
=$834a					XtPtr1 ::= *
=33478					WordListLink ::= Nt0 ; remember the nt of this word for later
.834a	a9 0a		lda #$0a			lda #FDim
.834c	4c e4 c7	jmp $c7e4			jmp PushZA
=5					CodeLen	.var *-XtPtr1
=$834f					Here1 = *	; remember here
>8348	05					.byte CodeLen	;patch wh_CodeLength
>834f	46 53 45 78 70			Name0:	.text "FSExp"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=33492					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>8354	05					.byte (("FSExp"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=14					LinkDisplacement = Nt0-WordListLink
>8355	10					.byte WordFlags	;wh_Flags
>8356	03					.byte 3	;wh_CodeLength
>8357	0e					  .byte LinkDisplacement	; offset to previous nt
=$8358					XtPtr1 ::= *
=33492					WordListLink ::= Nt0 ; remember the nt of this word for later
.8358	a9 4d		lda #$4d			lda #FSExp
.835a	4c e4 c7	jmp $c7e4			jmp PushZA
=5					CodeLen	.var *-XtPtr1
=$835d					Here1 = *	; remember here
>8356	05					.byte CodeLen	;patch wh_CodeLength
>835d	46 53 4d 61 6e 74 30		Name0:	.text "FSMant0"	;  name of word as a string, ending at wh_NameLastChar
=7					NameLength = *-Name0
=33508					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>8364	07					.byte (("FSMant0"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=16					LinkDisplacement = Nt0-WordListLink
>8365	10					.byte WordFlags	;wh_Flags
>8366	03					.byte 3	;wh_CodeLength
>8367	10					  .byte LinkDisplacement	; offset to previous nt
=$8368					XtPtr1 ::= *
=33508					WordListLink ::= Nt0 ; remember the nt of this word for later
.8368	a9 57		lda #$57			lda #FSMant0
.836a	4c e4 c7	jmp $c7e4			jmp PushZA
=5					CodeLen	.var *-XtPtr1
=$836d					Here1 = *	; remember here
>8366	05					.byte CodeLen	;patch wh_CodeLength
>836d	46 53 4d 61 6e 74 31		Name0:	.text "FSMant1"	;  name of word as a string, ending at wh_NameLastChar
=7					NameLength = *-Name0
=33524					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>8374	27					.byte (("FSMant1"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=16					LinkDisplacement = Nt0-WordListLink
>8375	10					.byte WordFlags	;wh_Flags
>8376	03					.byte 3	;wh_CodeLength
>8377	10					  .byte LinkDisplacement	; offset to previous nt
=$8378					XtPtr1 ::= *
=33524					WordListLink ::= Nt0 ; remember the nt of this word for later
.8378	a9 61		lda #$61			lda #FSMant1
.837a	4c e4 c7	jmp $c7e4			jmp PushZA
=5					CodeLen	.var *-XtPtr1
=$837d					Here1 = *	; remember here
>8376	05					.byte CodeLen	;patch wh_CodeLength
>837d	46 53 4d 61 6e 74 32		Name0:	.text "FSMant2"	;  name of word as a string, ending at wh_NameLastChar
=7					NameLength = *-Name0
=33540					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>8384	47					.byte (("FSMant2"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=16					LinkDisplacement = Nt0-WordListLink
>8385	10					.byte WordFlags	;wh_Flags
>8386	03					.byte 3	;wh_CodeLength
>8387	10					  .byte LinkDisplacement	; offset to previous nt
=$8388					XtPtr1 ::= *
=33540					WordListLink ::= Nt0 ; remember the nt of this word for later
.8388	a9 6b		lda #$6b			lda #FSMant2
.838a	4c e4 c7	jmp $c7e4			jmp PushZA
=5					CodeLen	.var *-XtPtr1
=$838d					Here1 = *	; remember here
>8386	05					.byte CodeLen	;patch wh_CodeLength
>838d	46 53 4d 61 6e 74 33		Name0:	.text "FSMant3"	;  name of word as a string, ending at wh_NameLastChar
=7					NameLength = *-Name0
=33556					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>8394	67					.byte (("FSMant3"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=16					LinkDisplacement = Nt0-WordListLink
>8395	10					.byte WordFlags	;wh_Flags
>8396	03					.byte 3	;wh_CodeLength
>8397	10					  .byte LinkDisplacement	; offset to previous nt
=$8398					XtPtr1 ::= *
=33556					WordListLink ::= Nt0 ; remember the nt of this word for later
.8398	a9 75		lda #$75			lda #FSMant3
.839a	4c e4 c7	jmp $c7e4			jmp PushZA
=5					CodeLen	.var *-XtPtr1
=$839d					Here1 = *	; remember here
>8396	05					.byte CodeLen	;patch wh_CodeLength
=5					Float_Size = 5 ; # of bytes in memory for a float
>839d	46 6c 6f 61 74			Name0:	.text "Float"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=33570					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>83a2	85					.byte (("Float"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=14					LinkDisplacement = Nt0-WordListLink
>83a3	10					.byte WordFlags	;wh_Flags
>83a4	03					.byte 3	;wh_CodeLength
>83a5	0e					  .byte LinkDisplacement	; offset to previous nt
=$83a6					XtPtr1 ::= *
=33570					WordListLink ::= Nt0 ; remember the nt of this word for later
.83a6	a9 05		lda #$05	Float:		lda #Float_Size
.83a8	4c e4 c7	jmp $c7e4			jmp PushZA
=5					CodeLen	.var *-XtPtr1
=$83ab					Here1 = *	; remember here
>83a4	05					.byte CodeLen	;patch wh_CodeLength
>83ab	46 6c 6f 61 74 2b		Name0:	.text "Float+"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=33585					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>83b1	66					.byte (("Float+"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=15					LinkDisplacement = Nt0-WordListLink
>83b2	10					.byte WordFlags	;wh_Flags
>83b3	03					.byte 3	;wh_CodeLength
>83b4	0f					  .byte LinkDisplacement	; offset to previous nt
=$83b5					XtPtr1 ::= *
=33585					WordListLink ::= Nt0 ; remember the nt of this word for later
.83b5	a9 05		lda #$05	FloatPlus:	lda #Float_Size
.83b7	4c 43 da	jmp $da43			jmp Plus_A
=5					CodeLen	.var *-XtPtr1
=$83ba					Here1 = *	; remember here
>83b3	05					.byte CodeLen	;patch wh_CodeLength
>83ba	46 6c 6f 61 74 73		Name0:	.text "Floats"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=33600					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>83c0	66					.byte (("Floats"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=15					LinkDisplacement = Nt0-WordListLink
>83c1	10					.byte WordFlags	;wh_Flags
>83c2	03					.byte 3	;wh_CodeLength
>83c3	0f					  .byte LinkDisplacement	; offset to previous nt
=$83c4					XtPtr1 ::= *
=33600					WordListLink ::= Nt0 ; remember the nt of this word for later
.83c4	20 a6 83	jsr $83a6	Floats:		jsr Float
.83c7	4c 73 be	jmp $be73			jmp Star
=6					CodeLen	.var *-XtPtr1
=$83ca					Here1 = *	; remember here
>83c2	06					.byte CodeLen	;patch wh_CodeLength
>83ca	46 41 6c 69 67 6e		Name0:	.text "FAlign"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=33616					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>83d0	c6					.byte (("FAlign"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=0					WordFlags ::= 0	; modifiable copy, remember for later
=16					LinkDisplacement = Nt0-WordListLink
>83d1	00					.byte WordFlags	;wh_Flags
>83d2	03					.byte 3	;wh_CodeLength
>83d3	10					  .byte LinkDisplacement	; offset to previous nt
=$83d4					XtPtr1 ::= *
=33616					WordListLink ::= Nt0 ; remember the nt of this word for later
.83d4					FAlign:
=0					CodeLen	.var *-XtPtr1
=$83d4					Here1 = *	; remember here
>83d2	00					.byte CodeLen	;patch wh_CodeLength
.83d4	60		rts				rts
>83d5	46 41 6c 69 67 6e 65 64		Name0:	.text "FAligned"	;  name of word as a string, ending at wh_NameLastChar
=8					NameLength = *-Name0
=33629					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>83dd	88					.byte (("FAligned"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=0					WordFlags ::= 0	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>83de	00					.byte WordFlags	;wh_Flags
>83df	03					.byte 3	;wh_CodeLength
>83e0	0d					  .byte LinkDisplacement	; offset to previous nt
=$83e1					XtPtr1 ::= *
=33629					WordListLink ::= Nt0 ; remember the nt of this word for later
.83e1					FAligned:
=0					CodeLen	.var *-XtPtr1
=$83e1					Here1 = *	; remember here
>83df	00					.byte CodeLen	;patch wh_CodeLength
.83e1	60		rts				rts
>83e2	48 65 78 3e 46			Name0:	.text "Hex>F"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=33639					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>83e7	c5					.byte (("Hex>F"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=10					LinkDisplacement = Nt0-WordListLink
>83e8	10					.byte WordFlags	;wh_Flags
>83e9	03					.byte 3	;wh_CodeLength
>83ea	0a					  .byte LinkDisplacement	; offset to previous nt
=$83eb					XtPtr1 ::= *
=33639					WordListLink ::= Nt0 ; remember the nt of this word for later
.83eb	20 c8 84	jsr $84c8	PartsToF:	jsr FAllocX		; alloc FP stack entry, X= FP stack index
.83ee	a6 14		ldx $14				ldx tmp1+0		; restore data stack index
.83f0	a4 4c		ldy $4c				ldy FIndex		; Y= FP stack index
.83f2	20 c3 c3	jsr $c3c3			jsr PopA		; pop n_exp
.83f5	99 4d 00	sta $004d,y			sta FSExp,y
.83f8	b5 25		lda $25,x			lda DStack+1,x
.83fa	99 57 00	sta $0057,y			sta FSMant0,y
.83fd	b5 24		lda $24,x			lda DStack+0,x
.83ff	99 61 00	sta $0061,y			sta FSMant1,y
.8402	b5 27		lda $27,x			lda DStack+3,x
.8404	99 6b 00	sta $006b,y			sta FSMant2,y
.8407	b5 26		lda $26,x			lda DStack+2,x
.8409	99 75 00	sta $0075,y			sta FSMant3,y
.840c	4c 6d d5	jmp $d56d			jmp Two_Drop
=36					CodeLen	.var *-XtPtr1
=$840f					Here1 = *	; remember here
>83e9	24					.byte CodeLen	;patch wh_CodeLength
>840f	46 3e 48 65 78			Name0:	.text "F>Hex"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=33684					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>8414	05					.byte (("F>Hex"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=45					LinkDisplacement = Nt0-WordListLink
>8415	10					.byte WordFlags	;wh_Flags
>8416	03					.byte 3	;wh_CodeLength
>8417	2d					  .byte LinkDisplacement	; offset to previous nt
=$8418					XtPtr1 ::= *
=33684					WordListLink ::= Nt0 ; remember the nt of this word for later
.8418	a4 4c		ldy $4c		FToParts:	ldy FIndex	; Y= FP stack index
.841a	ca		dex				dex		; alloc d_mantissa
.841b	ca		dex				dex
.841c	ca		dex				dex
.841d	ca		dex				dex
.841e	ca		dex				dex		; alloc n_exponent
.841f	ca		dex				dex
.8420	b9 57 00	lda $0057,y			lda FSMant0,y	; copy mantissa
.8423	95 27		sta $27,x			sta DStack+3,x
.8425	b9 61 00	lda $0061,y			lda FSMant1,y
.8428	95 26		sta $26,x			sta DStack+2,x
.842a	b9 6b 00	lda $006b,y			lda FSMant2,y
.842d	95 29		sta $29,x			sta DStack+5,x
.842f	b9 75 00	lda $0075,y			lda FSMant3,y
.8432	95 28		sta $28,x			sta DStack+4,x
.8434	b9 4d 00	lda $004d,y			lda FSExp,y	; copy exponent
.8437	95 24		sta $24,x			sta DStack+0,x
.8439	29 80		and #$80			and #$80	;   sign extend
.843b	f0 02		beq $843f			beq +
.843d	a9 ff		lda #$ff			lda #$ff
.843f	95 25		sta $25,x	+		sta DStack+1,x
.8441	e6 4c		inc $4c				inc FIndex	; FDrop r
=43					CodeLen	.var *-XtPtr1
=$8443					Here1 = *	; remember here
>8416	2b					.byte CodeLen	;patch wh_CodeLength
.8443	60		rts				rts
>8444	46 2e 48 65 78			Name0:	.text "F.Hex"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=33737					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>8449	05					.byte (("F.Hex"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=53					LinkDisplacement = Nt0-WordListLink
>844a	10					.byte WordFlags	;wh_Flags
>844b	03					.byte 3	;wh_CodeLength
>844c	35					  .byte LinkDisplacement	; offset to previous nt
=$844d					XtPtr1 ::= *
=33737					WordListLink ::= Nt0 ; remember the nt of this word for later
.844d	20 18 84	jsr $8418	FDotHex:	jsr FToParts	; get parts of r
.8450	20 d3 de	jsr $ded3			jsr Not_Rot
.8453	20 ec b8	jsr $b8ec			jsr Dot_Hex	; do mantissa
.8456	20 ec b8	jsr $b8ec			jsr Dot_Hex
.8459	a9 3a		lda #$3a			lda #':'
.845b	20 1c de	jsr $de1c			jsr Emit_A
.845e	4c cb b8	jmp $b8cb			jmp C_Dot_Hex	; do exponent
=20					CodeLen	.var *-XtPtr1
=$8461					Here1 = *	; remember here
>844b	14					.byte CodeLen	;patch wh_CodeLength
>8461	46 43 6d 70 41			Name0:	.text "FCmpA"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=33766					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>8466	25					.byte (("FCmpA"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=29					LinkDisplacement = Nt0-WordListLink
>8467	10					.byte WordFlags	;wh_Flags
>8468	03					.byte 3	;wh_CodeLength
>8469	1d					  .byte LinkDisplacement	; offset to previous nt
=$846a					XtPtr1 ::= *
=33766					WordListLink ::= Nt0 ; remember the nt of this word for later
.846a	86 14		stx $14		FCmpA:		stx tmp1		; save data stack index
.846c	a6 4c		ldx $4c				ldx FIndex		; X= FP stack index
.846e	b5 57		lda $57,x			lda FSMant0+0,x		; r2 mantissa == 0 ?
.8470	f0 35		beq $84a7			beq _r2Zero
.8472	b4 58		ldy $58,x			ldy FSMant0+1,x		; r1 mantissa == 0 ?
.8474	f0 2b		beq $84a1			beq _r1Zero
.8476	55 58		eor $58,x			eor FSMant0+1,x		; compare mantissa sign
.8478	30 3d		bmi $84b7			bmi _MantissaSignDifferent
.847a	38		sec				sec			; compare exponent
.847b	b5 4e		lda $4e,x			lda FSExp+1,x
.847d	f5 4d		sbc $4d,x			sbc FSExp+0,x
.847f	d0 2b		bne $84ac			bne _ExponentDifferent
.8481	98		tya				tya			; compare mantissa MSB
.8482	f5 57		sbc $57,x			sbc FSMant0+0,x		;   always same sign so can't overflow
.8484	d0 17		bne $849d			bne _13
.8486	b5 62		lda $62,x			lda FSMant1+1,x		; compare mantissa 1
.8488	f5 61		sbc $61,x			sbc FSMant1+0,x
.848a	d0 0c		bne $8498			bne _12
.848c	b5 6c		lda $6c,x			lda FSMant2+1,x		; compare mantissa 2
.848e	f5 6b		sbc $6b,x			sbc FSMant2+0,x
.8490	d0 06		bne $8498			bne _12
.8492	b5 76		lda $76,x			lda FSMant3+1,x		; compare mantissa LSB
.8494	f5 75		sbc $75,x			sbc FSMant3+0,x
.8496	f0 05		beq $849d			beq _13
.8498	6a		ror a		_12:		ror a
.8499	49 80		eor #$80	_14:		eor #$80
.849b	09 01		ora #$01			ora #1
.849d	a6 14		ldx $14		_13:		ldx tmp1		; restore data stack index
.849f	a8		tay				tay			; set CPU flags
.84a0	60		rts				rts
.84a1	b5 57		lda $57,x	_r1Zero:	lda FSMant0+0,x		; return 0-r2
.84a3	d0 f4		bne $8499			bne _14
.84a5	f0 f6		beq $849d			beq _13
.84a7	b5 58		lda $58,x	_r2Zero:	lda FSMant0+1,x		; return r1
.84a9	4c 9d 84	jmp $849d			jmp _13
.84ac					_ExponentDifferent:
.84ac	50 02		bvc $84b0			bvc +
.84ae	49 80		eor #$80			eor #$80
.84b0					+
.84b0	55 57		eor $57,x			eor FSMant0+0,x
.84b2	a6 14		ldx $14				ldx tmp1		; restore data stack index
.84b4	09 01		ora #$01			ora #1			; set CPU flags
.84b6	60		rts				rts
.84b7					_MantissaSignDifferent:
.84b7	98		tya				tya
.84b8	a6 14		ldx $14				ldx tmp1		; restore data stack index
.84ba	09 01		ora #$01			ora #1
.84bc	60		rts				rts
=83					CodeLen	.var *-XtPtr1
=$84bd					Here1 = *	; remember here
>8468	53					.byte CodeLen	;patch wh_CodeLength
>84bd	46 41 6c 6c 6f 63 58		Name0:	.text "FAllocX"	;  name of word as a string, ending at wh_NameLastChar
=7					NameLength = *-Name0
=33860					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>84c4	07					.byte (("FAllocX"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=94					LinkDisplacement = Nt0-WordListLink
>84c5	10					.byte WordFlags	;wh_Flags
>84c6	03					.byte 3	;wh_CodeLength
>84c7	5e					  .byte LinkDisplacement	; offset to previous nt
=$84c8					XtPtr1 ::= *
=33860					WordListLink ::= Nt0 ; remember the nt of this word for later
.84c8					FAllocX:
.84c8	86 14		stx $14				stx tmp1+0	; save data stack index
.84ca	a6 4c		ldx $4c				ldx FIndex	; X= floating point stack index
.84cc	ca		dex				dex		; alloc FP stack entry
.84cd	e0 0a		cpx #$0a			cpx #FDim	; stack overflow or underflow?
.84cf	b0 03		bcs $84d4			bcs _err
.84d1	86 4c		stx $4c				stx FIndex
.84d3	60		rts				rts		; return X= FP stack index
.84d4	08		php		_err:		php		; save sign bit
.84d5	a6 14		ldx $14				ldx tmp1+0	; restore data stack index
.84d7	28		plp				plp		; restore sign bit
.84d8	4c 34 c4	jmp $c434			jmp Throw_FPStack
=19					CodeLen	.var *-XtPtr1
=$84db					Here1 = *	; remember here
>84c6	13					.byte CodeLen	;patch wh_CodeLength
>84db	46 4d 61 78			Name0:	.text "FMax"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=33887					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>84df	04					.byte (("FMax"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=27					LinkDisplacement = Nt0-WordListLink
>84e0	10					.byte WordFlags	;wh_Flags
>84e1	03					.byte 3	;wh_CodeLength
>84e2	1b					  .byte LinkDisplacement	; offset to previous nt
=$84e3					XtPtr1 ::= *
=33887					WordListLink ::= Nt0 ; remember the nt of this word for later
.84e3	20 6a 84	jsr $846a	FMax:		jsr FCmpA
.84e6	10 2c		bpl $8514			bpl FDrop
.84e8	30 44		bmi $852e			bmi FNip
=7					CodeLen	.var *-XtPtr1
=$84ea					Here1 = *	; remember here
>84e1	07					.byte CodeLen	;patch wh_CodeLength
>84ea	46 4d 69 6e			Name0:	.text "FMin"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=33902					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>84ee	c4					.byte (("FMin"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=15					LinkDisplacement = Nt0-WordListLink
>84ef	10					.byte WordFlags	;wh_Flags
>84f0	03					.byte 3	;wh_CodeLength
>84f1	0f					  .byte LinkDisplacement	; offset to previous nt
=$84f2					XtPtr1 ::= *
=33902					WordListLink ::= Nt0 ; remember the nt of this word for later
.84f2	20 6a 84	jsr $846a	FMin:		jsr FCmpA
.84f5	30 1d		bmi $8514			bmi FDrop
.84f7	10 35		bpl $852e			bpl FNip
=7					CodeLen	.var *-XtPtr1
=$84f9					Here1 = *	; remember here
>84f0	07					.byte CodeLen	;patch wh_CodeLength
>84f9	46 44 65 70 74 68		Name0:	.text "FDepth"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=33919					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>84ff	06					.byte (("FDepth"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=17					LinkDisplacement = Nt0-WordListLink
>8500	10					.byte WordFlags	;wh_Flags
>8501	03					.byte 3	;wh_CodeLength
>8502	11					  .byte LinkDisplacement	; offset to previous nt
=$8503					XtPtr1 ::= *
=33919					WordListLink ::= Nt0 ; remember the nt of this word for later
.8503	a9 0a		lda #$0a	FDepth:		lda #FDim
.8505	38		sec				sec
.8506	e5 4c		sbc $4c				sbc FIndex
.8508	4c e4 c7	jmp $c7e4			jmp PushZA
=8					CodeLen	.var *-XtPtr1
=$850b					Here1 = *	; remember here
>8501	08					.byte CodeLen	;patch wh_CodeLength
>850b	46 44 72 6f 70			Name0:	.text "FDrop"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=33936					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>8510	05					.byte (("FDrop"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=0					WordFlags ::= 0	; modifiable copy, remember for later
=17					LinkDisplacement = Nt0-WordListLink
>8511	00					.byte WordFlags	;wh_Flags
>8512	03					.byte 3	;wh_CodeLength
>8513	11					  .byte LinkDisplacement	; offset to previous nt
=$8514					XtPtr1 ::= *
=33936					WordListLink ::= Nt0 ; remember the nt of this word for later
.8514	e6 4c		inc $4c		FDrop:		inc FIndex
=2					CodeLen	.var *-XtPtr1
=$8516					Here1 = *	; remember here
>8512	02					.byte CodeLen	;patch wh_CodeLength
.8516	60		rts				rts
>8517	46 32 44 72 6f 70		Name0:	.text "F2Drop"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=33949					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>851d	06					.byte (("F2Drop"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=0					WordFlags ::= 0	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>851e	00					.byte WordFlags	;wh_Flags
>851f	03					.byte 3	;wh_CodeLength
>8520	0d					  .byte LinkDisplacement	; offset to previous nt
=$8521					XtPtr1 ::= *
=33949					WordListLink ::= Nt0 ; remember the nt of this word for later
.8521	e6 4c		inc $4c		F2Drop:		inc FIndex
.8523	e6 4c		inc $4c				inc FIndex
=4					CodeLen	.var *-XtPtr1
=$8525					Here1 = *	; remember here
>851f	04					.byte CodeLen	;patch wh_CodeLength
.8525	60		rts				rts
>8526	46 4e 69 70			Name0:	.text "FNip"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=33962					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>852a	04					.byte (("FNip"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=0					WordFlags ::= 0	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>852b	00					.byte WordFlags	;wh_Flags
>852c	03					.byte 3	;wh_CodeLength
>852d	0d					  .byte LinkDisplacement	; offset to previous nt
=$852e					XtPtr1 ::= *
=33962					WordListLink ::= Nt0 ; remember the nt of this word for later
.852e	86 14		stx $14		FNip:		stx tmp1		; save data stack index
.8530	a6 4c		ldx $4c				ldx FIndex		; X= FP stack index
.8532	b5 4d		lda $4d,x			lda FSExp+0,x		; copy exponent
.8534	95 4e		sta $4e,x			sta FSExp+1,x
.8536	b5 57		lda $57,x			lda FSMant0+0,x		; copy mantissa
.8538	95 58		sta $58,x			sta FSMant0+1,x
.853a	b5 61		lda $61,x			lda FSMant1+0,x
.853c	95 62		sta $62,x			sta FSMant1+1,x
.853e	b5 6b		lda $6b,x			lda FSMant2+0,x
.8540	95 6c		sta $6c,x			sta FSMant2+1,x
.8542	b5 75		lda $75,x			lda FSMant3+0,x
.8544	95 76		sta $76,x			sta FSMant3+1,x
.8546	e6 4c		inc $4c				inc FIndex		; FDrop
.8548	a6 14		ldx $14				ldx tmp1		; restore data stack index
=28					CodeLen	.var *-XtPtr1
=$854a					Here1 = *	; remember here
>852c	1c					.byte CodeLen	;patch wh_CodeLength
.854a	60		rts				rts
>854b	46 44 75 70			Name0:	.text "FDup"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=33999					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>854f	04					.byte (("FDup"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=0					WordFlags ::= 0	; modifiable copy, remember for later
=37					LinkDisplacement = Nt0-WordListLink
>8550	00					.byte WordFlags	;wh_Flags
>8551	03					.byte 3	;wh_CodeLength
>8552	25					  .byte LinkDisplacement	; offset to previous nt
=$8553					XtPtr1 ::= *
=33999					WordListLink ::= Nt0 ; remember the nt of this word for later
.8553	20 c8 84	jsr $84c8	FDup:		jsr FAllocX		; alloc FP stack entry, X=fp stack index
.8556	b5 4e		lda $4e,x			lda FSExp+1,x		; copy exponent
.8558	95 4d		sta $4d,x			sta FSExp+0,x
.855a	b5 58		lda $58,x			lda FSMant0+1,x		; copy mantissa
.855c	95 57		sta $57,x			sta FSMant0+0,x
.855e	b5 62		lda $62,x			lda FSMant1+1,x
.8560	95 61		sta $61,x			sta FSMant1+0,x
.8562	b5 6c		lda $6c,x			lda FSMant2+1,x
.8564	95 6b		sta $6b,x			sta FSMant2+0,x
.8566	b5 76		lda $76,x			lda FSMant3+1,x
.8568	95 75		sta $75,x			sta FSMant3+0,x
.856a	a6 14		ldx $14				ldx tmp1+0		; restore data stack index
=25					CodeLen	.var *-XtPtr1
=$856c					Here1 = *	; remember here
>8551	19					.byte CodeLen	;patch wh_CodeLength
.856c	60		rts				rts
>856d	46 4f 76 65 72			Name0:	.text "FOver"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=34034					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>8572	45					.byte (("FOver"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=0					WordFlags ::= 0	; modifiable copy, remember for later
=35					LinkDisplacement = Nt0-WordListLink
>8573	00					.byte WordFlags	;wh_Flags
>8574	03					.byte 3	;wh_CodeLength
>8575	23					  .byte LinkDisplacement	; offset to previous nt
=$8576					XtPtr1 ::= *
=34034					WordListLink ::= Nt0 ; remember the nt of this word for later
.8576	20 c8 84	jsr $84c8	FOver:		jsr FAllocX		; alloc FP stack entry, X=fp stack index
.8579	b5 4f		lda $4f,x			lda FSExp+2,x		; copy exponent
.857b	95 4d		sta $4d,x			sta FSExp+0,x
.857d	b5 59		lda $59,x			lda FSMant0+2,x		; copy mantissa
.857f	95 57		sta $57,x			sta FSMant0+0,x
.8581	b5 63		lda $63,x			lda FSMant1+2,x
.8583	95 61		sta $61,x			sta FSMant1+0,x
.8585	b5 6d		lda $6d,x			lda FSMant2+2,x
.8587	95 6b		sta $6b,x			sta FSMant2+0,x
.8589	b5 77		lda $77,x			lda FSMant3+2,x
.858b	95 75		sta $75,x			sta FSMant3+0,x
.858d	a6 14		ldx $14				ldx tmp1+0		; restore data stack index
=25					CodeLen	.var *-XtPtr1
=$858f					Here1 = *	; remember here
>8574	19					.byte CodeLen	;patch wh_CodeLength
.858f	60		rts				rts
>8590	46 50 69 63 6b			Name0:	.text "FPick"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=34069					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>8595	65					.byte (("FPick"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=0					WordFlags ::= 0	; modifiable copy, remember for later
=35					LinkDisplacement = Nt0-WordListLink
>8596	00					.byte WordFlags	;wh_Flags
>8597	03					.byte 3	;wh_CodeLength
>8598	23					  .byte LinkDisplacement	; offset to previous nt
=$8599					XtPtr1 ::= *
=34069					WordListLink ::= Nt0 ; remember the nt of this word for later
.8599	20 c3 c3	jsr $c3c3	FPick:		jsr PopA		; pop u (desired entry #)
.859c	18		clc		FPickA:		clc			; Y= fp stack index of [u]
.859d	65 4c		adc $4c				adc FIndex
.859f	a8		tay		FPick3:		tay
.85a0	20 c8 84	jsr $84c8			jsr FAllocX		; alloc FP stack entry, X=fp stack index
.85a3	b9 4d 00	lda $004d,y			lda FSExp,y		; copy exponent
.85a6	95 4d		sta $4d,x			sta FSExp,x
.85a8	b9 57 00	lda $0057,y			lda FSMant0,y		; copy mantissa
.85ab	95 57		sta $57,x			sta FSMant0,x
.85ad	b9 61 00	lda $0061,y			lda FSMant1,y
.85b0	95 61		sta $61,x			sta FSMant1,x
.85b2	b9 6b 00	lda $006b,y			lda FSMant2,y
.85b5	95 6b		sta $6b,x			sta FSMant2,x
.85b7	b9 75 00	lda $0075,y			lda FSMant3,y
.85ba	95 75		sta $75,x			sta FSMant3,x
.85bc	a6 14		ldx $14				ldx tmp1+0		; restore data stack index
=37					CodeLen	.var *-XtPtr1
=$85be					Here1 = *	; remember here
>8597	25					.byte CodeLen	;patch wh_CodeLength
.85be	60		rts				rts
>85bf	46 32 44 75 70			Name0:	.text "F2Dup"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=34116					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>85c4	05					.byte (("F2Dup"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=47					LinkDisplacement = Nt0-WordListLink
>85c5	10					.byte WordFlags	;wh_Flags
>85c6	03					.byte 3	;wh_CodeLength
>85c7	2f					  .byte LinkDisplacement	; offset to previous nt
=$85c8					XtPtr1 ::= *
=34116					WordListLink ::= Nt0 ; remember the nt of this word for later
.85c8	20 76 85	jsr $8576	F2Dup:		jsr FOver
.85cb	4c 76 85	jmp $8576			jmp FOver
=6					CodeLen	.var *-XtPtr1
=$85ce					Here1 = *	; remember here
>85c6	06					.byte CodeLen	;patch wh_CodeLength
>85ce	46 53 77 61 70			Name0:	.text "FSwap"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=34131					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>85d3	05					.byte (("FSwap"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=0					WordFlags ::= 0	; modifiable copy, remember for later
=15					LinkDisplacement = Nt0-WordListLink
>85d4	00					.byte WordFlags	;wh_Flags
>85d5	03					.byte 3	;wh_CodeLength
>85d6	0f					  .byte LinkDisplacement	; offset to previous nt
=$85d7					XtPtr1 ::= *
=34131					WordListLink ::= Nt0 ; remember the nt of this word for later
.85d7	86 14		stx $14		FSwap:		stx tmp1+0		; save data stack index
.85d9	a6 4c		ldx $4c				ldx FIndex		; X=FP stack index
.85db	b5 4d		lda $4d,x			lda FSExp+0,x		; do FSExp
.85dd	b4 4e		ldy $4e,x			ldy FSExp+1,x
.85df	95 4e		sta $4e,x			sta FSExp+1,x
.85e1	94 4d		sty $4d,x			sty FSExp+0,x	; sty dir,x exists
.85e3	b5 57		lda $57,x			lda FSMant0+0,x		; do FSMant0
.85e5	b4 58		ldy $58,x			ldy FSMant0+1,x
.85e7	95 58		sta $58,x			sta FSMant0+1,x
.85e9	94 57		sty $57,x			sty FSMant0+0,x	; sty dir,x exists
.85eb	b5 61		lda $61,x			lda FSMant1+0,x		; do FSMant1
.85ed	b4 62		ldy $62,x			ldy FSMant1+1,x
.85ef	95 62		sta $62,x			sta FSMant1+1,x
.85f1	94 61		sty $61,x			sty FSMant1+0,x	; sty dir,x exists
.85f3	b5 6b		lda $6b,x			lda FSMant2+0,x		; do FSMant2
.85f5	b4 6c		ldy $6c,x			ldy FSMant2+1,x
.85f7	95 6c		sta $6c,x			sta FSMant2+1,x
.85f9	94 6b		sty $6b,x			sty FSMant2+0,x	; sty dir,x exists
.85fb	b5 75		lda $75,x			lda FSMant3+0,x		; do FSMant3
.85fd	b4 76		ldy $76,x			ldy FSMant3+1,x
.85ff	95 76		sta $76,x			sta FSMant3+1,x
.8601	94 75		sty $75,x			sty FSMant3+0,x	; sty dir,x exists
.8603	a6 14		ldx $14				ldx tmp1+0		; restore data stack index
=46					CodeLen	.var *-XtPtr1
=$8605					Here1 = *	; remember here
>85d5	2e					.byte CodeLen	;patch wh_CodeLength
.8605	60		rts				rts
>8606	46 54 75 63 6b			Name0:	.text "FTuck"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=34187					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>860b	65					.byte (("FTuck"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=56					LinkDisplacement = Nt0-WordListLink
>860c	10					.byte WordFlags	;wh_Flags
>860d	03					.byte 3	;wh_CodeLength
>860e	38					  .byte LinkDisplacement	; offset to previous nt
=$860f					XtPtr1 ::= *
=34187					WordListLink ::= Nt0 ; remember the nt of this word for later
.860f	20 d7 85	jsr $85d7	FTuck:		jsr FSwap
.8612	4c 76 85	jmp $8576			jmp FOver
=6					CodeLen	.var *-XtPtr1
=$8615					Here1 = *	; remember here
>860d	06					.byte CodeLen	;patch wh_CodeLength
>8615	46 52 6f 74			Name0:	.text "FRot"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=34201					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>8619	84					.byte (("FRot"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=0					WordFlags ::= 0	; modifiable copy, remember for later
=14					LinkDisplacement = Nt0-WordListLink
>861a	00					.byte WordFlags	;wh_Flags
>861b	03					.byte 3	;wh_CodeLength
>861c	0e					  .byte LinkDisplacement	; offset to previous nt
=$861d					XtPtr1 ::= *
=34201					WordListLink ::= Nt0 ; remember the nt of this word for later
.861d	86 14		stx $14		FRot:		stx tmp1		; save data stack index
.861f	a5 4c		lda $4c				lda FIndex		; for FSMant3, FSMant2, FSMant1, FSMant0, FSExp
.8621	18		clc				clc
.8622	69 28		adc #$28			adc #4*FDim
.8624	38		sec				sec
.8625	aa		tax		_2:		tax
.8626	b4 4f		ldy $4f,x			ldy FSExp+2,x		;   do a byte
.8628	b5 4e		lda $4e,x			lda FSExp+1,x
.862a	95 4f		sta $4f,x			sta FSExp+2,x
.862c	b5 4d		lda $4d,x			lda FSExp+0,x
.862e	95 4e		sta $4e,x			sta FSExp+1,x
.8630	94 4d		sty $4d,x			sty FSExp+0,x	; sty dir,x exists
.8632	8a		txa				txa			;   next byte
.8633	e9 0a		sbc #$0a			sbc #FDim
.8635	b0 ee		bcs $8625			bcs _2			; until done
.8637	a6 14		ldx $14				ldx tmp1		; restore param stack index
=28					CodeLen	.var *-XtPtr1
=$8639					Here1 = *	; remember here
>861b	1c					.byte CodeLen	;patch wh_CodeLength
.8639	60		rts				rts
>863a	46 2d 52 6f 74			Name0:	.text "F-Rot"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=34239					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>863f	85					.byte (("F-Rot"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=38					LinkDisplacement = Nt0-WordListLink
>8640	10					.byte WordFlags	;wh_Flags
>8641	03					.byte 3	;wh_CodeLength
>8642	26					  .byte LinkDisplacement	; offset to previous nt
=$8643					XtPtr1 ::= *
=34239					WordListLink ::= Nt0 ; remember the nt of this word for later
.8643	20 1d 86	jsr $861d	FMRot:		jsr FRot
.8646	4c 1d 86	jmp $861d			jmp FRot
=6					CodeLen	.var *-XtPtr1
=$8649					Here1 = *	; remember here
>8641	06					.byte CodeLen	;patch wh_CodeLength
>8649	46 40				Name0:	.text "F@"	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=34251					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>864b	02					.byte (("F@"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=0					WordFlags ::= 0	; modifiable copy, remember for later
=12					LinkDisplacement = Nt0-WordListLink
>864c	00					.byte WordFlags	;wh_Flags
>864d	03					.byte 3	;wh_CodeLength
>864e	0c					  .byte LinkDisplacement	; offset to previous nt
=$864f					XtPtr1 ::= *
=34251					WordListLink ::= Nt0 ; remember the nt of this word for later
.864f	20 de c3	jsr $c3de	FAt:		jsr PopYA		; pop addr
.8652	85 16		sta $16		FAt_YA:		sta tmp2+0		; save addr
.8654	84 17		sty $17				sty tmp2+1
.8656	a0 00		ldy #$00			ldy #0			; starting offset from tmp2
.8658	20 c8 84	jsr $84c8	FAt_Tmp2Y:	jsr FAllocX		; alloc FP stack entry, X= fp stack index
.865b	b1 16		lda ($16),y			lda (tmp2),y		; copy mantissa
.865d	95 75		sta $75,x			sta FSMant3,x
.865f	c8		iny				iny
.8660	b1 16		lda ($16),y			lda (tmp2),y
.8662	95 6b		sta $6b,x			sta FSMant2,x
.8664	c8		iny				iny
.8665	b1 16		lda ($16),y			lda (tmp2),y
.8667	95 61		sta $61,x			sta FSMant1,x
.8669	c8		iny				iny
.866a	b1 16		lda ($16),y			lda (tmp2),y
.866c	95 57		sta $57,x			sta FSMant0,x
.866e	c8		iny				iny			; copy exponent
.866f	b1 16		lda ($16),y			lda (tmp2),y
.8671	95 4d		sta $4d,x			sta FSExp,x
.8673	a6 14		ldx $14				ldx tmp1		; restore data stack index
=38					CodeLen	.var *-XtPtr1
=$8675					Here1 = *	; remember here
>864d	26					.byte CodeLen	;patch wh_CodeLength
.8675	60		rts				rts
>8676	46 21				Name0:	.text "F!"	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=34296					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>8678	22					.byte (("F!"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=0					WordFlags ::= 0	; modifiable copy, remember for later
=45					LinkDisplacement = Nt0-WordListLink
>8679	00					.byte WordFlags	;wh_Flags
>867a	03					.byte 3	;wh_CodeLength
>867b	2d					  .byte LinkDisplacement	; offset to previous nt
=$867c					XtPtr1 ::= *
=34296					WordListLink ::= Nt0 ; remember the nt of this word for later
.867c	20 de c3	jsr $c3de	FStore:		jsr PopYA		; pop addr
.867f	85 14		sta $14		FStore_YA:	sta tmp1+0		; save addr
.8681	84 15		sty $15				sty tmp1+1
.8683	a0 00		ldy #$00			ldy #0
.8685	86 16		stx $16				stx tmp2		; save data stack index
.8687	a6 4c		ldx $4c				ldx FIndex		; X= FP stack index
.8689	b5 75		lda $75,x			lda FSMant3,x		; copy mantissa
.868b	91 14		sta ($14),y			sta (tmp1),y
.868d	b5 6b		lda $6b,x			lda FSMant2,x
.868f	c8		iny				iny
.8690	91 14		sta ($14),y			sta (tmp1),y
.8692	b5 61		lda $61,x			lda FSMant1,x
.8694	c8		iny				iny
.8695	91 14		sta ($14),y			sta (tmp1),y
.8697	b5 57		lda $57,x			lda FSMant0,x
.8699	c8		iny				iny
.869a	91 14		sta ($14),y			sta (tmp1),y
.869c	b5 4d		lda $4d,x			lda FSExp,x		; copy exponent
.869e	c8		iny				iny
.869f	91 14		sta ($14),y			sta (tmp1),y
.86a1	e6 4c		inc $4c				inc FIndex		; FDrop
.86a3	a6 16		ldx $16				ldx tmp2		; restore data stack index
=41					CodeLen	.var *-XtPtr1
=$86a5					Here1 = *	; remember here
>867a	29					.byte CodeLen	;patch wh_CodeLength
.86a5	60		rts				rts
>86a6	46 2c				Name0:	.text "F,"	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=34344					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>86a8	82					.byte (("F,"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=48					LinkDisplacement = Nt0-WordListLink
>86a9	10					.byte WordFlags	;wh_Flags
>86aa	03					.byte 3	;wh_CodeLength
>86ab	30					  .byte LinkDisplacement	; offset to previous nt
=$86ac					XtPtr1 ::= *
=34344					WordListLink ::= Nt0 ; remember the nt of this word for later
.86ac	a5 00		lda $00		FComma:		lda cp+0		; store f at Here
.86ae	a4 01		ldy $01				ldy cp+1
.86b0	20 7f 86	jsr $867f			jsr FStore_YA
.86b3	a9 05		lda #$05			lda #Float_Size
.86b5	4c b2 d0	jmp $d0b2			jmp Allot_ZA
=12					CodeLen	.var *-XtPtr1
=$86b8					Here1 = *	; remember here
>86aa	0c					.byte CodeLen	;patch wh_CodeLength
>86b8	46 30 21			Name0:	.text "F0!"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=34363					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>86bb	23					.byte (("F0!"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=19					LinkDisplacement = Nt0-WordListLink
>86bc	10					.byte WordFlags	;wh_Flags
>86bd	03					.byte 3	;wh_CodeLength
>86be	13					  .byte LinkDisplacement	; offset to previous nt
=$86bf					XtPtr1 ::= *
=34363					WordListLink ::= Nt0 ; remember the nt of this word for later
.86bf	20 ab 88	jsr $88ab	FZStore:	jsr F0
.86c2	4c 7c 86	jmp $867c			jmp FStore
=6					CodeLen	.var *-XtPtr1
=$86c5					Here1 = *	; remember here
>86bd	06					.byte CodeLen	;patch wh_CodeLength
>86c5	46 30 3d			Name0:	.text "F0="	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=34376					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>86c8	a3					.byte (("F0="[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>86c9	10					.byte WordFlags	;wh_Flags
>86ca	03					.byte 3	;wh_CodeLength
>86cb	0d					  .byte LinkDisplacement	; offset to previous nt
=$86cc					XtPtr1 ::= *
=34376					WordListLink ::= Nt0 ; remember the nt of this word for later
.86cc	a4 4c		ldy $4c		FZEq:		ldy FIndex
.86ce	b9 57 00	lda $0057,y			lda FSMant0,y
.86d1	d0 24		bne $86f7			bne FFalse1
.86d3					FTrue1:
.86d3	e6 4c		inc $4c				inc FIndex	; FDrop
.86d5	4c c4 c7	jmp $c7c4			jmp True	; return true
=12					CodeLen	.var *-XtPtr1
=$86d8					Here1 = *	; remember here
>86ca	0c					.byte CodeLen	;patch wh_CodeLength
>86d8	46 30 3c 3e			Name0:	.text "F0<>"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=34396					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>86dc	c4					.byte (("F0<>"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=20					LinkDisplacement = Nt0-WordListLink
>86dd	10					.byte WordFlags	;wh_Flags
>86de	03					.byte 3	;wh_CodeLength
>86df	14					  .byte LinkDisplacement	; offset to previous nt
=$86e0					XtPtr1 ::= *
=34396					WordListLink ::= Nt0 ; remember the nt of this word for later
.86e0	a4 4c		ldy $4c		FZNe:		ldy FIndex
.86e2	b9 57 00	lda $0057,y			lda FSMant0,y
.86e5	d0 ec		bne $86d3			bne FTrue1
.86e7	f0 0e		beq $86f7			beq FFalse1
=9					CodeLen	.var *-XtPtr1
=$86e9					Here1 = *	; remember here
>86de	09					.byte CodeLen	;patch wh_CodeLength
>86e9	46 30 3c			Name0:	.text "F0<"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=34412					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>86ec	83					.byte (("F0<"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=16					LinkDisplacement = Nt0-WordListLink
>86ed	10					.byte WordFlags	;wh_Flags
>86ee	03					.byte 3	;wh_CodeLength
>86ef	10					  .byte LinkDisplacement	; offset to previous nt
=$86f0					XtPtr1 ::= *
=34412					WordListLink ::= Nt0 ; remember the nt of this word for later
.86f0	a4 4c		ldy $4c		FZLt:		ldy FIndex
.86f2	b9 57 00	lda $0057,y			lda FSMant0,y
.86f5	30 dc		bmi $86d3			bmi FTrue1
.86f7					FFalse1:
.86f7	e6 4c		inc $4c				inc FIndex	; FDrop
.86f9	4c d6 c7	jmp $c7d6			jmp False	; return false
=12					CodeLen	.var *-XtPtr1
=$86fc					Here1 = *	; remember here
>86ee	0c					.byte CodeLen	;patch wh_CodeLength
>86fc	46 30 3e 3d			Name0:	.text "F0>="	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=34432					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>8700	a4					.byte (("F0>="[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=20					LinkDisplacement = Nt0-WordListLink
>8701	10					.byte WordFlags	;wh_Flags
>8702	03					.byte 3	;wh_CodeLength
>8703	14					  .byte LinkDisplacement	; offset to previous nt
=$8704					XtPtr1 ::= *
=34432					WordListLink ::= Nt0 ; remember the nt of this word for later
.8704	a4 4c		ldy $4c		FZGe:		ldy FIndex
.8706	b9 57 00	lda $0057,y			lda FSMant0,y
.8709	10 c8		bpl $86d3			bpl FTrue1
.870b	30 ea		bmi $86f7			bmi FFalse1
=9					CodeLen	.var *-XtPtr1
=$870d					Here1 = *	; remember here
>8702	09					.byte CodeLen	;patch wh_CodeLength
>870d	46 30 3e			Name0:	.text "F0>"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=34448					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>8710	c3					.byte (("F0>"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=16					LinkDisplacement = Nt0-WordListLink
>8711	10					.byte WordFlags	;wh_Flags
>8712	03					.byte 3	;wh_CodeLength
>8713	10					  .byte LinkDisplacement	; offset to previous nt
=$8714					XtPtr1 ::= *
=34448					WordListLink ::= Nt0 ; remember the nt of this word for later
.8714	a4 4c		ldy $4c		FZGt:		ldy FIndex
.8716	b9 57 00	lda $0057,y			lda FSMant0,y
.8719	30 dc		bmi $86f7			bmi FFalse1
.871b	d0 b6		bne $86d3			bne FTrue1
.871d	f0 d8		beq $86f7			beq FFalse1
=11					CodeLen	.var *-XtPtr1
=$871f					Here1 = *	; remember here
>8712	0b					.byte CodeLen	;patch wh_CodeLength
>871f	46 30 3c 3d			Name0:	.text "F0<="	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=34467					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>8723	a4					.byte (("F0<="[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=19					LinkDisplacement = Nt0-WordListLink
>8724	10					.byte WordFlags	;wh_Flags
>8725	03					.byte 3	;wh_CodeLength
>8726	13					  .byte LinkDisplacement	; offset to previous nt
=$8727					XtPtr1 ::= *
=34467					WordListLink ::= Nt0 ; remember the nt of this word for later
.8727	a4 4c		ldy $4c		FZLe:		ldy FIndex
.8729	b9 57 00	lda $0057,y			lda FSMant0,y
.872c	30 a5		bmi $86d3			bmi FTrue1
.872e	d0 c7		bne $86f7			bne FFalse1
.8730	f0 a1		beq $86d3			beq FTrue1
=11					CodeLen	.var *-XtPtr1
=$8732					Here1 = *	; remember here
>8725	0b					.byte CodeLen	;patch wh_CodeLength
>8732	46 3c				Name0:	.text "F<"	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=34484					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>8734	82					.byte (("F<"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=17					LinkDisplacement = Nt0-WordListLink
>8735	10					.byte WordFlags	;wh_Flags
>8736	03					.byte 3	;wh_CodeLength
>8737	11					  .byte LinkDisplacement	; offset to previous nt
=$8738					XtPtr1 ::= *
=34484					WordListLink ::= Nt0 ; remember the nt of this word for later
.8738	20 6a 84	jsr $846a	FLt:		jsr FCmpA
.873b	30 32		bmi $876f			bmi FTrue2
.873d					FFalse2:
.873d	e6 4c		inc $4c				inc FIndex	; FDrop
.873f	e6 4c		inc $4c				inc FIndex	; FDrop
.8741	4c d6 c7	jmp $c7d6			jmp False	; return False
=12					CodeLen	.var *-XtPtr1
=$8744					Here1 = *	; remember here
>8736	0c					.byte CodeLen	;patch wh_CodeLength
>8744	46 3e 3d			Name0:	.text "F>="	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=34503					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>8747	a3					.byte (("F>="[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=19					LinkDisplacement = Nt0-WordListLink
>8748	10					.byte WordFlags	;wh_Flags
>8749	03					.byte 3	;wh_CodeLength
>874a	13					  .byte LinkDisplacement	; offset to previous nt
=$874b					XtPtr1 ::= *
=34503					WordListLink ::= Nt0 ; remember the nt of this word for later
.874b	20 6a 84	jsr $846a	FGe:		jsr FCmpA
.874e	10 1f		bpl $876f			bpl FTrue2
.8750	30 eb		bmi $873d			bmi FFalse2
=7					CodeLen	.var *-XtPtr1
=$8752					Here1 = *	; remember here
>8749	07					.byte CodeLen	;patch wh_CodeLength
>8752	46 3e				Name0:	.text "F>"	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=34516					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>8754	c2					.byte (("F>"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>8755	10					.byte WordFlags	;wh_Flags
>8756	03					.byte 3	;wh_CodeLength
>8757	0d					  .byte LinkDisplacement	; offset to previous nt
=$8758					XtPtr1 ::= *
=34516					WordListLink ::= Nt0 ; remember the nt of this word for later
.8758	20 6a 84	jsr $846a	FGt:		jsr FCmpA
.875b	30 e0		bmi $873d			bmi FFalse2
.875d	d0 10		bne $876f			bne FTrue2
.875f	f0 dc		beq $873d			beq FFalse2
=9					CodeLen	.var *-XtPtr1
=$8761					Here1 = *	; remember here
>8756	09					.byte CodeLen	;patch wh_CodeLength
>8761	46 3c 3d			Name0:	.text "F<="	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=34532					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>8764	a3					.byte (("F<="[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=16					LinkDisplacement = Nt0-WordListLink
>8765	10					.byte WordFlags	;wh_Flags
>8766	03					.byte 3	;wh_CodeLength
>8767	10					  .byte LinkDisplacement	; offset to previous nt
=$8768					XtPtr1 ::= *
=34532					WordListLink ::= Nt0 ; remember the nt of this word for later
.8768	20 6a 84	jsr $846a	FLe:		jsr FCmpA
.876b	30 02		bmi $876f			bmi FTrue2
.876d	d0 ce		bne $873d			bne FFalse2
.876f					FTrue2:
.876f	e6 4c		inc $4c				inc FIndex	; FDrop
.8771	e6 4c		inc $4c				inc FIndex	; FDrop
.8773	4c c4 c7	jmp $c7c4			jmp True	; return True
=14					CodeLen	.var *-XtPtr1
=$8776					Here1 = *	; remember here
>8766	0e					.byte CodeLen	;patch wh_CodeLength
>8776	46 3c 3e			Name0:	.text "F<>"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=34553					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>8779	c3					.byte (("F<>"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=21					LinkDisplacement = Nt0-WordListLink
>877a	10					.byte WordFlags	;wh_Flags
>877b	03					.byte 3	;wh_CodeLength
>877c	15					  .byte LinkDisplacement	; offset to previous nt
=$877d					XtPtr1 ::= *
=34553					WordListLink ::= Nt0 ; remember the nt of this word for later
.877d	20 6a 84	jsr $846a	FNe:		jsr FCmpA
.8780	d0 ed		bne $876f			bne FTrue2
.8782	f0 b9		beq $873d			beq FFalse2
=7					CodeLen	.var *-XtPtr1
=$8784					Here1 = *	; remember here
>877b	07					.byte CodeLen	;patch wh_CodeLength
>8784	46 3d				Name0:	.text "F="	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=34566					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>8786	a2					.byte (("F="[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>8787	10					.byte WordFlags	;wh_Flags
>8788	03					.byte 3	;wh_CodeLength
>8789	0d					  .byte LinkDisplacement	; offset to previous nt
=$878a					XtPtr1 ::= *
=34566					WordListLink ::= Nt0 ; remember the nt of this word for later
.878a	20 6a 84	jsr $846a	FEq:		jsr FCmpA
.878d	d0 ae		bne $873d			bne FFalse2
.878f	f0 de		beq $876f			beq FTrue2
=7					CodeLen	.var *-XtPtr1
=$8791					Here1 = *	; remember here
>8788	07					.byte CodeLen	;patch wh_CodeLength
>8791	46 7e 41 62 73			Name0:	.text "F~Abs"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=34582					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>8796	65					.byte (("F~Abs"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=16					LinkDisplacement = Nt0-WordListLink
>8797	10					.byte WordFlags	;wh_Flags
>8798	03					.byte 3	;wh_CodeLength
>8799	10					  .byte LinkDisplacement	; offset to previous nt
=$879a					XtPtr1 ::= *
=34582					WordListLink ::= Nt0 ; remember the nt of this word for later
.879a	20 43 86	jsr $8643	FTAbs:		jsr FMRot
.879d	20 70 8b	jsr $8b70			jsr FMinus
.87a0	20 cb 8b	jsr $8bcb			jsr FAbs
.87a3	4c 58 87	jmp $8758			jmp FGt
=12					CodeLen	.var *-XtPtr1
=$87a6					Here1 = *	; remember here
>8798	0c					.byte CodeLen	;patch wh_CodeLength
>87a6	46 7e 52 65 6c			Name0:	.text "F~Rel"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=34603					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>87ab	85					.byte (("F~Rel"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=21					LinkDisplacement = Nt0-WordListLink
>87ac	10					.byte WordFlags	;wh_Flags
>87ad	03					.byte 3	;wh_CodeLength
>87ae	15					  .byte LinkDisplacement	; offset to previous nt
=$87af					XtPtr1 ::= *
=34603					WordListLink ::= Nt0 ; remember the nt of this word for later
.87af	20 76 85	jsr $8576	FTRel:		jsr FOver
.87b2	a9 03		lda #$03			lda #3
.87b4	20 9c 85	jsr $859c			jsr FPickA
.87b7	20 30 8b	jsr $8b30			jsr FPlus
.87ba	20 cb 8b	jsr $8bcb			jsr FAbs
.87bd	20 fe 8b	jsr $8bfe			jsr FStar		; r1 r2 r3*|r1+r2|
.87c0	20 43 86	jsr $8643			jsr FMRot		; r3*|r1+r2| r1 r2
.87c3	20 70 8b	jsr $8b70			jsr FMinus
.87c6	20 cb 8b	jsr $8bcb			jsr FAbs
.87c9	4c 58 87	jmp $8758			jmp FGt
=29					CodeLen	.var *-XtPtr1
=$87cc					Here1 = *	; remember here
>87ad	1d					.byte CodeLen	;patch wh_CodeLength
>87cc	46 7e				Name0:	.text "F~"	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=34638					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>87ce	c2					.byte (("F~"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=35					LinkDisplacement = Nt0-WordListLink
>87cf	10					.byte WordFlags	;wh_Flags
>87d0	03					.byte 3	;wh_CodeLength
>87d1	23					  .byte LinkDisplacement	; offset to previous nt
=$87d2					XtPtr1 ::= *
=34638					WordListLink ::= Nt0 ; remember the nt of this word for later
.87d2	a4 4c		ldy $4c		FTilde:		ldy FIndex
.87d4	b9 57 00	lda $0057,y			lda FSMant0,y
.87d7	30 06		bmi $87df			bmi _10			; r3<0
.87d9	d0 bf		bne $879a			bne FTAbs		; r3>0
.87db	e6 4c		inc $4c				inc FIndex		; r3=0
.87dd	d0 ab		bne $878a			bne FEq
.87df	20 a5 8b	jsr $8ba5	_10:		jsr FNegate
.87e2	4c af 87	jmp $87af			jmp FTRel
=19					CodeLen	.var *-XtPtr1
=$87e5					Here1 = *	; remember here
>87d0	13					.byte CodeLen	;patch wh_CodeLength
>87e5	46 56 61 72 69 61 62 6c		Name0:	.text "FVariable"	;  name of word as a string, ending at wh_NameLastChar
>87ed	65
=9					NameLength = *-Name0
=34670					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>87ee	a9					.byte (("FVariable"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=24					WordFlags ::= IM+NN	; modifiable copy, remember for later
=32					LinkDisplacement = Nt0-WordListLink
>87ef	18					.byte WordFlags	;wh_Flags
>87f0	03					.byte 3	;wh_CodeLength
>87f1	20					  .byte LinkDisplacement	; offset to previous nt
=$87f2					XtPtr1 ::= *
=34670					WordListLink ::= Nt0 ; remember the nt of this word for later
.87f2	20 c8 d1	jsr $d1c8	FVariable:	jsr Create		; compile word header & push PFA adr
.87f5	20 db cb	jsr $cbdb			jsr adjust_z		; fix word code length
.87f8	20 ab 88	jsr $88ab			jsr F0			; alloc & init data
.87fb	4c ac 86	jmp $86ac			jmp FComma
=12					CodeLen	.var *-XtPtr1
=$87fe					Here1 = *	; remember here
>87f0	0c					.byte CodeLen	;patch wh_CodeLength
>87fe	46 4c 69 74 65 72 61 6c		Name0:	.text "FLiteral"	;  name of word as a string, ending at wh_NameLastChar
=8					NameLength = *-Name0
=34694					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>8806	88					.byte (("FLiteral"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=24					WordFlags ::= IM+NN	; modifiable copy, remember for later
=24					LinkDisplacement = Nt0-WordListLink
>8807	18					.byte WordFlags	;wh_Flags
>8808	03					.byte 3	;wh_CodeLength
>8809	18					  .byte LinkDisplacement	; offset to previous nt
=$880a					XtPtr1 ::= *
=34694					WordListLink ::= Nt0 ; remember the nt of this word for later
.880a	20 1f 88	jsr $881f	FLiteral:	jsr FLitTest
.880d	f0 0a		beq $8819			beq _Short
.880f	a9 48		lda #$48			lda #<FLitI		; compile JSR FLitI
.8811	a0 88		ldy #$88			ldy #>FLitI
.8813	20 73 dd	jsr $dd73			jsr Jsr_Comma_YA
.8816	4c ac 86	jmp $86ac			jmp FComma		; compile inline operand, return
.8819	20 2b 88	jsr $882b	_Short:		jsr FLitShort
.881c	4c 73 dd	jmp $dd73			jmp Jsr_Comma_YA	; compile jsr FLitYA, & return
=21					CodeLen	.var *-XtPtr1
=$881f					Here1 = *	; remember here
>8808	15					.byte CodeLen	;patch wh_CodeLength
.881f					FLitTest:
.881f	a4 4c		ldy $4c				ldy FIndex
.8821	b9 61 00	lda $0061,y			lda FSMant1,y		; will short work?
.8824	19 6b 00	ora $006b,y			ora FSMant2,y
.8827	19 75 00	ora $0075,y			ora FSMant3,y
.882a	60		rts				rts
.882b					FLitShort:
.882b	a9 a9		lda #$a9			lda #$a9		; compile LDA #mant0
.882d	20 39 dd	jsr $dd39			jsr C_Comma_A
.8830	b9 57 00	lda $0057,y			lda FSMant0,y
.8833	20 39 dd	jsr $dd39			jsr C_Comma_A
.8836	a9 a0		lda #$a0			lda #$a0		; compile LDY #exp
.8838	20 39 dd	jsr $dd39			jsr C_Comma_A
.883b	b9 4d 00	lda $004d,y			lda FSExp,y
.883e	20 39 dd	jsr $dd39			jsr C_Comma_A
.8841	e6 4c		inc $4c				inc FIndex		; FDrop
.8843	a9 92		lda #$92			lda #<FLitYA		; point at FLitYA
.8845	a0 88		ldy #$88			ldy #>FLitYA
.8847	60		rts				rts
.8848					FLitI:
.8848	68		pla				pla			; tmp2= RTS addr
.8849	85 16		sta $16				sta tmp2+0
.884b	18		clc				clc			; bump RTS addr over inline float data
.884c	69 05		adc #$05			adc #Float_Size
.884e	a8		tay				tay
.884f	68		pla				pla
.8850	85 17		sta $17				sta tmp2+1
.8852	69 00		adc #$00			adc #0
.8854	48		pha				pha
.8855	98		tya				tya
.8856	48		pha				pha
.8857	a0 01		ldy #$01			ldy #1			; correct for RTS addr
.8859	4c 58 86	jmp $8658			jmp FAt_Tmp2Y		; fetch inline data, & return
>885c	46 43 6f 6e 73 74 61 6e		Name0:	.text "FConstant"	;  name of word as a string, ending at wh_NameLastChar
>8864	74
=9					NameLength = *-Name0
=34789					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>8865	89					.byte (("FConstant"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=95					LinkDisplacement = Nt0-WordListLink
>8866	10					.byte WordFlags	;wh_Flags
>8867	03					.byte 3	;wh_CodeLength
>8868	5f					  .byte LinkDisplacement	; offset to previous nt
=$8869					XtPtr1 ::= *
=34789					WordListLink ::= Nt0 ; remember the nt of this word for later
.8869	20 1b d1	jsr $d11b	FConstant:	jsr Header_Comma	; compile word header
.886c	20 1f 88	jsr $881f			jsr FLitTest		; will short work?
.886f	f0 0d		beq $887e			beq _Short
.8871	a9 87		lda #$87			lda #<FConstantRun	; compile JSR
.8873	a0 88		ldy #$88			ldy #>FConstantRun
.8875	20 73 dd	jsr $dd73			jsr Jsr_Comma_YA
.8878	20 db cb	jsr $cbdb			jsr adjust_z
.887b	4c ac 86	jmp $86ac			jmp FComma		; compile inline operand, & return
.887e					_Short:
.887e	20 2b 88	jsr $882b			jsr FLitShort		; compile load value
.8881	20 89 dd	jsr $dd89			jsr Jmp_Comma_YA	; compile JMP
.8884	4c db cb	jmp $cbdb			jmp adjust_z
=30					CodeLen	.var *-XtPtr1
=$8887					Here1 = *	; remember here
>8867	1e					.byte CodeLen	;patch wh_CodeLength
.8887					FConstantRun:
.8887	68		pla				pla			; tmp2= pop RTS addr
.8888	85 16		sta $16				sta tmp2+0
.888a	68		pla				pla
.888b	85 17		sta $17				sta tmp2+1
.888d	a0 01		ldy #$01			ldy #1			; correct for RTS addr
.888f	4c 58 86	jmp $8658			jmp FAt_Tmp2Y		; fetch inline data, & return
.8892					FLitYA:
.8892	20 c8 84	jsr $84c8			jsr FAllocX		; alloc FP stack entry, X=FP stack index
.8895	95 57		sta $57,x			sta FSMant0,x		; Mant= A,0,0,0
.8897	94 4d		sty $4d,x			sty FSExp,x	; sty dir,x exists
.8899	a9 00		lda #$00			lda #0
.889b	95 61		sta $61,x			sta FSMant1,x
.889d	95 6b		sta $6b,x			sta FSMant2,x
.889f	95 75		sta $75,x			sta FSMant3,x
.88a1	a6 14		ldx $14				ldx tmp1+0		; restore data stack index
.88a3	60		rts				rts
>88a4	30 2e 65			Name0:	.text "0.e"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=34855					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>88a7	a3					.byte (("0.e"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=66					LinkDisplacement = Nt0-WordListLink
>88a8	10					.byte WordFlags	;wh_Flags
>88a9	03					.byte 3	;wh_CodeLength
>88aa	42					  .byte LinkDisplacement	; offset to previous nt
=$88ab					XtPtr1 ::= *
=34855					WordListLink ::= Nt0 ; remember the nt of this word for later
.88ab	a9 00		lda #$00	F0:		lda #0			; FSMant0
.88ad	a0 80		ldy #$80			ldy #$80		; FSExp
.88af	d0 e1		bne $8892			bne FLitYA
=6					CodeLen	.var *-XtPtr1
=$88b1					Here1 = *	; remember here
>88a9	06					.byte CodeLen	;patch wh_CodeLength
>88b1	31 30 30 30 2e 65		Name0:	.text "1000.e"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=34871					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>88b7	a6					.byte (("1000.e"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=16					LinkDisplacement = Nt0-WordListLink
>88b8	10					.byte WordFlags	;wh_Flags
>88b9	03					.byte 3	;wh_CodeLength
>88ba	10					  .byte LinkDisplacement	; offset to previous nt
=$88bb					XtPtr1 ::= *
=34871					WordListLink ::= Nt0 ; remember the nt of this word for later
.88bb	a9 7d		lda #$7d	F1000:		lda #$7d
.88bd	a0 0a		ldy #$0a			ldy #10
.88bf	d0 d1		bne $8892			bne FLitYA
=6					CodeLen	.var *-XtPtr1
=$88c1					Here1 = *	; remember here
>88b9	06					.byte CodeLen	;patch wh_CodeLength
>88c1	31 30 2e 65			Name0:	.text "10.e"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=34885					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>88c5	a4					.byte (("10.e"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=14					LinkDisplacement = Nt0-WordListLink
>88c6	10					.byte WordFlags	;wh_Flags
>88c7	03					.byte 3	;wh_CodeLength
>88c8	0e					  .byte LinkDisplacement	; offset to previous nt
=$88c9					XtPtr1 ::= *
=34885					WordListLink ::= Nt0 ; remember the nt of this word for later
.88c9	a9 50		lda #$50	F10:		lda #$50
.88cb	a0 04		ldy #$04			ldy #4
.88cd	d0 c3		bne $8892			bne FLitYA
=6					CodeLen	.var *-XtPtr1
=$88cf					Here1 = *	; remember here
>88c7	06					.byte CodeLen	;patch wh_CodeLength
>88cf	32 2e 65			Name0:	.text "2.e"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=34898					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>88d2	a3					.byte (("2.e"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>88d3	10					.byte WordFlags	;wh_Flags
>88d4	03					.byte 3	;wh_CodeLength
>88d5	0d					  .byte LinkDisplacement	; offset to previous nt
=$88d6					XtPtr1 ::= *
=34898					WordListLink ::= Nt0 ; remember the nt of this word for later
.88d6	a9 40		lda #$40	F2:		lda #$40
.88d8	a0 02		ldy #$02			ldy #2
.88da	d0 b6		bne $8892			bne FLitYA
=6					CodeLen	.var *-XtPtr1
=$88dc					Here1 = *	; remember here
>88d4	06					.byte CodeLen	;patch wh_CodeLength
>88dc	31 2e 65			Name0:	.text "1.e"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=34911					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>88df	a3					.byte (("1.e"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>88e0	10					.byte WordFlags	;wh_Flags
>88e1	03					.byte 3	;wh_CodeLength
>88e2	0d					  .byte LinkDisplacement	; offset to previous nt
=$88e3					XtPtr1 ::= *
=34911					WordListLink ::= Nt0 ; remember the nt of this word for later
.88e3	a9 40		lda #$40	F1:		lda #$40
.88e5	a0 01		ldy #$01			ldy #1
.88e7	d0 a9		bne $8892			bne FLitYA
=6					CodeLen	.var *-XtPtr1
=$88e9					Here1 = *	; remember here
>88e1	06					.byte CodeLen	;patch wh_CodeLength
>88e9	2e 31 65			Name0:	.text ".1e"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=34924					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>88ec	a3					.byte ((".1e"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>88ed	10					.byte WordFlags	;wh_Flags
>88ee	03					.byte 3	;wh_CodeLength
>88ef	0d					  .byte LinkDisplacement	; offset to previous nt
=$88f0					XtPtr1 ::= *
=34924					WordListLink ::= Nt0 ; remember the nt of this word for later
.88f0	20 87 88	jsr $8887	F10th:		jsr FConstantRun
>88f3	67 66 66 66					.dword $66666667	; 32 bit signed binary mantissa.  $40000000 = +0.5
>88f7	fd						.char -3		; 8 bit signed binary exponent.  $00 = 2**0
=8					CodeLen	.var *-XtPtr1
=$88f8					Here1 = *	; remember here
>88ee	08					.byte CodeLen	;patch wh_CodeLength
>88f8	50 69				Name0:	.text "Pi"	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=34938					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>88fa	22					.byte (("Pi"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=14					LinkDisplacement = Nt0-WordListLink
>88fb	10					.byte WordFlags	;wh_Flags
>88fc	03					.byte 3	;wh_CodeLength
>88fd	0e					  .byte LinkDisplacement	; offset to previous nt
=$88fe					XtPtr1 ::= *
=34938					WordListLink ::= Nt0 ; remember the nt of this word for later
.88fe	20 87 88	jsr $8887	FPi:		jsr FConstantRun
>8901	51 ed 87 64					.dword $6487ed51	; 32 bit signed binary mantissa.  $40000000 = +0.5
>8905	02						.char 2		; 8 bit signed binary exponent.  $00 = 2**0
=8					CodeLen	.var *-XtPtr1
=$8906					Here1 = *	; remember here
>88fc	08					.byte CodeLen	;patch wh_CodeLength
>8906	50 69 2f 32			Name0:	.text "Pi/2"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=34954					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>890a	44					.byte (("Pi/2"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=16					LinkDisplacement = Nt0-WordListLink
>890b	10					.byte WordFlags	;wh_Flags
>890c	03					.byte 3	;wh_CodeLength
>890d	10					  .byte LinkDisplacement	; offset to previous nt
=$890e					XtPtr1 ::= *
=34954					WordListLink ::= Nt0 ; remember the nt of this word for later
.890e	20 87 88	jsr $8887	FPiH:		jsr FConstantRun
>8911	51 ed 87 64					.dword $6487ed51	; 32 bit signed binary mantissa.  $40000000 = +0.5
>8915	01						.char 1		; 8 bit signed binary exponent.  $00 = 2**0
=8					CodeLen	.var *-XtPtr1
=$8916					Here1 = *	; remember here
>890c	08					.byte CodeLen	;patch wh_CodeLength
>8916	50 69 2f 34			Name0:	.text "Pi/4"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=34970					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>891a	84					.byte (("Pi/4"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=16					LinkDisplacement = Nt0-WordListLink
>891b	10					.byte WordFlags	;wh_Flags
>891c	03					.byte 3	;wh_CodeLength
>891d	10					  .byte LinkDisplacement	; offset to previous nt
=$891e					XtPtr1 ::= *
=34970					WordListLink ::= Nt0 ; remember the nt of this word for later
.891e	20 87 88	jsr $8887	FPiQ:		jsr FConstantRun
>8921	51 ed 87 64					.dword $6487ed51	; 32 bit signed binary mantissa.  $40000000 = +0.5
>8925	00						.char 0		; 8 bit signed binary exponent.  $00 = 2**0
=8					CodeLen	.var *-XtPtr1
=$8926					Here1 = *	; remember here
>891c	08					.byte CodeLen	;patch wh_CodeLength
>8926	32 50 69			Name0:	.text "2Pi"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=34985					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>8929	23					.byte (("2Pi"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=15					LinkDisplacement = Nt0-WordListLink
>892a	10					.byte WordFlags	;wh_Flags
>892b	03					.byte 3	;wh_CodeLength
>892c	0f					  .byte LinkDisplacement	; offset to previous nt
=$892d					XtPtr1 ::= *
=34985					WordListLink ::= Nt0 ; remember the nt of this word for later
.892d	20 87 88	jsr $8887	F2Pi:		jsr FConstantRun
>8930	51 ed 87 64					.dword $6487ed51	; 32 bit signed binary mantissa.  $40000000 = +0.5
>8934	03						.char 3		; 8 bit signed binary exponent.  $00 = 2**0
=8					CodeLen	.var *-XtPtr1
=$8935					Here1 = *	; remember here
>892b	08					.byte CodeLen	;patch wh_CodeLength
>8935	46 2e 45			Name0:	.text "F.E"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=35000					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>8938	a3					.byte (("F.E"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=15					LinkDisplacement = Nt0-WordListLink
>8939	10					.byte WordFlags	;wh_Flags
>893a	03					.byte 3	;wh_CodeLength
>893b	0f					  .byte LinkDisplacement	; offset to previous nt
=$893c					XtPtr1 ::= *
=35000					WordListLink ::= Nt0 ; remember the nt of this word for later
.893c	20 87 88	jsr $8887	FE:		jsr FConstantRun
>893f	2c 2a fc 56					.dword $56fc2a2c	; 32 bit signed binary mantissa.  $40000000 = +0.5
>8943	02						.char 2		; 8 bit signed binary exponent.  $00 = 2**0
=8					CodeLen	.var *-XtPtr1
=$8944					Here1 = *	; remember here
>893a	08					.byte CodeLen	;patch wh_CodeLength
>8944	46 56 61 6c 75 65		Name0:	.text "FValue"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=35018					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>894a	a6					.byte (("FValue"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=24					WordFlags ::= IM+NN	; modifiable copy, remember for later
=18					LinkDisplacement = Nt0-WordListLink
>894b	18					.byte WordFlags	;wh_Flags
>894c	03					.byte 3	;wh_CodeLength
>894d	12					  .byte LinkDisplacement	; offset to previous nt
=$894e					XtPtr1 ::= *
=35018					WordListLink ::= Nt0 ; remember the nt of this word for later
.894e	20 1b d1	jsr $d11b	FValue:		jsr Header_Comma	; compile word header
.8951	a9 5e		lda #$5e			lda #<FValue_runtime	; compile JSR FValue_runtime
.8953	a0 89		ldy #$89			ldy #>FValue_runtime
.8955	20 73 dd	jsr $dd73			jsr Jsr_Comma_YA
.8958	20 db cb	jsr $cbdb			jsr adjust_z		; fix word length
.895b	4c ac 86	jmp $86ac			jmp FComma		; alloc & init value
=16					CodeLen	.var *-XtPtr1
=$895e					Here1 = *	; remember here
>894c	10					.byte CodeLen	;patch wh_CodeLength
.895e					FValue_runtime:
.895e	4c 87 88	jmp $8887			jmp FConstantRun
>8961	46 53 63 61 6c 65		Name0:	.text "FScale"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=35047					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>8967	a6					.byte (("FScale"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=29					LinkDisplacement = Nt0-WordListLink
>8968	10					.byte WordFlags	;wh_Flags
>8969	03					.byte 3	;wh_CodeLength
>896a	1d					  .byte LinkDisplacement	; offset to previous nt
=$896b					XtPtr1 ::= *
=35047					WordListLink ::= Nt0 ; remember the nt of this word for later
.896b	20 c3 c3	jsr $c3c3	FScale:		jsr PopA		; pop n
.896e	86 14		stx $14		FScaleA:	stx tmp1		; save data stack index
.8970	a6 4c		ldx $4c				ldx FIndex		; X= FP stack index
.8972	b4 57		ldy $57,x			ldy FSMant0,x		; mantissa zero?
.8974	f0 07		beq $897d			beq _8
.8976	18		clc				clc
.8977	75 4d		adc $4d,x			adc FSExp,x
.8979	95 4d		sta $4d,x			sta FSExp,x
.897b	70 03		bvs $8980			bvs _overflow		; overflow or underflow?
.897d	a6 14		ldx $14		_8:		ldx tmp1		; restore data stack index
.897f	60		rts				rts
.8980					_overflow:
.8980	a6 14		ldx $14				ldx tmp1		; restore data stack index
.8982	20 3e c4	jsr $c43e			jsr Throw_FpOutOfRange
=26					CodeLen	.var *-XtPtr1
=$8985					Here1 = *	; remember here
>8969	1a					.byte CodeLen	;patch wh_CodeLength
>8985	46 32 2a			Name0:	.text "F2*"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=35080					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>8988	43					.byte (("F2*"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=33					LinkDisplacement = Nt0-WordListLink
>8989	10					.byte WordFlags	;wh_Flags
>898a	03					.byte 3	;wh_CodeLength
>898b	21					  .byte LinkDisplacement	; offset to previous nt
=$898c					XtPtr1 ::= *
=35080					WordListLink ::= Nt0 ; remember the nt of this word for later
.898c	a9 01		lda #$01	F2Star:		lda #1
.898e	d0 de		bne $896e			bne FScaleA
=4					CodeLen	.var *-XtPtr1
=$8990					Here1 = *	; remember here
>898a	04					.byte CodeLen	;patch wh_CodeLength
>8990	46 32 2f			Name0:	.text "F2/"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=35091					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>8993	e3					.byte (("F2/"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=11					LinkDisplacement = Nt0-WordListLink
>8994	10					.byte WordFlags	;wh_Flags
>8995	03					.byte 3	;wh_CodeLength
>8996	0b					  .byte LinkDisplacement	; offset to previous nt
=$8997					XtPtr1 ::= *
=35091					WordListLink ::= Nt0 ; remember the nt of this word for later
.8997	a9 ff		lda #$ff	F2Slash:	lda #$ff
.8999	d0 d3		bne $896e			bne FScaleA
=4					CodeLen	.var *-XtPtr1
=$899b					Here1 = *	; remember here
>8995	04					.byte CodeLen	;patch wh_CodeLength
>899b	46 31 30 2a			Name0:	.text "F10*"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=35103					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>899f	44					.byte (("F10*"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=12					LinkDisplacement = Nt0-WordListLink
>89a0	10					.byte WordFlags	;wh_Flags
>89a1	03					.byte 3	;wh_CodeLength
>89a2	0c					  .byte LinkDisplacement	; offset to previous nt
=$89a3					XtPtr1 ::= *
=35103					WordListLink ::= Nt0 ; remember the nt of this word for later
.89a3	20 8c 89	jsr $898c	F10Star:	jsr F2Star
.89a6	20 53 85	jsr $8553			jsr FDup
.89a9	a9 02		lda #$02			lda #2
.89ab	20 6e 89	jsr $896e			jsr FScaleA
.89ae	4c 30 8b	jmp $8b30			jmp FPlus
.89b1	86 14		stx $14		FShiftA:	stx tmp1+0		; save data stack index
.89b3	a6 4c		ldx $4c				ldx FIndex		; X= FP stack index
.89b5	85 15		sta $15		FShiftAX:	sta tmp1+1		; save desired alignment
.89b7	38		sec				sec			; calc bit shift count
.89b8	f5 4d		sbc $4d,x			sbc FSExp,x
.89ba	f0 32		beq $89ee			beq _leave
.89bc	70 20		bvs $89de			bvs _overflow
.89be	30 2e		bmi $89ee			bmi _leave
.89c0	c9 20		cmp #$20			cmp #32
.89c2	b0 1c		bcs $89e0			bcs _zero
.89c4	a8		tay				tay
.89c5	a5 15		lda $15				lda tmp1+1
.89c7	95 4d		sta $4d,x			sta FSExp,x
.89c9	b5 57		lda $57,x			lda FSMant0,x
.89cb	c9 80		cmp #$80	_12:		cmp #$80		; mantissa >>=1
.89cd	6a		ror a				ror a
.89ce	76 61		ror $61,x			ror FSMant1,x
.89d0	76 6b		ror $6b,x			ror FSMant2,x
.89d2	76 75		ror $75,x			ror FSMant3,x
.89d4	88		dey				dey
.89d5	d0 f4		bne $89cb			bne _12
.89d7	95 57		sta $57,x			sta FSMant0,x
.89d9	b4 4d		ldy $4d,x	_30:		ldy FSExp,x
.89db	a6 4c		ldx $4c				ldx FIndex		; restore fp stack index (FShiftAX could have had a funny one)
.89dd	60		rts				rts
.89de	10 0e		bpl $89ee	_overflow:	bpl _leave
.89e0	a5 15		lda $15		_zero:		lda tmp1+1
.89e2	95 4d		sta $4d,x			sta FSExp,x		; return zero
.89e4	a9 00		lda #$00			lda #0
.89e6	95 57		sta $57,x			sta FSMant0,x
.89e8	95 61		sta $61,x			sta FSMant1,x
.89ea	95 6b		sta $6b,x			sta FSMant2,x
.89ec	95 75		sta $75,x			sta FSMant3,x
.89ee	18		clc		_leave:		clc
.89ef	90 e8		bcc $89d9			bcc _30
>89f1	46 6c 6f 6f 72			Name0:	.text "Floor"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=35190					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>89f6	45					.byte (("Floor"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=87					LinkDisplacement = Nt0-WordListLink
>89f7	10					.byte WordFlags	;wh_Flags
>89f8	03					.byte 3	;wh_CodeLength
>89f9	57					  .byte LinkDisplacement	; offset to previous nt
=$89fa					XtPtr1 ::= *
=35190					WordListLink ::= Nt0 ; remember the nt of this word for later
.89fa	a4 4c		ldy $4c		Floor:		ldy FIndex
.89fc	b9 57 00	lda $0057,y			lda FSMant0,y		; negative?
.89ff	10 19		bpl $8a1a			bpl _a
.8a01	b9 4d 00	lda $004d,y			lda FSExp,y		; > -1 ?
.8a04	10 14		bpl $8a1a			bpl _a
.8a06	a9 80		lda #$80			lda #$80		; return -1
.8a08	99 57 00	sta $0057,y			sta FSMant0,y
.8a0b	a9 00		lda #$00			lda #0
.8a0d	99 4d 00	sta $004d,y			sta FSExp,y
.8a10	99 61 00	sta $0061,y			sta FSMant1,y
.8a13	99 6b 00	sta $006b,y			sta FSMant2,y
.8a16	99 75 00	sta $0075,y			sta FSMant3,y
.8a19	60		rts				rts
.8a1a	a9 1f		lda #$1f	_a:		lda #31
.8a1c	20 b1 89	jsr $89b1			jsr FShiftA
.8a1f	4c aa 8a	jmp $8aaa			jmp FNormX
=40					CodeLen	.var *-XtPtr1
=$8a22					Here1 = *	; remember here
>89f8	28					.byte CodeLen	;patch wh_CodeLength
>8a22	46 54 72 75 6e 63		Name0:	.text "FTrunc"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=35240					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>8a28	66					.byte (("FTrunc"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=50					LinkDisplacement = Nt0-WordListLink
>8a29	10					.byte WordFlags	;wh_Flags
>8a2a	03					.byte 3	;wh_CodeLength
>8a2b	32					  .byte LinkDisplacement	; offset to previous nt
=$8a2c					XtPtr1 ::= *
=35240					WordListLink ::= Nt0 ; remember the nt of this word for later
.8a2c	a4 4c		ldy $4c		FTrunc:		ldy FIndex
.8a2e	b9 57 00	lda $0057,y			lda FSMant0,y
.8a31	10 c7		bpl $89fa			bpl Floor
.8a33	20 a5 8b	jsr $8ba5			jsr FNegate
.8a36	20 fa 89	jsr $89fa			jsr Floor
.8a39	4c a5 8b	jmp $8ba5			jmp FNegate
>8a3c	46 52 6f 75 6e 64		Name0:	.text "FRound"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=35266					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>8a42	86					.byte (("FRound"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=26					LinkDisplacement = Nt0-WordListLink
>8a43	10					.byte WordFlags	;wh_Flags
>8a44	03					.byte 3	;wh_CodeLength
>8a45	1a					  .byte LinkDisplacement	; offset to previous nt
=$8a46					XtPtr1 ::= *
=35266					WordListLink ::= Nt0 ; remember the nt of this word for later
.8a46	a9 1f		lda #$1f	FRound:		lda #31
.8a48	20 b1 89	jsr $89b1			jsr FShiftA
.8a4b	90 05		bcc $8a52			bcc _15
.8a4d	a6 14		ldx $14				ldx tmp1+0		; restore data stack index
.8a4f	4c 64 8b	jmp $8b64			jmp F1Plus
.8a52	4c aa 8a	jmp $8aaa	_15:		jmp FNormX
=15					CodeLen	.var *-XtPtr1
=$8a55					Here1 = *	; remember here
>8a44	0f					.byte CodeLen	;patch wh_CodeLength
>8a55	46 49 6e 74 46 72 63		Name0:	.text "FIntFrc"	;  name of word as a string, ending at wh_NameLastChar
=7					NameLength = *-Name0
=35292					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>8a5c	67					.byte (("FIntFrc"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=26					LinkDisplacement = Nt0-WordListLink
>8a5d	10					.byte WordFlags	;wh_Flags
>8a5e	03					.byte 3	;wh_CodeLength
>8a5f	1a					  .byte LinkDisplacement	; offset to previous nt
=$8a60					XtPtr1 ::= *
=35292					WordListLink ::= Nt0 ; remember the nt of this word for later
.8a60	20 53 85	jsr $8553	FIntFrc:	jsr FDup	; ( r1 r1 )
.8a63	20 fa 89	jsr $89fa			jsr Floor	; ( r1 rint )
.8a66	20 0f 86	jsr $860f			jsr FTuck	; ( rint r1 rint )
.8a69	20 70 8b	jsr $8b70			jsr FMinus	; ( rint rfrac )
.8a6c	4c d7 85	jmp $85d7			jmp FSwap	; ( rfrac rint )
=15					CodeLen	.var *-XtPtr1
=$8a6f					Here1 = *	; remember here
>8a5e	0f					.byte CodeLen	;patch wh_CodeLength
>8a6f	46 4d 41 6c 69 67 6e 58		Name0:	.text "FMAlignX"	;  name of word as a string, ending at wh_NameLastChar
=8					NameLength = *-Name0
=35319					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>8a77	08					.byte (("FMAlignX"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=27					LinkDisplacement = Nt0-WordListLink
>8a78	10					.byte WordFlags	;wh_Flags
>8a79	03					.byte 3	;wh_CodeLength
>8a7a	1b					  .byte LinkDisplacement	; offset to previous nt
=$8a7b					XtPtr1 ::= *
=35319					WordListLink ::= Nt0 ; remember the nt of this word for later
.8a7b	86 14		stx $14		FMAlignX:	stx tmp1+0	; save data stack index
.8a7d	a6 4c		ldx $4c				ldx FIndex	; load FP stack index
.8a7f	e0 09		cpx #$09			cpx #FDim-1	; check FP stack for >=2 entries
.8a81	b0 19		bcs $8a9c			bcs Throw_FPStack_3
.8a83	b5 4d		lda $4d,x			lda FSExp+0,x	; compare exponents
.8a85	38		sec				sec
.8a86	f5 4e		sbc $4e,x			sbc FSExp+1,x
.8a88	30 03		bmi $8a8d			bmi _1		; r1 smaller?
.8a8a	d0 08		bne $8a94			bne _2		; r2 smaller?
.8a8c	60		rts				rts
.8a8d					_1:
.8a8d	70 07		bvs $8a96			bvs _2b		; was this a big positive #?
.8a8f	b5 4e		lda $4e,x	_1b:		lda FSExp+1,x	; make r1 like r2
.8a91	4c b5 89	jmp $89b5			jmp FShiftAX
.8a94					_2:
.8a94	70 f7		bvs $8a8d			bvs _1		; was this a big negative #?
.8a96	b5 4d		lda $4d,x	_2b:		lda FSExp+0,x	; make r2 like r1
.8a98	e8		inx				inx
.8a99	4c b5 89	jmp $89b5			jmp FShiftAX
=33					CodeLen	.var *-XtPtr1
=$8a9c					Here1 = *	; remember here
>8a79	21					.byte CodeLen	;patch wh_CodeLength
.8a9c	20 34 c4	jsr $c434	Throw_FPStack_3: jsr Throw_FPStack
>8a9f	46 4e 6f 72 6d			Name0:	.text "FNorm"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=35364					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>8aa4	a5					.byte (("FNorm"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=45					LinkDisplacement = Nt0-WordListLink
>8aa5	10					.byte WordFlags	;wh_Flags
>8aa6	03					.byte 3	;wh_CodeLength
>8aa7	2d					  .byte LinkDisplacement	; offset to previous nt
=$8aa8					XtPtr1 ::= *
=35364					WordListLink ::= Nt0 ; remember the nt of this word for later
.8aa8	86 14		stx $14		FNorm:		stx tmp1+0		; save data stack index
.8aaa	a6 4c		ldx $4c		FNormX:		ldx FIndex		; switch to FP stack
.8aac	b4 4d		ldy $4d,x			ldy FSExp,x
.8aae	b5 57		lda $57,x			lda FSMant0,x		; mantissa negative?
.8ab0	30 2d		bmi $8adf			bmi _Neg
.8ab2	d0 0f		bne $8ac3			bne _Pos2		; do byte shift
.8ab4	20 12 8b	jsr $8b12			jsr _ShiftB
.8ab7	d0 0a		bne $8ac3			bne _Pos2
.8ab9	20 12 8b	jsr $8b12			jsr _ShiftB
.8abc	d0 05		bne $8ac3			bne _Pos2
.8abe	20 12 8b	jsr $8b12			jsr _ShiftB
.8ac1	f0 43		beq $8b06			beq _zero		; no significant bits left?
.8ac3	18		clc		_Pos2:		clc
.8ac4	30 0a		bmi $8ad0			bmi _RShft
.8ac6	88		dey		_Pos3:		dey			; do bit shift
.8ac7	16 75		asl $75,x			asl FSMant3,x
.8ac9	36 6b		rol $6b,x			rol FSMant2,x
.8acb	36 61		rol $61,x			rol FSMant1,x
.8acd	2a		rol a				rol a
.8ace	10 f6		bpl $8ac6			bpl _Pos3
.8ad0					_RShft:
.8ad0	c8		iny				iny
.8ad1	6a		ror a				ror a
.8ad2	76 61		ror $61,x			ror FSMant1,x
.8ad4	76 6b		ror $6b,x			ror FSMant2,x
.8ad6	76 75		ror $75,x			ror FSMant3,x
.8ad8					_28:
.8ad8	95 57		sta $57,x			sta FSMant0,x
.8ada	94 4d		sty $4d,x			sty FSExp,x	; sty dir,x exists
.8adc	a6 14		ldx $14				ldx tmp1+0	; restore data stack index
.8ade	60		rts				rts
.8adf					_Neg:
.8adf	c9 ff		cmp #$ff			cmp #$ff
.8ae1	d0 11		bne $8af4			bne _Neg2	; do byte shift
.8ae3	20 12 8b	jsr $8b12			jsr _ShiftB
.8ae6	c9 ff		cmp #$ff			cmp #$ff
.8ae8	d0 0a		bne $8af4			bne _Neg2
.8aea	20 12 8b	jsr $8b12			jsr _ShiftB
.8aed	c9 ff		cmp #$ff			cmp #$ff
.8aef	d0 03		bne $8af4			bne _Neg2
.8af1	20 12 8b	jsr $8b12			jsr _ShiftB
.8af4	c9 00		cmp #$00	_Neg2:		cmp #0
.8af6	10 d8		bpl $8ad0			bpl _RShft
.8af8	88		dey		_Neg3:		dey
.8af9	16 75		asl $75,x			asl FSMant3,x
.8afb	36 6b		rol $6b,x			rol FSMant2,x
.8afd	36 61		rol $61,x			rol FSMant1,x
.8aff	2a		rol a				rol a
.8b00	30 f6		bmi $8af8			bmi _Neg3
.8b02	10 cc		bpl $8ad0			bpl _RShft
.8b04	68		pla		_Zerop:		pla
.8b05	68		pla				pla		; pop rts addr from _ShiftB
.8b06	a9 00		lda #$00	_zero:		lda #0
.8b08	95 75		sta $75,x			sta FSMant3,x
.8b0a	95 6b		sta $6b,x			sta FSMant2,x
.8b0c	95 61		sta $61,x			sta FSMant1,x
.8b0e	a0 80		ldy #$80			ldy #$80
.8b10	d0 c6		bne $8ad8			bne _28
.8b12					_ShiftB:
.8b12	98		tya				tya		; exponent -= 8
.8b13	38		sec				sec
.8b14	e9 08		sbc #$08			sbc #8
.8b16	a8		tay				tay
.8b17	70 eb		bvs $8b04			bvs _zerop	;is this useful? do we need more of them?
.8b19	b5 61		lda $61,x			lda FSMant1,x
.8b1b	48		pha				pha
.8b1c	b5 6b		lda $6b,x			lda FSMant2,x
.8b1e	95 61		sta $61,x			sta FSMant1,x
.8b20	b5 75		lda $75,x			lda FSMant3,x
.8b22	95 6b		sta $6b,x			sta FSMant2,x
.8b24	a9 00		lda #$00			lda #0
.8b26	95 75		sta $75,x			sta FSMant3,x
.8b28	68		pla				pla
.8b29	60		rts				rts
=130					CodeLen	.var *-XtPtr1
=$8b2a					Here1 = *	; remember here
>8aa6	82					.byte CodeLen	;patch wh_CodeLength
>8b2a	46 2b				Name0:	.text "F+"	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=35500					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>8b2c	62					.byte (("F+"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=136					LinkDisplacement = Nt0-WordListLink
>8b2d	10					.byte WordFlags	;wh_Flags
>8b2e	03					.byte 3	;wh_CodeLength
>8b2f	88					  .byte LinkDisplacement	; offset to previous nt
=$8b30					XtPtr1 ::= *
=35500					WordListLink ::= Nt0 ; remember the nt of this word for later
.8b30	20 7b 8a	jsr $8a7b	FPlus:		jsr FMAlignX	; align mantissas, X= FP stack index
.8b33	18		clc				clc		; add mantissas
.8b34	b5 76		lda $76,x			lda FSMant3+1,x
.8b36	75 75		adc $75,x			adc FSMant3+0,x
.8b38	95 76		sta $76,x			sta FSMant3+1,x
.8b3a	b5 6c		lda $6c,x			lda FSMant2+1,x
.8b3c	75 6b		adc $6b,x			adc FSMant2+0,x
.8b3e	95 6c		sta $6c,x			sta FSMant2+1,x
.8b40	b5 62		lda $62,x			lda FSMant1+1,x
.8b42	75 61		adc $61,x			adc FSMant1+0,x
.8b44	95 62		sta $62,x			sta FSMant1+1,x
.8b46	b5 58		lda $58,x			lda FSMant0+1,x
.8b48	75 57		adc $57,x			adc FSMant0+0,x
.8b4a					FPlusFin:
.8b4a	e8		inx				inx		; FDrop r2
.8b4b	86 4c		stx $4c				stx FIndex
.8b4d	50 09		bvc $8b58	FPlusFin3:	bvc _19		; if overflow
.8b4f	6a		ror a				ror a		;   shift mantissa right 1 bit
.8b50	76 61		ror $61,x			ror FSMant1,x
.8b52	76 6b		ror $6b,x			ror FSMant2,x
.8b54	76 75		ror $75,x			ror FSMant3,x
.8b56	f6 4d		inc $4d,x			inc FSExp,x	;   adjust exponent
.8b58					_19:
.8b58	95 57		sta $57,x			sta FSMant0,x
.8b5a	4c aa 8a	jmp $8aaa			jmp FNormX	; normalize, return
=45					CodeLen	.var *-XtPtr1
=$8b5d					Here1 = *	; remember here
>8b2e	2d					.byte CodeLen	;patch wh_CodeLength
>8b5d	46 31 2b			Name0:	.text "F1+"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=35552					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>8b60	63					.byte (("F1+"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=52					LinkDisplacement = Nt0-WordListLink
>8b61	10					.byte WordFlags	;wh_Flags
>8b62	03					.byte 3	;wh_CodeLength
>8b63	34					  .byte LinkDisplacement	; offset to previous nt
=$8b64					XtPtr1 ::= *
=35552					WordListLink ::= Nt0 ; remember the nt of this word for later
.8b64	20 e3 88	jsr $88e3	F1Plus:		jsr F1
.8b67	4c 30 8b	jmp $8b30			jmp FPlus
=6					CodeLen	.var *-XtPtr1
=$8b6a					Here1 = *	; remember here
>8b62	06					.byte CodeLen	;patch wh_CodeLength
>8b6a	46 2d				Name0:	.text "F-"	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=35564					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>8b6c	a2					.byte (("F-"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=12					LinkDisplacement = Nt0-WordListLink
>8b6d	10					.byte WordFlags	;wh_Flags
>8b6e	03					.byte 3	;wh_CodeLength
>8b6f	0c					  .byte LinkDisplacement	; offset to previous nt
=$8b70					XtPtr1 ::= *
=35564					WordListLink ::= Nt0 ; remember the nt of this word for later
.8b70	20 7b 8a	jsr $8a7b	FMinus:		jsr FMAlignX	; align mantissas
.8b73	38		sec				sec		; subtract mantissas
.8b74	b5 76		lda $76,x			lda FSMant3+1,x
.8b76	f5 75		sbc $75,x			sbc FSMant3+0,x
.8b78	95 76		sta $76,x			sta FSMant3+1,x
.8b7a	b5 6c		lda $6c,x			lda FSMant2+1,x
.8b7c	f5 6b		sbc $6b,x			sbc FSMant2+0,x
.8b7e	95 6c		sta $6c,x			sta FSMant2+1,x
.8b80	b5 62		lda $62,x			lda FSMant1+1,x
.8b82	f5 61		sbc $61,x			sbc FSMant1+0,x
.8b84	95 62		sta $62,x			sta FSMant1+1,x
.8b86	b5 58		lda $58,x			lda FSMant0+1,x
.8b88	f5 57		sbc $57,x			sbc FSMant0+0,x
.8b8a	4c 4a 8b	jmp $8b4a			jmp FPlusFin	; finish
=29					CodeLen	.var *-XtPtr1
=$8b8d					Here1 = *	; remember here
>8b6e	1d					.byte CodeLen	;patch wh_CodeLength
>8b8d	46 31 2d			Name0:	.text "F1-"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=35600					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>8b90	a3					.byte (("F1-"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=36					LinkDisplacement = Nt0-WordListLink
>8b91	10					.byte WordFlags	;wh_Flags
>8b92	03					.byte 3	;wh_CodeLength
>8b93	24					  .byte LinkDisplacement	; offset to previous nt
=$8b94					XtPtr1 ::= *
=35600					WordListLink ::= Nt0 ; remember the nt of this word for later
.8b94	20 e3 88	jsr $88e3	F1Minus:	jsr F1
.8b97	4c 70 8b	jmp $8b70			jmp FMinus
=6					CodeLen	.var *-XtPtr1
=$8b9a					Here1 = *	; remember here
>8b92	06					.byte CodeLen	;patch wh_CodeLength
>8b9a	46 4e 65 67 61 74 65		Name0:	.text "FNegate"	;  name of word as a string, ending at wh_NameLastChar
=7					NameLength = *-Name0
=35617					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>8ba1	a7					.byte (("FNegate"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=17					LinkDisplacement = Nt0-WordListLink
>8ba2	10					.byte WordFlags	;wh_Flags
>8ba3	03					.byte 3	;wh_CodeLength
>8ba4	11					  .byte LinkDisplacement	; offset to previous nt
=$8ba5					XtPtr1 ::= *
=35617					WordListLink ::= Nt0 ; remember the nt of this word for later
.8ba5	86 14		stx $14		FNegate:	stx tmp1	; save data stack index
.8ba7	a6 4c		ldx $4c				ldx FIndex	; X= FP stack index
.8ba9	38		sec				sec		; mantissa = 0 - mantissa
.8baa	a9 00		lda #$00			lda #0
.8bac	f5 75		sbc $75,x			sbc FSMant3,x
.8bae	95 75		sta $75,x			sta FSMant3,x
.8bb0	a9 00		lda #$00			lda #0
.8bb2	f5 6b		sbc $6b,x			sbc FSMant2,x
.8bb4	95 6b		sta $6b,x			sta FSMant2,x
.8bb6	a9 00		lda #$00			lda #0
.8bb8	f5 61		sbc $61,x			sbc FSMant1,x
.8bba	95 61		sta $61,x			sta FSMant1,x
.8bbc	a9 00		lda #$00			lda #0
.8bbe	f5 57		sbc $57,x			sbc FSMant0,x
.8bc0	4c 4d 8b	jmp $8b4d			jmp FPlusFin3	; finish up, return
=30					CodeLen	.var *-XtPtr1
=$8bc3					Here1 = *	; remember here
>8ba3	1e					.byte CodeLen	;patch wh_CodeLength
>8bc3	46 41 62 73			Name0:	.text "FAbs"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=35655					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>8bc7	64					.byte (("FAbs"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=38					LinkDisplacement = Nt0-WordListLink
>8bc8	10					.byte WordFlags	;wh_Flags
>8bc9	03					.byte 3	;wh_CodeLength
>8bca	26					  .byte LinkDisplacement	; offset to previous nt
=$8bcb					XtPtr1 ::= *
=35655					WordListLink ::= Nt0 ; remember the nt of this word for later
.8bcb	a4 4c		ldy $4c		FAbs:		ldy FIndex
.8bcd	b9 57 00	lda $0057,y			lda FSMant0,y		; mantissa negative?
.8bd0	30 d3		bmi $8ba5			bmi FNegate
.8bd2	60		rts				rts
=8					CodeLen	.var *-XtPtr1
=$8bd3					Here1 = *	; remember here
>8bc9	08					.byte CodeLen	;patch wh_CodeLength
.8bd3	4c 34 c4	jmp $c434	Throw_FPStack_4: jmp Throw_FPStack
.8bd6	a4 4c		ldy $4c		FPos:		ldy FIndex		; load FP stack index
.8bd8	c0 09		cpy #$09			cpy #FDim-1		; check FP stack for 2
.8bda	b0 f7		bcs $8bd3			bcs Throw_FPStack_4
.8bdc	b9 57 00	lda $0057,y			lda FSMant0+0,y		; calc result sign
.8bdf	59 58 00	eor $0058,y			eor FSMant0+1,y
.8be2	08		php				php
.8be3	b9 58 00	lda $0058,y			lda FSMant0+1,y		; if NOS negative
.8be6	10 07		bpl $8bef			bpl +
.8be8	e6 4c		inc $4c				inc FIndex		;   point at NOS
.8bea	20 a5 8b	jsr $8ba5			jsr FNegate		;   negate NOS
.8bed	c6 4c		dec $4c				dec FIndex		;   restore fp
.8bef					+
.8bef	20 cb 8b	jsr $8bcb			jsr FAbs		; abs TOS
.8bf2	86 14		stx $14				stx tmp1+0		; save data stack index
.8bf4	a6 4c		ldx $4c				ldx FIndex		; load FP stack index
.8bf6	28		plp				plp			; return sign flag
.8bf7	60		rts				rts
>8bf8	46 2a				Name0:	.text "F*"	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=35706					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>8bfa	42					.byte (("F*"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=51					LinkDisplacement = Nt0-WordListLink
>8bfb	10					.byte WordFlags	;wh_Flags
>8bfc	03					.byte 3	;wh_CodeLength
>8bfd	33					  .byte LinkDisplacement	; offset to previous nt
=$8bfe					XtPtr1 ::= *
=35706					WordListLink ::= Nt0 ; remember the nt of this word for later
.8bfe					FStar:
.8bfe	20 d6 8b	jsr $8bd6			jsr FPos		; make r1 & r2 positive,
.8c01	08		php				php			;   save r3 sign
.8c02	b5 4d		lda $4d,x			lda FSExp+0,x		; add exponents
.8c04	38		sec				sec
.8c05	75 4e		adc $4e,x			adc FSExp+1,x
.8c07	95 4e		sta $4e,x			sta FSExp+1,x
.8c09	50 12		bvc $8c1d			bvc _49			; IfVs,
.8c0b	b0 06		bcs $8c13			bcs _zero		;   underflow?
.8c0d	a6 14		ldx $14				ldx tmp1+0		;   restore data stack index
.8c0f	28		plp				plp			; RDrop sign flag
.8c10	20 3e c4	jsr $c43e			jsr Throw_FpOutOfRange
.8c13	e8		inx		_zero:		inx			; F2Drop r1 & r2
.8c14	e8		inx				inx
.8c15	86 4c		stx $4c				stx FIndex
.8c17	28		plp				plp			; RDrop saved result sign
.8c18	a6 14		ldx $14				ldx tmp1+0		; restore data stack index
.8c1a	4c ab 88	jmp $88ab			jmp F0			; return zero
.8c1d					_49:
.8c1d	a9 00		lda #$00			lda #0			; tmp32= 0
.8c1f	85 16		sta $16				sta tmp2+0
.8c21	85 17		sta $17				sta tmp2+1
.8c23	85 18		sta $18				sta tmp3+0
.8c25	85 19		sta $19				sta tmp3+1
.8c27	b5 76		lda $76,x			lda FSMant3+1,x
.8c29	20 58 8c	jsr $8c58			jsr _Byte		; do bytes of r1 mantissa
.8c2c	b5 6c		lda $6c,x			lda FSMant2+1,x
.8c2e	20 58 8c	jsr $8c58			jsr _Byte
.8c31	b5 62		lda $62,x			lda FSMant1+1,x
.8c33	20 58 8c	jsr $8c58			jsr _Byte
.8c36	b5 58		lda $58,x			lda FSMant0+1,x
.8c38	20 58 8c	jsr $8c58			jsr _Byte
.8c3b	a5 16		lda $16				lda tmp2+0		; r1.mant= tmp32
.8c3d	95 76		sta $76,x			sta FSMant3+1,x
.8c3f	a5 17		lda $17				lda tmp2+1
.8c41	95 6c		sta $6c,x			sta FSMant2+1,x
.8c43	a5 18		lda $18				lda tmp3+0
.8c45	95 62		sta $62,x			sta FSMant1+1,x
.8c47	a5 19		lda $19				lda tmp3+1
.8c49	95 58		sta $58,x			sta FSMant0+1,x
.8c4b	e6 4c		inc $4c				inc FIndex		; FDrop
.8c4d	a6 14		ldx $14				ldx tmp1+0		; restore data stack index
.8c4f	28		plp				plp			; fix result sign
.8c50	10 03		bpl $8c55			bpl +
.8c52	4c a5 8b	jmp $8ba5			jmp FNegate
.8c55					+
.8c55	4c a8 8a	jmp $8aa8			jmp FNorm
.8c58					_Byte:
.8c58	49 ff		eor #$ff			eor #$ff
.8c5a	85 15		sta $15				sta tmp1+1
.8c5c	a0 08		ldy #$08			ldy #8			; for each bit in byte
.8c5e	46 15		lsr $15		_b1:		lsr tmp1+1		;   if bit set
.8c60	b0 18		bcs $8c7a			bcs _b3
.8c62	a5 16		lda $16				lda tmp2+0		;     tmp32 += r2
.8c64	75 75		adc $75,x			adc FSMant3+0,x
.8c66	85 16		sta $16				sta tmp2+0
.8c68	a5 17		lda $17				lda tmp2+1
.8c6a	75 6b		adc $6b,x			adc FSMant2+0,x
.8c6c	85 17		sta $17				sta tmp2+1
.8c6e	a5 18		lda $18				lda tmp3+0
.8c70	75 61		adc $61,x			adc FSMant1+0,x
.8c72	85 18		sta $18				sta tmp3+0
.8c74	a5 19		lda $19				lda tmp3+1
.8c76	75 57		adc $57,x			adc FSMant0+0,x
.8c78	85 19		sta $19				sta tmp3+1
.8c7a	46 19		lsr $19		_b3:		lsr tmp3+1		;   tmp32 >>= 1
.8c7c	66 18		ror $18				ror tmp3+0
.8c7e	66 17		ror $17				ror tmp2+1
.8c80	66 16		ror $16				ror tmp2+0
.8c82	88		dey				dey			;  next bit
.8c83	d0 d9		bne $8c5e			bne _b1
.8c85	60		rts				rts
=136					CodeLen	.var *-XtPtr1
=$8c86					Here1 = *	; remember here
>8bfc	88					.byte CodeLen	;patch wh_CodeLength
>8c86	46 53 71 72			Name0:	.text "FSqr"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=35850					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>8c8a	44					.byte (("FSqr"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=144					LinkDisplacement = Nt0-WordListLink
>8c8b	10					.byte WordFlags	;wh_Flags
>8c8c	03					.byte 3	;wh_CodeLength
>8c8d	90					  .byte LinkDisplacement	; offset to previous nt
=$8c8e					XtPtr1 ::= *
=35850					WordListLink ::= Nt0 ; remember the nt of this word for later
.8c8e	20 53 85	jsr $8553	FSqr:		jsr FDup
.8c91	4c fe 8b	jmp $8bfe			jmp FStar
=6					CodeLen	.var *-XtPtr1
=$8c94					Here1 = *	; remember here
>8c8c	06					.byte CodeLen	;patch wh_CodeLength
>8c94	46 2f				Name0:	.text "F/"	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=35862					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>8c96	e2					.byte (("F/"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=12					LinkDisplacement = Nt0-WordListLink
>8c97	10					.byte WordFlags	;wh_Flags
>8c98	03					.byte 3	;wh_CodeLength
>8c99	0c					  .byte LinkDisplacement	; offset to previous nt
=$8c9a					XtPtr1 ::= *
=35862					WordListLink ::= Nt0 ; remember the nt of this word for later
.8c9a	20 d6 8b	jsr $8bd6	FSlash:		jsr FPos		; make r1 & r2 positive
.8c9d	08		php				php			;   save result sign
.8c9e	b5 4e		lda $4e,x			lda FSExp+1,x		; calc exponent
.8ca0	18		clc				clc
.8ca1	69 01		adc #$01			adc #1
.8ca3	38		sec				sec
.8ca4	f5 4d		sbc $4d,x			sbc FSExp+0,x
.8ca6	95 4e		sta $4e,x			sta FSExp+1,x
.8ca8	50 12		bvc $8cbc			bvc _49			;  IfVs
.8caa	b0 06		bcs $8cb2			bcs _Zero		; underflow?
.8cac	28		plp				plp			; drop saved result sign
.8cad	a6 15		ldx $15				ldx tmp1+1		; restore data stack index
.8caf	20 3e c4	jsr $c43e			jsr Throw_FpOutOfRange	; overflow
.8cb2	e8		inx		_Zero:		inx			; F2Drop
.8cb3	e8		inx				inx
.8cb4	86 4c		stx $4c				stx FIndex
.8cb6	28		plp				plp			; drop saved result sign
.8cb7	a6 14		ldx $14				ldx tmp1+0		; restore data stack index
.8cb9	4c ab 88	jmp $88ab			jmp F0			; return 0
.8cbc					_49:
.8cbc	b5 76		lda $76,x			lda FSMant3+1,x		; tmp32 = r1
.8cbe	85 16		sta $16				sta tmp2+0
.8cc0	b5 6c		lda $6c,x			lda FSMant2+1,x
.8cc2	85 17		sta $17				sta tmp2+1
.8cc4	b5 62		lda $62,x			lda FSMant1+1,x
.8cc6	85 18		sta $18				sta tmp3+0
.8cc8	b5 58		lda $58,x			lda FSMant0+1,x
.8cca	85 19		sta $19				sta tmp3+1
.8ccc	20 f5 8c	jsr $8cf5			jsr _Byte
.8ccf	95 58		sta $58,x			sta FSMant0+1,x
.8cd1	20 f5 8c	jsr $8cf5			jsr _Byte
.8cd4	95 62		sta $62,x			sta FSMant1+1,x
.8cd6	20 f5 8c	jsr $8cf5			jsr _Byte
.8cd9	95 6c		sta $6c,x			sta FSMant2+1,x
.8cdb	20 f5 8c	jsr $8cf5			jsr _Byte
.8cde	95 76		sta $76,x			sta FSMant3+1,x
.8ce0	56 58		lsr $58,x			lsr FSMant0+1,x
.8ce2	76 62		ror $62,x			ror FSMant1+1,x
.8ce4	76 6c		ror $6c,x			ror FSMant2+1,x
.8ce6	76 76		ror $76,x			ror FSMant3+1,x
.8ce8	e6 4c		inc $4c				inc FIndex		; FDrop
.8cea	a6 14		ldx $14				ldx tmp1+0		; restore X
.8cec	28		plp				plp			; fix sign
.8ced	10 03		bpl $8cf2			bpl +
.8cef	20 a5 8b	jsr $8ba5			jsr FNegate
.8cf2	4c a8 8a	jmp $8aa8	+		jmp FNorm
.8cf5					_Byte:
.8cf5	a0 08		ldy #$08			ldy #8			; for 8 bits
.8cf7					_1:
.8cf7	a5 19		lda $19				lda tmp3+1		;   if r1>=r2
.8cf9	d5 57		cmp $57,x			cmp FSMant0+0,x
.8cfb	d0 10		bne $8d0d			bne _4
.8cfd	a5 18		lda $18				lda tmp3+0
.8cff	d5 61		cmp $61,x			cmp FSMant1+0,x
.8d01	d0 0a		bne $8d0d			bne _4
.8d03	a5 17		lda $17				lda tmp2+1
.8d05	d5 6b		cmp $6b,x			cmp FSMant2+0,x
.8d07	d0 04		bne $8d0d			bne _4
.8d09	a5 16		lda $16				lda tmp2+0
.8d0b	d5 75		cmp $75,x			cmp FSMant3+0,x
.8d0d	90 18		bcc $8d27	_4:		bcc _2
.8d0f	a5 16		lda $16				lda tmp2+0		;     tmp32 -= r2
.8d11	f5 75		sbc $75,x			sbc FSMant3+0,x
.8d13	85 16		sta $16				sta tmp2+0
.8d15	a5 17		lda $17				lda tmp2+1
.8d17	f5 6b		sbc $6b,x			sbc FSMant2+0,x
.8d19	85 17		sta $17				sta tmp2+1
.8d1b	a5 18		lda $18				lda tmp3+0
.8d1d	f5 61		sbc $61,x			sbc FSMant1+0,x
.8d1f	85 18		sta $18				sta tmp3+0
.8d21	a5 19		lda $19				lda tmp3+1
.8d23	f5 57		sbc $57,x			sbc FSMant0+0,x
.8d25	85 19		sta $19				sta tmp3+1
.8d27	26 15		rol $15		_2:		rol tmp1+1		;   accum quotient bits
.8d29	06 16		asl $16				asl tmp2+0
.8d2b	26 17		rol $17				rol tmp2+1
.8d2d	26 18		rol $18				rol tmp3+0
.8d2f	26 19		rol $19				rol tmp3+1		;   tmp32<<=1
.8d31	88		dey				dey			;  next
.8d32	d0 c3		bne $8cf7			bne _1
.8d34	a5 15		lda $15				lda tmp1+1		; return bits
.8d36	60		rts				rts
=157					CodeLen	.var *-XtPtr1
=$8d37					Here1 = *	; remember here
>8c98	9d					.byte CodeLen	;patch wh_CodeLength
>8d37	46 31 2f			Name0:	.text "F1/"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=36026					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>8d3a	e3					.byte (("F1/"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=164					LinkDisplacement = Nt0-WordListLink
>8d3b	10					.byte WordFlags	;wh_Flags
>8d3c	03					.byte 3	;wh_CodeLength
>8d3d	a4					  .byte LinkDisplacement	; offset to previous nt
=$8d3e					XtPtr1 ::= *
=36026					WordListLink ::= Nt0 ; remember the nt of this word for later
.8d3e	20 e3 88	jsr $88e3	F1Slash:	jsr F1
.8d41	20 d7 85	jsr $85d7			jsr FSwap
.8d44	4c 9a 8c	jmp $8c9a			jmp FSlash
=9					CodeLen	.var *-XtPtr1
=$8d47					Here1 = *	; remember here
>8d3c	09					.byte CodeLen	;patch wh_CodeLength
>8d47	45 2a				Name0:	.text "E*"	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=36041					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>8d49	42					.byte (("E*"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=15					LinkDisplacement = Nt0-WordListLink
>8d4a	10					.byte WordFlags	;wh_Flags
>8d4b	03					.byte 3	;wh_CodeLength
>8d4c	0f					  .byte LinkDisplacement	; offset to previous nt
=$8d4d					XtPtr1 ::= *
=36041					WordListLink ::= Nt0 ; remember the nt of this word for later
.8d4d					EStar:
.8d4d	20 d6 8b	jsr $8bd6			jsr FPos		; make r1 & r2 positive
.8d50	08		php				php			;   remember result sign
.8d51	b5 4d		lda $4d,x			lda FSExp+0,x		; add exponents
.8d53	38		sec				sec
.8d54	75 4e		adc $4e,x			adc FSExp+1,x
.8d56	95 4e		sta $4e,x			sta FSExp+1,x
.8d58	70 1b		bvs $8d75			bvs _ExpOvfl
.8d5a	a0 00		ldy #$00			ldy #0
.8d5c	84 16		sty $16				sty tmp2+0
.8d5e	84 17		sty $17				sty tmp2+1		; zero result
.8d60	b5 62		lda $62,x			lda FSMant1+1,x
.8d62	20 84 8d	jsr $8d84			jsr _Byte		; do FSMant1+1 byte
.8d65	b5 58		lda $58,x			lda FSMant0+1,x
.8d67	20 84 8d	jsr $8d84			jsr _Byte		; do FSMant0+1 byte
.8d6a	a5 16		lda $16				lda tmp2+0		; r3 = tmp2
.8d6c	95 62		sta $62,x			sta FSMant1+1,x
.8d6e	a5 17		lda $17				lda tmp2+1
.8d70	95 58		sta $58,x			sta FSMant0+1,x
.8d72	4c a2 8d	jmp $8da2			jmp EFix3		; finish
.8d75					_ExpOvfl:
.8d75	b0 05		bcs $8d7c			bcs _Zero		;underflow?
.8d77	a6 14		ldx $14				ldx tmp1+0		; restore X
.8d79	20 3e c4	jsr $c43e			jsr Throw_FpOutOfRange	;overflow
.8d7c	a9 00		lda #$00	_Zero:		lda #0
.8d7e	95 62		sta $62,x			sta FSMant1+1,x
.8d80	95 58		sta $58,x			sta FSMant0+1,x
.8d82	f0 1e		beq $8da2			beq EFix3
.8d84					_Byte:
.8d84	49 ff		eor #$ff			eor #$ff
.8d86	85 15		sta $15				sta tmp1+1
.8d88	a0 08		ldy #$08			ldy #8			; for 8 bits
.8d8a	46 15		lsr $15		_b1:		lsr tmp1+1		;   if bit set
.8d8c	b0 0c		bcs $8d9a			bcs _b5
.8d8e	a5 16		lda $16				lda tmp2+0		;     tmp2 += r2
.8d90	75 61		adc $61,x			adc FSMant1+0,x
.8d92	85 16		sta $16				sta tmp2+0
.8d94	a5 17		lda $17				lda tmp2+1
.8d96	75 57		adc $57,x			adc FSMant0+0,x
.8d98	85 17		sta $17				sta tmp2+1
.8d9a	46 17		lsr $17		_b5:		lsr tmp2+1		;   tmp2 <<= 1
.8d9c	66 16		ror $16				ror tmp2+0
.8d9e	88		dey				dey			;  next bit
.8d9f	d0 e9		bne $8d8a			bne _b1
.8da1	60		rts				rts
=85					CodeLen	.var *-XtPtr1
=$8da2					Here1 = *	; remember here
>8d4b	55					.byte CodeLen	;patch wh_CodeLength
.8da2					EFix3:
.8da2	a9 00		lda #$00			lda #0			; zero unused mantissa
.8da4	95 6c		sta $6c,x			sta FSMant2+1,x
.8da6	95 76		sta $76,x			sta FSMant3+1,x
.8da8	e6 4c		inc $4c				inc FIndex		; FDrop
.8daa	a6 14		ldx $14				ldx tmp1+0		; restore X
.8dac	28		plp				plp			;fix result sign
.8dad	10 03		bpl $8db2			bpl +
.8daf	4c a5 8b	jmp $8ba5			jmp FNegate
.8db2	4c a8 8a	jmp $8aa8	+		jmp FNorm
>8db5	45 53 71 72			Name0:	.text "ESqr"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=36153					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>8db9	44					.byte (("ESqr"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=112					LinkDisplacement = Nt0-WordListLink
>8dba	10					.byte WordFlags	;wh_Flags
>8dbb	03					.byte 3	;wh_CodeLength
>8dbc	70					  .byte LinkDisplacement	; offset to previous nt
=$8dbd					XtPtr1 ::= *
=36153					WordListLink ::= Nt0 ; remember the nt of this word for later
.8dbd	20 53 85	jsr $8553	ESqr:		jsr FDup
.8dc0	4c 4d 8d	jmp $8d4d			jmp EStar
=6					CodeLen	.var *-XtPtr1
=$8dc3					Here1 = *	; remember here
>8dbb	06					.byte CodeLen	;patch wh_CodeLength
>8dc3	45 2f				Name0:	.text "E/"	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=36165					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>8dc5	e2					.byte (("E/"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=12					LinkDisplacement = Nt0-WordListLink
>8dc6	10					.byte WordFlags	;wh_Flags
>8dc7	03					.byte 3	;wh_CodeLength
>8dc8	0c					  .byte LinkDisplacement	; offset to previous nt
=$8dc9					XtPtr1 ::= *
=36165					WordListLink ::= Nt0 ; remember the nt of this word for later
.8dc9	20 ea a0	jsr $a0ea	ESlash:		jsr EPos	; make e1 & e2 positive
.8dcc	08		php				php		; remember result sign
.8dcd	b5 4e		lda $4e,x			lda FSExp+1,x		; calc e3 exponent
.8dcf	38		sec				sec
.8dd0	f5 4d		sbc $4d,x			sbc FSExp+0,x
.8dd2	70 17		bvs $8deb			bvs _ExpOvfl
.8dd4	18		clc				clc
.8dd5	69 01		adc #$01			adc #1
.8dd7	95 4e		sta $4e,x			sta FSExp+1,x
.8dd9	20 fb 8d	jsr $8dfb			jsr _Byte		; gen quotient hi byte
.8ddc	48		pha				pha
.8ddd	20 fb 8d	jsr $8dfb			jsr _Byte		; gen quotient lo byte
.8de0	95 62		sta $62,x			sta FSMant1+1,x
.8de2	68		pla				pla
.8de3	4a		lsr a				lsr a
.8de4	95 58		sta $58,x			sta FSMant0+1,x
.8de6	76 62		ror $62,x			ror FSMant1+1,x
.8de8	4c a2 8d	jmp $8da2			jmp EFix3
.8deb					_ExpOvfl:
.8deb	a6 14		ldx $14				ldx tmp1+0		; restore data stack index
.8ded	b0 04		bcs $8df3			bcs _zero		; underflow?
.8def	28		plp				plp			; rdrop saved result sign
.8df0	20 3e c4	jsr $c43e			jsr Throw_FpOutOfRange	; overflow
.8df3	28		plp		_zero:		plp			; rdrop saved result sign
.8df4	e6 4c		inc $4c				inc FIndex		; FDrop e2
.8df6	e6 4c		inc $4c				inc FIndex		; FDrop e1
.8df8	4c 27 9e	jmp $9e27			jmp E0			; return zero
.8dfb					_Byte:
.8dfb	a0 08		ldy #$08			ldy #8			; for 8 bits
.8dfd	b5 62		lda $62,x	_b1:		lda FSMant1+1,x		;   if r1 >= r2
.8dff	d5 61		cmp $61,x			cmp FSMant1+0,x
.8e01	b5 58		lda $58,x			lda FSMant0+1,x
.8e03	f5 57		sbc $57,x			sbc FSMant0+0,x
.8e05	90 09		bcc $8e10			bcc _b5
.8e07	95 58		sta $58,x			sta FSMant0+1,x
.8e09	b5 62		lda $62,x			lda FSMant1+1,x		;     r1 -= r2
.8e0b	f5 61		sbc $61,x			sbc FSMant1+0,x
.8e0d	95 62		sta $62,x			sta FSMant1+1,x
.8e0f	38		sec				sec
.8e10					_b5:
.8e10	26 15		rol $15				rol tmp1+1		;   save quotient bit
.8e12	16 62		asl $62,x			asl FSMant1+1,x		;   r1 *= 2
.8e14	36 58		rol $58,x			rol FSMant0+1,x
.8e16	88		dey				dey			;  next bit
.8e17	d0 e4		bne $8dfd			bne _b1
.8e19	a5 15		lda $15				lda tmp1+1		; return bits
.8e1b	60		rts				rts
=83					CodeLen	.var *-XtPtr1
=$8e1c					Here1 = *	; remember here
>8dc7	53					.byte CodeLen	;patch wh_CodeLength
>8e1c	45 31 2f			Name0:	.text "E1/"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=36255					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>8e1f	e3					.byte (("E1/"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=90					LinkDisplacement = Nt0-WordListLink
>8e20	10					.byte WordFlags	;wh_Flags
>8e21	03					.byte 3	;wh_CodeLength
>8e22	5a					  .byte LinkDisplacement	; offset to previous nt
=$8e23					XtPtr1 ::= *
=36255					WordListLink ::= Nt0 ; remember the nt of this word for later
.8e23	20 e3 88	jsr $88e3	E1Slash:	jsr F1
.8e26	20 d7 85	jsr $85d7			jsr FSwap
.8e29	4c c9 8d	jmp $8dc9			jmp ESlash
=9					CodeLen	.var *-XtPtr1
=$8e2c					Here1 = *	; remember here
>8e21	09					.byte CodeLen	;patch wh_CodeLength
>8e2c	53 3e 46			Name0:	.text "S>F"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=36271					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>8e2f	c3					.byte (("S>F"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=16					LinkDisplacement = Nt0-WordListLink
>8e30	10					.byte WordFlags	;wh_Flags
>8e31	03					.byte 3	;wh_CodeLength
>8e32	10					  .byte LinkDisplacement	; offset to previous nt
=$8e33					XtPtr1 ::= *
=36271					WordListLink ::= Nt0 ; remember the nt of this word for later
.8e33	20 de c3	jsr $c3de	SToF:		jsr PopYA		; pop n
.8e36	20 c8 84	jsr $84c8	SToFYA:		jsr FAllocX		; alloc FP stack entry
.8e39	95 61		sta $61,x			sta FSMant1,x		; copy n to mantissa
.8e3b	94 57		sty $57,x			sty FSMant0,x	; sty dir,x exists
.8e3d	a9 00		lda #$00			lda #0			; pad mantissa
.8e3f	95 6b		sta $6b,x			sta FSMant2,x
.8e41	95 75		sta $75,x			sta FSMant3,x
.8e43	a9 0f		lda #$0f			lda #15			; set exponent
.8e45	95 4d		sta $4d,x			sta FSExp,x
.8e47	4c aa 8a	jmp $8aaa			jmp FNormX		; normalize, return
=23					CodeLen	.var *-XtPtr1
=$8e4a					Here1 = *	; remember here
>8e31	17					.byte CodeLen	;patch wh_CodeLength
>8e4a	44 3e 46			Name0:	.text "D>F"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=36301					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>8e4d	c3					.byte (("D>F"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=30					LinkDisplacement = Nt0-WordListLink
>8e4e	10					.byte WordFlags	;wh_Flags
>8e4f	03					.byte 3	;wh_CodeLength
>8e50	1e					  .byte LinkDisplacement	; offset to previous nt
=$8e51					XtPtr1 ::= *
=36301					WordListLink ::= Nt0 ; remember the nt of this word for later
.8e51	20 c8 84	jsr $84c8	FDToF:		jsr FAllocX		; alloc FP stack entry
.8e54	a6 14		ldx $14				ldx tmp1+0		; restore data stack index
.8e56	a4 4c		ldy $4c				ldy FIndex		; Y= fp stack index
.8e58	b5 26		lda $26,x			lda DStack+2,x		; mantissa= d
.8e5a	99 75 00	sta $0075,y			sta FSMant3,y
.8e5d	b5 27		lda $27,x			lda DStack+3,x
.8e5f	99 6b 00	sta $006b,y			sta FSMant2,y
.8e62	b5 24		lda $24,x			lda DStack+0,x
.8e64	99 61 00	sta $0061,y			sta FSMant1,y
.8e67	b5 25		lda $25,x			lda DStack+1,x
.8e69	99 57 00	sta $0057,y			sta FSMant0,y
.8e6c	a9 1f		lda #$1f			lda #31			; set exponent
.8e6e	99 4d 00	sta $004d,y			sta FSExp,y
.8e71	20 6d d5	jsr $d56d			jsr Two_Drop
.8e74	4c a8 8a	jmp $8aa8			jmp FNorm		; normalize, return
=38					CodeLen	.var *-XtPtr1
=$8e77					Here1 = *	; remember here
>8e4f	26					.byte CodeLen	;patch wh_CodeLength
>8e77	46 3e 53			Name0:	.text "F>S"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=36346					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>8e7a	63					.byte (("F>S"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=45					LinkDisplacement = Nt0-WordListLink
>8e7b	10					.byte WordFlags	;wh_Flags
>8e7c	03					.byte 3	;wh_CodeLength
>8e7d	2d					  .byte LinkDisplacement	; offset to previous nt
=$8e7e					XtPtr1 ::= *
=36346					WordListLink ::= Nt0 ; remember the nt of this word for later
.8e7e	a4 4c		ldy $4c		FToS:		ldy FIndex
.8e80	b9 57 00	lda $0057,y			lda FSMant0,y		; save sign
.8e83	08		php				php
.8e84	10 03		bpl $8e89			bpl +
.8e86	20 a5 8b	jsr $8ba5			jsr FNegate
.8e89					+
.8e89	a9 0f		lda #$0f			lda #15
.8e8b	20 b1 89	jsr $89b1			jsr FShiftA
.8e8e	a6 14		ldx $14				ldx tmp1+0		; restore data stack index
.8e90	c0 10		cpy #$10			cpy #15+1		; always positive, so unsigned compare works
.8e92	b0 17		bcs $8eab			bcs _overflow
.8e94	a4 4c		ldy $4c				ldy FIndex
.8e96	ca		dex				dex
.8e97	ca		dex				dex
.8e98	b9 57 00	lda $0057,y			lda FSMant0,y
.8e9b	95 25		sta $25,x			sta DStack+1,x
.8e9d	b9 61 00	lda $0061,y			lda FSMant1,y
.8ea0	95 24		sta $24,x			sta DStack+0,x
.8ea2	e6 4c		inc $4c				inc FIndex		; FDrop
.8ea4	28		plp				plp			; apply saved sign
.8ea5	30 01		bmi $8ea8			bmi +
.8ea7	60		rts				rts
.8ea8	4c e4 d6	jmp $d6e4	+		jmp Negate
.8eab	28		plp		_overflow:	plp			; RDrop saved sign
.8eac	a9 f5		lda #$f5			lda #$100+err_OutOfRange
.8eae	20 63 c4	jsr $c463			jsr ThrowA
=51					CodeLen	.var *-XtPtr1
=$8eb1					Here1 = *	; remember here
>8e7c	33					.byte CodeLen	;patch wh_CodeLength
>8eb1	46 3e 44			Name0:	.text "F>D"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=36404					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>8eb4	83					.byte (("F>D"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=58					LinkDisplacement = Nt0-WordListLink
>8eb5	10					.byte WordFlags	;wh_Flags
>8eb6	03					.byte 3	;wh_CodeLength
>8eb7	3a					  .byte LinkDisplacement	; offset to previous nt
=$8eb8					XtPtr1 ::= *
=36404					WordListLink ::= Nt0 ; remember the nt of this word for later
.8eb8	a4 4c		ldy $4c		FToD:		ldy FIndex
.8eba	b9 57 00	lda $0057,y			lda FSMant0,y		; save sign
.8ebd	08		php				php
.8ebe	10 03		bpl $8ec3			bpl +
.8ec0	20 a5 8b	jsr $8ba5			jsr FNegate
.8ec3					+
.8ec3	a9 1f		lda #$1f			lda #31
.8ec5	20 b1 89	jsr $89b1			jsr FShiftA
.8ec8	a6 14		ldx $14				ldx tmp1+0		; restore data stack index
.8eca	c0 20		cpy #$20			cpy #31+1		; always positive, so unsigned compare works
.8ecc	b0 23		bcs $8ef1			bcs _overflow
.8ece	a4 4c		ldy $4c				ldy FIndex
.8ed0	ca		dex				dex			; d= mantissa
.8ed1	ca		dex				dex
.8ed2	ca		dex				dex
.8ed3	ca		dex				dex
.8ed4	b9 57 00	lda $0057,y			lda FSMant0,y
.8ed7	95 25		sta $25,x			sta DStack+1,x
.8ed9	b9 61 00	lda $0061,y			lda FSMant1,y
.8edc	95 24		sta $24,x			sta DStack+0,x
.8ede	b9 6b 00	lda $006b,y			lda FSMant2,y
.8ee1	95 27		sta $27,x			sta DStack+3,x
.8ee3	b9 75 00	lda $0075,y			lda FSMant3,y
.8ee6	95 26		sta $26,x			sta DStack+2,x
.8ee8	e6 4c		inc $4c				inc FIndex		; FDrop
.8eea	28		plp				plp			; apply saved sign
.8eeb	30 01		bmi $8eee			bmi +
.8eed	60		rts				rts
.8eee	4c 14 d7	jmp $d714	+		jmp DNegate
.8ef1	28		plp		_overflow:	plp			; RDrop sign
.8ef2	a9 f5		lda #$f5			lda #$100+err_OutOfRange
.8ef4	20 63 c4	jsr $c463			jsr ThrowA
=63					CodeLen	.var *-XtPtr1
=$8ef7					Here1 = *	; remember here
>8eb6	3f					.byte CodeLen	;patch wh_CodeLength
>8ef7	46 52 6e 64			Name0:	.text "FRnd"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=36475					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>8efb	84					.byte (("FRnd"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=71					LinkDisplacement = Nt0-WordListLink
>8efc	10					.byte WordFlags	;wh_Flags
>8efd	03					.byte 3	;wh_CodeLength
>8efe	47					  .byte LinkDisplacement	; offset to previous nt
=$8eff					XtPtr1 ::= *
=36475					WordListLink ::= Nt0 ; remember the nt of this word for later
.8eff	20 f7 82	jsr $82f7	FRnd:		jsr Rand		; generate next RndState
.8f02	20 c8 84	jsr $84c8			jsr FAllocX		; alloc FP stack entry
.8f05	4a		lsr a				lsr a			;   make positive
.8f06	95 57		sta $57,x			sta FSMant0,x
.8f08	94 61		sty $61,x			sty FSMant1,x	; sty dir,x exists
.8f0a	ad 35 03	lda $0335			lda RndState+0
.8f0d	95 6b		sta $6b,x			sta FSMant2,x
.8f0f	ad 36 03	lda $0336			lda RndState+1
.8f12	95 75		sta $75,x			sta FSMant3,x
.8f14	a9 00		lda #$00			lda #0			; exponent=0
.8f16	95 4d		sta $4d,x			sta FSExp,x
.8f18	4c aa 8a	jmp $8aaa			jmp FNormX		; normalize, return
=28					CodeLen	.var *-XtPtr1
=$8f1b					Here1 = *	; remember here
>8efd	1c					.byte CodeLen	;patch wh_CodeLength
>8f1b	46 53 71 72 74			Name0:	.text "FSqrt"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=36512					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>8f20	85					.byte (("FSqrt"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=37					LinkDisplacement = Nt0-WordListLink
>8f21	10					.byte WordFlags	;wh_Flags
>8f22	03					.byte 3	;wh_CodeLength
>8f23	25					  .byte LinkDisplacement	; offset to previous nt
=$8f24					XtPtr1 ::= *
=36512					WordListLink ::= Nt0 ; remember the nt of this word for later
.8f24	a4 4c		ldy $4c		FSqrt:		ldy FIndex
.8f26	b9 57 00	lda $0057,y			lda FSMant0,y		; zero?
.8f29	d0 01		bne $8f2c			bne +
.8f2b	60		rts				rts			;   just return the zero
.8f2c					+
.8f2c	20 53 85	jsr $8553			jsr FDup		; get trial value
.8f2f	a4 4c		ldy $4c				ldy FIndex
.8f31	b9 4d 00	lda $004d,y			lda FSExp,y		; halve the exponent of trial value
.8f34	c9 80		cmp #$80			cmp #$80
.8f36	6a		ror a				ror a
.8f37	99 4d 00	sta $004d,y			sta FSExp,y
.8f3a	a9 09		lda #$09			lda #9			; for 9 iterations
.8f3c	48		pha		_3:		pha
.8f3d	20 c8 85	jsr $85c8			jsr F2Dup		;   calc new trial value
.8f40	20 9a 8c	jsr $8c9a			jsr FSlash
.8f43	20 30 8b	jsr $8b30			jsr FPlus
.8f46	20 97 89	jsr $8997			jsr F2Slash
.8f49	68		pla				pla			;  next
.8f4a	38		sec				sec
.8f4b	e9 01		sbc #$01			sbc #1
.8f4d	d0 ed		bne $8f3c			bne _3
.8f4f	4c 2e 85	jmp $852e			jmp FNip		; return trial value
=46					CodeLen	.var *-XtPtr1
=$8f52					Here1 = *	; remember here
>8f22	2e					.byte CodeLen	;patch wh_CodeLength
>8f52	50 72 65 63 69 73 69 6f		Name0:	.text "Precision"	;  name of word as a string, ending at wh_NameLastChar
>8f5a	6e
=9					NameLength = *-Name0
=36571					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>8f5b	c9					.byte (("Precision"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=59					LinkDisplacement = Nt0-WordListLink
>8f5c	10					.byte WordFlags	;wh_Flags
>8f5d	03					.byte 3	;wh_CodeLength
>8f5e	3b					  .byte LinkDisplacement	; offset to previous nt
=$8f5f					XtPtr1 ::= *
=36571					WordListLink ::= Nt0 ; remember the nt of this word for later
.8f5f	ad ff 02	lda $02ff	Precision:	lda PrecisionV
.8f62	4c e4 c7	jmp $c7e4			jmp PushZA
=6					CodeLen	.var *-XtPtr1
=$8f65					Here1 = *	; remember here
>8f5d	06					.byte CodeLen	;patch wh_CodeLength
.8f65	60		rts				rts
>8f66	53 65 74 2d 50 72 65 63		Name0:	.text "Set-Precision"	;  name of word as a string, ending at wh_NameLastChar
>8f6e	69 73 69 6f 6e
=13					NameLength = *-Name0
=36595					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>8f73	cd					.byte (("Set-Precision"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=24					LinkDisplacement = Nt0-WordListLink
>8f74	10					.byte WordFlags	;wh_Flags
>8f75	03					.byte 3	;wh_CodeLength
>8f76	18					  .byte LinkDisplacement	; offset to previous nt
=$8f77					XtPtr1 ::= *
=36595					WordListLink ::= Nt0 ; remember the nt of this word for later
.8f77	20 c3 c3	jsr $c3c3			jsr PopA
.8f7a	8d ff 02	sta $02ff			sta PrecisionV
=6					CodeLen	.var *-XtPtr1
=$8f7d					Here1 = *	; remember here
>8f75	06					.byte CodeLen	;patch wh_CodeLength
.8f7d	60		rts				rts
>8f7e	28 46 2e 29			Name0:	.text "(F.)"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=36610					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>8f82	24					.byte (("(F.)"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=15					LinkDisplacement = Nt0-WordListLink
>8f83	10					.byte WordFlags	;wh_Flags
>8f84	03					.byte 3	;wh_CodeLength
>8f85	0f					  .byte LinkDisplacement	; offset to previous nt
=$8f86					XtPtr1 ::= *
=36610					WordListLink ::= Nt0 ; remember the nt of this word for later
.8f86	20 03 90	jsr $9003	PFDot:		jsr pfcstart		;start collecting chars, make r positive
.8f89	20 8f 8f	jsr $8f8f			jsr PFDotSub
.8f8c	4c 21 90	jmp $9021			jmp pfcend
.8f8f					PFDotSub:
.8f8f	20 5f 8f	jsr $8f5f			jsr Precision	;alloc & init work area
.8f92	20 fb c7	jsr $c7fb			jsr One
=$27					_mantNzFound  = DStack+3	; nonzero mantissa digit processed
=$26					_NumSigDigits = DStack+2	; # of significant digits
=$24					_decimalPos   = DStack+0	; decimal point position
.8f95	20 e3 8f	jsr $8fe3			jsr FLt10		; scale down to <10, counting exponent
.8f98					_c:
.8f98	b5 24		lda $24,x			lda _decimalPos,x	;  insert decimal point here?
.8f9a	d0 05		bne $8fa1			bne _c2
.8f9c	a9 2e		lda #$2e			lda #'.'
.8f9e	20 18 90	jsr $9018			jsr pfchar
.8fa1	d6 24		dec $24,x	_c2:		dec _decimalPos,x
.8fa3	20 53 85	jsr $8553			jsr FDup		;  do a digit
.8fa6	20 7e 8e	jsr $8e7e			jsr FToS		;  ( work n )
.8fa9	b5 24		lda $24,x			lda DStack+0,x
.8fab	15 29		ora $29,x			ora _mantNzFound+2,x	;  doing significant digits?
.8fad	95 29		sta $29,x			sta _mantNzFound+2,x
.8faf	f0 08		beq $8fb9			beq _c7
.8fb1	d6 28		dec $28,x			dec _NumSigDigits+2,x
.8fb3	10 04		bpl $8fb9			bpl _c7
.8fb5	e8		inx				inx			;    drop integer
.8fb6	e8		inx				inx
.8fb7	d0 17		bne $8fd0			bne _d
.8fb9	b5 24		lda $24,x	_c7:		lda DStack+0,x		;  store the char
.8fbb	09 30		ora #$30			ora #'0'
.8fbd	20 18 90	jsr $9018			jsr pfchar
.8fc0	20 33 8e	jsr $8e33			jsr SToF		;  ( work )
.8fc3	20 70 8b	jsr $8b70			jsr FMinus
.8fc6	20 a3 89	jsr $89a3			jsr F10Star
.8fc9	a4 4c		ldy $4c				ldy FIndex		;  until mantissa==0
.8fcb	b9 57 00	lda $0057,y			lda FSMant0,y
.8fce	d0 c8		bne $8f98			bne _c
.8fd0	d6 24		dec $24,x	_d:		dec _decimalPos,x	;do trailing zeros
.8fd2	30 08		bmi $8fdc			bmi _d9
.8fd4	a9 30		lda #$30			lda #'0'
.8fd6	20 18 90	jsr $9018			jsr pfchar
.8fd9	4c d0 8f	jmp $8fd0			jmp _d
.8fdc					_d9:
.8fdc	e8		inx				inx			; drop work area
.8fdd	e8		inx				inx
.8fde	e8		inx				inx
.8fdf	e8		inx				inx
.8fe0	e6 4c		inc $4c				inc FIndex		; FDrop
.8fe2	60		rts				rts
=93					CodeLen	.var *-XtPtr1
=$8fe3					Here1 = *	; remember here
>8f84	5d					.byte CodeLen	;patch wh_CodeLength
.8fe3					FLt10:
.8fe3	a4 4c		ldy $4c		_1:		ldy FIndex		; while r >= 10
.8fe5	b9 4d 00	lda $004d,y			lda FSExp,y
.8fe8	30 18		bmi $9002			bmi _9			;   exponent negative?
.8fea	c9 04		cmp #$04			cmp #4
.8fec	90 14		bcc $9002			bcc _9			;   < 4 ?
.8fee	d0 07		bne $8ff7			bne _2			;   > 4 ?
.8ff0	b9 57 00	lda $0057,y			lda FSMant0,y		;   r > 10 ?
.8ff3	c9 50		cmp #$50			cmp #$50
.8ff5	90 0b		bcc $9002			bcc _9
.8ff7	f6 24		inc $24,x	_2:		inc DStack+0,x		;   exp ++
.8ff9	20 c9 88	jsr $88c9			jsr F10			;   r /= 10
.8ffc	20 9a 8c	jsr $8c9a			jsr FSlash
.8fff	4c e3 8f	jmp $8fe3			jmp _1
.9002	60		rts		_9:		rts
.9003					pfcstart:
.9003	a9 01		lda #$01			lda #1
.9005	8d 34 03	sta $0334			sta ToHold
.9008	a4 4c		ldy $4c				ldy FIndex		; if r1 negative
.900a	b9 57 00	lda $0057,y			lda FSMant0,y
.900d	10 08		bpl $9017			bpl _19
.900f	a9 2d		lda #$2d			lda #'-'		;   append sign
.9011	20 18 90	jsr $9018			jsr pfchar
.9014	4c a5 8b	jmp $8ba5			jmp FNegate		;   make positive, return
.9017	60		rts		_19:		rts
.9018					pfchar:
.9018	ac 34 03	ldy $0334			ldy ToHold
.901b	91 00		sta ($00),y			sta (cp),y
.901d	ee 34 03	inc $0334			inc ToHold
.9020	60		rts				rts
.9021					pfcend:
.9021	ad 34 03	lda $0334			lda ToHold
.9024	38		sec				sec
.9025	e9 01		sbc #$01			sbc #1
.9027	a0 00		ldy #$00			ldy #0
.9029	91 00		sta ($00),y			sta (cp),y		; fill in length
.902b	4c 62 da	jmp $da62			jmp Here		; push start addr
.902e					pfciA:
.902e	a8		tay				tay
.902f	10 09		bpl $903a			bpl _15			; IfMi,
.9031	c8		iny				iny			;   negate
.9032	98		tya				tya
.9033	49 ff		eor #$ff			eor #$ff
.9035	48		pha				pha
.9036	a9 2d		lda #$2d			lda #'-'
.9038	d0 03		bne $903d			bne _19
.903a	48		pha		_15:		pha
.903b	a9 2b		lda #$2b			lda #'+'
.903d					_19:
.903d	20 18 90	jsr $9018			jsr pfchar
.9040	68		pla				pla
.9041	a0 2f		ldy #$2f			ldy #'0'-1
.9043	c8		iny		_20:		iny
.9044	38		sec				sec
.9045	e9 0a		sbc #$0a			sbc #10
.9047	b0 fa		bcs $9043			bcs _20
.9049	69 0a		adc #$0a			adc #10
.904b	48		pha				pha
.904c	98		tya				tya
.904d	20 18 90	jsr $9018			jsr pfchar
.9050	68		pla				pla
.9051	09 30		ora #$30			ora #'0'
.9053	d0 c3		bne $9018			bne pfchar
>9055	46 2e				Name0:	.text "F."	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=36823					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9057	c2					.byte (("F."[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=213					LinkDisplacement = Nt0-WordListLink
>9058	10					.byte WordFlags	;wh_Flags
>9059	03					.byte 3	;wh_CodeLength
>905a	d5					  .byte LinkDisplacement	; offset to previous nt
=$905b					XtPtr1 ::= *
=36823					WordListLink ::= Nt0 ; remember the nt of this word for later
.905b	20 86 8f	jsr $8f86	FDot:		jsr PFDot
.905e	20 d7 c1	jsr $c1d7	FDot2:		jsr Count
.9061	20 34 de	jsr $de34			jsr Type
.9064	4c 28 de	jmp $de28			jmp Space
=12					CodeLen	.var *-XtPtr1
=$9067					Here1 = *	; remember here
>9059	0c					.byte CodeLen	;patch wh_CodeLength
>9067	46 2e 53			Name0:	.text "F.S"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=36842					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>906a	63					.byte (("F.S"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=19					LinkDisplacement = Nt0-WordListLink
>906b	10					.byte WordFlags	;wh_Flags
>906c	03					.byte 3	;wh_CodeLength
>906d	13					  .byte LinkDisplacement	; offset to previous nt
=$906e					XtPtr1 ::= *
=36842					WordListLink ::= Nt0 ; remember the nt of this word for later
.906e	a9 09		lda #$09	FDotS:		lda #FDim-1	; for each FP stack entry
.9070	d0 0b		bne $907d			bne _8
.9072	48		pha		_2:		pha
.9073	20 9f 85	jsr $859f			jsr FPick3	;   print it
.9076	20 5b 90	jsr $905b			jsr FDot
.9079	68		pla				pla		;  next
.907a	38		sec				sec
.907b	e9 01		sbc #$01			sbc #1
.907d	c5 4c		cmp $4c		_8:		cmp FIndex
.907f	b0 f1		bcs $9072			bcs _2
=19					CodeLen	.var *-XtPtr1
=$9081					Here1 = *	; remember here
>906c	13					.byte CodeLen	;patch wh_CodeLength
.9081	60		rts				rts
>9082	28 46 53 2e 29			Name0:	.text "(FS.)"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=36871					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9087	25					.byte (("(FS.)"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=29					LinkDisplacement = Nt0-WordListLink
>9088	10					.byte WordFlags	;wh_Flags
>9089	03					.byte 3	;wh_CodeLength
>908a	1d					  .byte LinkDisplacement	; offset to previous nt
=$908b					XtPtr1 ::= *
=36871					WordListLink ::= Nt0 ; remember the nt of this word for later
.908b	20 f2 c7	jsr $c7f2	PFSDot:		jsr Zero		; alloc work area
=$24					_exp    = DStack+0
.908e	20 03 90	jsr $9003			jsr pfcstart		; start collecting chars, make r positive
.9091	20 e3 8f	jsr $8fe3			jsr FLt10		; scale down to <10
.9094	a4 4c		ldy $4c		_c1:		ldy FIndex		; while r < 1
.9096	b9 57 00	lda $0057,y			lda FSMant0,y		;   mantissa == 0 ?
.9099	f0 0f		beq $90aa			beq _c9
.909b	b9 4d 00	lda $004d,y			lda FSExp,y		;   exp < 1 ?
.909e	f0 02		beq $90a2			beq _c2
.90a0	10 08		bpl $90aa			bpl _c9
.90a2	d6 24		dec $24,x	_c2:		dec DStack+0,x		;  exp -= 1
.90a4	20 a3 89	jsr $89a3			jsr F10Star		;  r *= 10
.90a7	4c 94 90	jmp $9094			jmp _c1
.90aa					_c9:
.90aa	20 8f 8f	jsr $8f8f	PFSDotM:	jsr PFDotSub		; do mantissa
.90ad	a9 45		lda #$45			lda #'E'
.90af	20 18 90	jsr $9018			jsr pfchar		; do exponent
.90b2	b5 24		lda $24,x			lda DStack+0,x		;   _exp
.90b4	20 2e 90	jsr $902e			jsr pfciA
.90b7	e8		inx				inx			; Drop work area
.90b8	e8		inx				inx
.90b9	4c 21 90	jmp $9021			jmp pfcend		; finish string
=49					CodeLen	.var *-XtPtr1
=$90bc					Here1 = *	; remember here
>9089	31					.byte CodeLen	;patch wh_CodeLength
>90bc	46 53 2e			Name0:	.text "FS."	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=36927					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>90bf	c3					.byte (("FS."[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=56					LinkDisplacement = Nt0-WordListLink
>90c0	10					.byte WordFlags	;wh_Flags
>90c1	03					.byte 3	;wh_CodeLength
>90c2	38					  .byte LinkDisplacement	; offset to previous nt
=$90c3					XtPtr1 ::= *
=36927					WordListLink ::= Nt0 ; remember the nt of this word for later
.90c3	20 8b 90	jsr $908b	FSDot:		jsr PFSDot
.90c6	4c 5e 90	jmp $905e			jmp FDot2
=6					CodeLen	.var *-XtPtr1
=$90c9					Here1 = *	; remember here
>90c1	06					.byte CodeLen	;patch wh_CodeLength
>90c9	28 46 45 2e 29			Name0:	.text "(FE.)"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=36942					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>90ce	25					.byte (("(FE.)"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=15					LinkDisplacement = Nt0-WordListLink
>90cf	10					.byte WordFlags	;wh_Flags
>90d0	03					.byte 3	;wh_CodeLength
>90d1	0f					  .byte LinkDisplacement	; offset to previous nt
=$90d2					XtPtr1 ::= *
=36942					WordListLink ::= Nt0 ; remember the nt of this word for later
.90d2	20 f2 c7	jsr $c7f2	PFEDot:		jsr Zero		; alloc work area
=$24					_exp    = DStack+0
.90d5	20 03 90	jsr $9003			jsr pfcstart		; start collecting chars, make r positive
.90d8	a4 4c		ldy $4c		_30:		ldy FIndex		; while r < 1
.90da	b9 57 00	lda $0057,y			lda FSMant0,y
.90dd	f0 16		beq $90f5			beq _39
.90df	b9 4d 00	lda $004d,y			lda FSExp,y
.90e2	f0 02		beq $90e6			beq _31
.90e4	10 0f		bpl $90f5			bpl _39
.90e6	d6 24		dec $24,x	_31:		dec _exp,x		;  exp -= 3
.90e8	d6 24		dec $24,x			dec _exp,x
.90ea	d6 24		dec $24,x			dec _exp,x
.90ec	20 bb 88	jsr $88bb			jsr F1000		;  r *= 1000
.90ef	20 fe 8b	jsr $8bfe			jsr FStar
.90f2	4c d8 90	jmp $90d8			jmp _30
.90f5					_39:
.90f5	a4 4c		ldy $4c		_a:		ldy FIndex		; while r >= 1000
.90f7	b9 4d 00	lda $004d,y			lda FSExp,y
.90fa	30 1c		bmi $9118			bmi _a9			; exponent negative?
.90fc	c9 0a		cmp #$0a			cmp #10
.90fe	90 18		bcc $9118			bcc _a9			;   < 10 ?
.9100	d0 07		bne $9109			bne _a2			;   > 10 ?
.9102	b9 57 00	lda $0057,y			lda FSMant0,y
.9105	c9 7d		cmp #$7d			cmp #$7d
.9107	90 0f		bcc $9118			bcc _a9
.9109	f6 24		inc $24,x	_a2:		inc _exp,x		;   exp += 3
.910b	f6 24		inc $24,x			inc _exp,x
.910d	f6 24		inc $24,x			inc _exp,x
.910f	20 bb 88	jsr $88bb			jsr F1000		;   r /= 1000
.9112	20 9a 8c	jsr $8c9a			jsr FSlash
.9115	4c f5 90	jmp $90f5			jmp _a
.9118					_a9:
.9118	4c aa 90	jmp $90aa			jmp PFSDotM
=73					CodeLen	.var *-XtPtr1
=$911b					Here1 = *	; remember here
>90d0	49					.byte CodeLen	;patch wh_CodeLength
>911b	46 45 2e			Name0:	.text "FE."	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=37022					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>911e	c3					.byte (("FE."[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=80					LinkDisplacement = Nt0-WordListLink
>911f	10					.byte WordFlags	;wh_Flags
>9120	03					.byte 3	;wh_CodeLength
>9121	50					  .byte LinkDisplacement	; offset to previous nt
=$9122					XtPtr1 ::= *
=37022					WordListLink ::= Nt0 ; remember the nt of this word for later
.9122	20 d2 90	jsr $90d2	FEDot:		jsr PFEDot
.9125	4c 5e 90	jmp $905e			jmp FDot2
=6					CodeLen	.var *-XtPtr1
=$9128					Here1 = *	; remember here
>9120	06					.byte CodeLen	;patch wh_CodeLength
>9128	46 27				Name0:	.text "F'"	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=37034					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>912a	e2					.byte (("F'"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=24					WordFlags ::= IM+NN	; modifiable copy, remember for later
=12					LinkDisplacement = Nt0-WordListLink
>912b	18					.byte WordFlags	;wh_Flags
>912c	03					.byte 3	;wh_CodeLength
>912d	0c					  .byte LinkDisplacement	; offset to previous nt
=$912e					XtPtr1 ::= *
=37034					WordListLink ::= Nt0 ; remember the nt of this word for later
.912e	20 82 ca	jsr $ca82	FQuote:		jsr Parse_Name		; get string
.9131	20 51 91	jsr $9151			jsr ToFloat		; convert
.9134	b5 24		lda $24,x			lda DStack+0,x		; error?
.9136	f0 0a		beq $9142			beq _Err
.9138	e8		inx				inx
.9139	e8		inx				inx
.913a	a5 0a		lda $0a				lda State		; compiling?
.913c	d0 01		bne $913f			bne _compile
.913e	60		rts				rts
.913f	4c 0a 88	jmp $880a	_compile:	jmp FLiteral		; compile a FP literal
.9142	a9 36		lda #$36	_Err:		lda #100+err_FPInvalidArg
.9144	20 63 c4	jsr $c463			jsr ThrowA
=25					CodeLen	.var *-XtPtr1
=$9147					Here1 = *	; remember here
>912c	19					.byte CodeLen	;patch wh_CodeLength
>9147	3e 46 6c 6f 61 74		Name0:	.text ">Float"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=37069					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>914d	86					.byte ((">Float"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=35					LinkDisplacement = Nt0-WordListLink
>914e	10					.byte WordFlags	;wh_Flags
>914f	03					.byte 3	;wh_CodeLength
>9150	23					  .byte LinkDisplacement	; offset to previous nt
=$9151					XtPtr1 ::= *
=37069					WordListLink ::= Nt0 ; remember the nt of this word for later
.9151					ToFloat:
.9151	20 f2 c7	jsr $c7f2			jsr Zero	; alloc & init workspace
.9154	20 f2 c7	jsr $c7f2			jsr Zero
.9157	20 f2 c7	jsr $c7f2			jsr Zero
=$2c					_addr		= DStack+8
=$2a					_len		= DStack+6
=$29					_mantfound 	= DStack+5		;mantissa digits found
=$28					_exponent 	= DStack+4		;exponent
=$27					_decimalPos 	= DStack+3		;decimal point position
=$26					_DecPointFound1 = DStack+2
=$25					_MantissaNegative1 = DStack+1
=$24					_ExponentNegative1 = DStack+0
.915a	20 ab 88	jsr $88ab			jsr F0			; init result
.915d	20 2f 92	jsr $922f	_11:		jsr _GetChar		; get mantissa prefix
.9160	b0 57		bcs $91b9			bcs _trueb ;_finishb
.9162	c9 20		cmp #$20			cmp #' '
.9164	f0 f7		beq $915d			beq _11
.9166	c9 2b		cmp #$2b			cmp #'+'
.9168	f0 06		beq $9170			beq _20
.916a	c9 2d		cmp #$2d			cmp #'-'
.916c	d0 07		bne $9175			bne _21
.916e	95 25		sta $25,x			sta _MantissaNegative1,x ; remember mantissa is negative
.9170	20 2f 92	jsr $922f	_20:		jsr _GetChar		; do next mantissa digits
.9173	b0 47		bcs $91bc			bcs _finishb
.9175	c9 2e		cmp #$2e	_21:		cmp #'.'
.9177	f0 31		beq $91aa			beq _27
.9179	c9 45		cmp #$45			cmp #'E'
.917b	f0 42		beq $91bf			beq _30
.917d	c9 65		cmp #$65			cmp #'e'
.917f	f0 3e		beq $91bf			beq _30
.9181	c9 44		cmp #$44			cmp #'D'
.9183	f0 3a		beq $91bf			beq _30
.9185	c9 64		cmp #$64			cmp #'d'
.9187	f0 36		beq $91bf			beq _30
.9189	38		sec				sec			;   a digit?
.918a	e9 30		sbc #$30			sbc #'0'
.918c	90 24		bcc $91b2			bcc _fail
.918e	c9 0a		cmp #$0a			cmp #9+1
.9190	b0 20		bcs $91b2			bcs _fail
.9192	48		pha				pha			; append digit to mantissa
.9193	20 a3 89	jsr $89a3			jsr F10Star
.9196	68		pla				pla
.9197	a0 00		ldy #$00			ldy #0
.9199	20 36 8e	jsr $8e36			jsr SToFYA
.919c	20 30 8b	jsr $8b30			jsr FPlus
.919f	f6 29		inc $29,x			inc _mantfound,x	; remember we found a mantissa digit
.91a1	b5 26		lda $26,x			lda _DecPointFound1,x	; if mantissa decimal point found
.91a3	f0 02		beq $91a7			beq +
.91a5	d6 27		dec $27,x			dec _decimalPos,x	;   increment decimal point position
.91a7					+
.91a7	4c 70 91	jmp $9170			jmp _20
.91aa					_27:
.91aa	b4 26		ldy $26,x			ldy _DecPointFound1,x	; already have one?
.91ac	d0 04		bne $91b2			bne _fail
.91ae	95 26		sta $26,x			sta _DecPointFound1,x	; we have one now!
.91b0	f0 be		beq $9170			beq _20
.91b2					_fail:
.91b2	20 14 85	jsr $8514			jsr FDrop
.91b5	a9 00		lda #$00			lda #0			;return false
.91b7	f0 69		beq $9222			beq _return
.91b9	4c 20 92	jmp $9220	_trueb:		jmp _true
.91bc	4c ed 91	jmp $91ed	_finishb:	jmp _finish
.91bf					_30:
.91bf	20 2f 92	jsr $922f			jsr _GetChar
.91c2	b0 29		bcs $91ed			bcs _finish
.91c4	c9 2b		cmp #$2b			cmp #'+'
.91c6	f0 06		beq $91ce			beq _40
.91c8	c9 2d		cmp #$2d			cmp #'-'
.91ca	d0 07		bne $91d3			bne _41
.91cc	95 24		sta $24,x			sta _ExponentNegative1,x ; remember exponent is negative
.91ce	20 2f 92	jsr $922f	_40:		jsr _GetChar		;get exponent digits
.91d1	b0 1a		bcs $91ed			bcs _finish
.91d3	38		sec		_41:		sec			;  digit?
.91d4	e9 30		sbc #$30			sbc #'0'
.91d6	90 da		bcc $91b2			bcc _fail
.91d8	c9 0a		cmp #$0a			cmp #9+1
.91da	b0 d6		bcs $91b2			bcs _fail
.91dc	85 14		sta $14				sta tmp1
.91de	16 28		asl $28,x			asl _exponent,x		;  exponent *= 10
.91e0	b5 28		lda $28,x			lda _exponent,x
.91e2	0a		asl a				asl a
.91e3	0a		asl a				asl a
.91e4	75 28		adc $28,x			adc _exponent,x
.91e6	65 14		adc $14				adc tmp1		;  + digit
.91e8	95 28		sta $28,x			sta _exponent,x
.91ea	4c ce 91	jmp $91ce			jmp _40
.91ed					_finish:
.91ed	b5 29		lda $29,x			lda _mantfound,x	;some mantissa digits found?
.91ef	f0 c1		beq $91b2			beq _fail
.91f1	b5 24		lda $24,x			lda _ExponentNegative1,x ;apply exponent sign
.91f3	f0 07		beq $91fc			beq +
.91f5	a9 00		lda #$00			lda #0
.91f7	38		sec				sec
.91f8	f5 28		sbc $28,x			sbc _exponent,x
.91fa	95 28		sta $28,x			sta _exponent,x
.91fc					+
.91fc	b5 28		lda $28,x			lda _exponent,x		;apply decimal position to exponent
.91fe	18		clc				clc
.91ff	75 27		adc $27,x			adc _decimalPos,x
.9201	95 28		sta $28,x			sta _exponent,x
.9203	4c 0b 92	jmp $920b			jmp _93
.9206	20 a3 89	jsr $89a3	_93b:		jsr F10Star		;apply exponent to mantissa
.9209	d6 28		dec $28,x			dec _exponent,x
.920b	f0 0a		beq $9217	_93:		beq _94
.920d	10 f7		bpl $9206			bpl _93b
.920f	20 c9 88	jsr $88c9	_94b:		jsr F10
.9212	20 9a 8c	jsr $8c9a			jsr FSlash
.9215	f6 28		inc $28,x			inc _exponent,x
.9217	30 f6		bmi $920f	_94:		bmi _94b
.9219					_95:
.9219	b5 25		lda $25,x			lda _MantissaNegative1,x ;apply mantissa sign
.921b	f0 03		beq $9220			beq +
.921d	20 a5 8b	jsr $8ba5			jsr FNegate
.9220					+
.9220	a9 ff		lda #$ff	_true:		lda #$ff		;return true
.9222					_return:
.9222	95 2c		sta $2c,x			sta _addr+0,x		; replace _addr with flag
.9224	95 2d		sta $2d,x			sta _addr+1,x
.9226	e8		inx				inx			; Drop work
.9227	e8		inx				inx
.9228	e8		inx				inx			; 2Drop work
.9229	e8		inx				inx
.922a	e8		inx				inx
.922b	e8		inx				inx
.922c	e8		inx				inx			; Drop len
.922d	e8		inx				inx
.922e	60		rts				rts
.922f					_GetChar:
.922f	38		sec				sec
.9230	b5 2a		lda $2a,x			lda _len,x
.9232	f0 0b		beq $923f			beq _gc_rts		; if end, return C=1
.9234	d6 2a		dec $2a,x			dec _len,x
.9236	a1 2c		lda ($2c,x)			lda (_addr,x)
.9238	f6 2c		inc $2c,x			inc _addr+0,x
.923a	d0 02		bne $923e			bne +
.923c	f6 2d		inc $2d,x			inc _addr+1,x
.923e					+
.923e	18		clc				clc			; get char, return C=0
.923f	60		rts		_gc_rts:	rts
>9240	46 4b 65 79			Name0:	.text "FKey"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=37316					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9244	24					.byte (("FKey"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=247					LinkDisplacement = Nt0-WordListLink
>9245	10					.byte WordFlags	;wh_Flags
>9246	03					.byte 3	;wh_CodeLength
>9247	f7					  .byte LinkDisplacement	; offset to previous nt
=$9248					XtPtr1 ::= *
=37316					WordListLink ::= Nt0 ; remember the nt of this word for later
.9248					FKey:
.9248	20 62 da	jsr $da62			jsr Here		; ( addr )
.924b	20 62 da	jsr $da62			jsr Here		; ( addr addr )
.924e	a9 28		lda #$28			lda #40			; ( addr addr 40 )
.9250	20 e4 c7	jsr $c7e4			jsr PushZA
.9253	20 d9 d2	jsr $d2d9			jsr Accept		; ( addr len )
.9256	20 51 91	jsr $9151			jsr ToFloat		; ( true | false)
.9259	e8		inx				inx			; err?
.925a	e8		inx				inx
.925b	b5 22		lda $22,x			lda DStack-2,x
.925d	f0 01		beq $9260			beq _err
.925f	60		rts				rts
.9260	20 b8 c8	jsr $c8b8	_err:		jsr SLiteral_runtime
.9263	4c 69 92	jmp $9269			  jmp +
>9266	20 3f 20					  .text " ? "
.9269	20 34 de	jsr $de34	+		jsr Type
.926c	4c 48 92	jmp $9248			jmp FKey
>926f	53 46 40			Name0:	.text "SF@"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=37362					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9272	03					.byte (("SF@"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=46					LinkDisplacement = Nt0-WordListLink
>9273	10					.byte WordFlags	;wh_Flags
>9274	03					.byte 3	;wh_CodeLength
>9275	2e					  .byte LinkDisplacement	; offset to previous nt
=$9276					XtPtr1 ::= *
=37362					WordListLink ::= Nt0 ; remember the nt of this word for later
.9276	20 de c3	jsr $c3de	SFAt:		jsr PopYA		; pop sf_addr
.9279	85 16		sta $16		SFAt_YA:	sta tmp2+0		; save sf_addr
.927b	84 17		sty $17				sty tmp2+1
.927d	20 c8 84	jsr $84c8			jsr FAllocX		; alloc FP stack entry
.9280	a0 01		ldy #$01			ldy #1			; copy exponent
.9282	b1 16		lda ($16),y			lda (tmp2),y
.9284	0a		asl a				asl a
.9285	88		dey				dey
.9286	b1 16		lda ($16),y			lda (tmp2),y
.9288	2a		rol a				rol a
.9289	38		sec				sec
.928a	e9 7e		sbc #$7e			sbc #126
.928c	95 4d		sta $4d,x			sta FSExp,x
.928e	a0 01		ldy #$01			ldy #1			; copy mantissa
.9290	b1 16		lda ($16),y			lda (tmp2),y
.9292	09 80		ora #$80			ora #$80
.9294	4a		lsr a				lsr a
.9295	95 57		sta $57,x			sta FSMant0,x
.9297	c8		iny				iny
.9298	b1 16		lda ($16),y			lda (tmp2),y
.929a	6a		ror a				ror a
.929b	95 61		sta $61,x			sta FSMant1,x
.929d	c8		iny				iny
.929e	b1 16		lda ($16),y			lda (tmp2),y
.92a0	6a		ror a				ror a
.92a1	95 6b		sta $6b,x			sta FSMant2,x
.92a3	a9 00		lda #$00			lda #0
.92a5	6a		ror a				ror a
.92a6	95 75		sta $75,x			sta FSMant3,x
.92a8	a6 14		ldx $14				ldx tmp1+0		; restore data stack index
.92aa	a0 00		ldy #$00			ldy #0			; get sign
.92ac	b1 16		lda ($16),y			lda (tmp2),y
.92ae	10 03		bpl $92b3			bpl +
.92b0	20 a5 8b	jsr $8ba5			jsr FNegate
.92b3					+
=61					CodeLen	.var *-XtPtr1
=$92b3					Here1 = *	; remember here
>9274	3d					.byte CodeLen	;patch wh_CodeLength
.92b3	60		rts				rts
>92b4	53 46 21			Name0:	.text "SF!"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=37431					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>92b7	23					.byte (("SF!"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=69					LinkDisplacement = Nt0-WordListLink
>92b8	10					.byte WordFlags	;wh_Flags
>92b9	03					.byte 3	;wh_CodeLength
>92ba	45					  .byte LinkDisplacement	; offset to previous nt
=$92bb					XtPtr1 ::= *
=37431					WordListLink ::= Nt0 ; remember the nt of this word for later
.92bb	20 de c3	jsr $c3de	SFStore:	jsr PopYA		; pop sf_addr
.92be	85 16		sta $16		SFStore_YA:	sta tmp2+0		; save
.92c0	84 17		sty $17				sty tmp2+1
.92c2	a4 4c		ldy $4c				ldy FIndex		; negative?
.92c4	b9 57 00	lda $0057,y			lda FSMant0,y
.92c7	29 80		and #$80			and #$80		;  save sign
.92c9	85 19		sta $19				sta tmp3+1
.92cb	10 03		bpl $92d0			bpl +
.92cd	20 a5 8b	jsr $8ba5			jsr FNegate
.92d0					+
.92d0	86 14		stx $14				stx tmp1+0		; save data stack index
.92d2	a6 4c		ldx $4c				ldx FIndex		; switch to FP stack index
.92d4	b5 4d		lda $4d,x			lda FSExp,x		; +128
.92d6	18		clc				clc
.92d7	69 7e		adc #$7e			adc #126
.92d9	95 4d		sta $4d,x			sta FSExp,x
.92db	16 75		asl $75,x			asl FSMant3,x
.92dd	b5 6b		lda $6b,x			lda FSMant2,x
.92df	2a		rol a				rol a
.92e0	a0 03		ldy #$03			ldy #3			; +3 IEEE
.92e2	91 16		sta ($16),y			sta (tmp2),y
.92e4	b5 61		lda $61,x			lda FSMant1,x
.92e6	2a		rol a				rol a
.92e7	88		dey				dey			; +2 IEEE
.92e8	91 16		sta ($16),y			sta (tmp2),y
.92ea	b5 57		lda $57,x			lda FSMant0,x
.92ec	2a		rol a				rol a
.92ed	2a		rol a				rol a
.92ee	56 4d		lsr $4d,x			lsr FSExp,x
.92f0	6a		ror a				ror a
.92f1	88		dey				dey			; +1 IEEE
.92f2	91 16		sta ($16),y			sta (tmp2),y
.92f4	b5 4d		lda $4d,x			lda FSExp,x
.92f6	05 19		ora $19				ora tmp3+1		;  insert sign
.92f8	88		dey				dey			; +0 IEEE
.92f9	91 16		sta ($16),y			sta (tmp2),y
.92fb	e6 4c		inc $4c				inc FIndex		; FDrop
.92fd	a6 14		ldx $14				ldx tmp1+0		; restore data stack index
=68					CodeLen	.var *-XtPtr1
=$92ff					Here1 = *	; remember here
>92b9	44					.byte CodeLen	;patch wh_CodeLength
.92ff	60		rts				rts
>9300	53 46 6c 6f 61 74 2b		Name0:	.text "SFloat+"	;  name of word as a string, ending at wh_NameLastChar
=7					NameLength = *-Name0
=37511					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9307	67					.byte (("SFloat+"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=80					LinkDisplacement = Nt0-WordListLink
>9308	10					.byte WordFlags	;wh_Flags
>9309	03					.byte 3	;wh_CodeLength
>930a	50					  .byte LinkDisplacement	; offset to previous nt
=$930b					XtPtr1 ::= *
=37511					WordListLink ::= Nt0 ; remember the nt of this word for later
.930b	a9 04		lda #$04	SFloatPlus:	lda #4
.930d	4c 43 da	jmp $da43			jmp Plus_A
=5					CodeLen	.var *-XtPtr1
=$9310					Here1 = *	; remember here
>9309	05					.byte CodeLen	;patch wh_CodeLength
>9310	53 46 6c 6f 61 74 73		Name0:	.text "SFloats"	;  name of word as a string, ending at wh_NameLastChar
=7					NameLength = *-Name0
=37527					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9317	67					.byte (("SFloats"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=16					LinkDisplacement = Nt0-WordListLink
>9318	10					.byte WordFlags	;wh_Flags
>9319	03					.byte 3	;wh_CodeLength
>931a	10					  .byte LinkDisplacement	; offset to previous nt
=$931b					XtPtr1 ::= *
=37527					WordListLink ::= Nt0 ; remember the nt of this word for later
.931b	a9 02		lda #$02	SFloats:	lda #2
.931d	4c 87 db	jmp $db87			jmp LShift_A
=5					CodeLen	.var *-XtPtr1
=$9320					Here1 = *	; remember here
>9319	05					.byte CodeLen	;patch wh_CodeLength
>9320	44 46 21			Name0:	.text "DF!"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=37539					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9323	23					.byte (("DF!"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=12					LinkDisplacement = Nt0-WordListLink
>9324	10					.byte WordFlags	;wh_Flags
>9325	03					.byte 3	;wh_CodeLength
>9326	0c					  .byte LinkDisplacement	; offset to previous nt
=$9327					XtPtr1 ::= *
=37539					WordListLink ::= Nt0 ; remember the nt of this word for later
.9327	20 de c3	jsr $c3de	DFStore:	jsr PopYA		; pop df_addr
.932a	85 16		sta $16		DFStore_YA:	sta tmp2+0		; save df_addr
.932c	84 17		sty $17				sty tmp2+1
.932e	a4 4c		ldy $4c				ldy FIndex		; negative?
.9330	b9 57 00	lda $0057,y			lda FSMant0,y
.9333	29 80		and #$80			and #$80		; remember sign
.9335	85 19		sta $19				sta tmp3+1
.9337	10 03		bpl $933c			bpl +			; make positive
.9339	20 a5 8b	jsr $8ba5			jsr FNegate
.933c					+
.933c	86 14		stx $14				stx tmp1+0		; save data stack index
.933e	a6 4c		ldx $4c				ldx FIndex
.9340	a9 00		lda #$00			lda #0
.9342	a0 07		ldy #$07			ldy #7			; +7 IEEE
.9344	91 16		sta ($16),y			sta (tmp2),y
.9346	88		dey				dey			; +6 IEEE
.9347	91 16		sta ($16),y			sta (tmp2),y
.9349	20 91 93	jsr $9391			jsr _shift		; shift mantissa
.934c	20 91 93	jsr $9391			jsr _shift
.934f	88		dey				dey			; +5 IEEE
.9350	91 16		sta ($16),y			sta (tmp2),y
.9352	b5 75		lda $75,x			lda FSMant3,x
.9354	88		dey				dey			; +4 IEEE
.9355	91 16		sta ($16),y			sta (tmp2),y
.9357	b5 6b		lda $6b,x			lda FSMant2,x
.9359	88		dey				dey			; +3 IEEE
.935a	91 16		sta ($16),y			sta (tmp2),y
.935c	b5 61		lda $61,x			lda FSMant1,x
.935e	88		dey				dey			; +2 IEEE
.935f	91 16		sta ($16),y			sta (tmp2),y
.9361	b5 57		lda $57,x			lda FSMant0,x		; clear extra bits
.9363	29 0f		and #$0f			and #$f
.9365	95 57		sta $57,x			sta FSMant0,x
.9367	b5 4d		lda $4d,x			lda FSExp,x
.9369	38		sec				sec
.936a	e9 02		sbc #$02			sbc #2
.936c	95 4d		sta $4d,x			sta FSExp,x
.936e	0a		asl a				asl a
.936f	0a		asl a				asl a
.9370	0a		asl a				asl a
.9371	0a		asl a				asl a
.9372	15 57		ora $57,x			ora FSMant0,x
.9374	88		dey				dey			; +1 IEEE
.9375	91 16		sta ($16),y			sta (tmp2),y
.9377	b5 4d		lda $4d,x			lda FSExp,x
.9379	08		php				php
.937a	4a		lsr a				lsr a
.937b	4a		lsr a				lsr a
.937c	4a		lsr a				lsr a
.937d	4a		lsr a				lsr a
.937e	18		clc				clc
.937f	69 30		adc #$30			adc #$30
.9381	28		plp				plp
.9382	30 03		bmi $9387			bmi +
.9384	18		clc				clc
.9385	69 10		adc #$10			adc #$10
.9387	05 19		ora $19		+		ora tmp3+1		; add sign bit
.9389	88		dey				dey			; +0 IEEE
.938a	91 16		sta ($16),y			sta (tmp2),y
.938c	e6 4c		inc $4c				inc FIndex		; FDrop
.938e	a6 14		ldx $14				ldx tmp1+0		; restore data stack index
.9390	60		rts				rts
.9391	56 57		lsr $57,x	_shift:		lsr FSMant0,x
.9393	76 61		ror $61,x			ror FSMant1,x
.9395	76 6b		ror $6b,x			ror FSMant2,x
.9397	76 75		ror $75,x			ror FSMant3,x
.9399	6a		ror a				ror a
=115					CodeLen	.var *-XtPtr1
=$939a					Here1 = *	; remember here
>9325	73					.byte CodeLen	;patch wh_CodeLength
.939a	60		rts				rts
>939b	44 46 40			Name0:	.text "DF@"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=37662					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>939e	03					.byte (("DF@"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=123					LinkDisplacement = Nt0-WordListLink
>939f	10					.byte WordFlags	;wh_Flags
>93a0	03					.byte 3	;wh_CodeLength
>93a1	7b					  .byte LinkDisplacement	; offset to previous nt
=$93a2					XtPtr1 ::= *
=37662					WordListLink ::= Nt0 ; remember the nt of this word for later
.93a2	20 de c3	jsr $c3de	DFAt:		jsr PopYA		; pop df_addr
.93a5	85 16		sta $16		DFAt_YA:	sta tmp2+0		; save df_addr
.93a7	84 17		sty $17				sty tmp2+1
.93a9	20 c8 84	jsr $84c8			jsr FAllocX		; alloc FP stack entry
.93ac	a0 00		ldy #$00			ldy #0			; +0 IEEE byte
.93ae	b1 16		lda ($16),y			lda (tmp2),y
.93b0	95 4d		sta $4d,x			sta FSExp,x
.93b2	c8		iny				iny			; +1 IEEE byte
.93b3	b1 16		lda ($16),y			lda (tmp2),y
.93b5	95 57		sta $57,x			sta FSMant0,x
.93b7	c8		iny				iny			; +2 IEEE byte
.93b8	b1 16		lda ($16),y			lda (tmp2),y
.93ba	95 61		sta $61,x			sta FSMant1,x
.93bc	c8		iny				iny			; +3 IEEE byte
.93bd	b1 16		lda ($16),y			lda (tmp2),y
.93bf	95 6b		sta $6b,x			sta FSMant2,x
.93c1	c8		iny				iny			; +4 IEEE byte
.93c2	b1 16		lda ($16),y			lda (tmp2),y
.93c4	95 75		sta $75,x			sta FSMant3,x
.93c6	c8		iny				iny			; +5 IEEE byte
.93c7	b1 16		lda ($16),y			lda (tmp2),y
.93c9	20 f2 93	jsr $93f2			jsr _shifta		; shift exponent & mantissa bits into place
.93cc	20 f2 93	jsr $93f2			jsr _shifta
.93cf	b5 57		lda $57,x			lda FSMant0,x		; finish shifting exponent bits
.93d1	0a		asl a				asl a
.93d2	36 4d		rol $4d,x			rol FSExp,x
.93d4	0a		asl a				asl a
.93d5	36 4d		rol $4d,x			rol FSExp,x
.93d7	b5 4d		lda $4d,x			lda FSExp,x		; remove +1023
.93d9	18		clc				clc
.93da	69 02		adc #$02			adc #2
.93dc	95 4d		sta $4d,x			sta FSExp,x
.93de	b5 57		lda $57,x			lda FSMant0,x
.93e0	29 7f		and #$7f			and #$7f
.93e2	09 40		ora #$40			ora #$40		;   insert implied 1
.93e4	95 57		sta $57,x			sta FSMant0,x		;   insert sign=0
.93e6	a6 14		ldx $14				ldx tmp1		; restore data stack index
.93e8	a0 00		ldy #$00			ldy #0			; get sign from +0 IEEE byte
.93ea	b1 16		lda ($16),y			lda (tmp2),y
.93ec	10 03		bpl $93f1			bpl +
.93ee	20 a5 8b	jsr $8ba5			jsr FNegate
.93f1					+
.93f1	60		rts				rts
.93f2	0a		asl a		_shifta:	asl a
.93f3	36 75		rol $75,x			rol FSMant3,x
.93f5	36 6b		rol $6b,x			rol FSMant2,x
.93f7	36 61		rol $61,x			rol FSMant1,x
.93f9	36 57		rol $57,x			rol FSMant0,x
.93fb	36 4d		rol $4d,x			rol FSExp,x
.93fd	60		rts				rts
=92					CodeLen	.var *-XtPtr1
=$93fe					Here1 = *	; remember here
>93a0	5c					.byte CodeLen	;patch wh_CodeLength
>93fe	44 46 6c 6f 61 74 2b		Name0:	.text "DFloat+"	;  name of word as a string, ending at wh_NameLastChar
=7					NameLength = *-Name0
=37765					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9405	67					.byte (("DFloat+"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=103					LinkDisplacement = Nt0-WordListLink
>9406	10					.byte WordFlags	;wh_Flags
>9407	03					.byte 3	;wh_CodeLength
>9408	67					  .byte LinkDisplacement	; offset to previous nt
=$9409					XtPtr1 ::= *
=37765					WordListLink ::= Nt0 ; remember the nt of this word for later
.9409	a9 08		lda #$08	DFloatPlus:	lda #8
.940b	4c 43 da	jmp $da43			jmp Plus_A
=5					CodeLen	.var *-XtPtr1
=$940e					Here1 = *	; remember here
>9407	05					.byte CodeLen	;patch wh_CodeLength
>940e	44 46 6c 6f 61 74 73		Name0:	.text "DFloats"	;  name of word as a string, ending at wh_NameLastChar
=7					NameLength = *-Name0
=37781					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9415	67					.byte (("DFloats"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=16					LinkDisplacement = Nt0-WordListLink
>9416	10					.byte WordFlags	;wh_Flags
>9417	03					.byte 3	;wh_CodeLength
>9418	10					  .byte LinkDisplacement	; offset to previous nt
=$9419					XtPtr1 ::= *
=37781					WordListLink ::= Nt0 ; remember the nt of this word for later
.9419	a9 03		lda #$03	DFloats:	lda #3
.941b	4c 87 db	jmp $db87			jmp LShift_A
=5					CodeLen	.var *-XtPtr1
=$941e					Here1 = *	; remember here
>9417	05					.byte CodeLen	;patch wh_CodeLength
>941e	46 4d 50 6f 6c 79		Name0:	.text "FMPoly"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=37796					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9424	26					.byte (("FMPoly"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=15					LinkDisplacement = Nt0-WordListLink
>9425	10					.byte WordFlags	;wh_Flags
>9426	03					.byte 3	;wh_CodeLength
>9427	0f					  .byte LinkDisplacement	; offset to previous nt
=$9428					XtPtr1 ::= *
=37796					WordListLink ::= Nt0 ; remember the nt of this word for later
.9428	20 de c3	jsr $c3de	FMPoly:		jsr PopYA
.942b	20 b5 c7	jsr $c7b5	FMPolyYA:	jsr PushYA		; push coefficent table addr
.942e	20 52 86	jsr $8652			jsr FAt_YA		; fetch 1st coefficent
.9431	4c 44 94	jmp $9444			jmp _4
.9434	20 76 85	jsr $8576	_2:		jsr FOver
.9437	20 fe 8b	jsr $8bfe			jsr FStar
.943a	b5 24		lda $24,x			lda DStack+0,x		; fetch next coefficent
.943c	b4 25		ldy $25,x			ldy DStack+1,x
.943e	20 52 86	jsr $8652			jsr FAt_YA
.9441	20 30 8b	jsr $8b30			jsr FPlus
.9444	a9 05		lda #$05	_4:		lda #Float_Size		; bump coefficent ptr
.9446	20 43 da	jsr $da43			jsr Plus_A
.9449	a1 24		lda ($24,x)			lda (DStack+0,x)	; end of coefficent list?
.944b	d0 e7		bne $9434			bne _2
.944d	e8		inx				inx			; Drop coefficent ptr
.944e	e8		inx				inx
=39					CodeLen	.var *-XtPtr1
=$944f					Here1 = *	; remember here
>9426	27					.byte CodeLen	;patch wh_CodeLength
.944f	60		rts				rts
>9450	46 4c 6f 67 32 4d 31 4d		Name0:	.text "FLog2M1M"	;  name of word as a string, ending at wh_NameLastChar
=8					NameLength = *-Name0
=37848					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9458	a8					.byte (("FLog2M1M"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=52					LinkDisplacement = Nt0-WordListLink
>9459	10					.byte WordFlags	;wh_Flags
>945a	03					.byte 3	;wh_CodeLength
>945b	34					  .byte LinkDisplacement	; offset to previous nt
=$945c					XtPtr1 ::= *
=37848					WordListLink ::= Nt0 ; remember the nt of this word for later
.945c	a9 66		lda #$66	FLog2M1M:	lda #<_c
.945e	a0 94		ldy #$94			ldy #>_c
.9460	20 2b 94	jsr $942b			jsr FMPolyYA
.9463	4c fe 8b	jmp $8bfe			jmp FStar
=10					CodeLen	.var *-XtPtr1
=$9466					Here1 = *	; remember here
>945a	0a					.byte CodeLen	;patch wh_CodeLength
.9466					_c:
>9466	cc cf 97 7c					.dword $7C97CFCC	; 32 bit signed binary mantissa.  $40000000 = +0.5
>946a	fa						.char -6		; 8 bit signed binary exponent.  $00 = 2**0
>946b	64 87 94 af					.dword $AF948764	; 32 bit signed binary mantissa.  $40000000 = +0.5
>946f	fd						.char -3		; 8 bit signed binary exponent.  $00 = 2**0
>9470	66 c8 d4 62					.dword $62D4C866	; 32 bit signed binary mantissa.  $40000000 = +0.5
>9474	fe						.char -2		; 8 bit signed binary exponent.  $00 = 2**0
>9475	e2 9c c3 ac					.dword $ACC39CE2	; 32 bit signed binary mantissa.  $40000000 = +0.5
>9479	ff						.char -1		; 8 bit signed binary exponent.  $00 = 2**0
>947a	1a c6 2b 79					.dword $792BC61A	; 32 bit signed binary mantissa.  $40000000 = +0.5
>947e	ff						.char -1		; 8 bit signed binary exponent.  $00 = 2**0
>947f	07 e1 c4 a3					.dword $A3C4E107	; 32 bit signed binary mantissa.  $40000000 = +0.5
>9483	00						.char 0		; 8 bit signed binary exponent.  $00 = 2**0
>9484	91 a5 54 5c					.dword $5C54A591	; 32 bit signed binary mantissa.  $40000000 = +0.5
>9488	01						.char 1		; 8 bit signed binary exponent.  $00 = 2**0
>9489	00						.byte 0
>948a	46 4c 6f 67 32			Name0:	.text "FLog2"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=37903					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>948f	45					.byte (("FLog2"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=55					LinkDisplacement = Nt0-WordListLink
>9490	10					.byte WordFlags	;wh_Flags
>9491	03					.byte 3	;wh_CodeLength
>9492	37					  .byte LinkDisplacement	; offset to previous nt
=$9493					XtPtr1 ::= *
=37903					WordListLink ::= Nt0 ; remember the nt of this word for later
.9493	a4 4c		ldy $4c		FLog2:		ldy FIndex
.9495	b9 57 00	lda $0057,y			lda FSMant0,y	; bad param?
.9498	30 20		bmi $94ba			bmi _OutOfRange
.949a	f0 1e		beq $94ba			beq _OutOfRange
.949c	b9 4d 00	lda $004d,y			lda FSExp,y
.949f	48		pha				pha		; remember orig exponent
.94a0	a9 01		lda #$01			lda #1
.94a2	99 4d 00	sta $004d,y			sta FSExp,y	; set to 1
.94a5	20 94 8b	jsr $8b94			jsr F1Minus
.94a8	20 5c 94	jsr $945c			jsr FLog2M1M
.94ab	a0 00		ldy #$00			ldy #0		; add orig exponent to float
.94ad	68		pla				pla
.94ae	38		sec				sec
.94af	e9 01		sbc #$01			sbc #1
.94b1	10 01		bpl $94b4			bpl +
.94b3	88		dey				dey
.94b4					+
.94b4	20 36 8e	jsr $8e36			jsr SToFYA
.94b7	4c 30 8b	jmp $8b30			jmp FPlus
.94ba	4c 3e c4	jmp $c43e	_OutOfRange:	jmp Throw_FpOutOfRange
=42					CodeLen	.var *-XtPtr1
=$94bd					Here1 = *	; remember here
>9491	2a					.byte CodeLen	;patch wh_CodeLength
>94bd	46 4c 6e			Name0:	.text "FLn"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=37952					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>94c0	c3					.byte (("FLn"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=49					LinkDisplacement = Nt0-WordListLink
>94c1	10					.byte WordFlags	;wh_Flags
>94c2	03					.byte 3	;wh_CodeLength
>94c3	31					  .byte LinkDisplacement	; offset to previous nt
=$94c4					XtPtr1 ::= *
=37952					WordListLink ::= Nt0 ; remember the nt of this word for later
.94c4	20 93 94	jsr $9493	FLn:		jsr FLog2
.94c7	20 48 88	jsr $8848			jsr FLitI
>94ca	f8 0b b9 58					.dword $58b90bf8	; 32 bit signed binary mantissa.  $40000000 = +0.5
>94ce	00						.char 0		; 8 bit signed binary exponent.  $00 = 2**0
.94cf	4c fe 8b	jmp $8bfe			jmp FStar
=14					CodeLen	.var *-XtPtr1
=$94d2					Here1 = *	; remember here
>94c2	0e					.byte CodeLen	;patch wh_CodeLength
>94d2	46 4c 6e 50 31			Name0:	.text "FLnP1"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=37975					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>94d7	25					.byte (("FLnP1"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=23					LinkDisplacement = Nt0-WordListLink
>94d8	10					.byte WordFlags	;wh_Flags
>94d9	03					.byte 3	;wh_CodeLength
>94da	17					  .byte LinkDisplacement	; offset to previous nt
=$94db					XtPtr1 ::= *
=37975					WordListLink ::= Nt0 ; remember the nt of this word for later
.94db	20 64 8b	jsr $8b64	FlnP1:		jsr F1Plus
.94de	4c c4 94	jmp $94c4			jmp FLn
=6					CodeLen	.var *-XtPtr1
=$94e1					Here1 = *	; remember here
>94d9	06					.byte CodeLen	;patch wh_CodeLength
>94e1	46 4c 6f 67			Name0:	.text "FLog"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=37989					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>94e5	e4					.byte (("FLog"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=14					LinkDisplacement = Nt0-WordListLink
>94e6	10					.byte WordFlags	;wh_Flags
>94e7	03					.byte 3	;wh_CodeLength
>94e8	0e					  .byte LinkDisplacement	; offset to previous nt
=$94e9					XtPtr1 ::= *
=37989					WordListLink ::= Nt0 ; remember the nt of this word for later
.94e9	20 93 94	jsr $9493	FLog:		jsr FLog2
.94ec	20 48 88	jsr $8848			jsr FLitI
>94ef	3c 4d 10 4d					.dword $4d104d3c	; 32 bit signed binary mantissa.  $40000000 = +0.5
>94f3	ff						.char -1		; 8 bit signed binary exponent.  $00 = 2**0
.94f4	4c fe 8b	jmp $8bfe			jmp FStar
=14					CodeLen	.var *-XtPtr1
=$94f7					Here1 = *	; remember here
>94e7	0e					.byte CodeLen	;patch wh_CodeLength
>94f7	46 45 78 70 32 4d 31 4d		Name0:	.text "FExp2M1M"	;  name of word as a string, ending at wh_NameLastChar
=8					NameLength = *-Name0
=38015					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>94ff	a8					.byte (("FExp2M1M"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=26					LinkDisplacement = Nt0-WordListLink
>9500	10					.byte WordFlags	;wh_Flags
>9501	03					.byte 3	;wh_CodeLength
>9502	1a					  .byte LinkDisplacement	; offset to previous nt
=$9503					XtPtr1 ::= *
=38015					WordListLink ::= Nt0 ; remember the nt of this word for later
.9503	a9 0d		lda #$0d	FExp2M1M:	lda #<_c
.9505	a0 95		ldy #$95			ldy #>_c
.9507	20 2b 94	jsr $942b			jsr FMPolyYA
.950a	4c fe 8b	jmp $8bfe			jmp FStar
=10					CodeLen	.var *-XtPtr1
=$950d					Here1 = *	; remember here
>9501	0a					.byte CodeLen	;patch wh_CodeLength
.950d					_c:
>950d	e7 dc 4f 7c					.dword $7C4FDCe7	; 32 bit signed binary mantissa.  $40000000 = +0.5
>9511	f7						.char -9		; 8 bit signed binary exponent.  $00 = 2**0
>9512	de ca 4c 49					.dword $494CCADe	; 32 bit signed binary mantissa.  $40000000 = +0.5
>9516	fa						.char -6		; 8 bit signed binary exponent.  $00 = 2**0
>9517	fb 42 64 72					.dword $726442fb	; 32 bit signed binary mantissa.  $40000000 = +0.5
>951b	fc						.char -4		; 8 bit signed binary exponent.  $00 = 2**0
>951c	50 90 f4 7a					.dword $7AF49050	; 32 bit signed binary mantissa.  $40000000 = +0.5
>9520	fe						.char -2		; 8 bit signed binary exponent.  $00 = 2**0
>9521	a2 3c b9 58					.dword $58B93Ca2	; 32 bit signed binary mantissa.  $40000000 = +0.5
>9525	00						.char 0		; 8 bit signed binary exponent.  $00 = 2**0
>9526	00						.byte 0
>9527	46 45 78 70 32			Name0:	.text "FExp2"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=38060					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>952c	45					.byte (("FExp2"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=45					LinkDisplacement = Nt0-WordListLink
>952d	10					.byte WordFlags	;wh_Flags
>952e	03					.byte 3	;wh_CodeLength
>952f	2d					  .byte LinkDisplacement	; offset to previous nt
=$9530					XtPtr1 ::= *
=38060					WordListLink ::= Nt0 ; remember the nt of this word for later
.9530	20 60 8a	jsr $8a60	FExp2:		jsr FIntFrc	; ( f: r_rem r_int )
.9533	20 7e 8e	jsr $8e7e			jsr FToS
.9536	20 03 95	jsr $9503			jsr FExp2M1M
.9539	20 64 8b	jsr $8b64			jsr F1Plus
.953c	20 c3 c3	jsr $c3c3			jsr PopA
.953f	a4 4c		ldy $4c				ldy FIndex
.9541	18		clc				clc
.9542	79 4d 00	adc $004d,y			adc FSExp,y
.9545	99 4d 00	sta $004d,y			sta FSExp,y
=24					CodeLen	.var *-XtPtr1
=$9548					Here1 = *	; remember here
>952e	18					.byte CodeLen	;patch wh_CodeLength
.9548	60		rts				rts
>9549	46 45 78 70			Name0:	.text "FExp"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=38093					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>954d	04					.byte (("FExp"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=33					LinkDisplacement = Nt0-WordListLink
>954e	10					.byte WordFlags	;wh_Flags
>954f	03					.byte 3	;wh_CodeLength
>9550	21					  .byte LinkDisplacement	; offset to previous nt
=$9551					XtPtr1 ::= *
=38093					WordListLink ::= Nt0 ; remember the nt of this word for later
.9551					FExp:
.9551	20 48 88	jsr $8848			jsr FLitI
>9554	94 1d 55 5c					.dword $5c551d94	; 32 bit signed binary mantissa.  $40000000 = +0.5
>9558	01						.char 1		; 8 bit signed binary exponent.  $00 = 2**0
.9559	20 fe 8b	jsr $8bfe			jsr FStar
.955c	4c 30 95	jmp $9530			jmp FExp2
=14					CodeLen	.var *-XtPtr1
=$955f					Here1 = *	; remember here
>954f	0e					.byte CodeLen	;patch wh_CodeLength
>955f	46 45 78 70 4d 31		Name0:	.text "FExpM1"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=38117					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9565	26					.byte (("FExpM1"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=24					LinkDisplacement = Nt0-WordListLink
>9566	10					.byte WordFlags	;wh_Flags
>9567	03					.byte 3	;wh_CodeLength
>9568	18					  .byte LinkDisplacement	; offset to previous nt
=$9569					XtPtr1 ::= *
=38117					WordListLink ::= Nt0 ; remember the nt of this word for later
.9569	20 51 95	jsr $9551	FExpM1:		jsr FExp
.956c	4c 94 8b	jmp $8b94			jmp F1Minus
=6					CodeLen	.var *-XtPtr1
=$956f					Here1 = *	; remember here
>9567	06					.byte CodeLen	;patch wh_CodeLength
>956f	46 41 4c 6f 67			Name0:	.text "FALog"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=38132					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9574	e5					.byte (("FALog"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=15					LinkDisplacement = Nt0-WordListLink
>9575	10					.byte WordFlags	;wh_Flags
>9576	03					.byte 3	;wh_CodeLength
>9577	0f					  .byte LinkDisplacement	; offset to previous nt
=$9578					XtPtr1 ::= *
=38132					WordListLink ::= Nt0 ; remember the nt of this word for later
.9578					FALog:
.9578	20 48 88	jsr $8848			jsr FLitI
>957b	25 3c 4d 6a					.dword $6a4d3c25	; 32 bit signed binary mantissa.  $40000000 = +0.5
>957f	02						.char 2		; 8 bit signed binary exponent.  $00 = 2**0
.9580	20 fe 8b	jsr $8bfe			jsr FStar
.9583	4c 30 95	jmp $9530			jmp FExp2
=14					CodeLen	.var *-XtPtr1
=$9586					Here1 = *	; remember here
>9576	0e					.byte CodeLen	;patch wh_CodeLength
>9586	46 2a 2a			Name0:	.text "F**"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=38153					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9589	43					.byte (("F**"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=21					LinkDisplacement = Nt0-WordListLink
>958a	10					.byte WordFlags	;wh_Flags
>958b	03					.byte 3	;wh_CodeLength
>958c	15					  .byte LinkDisplacement	; offset to previous nt
=$958d					XtPtr1 ::= *
=38153					WordListLink ::= Nt0 ; remember the nt of this word for later
.958d	20 d7 85	jsr $85d7	FPower:		jsr FSwap
.9590	20 93 94	jsr $9493			jsr FLog2
.9593	20 fe 8b	jsr $8bfe			jsr FStar
.9596	4c 30 95	jmp $9530			jmp FExp2
=12					CodeLen	.var *-XtPtr1
=$9599					Here1 = *	; remember here
>958b	0c					.byte CodeLen	;patch wh_CodeLength
>9599	44 65 67 32 52 61 64		Name0:	.text "Deg2Rad"	;  name of word as a string, ending at wh_NameLastChar
=7					NameLength = *-Name0
=38176					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>95a0	87					.byte (("Deg2Rad"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=23					LinkDisplacement = Nt0-WordListLink
>95a1	10					.byte WordFlags	;wh_Flags
>95a2	03					.byte 3	;wh_CodeLength
>95a3	17					  .byte LinkDisplacement	; offset to previous nt
=$95a4					XtPtr1 ::= *
=38176					WordListLink ::= Nt0 ; remember the nt of this word for later
.95a4					Deg2Rad:
.95a4	20 48 88	jsr $8848			jsr FLitI
>95a7	8a 1a 7d 47					.dword $477d1A8A	; 32 bit signed binary mantissa.  $40000000 = +0.5
>95ab	fb						.char -5		; 8 bit signed binary exponent.  $00 = 2**0
.95ac	4c fe 8b	jmp $8bfe			jmp FStar
=11					CodeLen	.var *-XtPtr1
=$95af					Here1 = *	; remember here
>95a2	0b					.byte CodeLen	;patch wh_CodeLength
>95af	52 61 64 32 44 65 67		Name0:	.text "Rad2Deg"	;  name of word as a string, ending at wh_NameLastChar
=7					NameLength = *-Name0
=38198					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>95b6	e7					.byte (("Rad2Deg"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=22					LinkDisplacement = Nt0-WordListLink
>95b7	10					.byte WordFlags	;wh_Flags
>95b8	03					.byte 3	;wh_CodeLength
>95b9	16					  .byte LinkDisplacement	; offset to previous nt
=$95ba					XtPtr1 ::= *
=38198					WordListLink ::= Nt0 ; remember the nt of this word for later
.95ba					Rad2Deg:
.95ba	20 48 88	jsr $8848			jsr FLitI
>95bd	68 70 97 72					.dword $72977068	; 32 bit signed binary mantissa.  $40000000 = +0.5
>95c1	06						.char 6		; 8 bit signed binary exponent.  $00 = 2**0
.95c2	4c fe 8b	jmp $8bfe			jmp FStar
=11					CodeLen	.var *-XtPtr1
=$95c5					Here1 = *	; remember here
>95b8	0b					.byte CodeLen	;patch wh_CodeLength
>95c5	46 41 52 65 64 75 63 65		Name0:	.text "FAReduce"	;  name of word as a string, ending at wh_NameLastChar
=8					NameLength = *-Name0
=38221					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>95cd	a8					.byte (("FAReduce"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=23					LinkDisplacement = Nt0-WordListLink
>95ce	10					.byte WordFlags	;wh_Flags
>95cf	03					.byte 3	;wh_CodeLength
>95d0	17					  .byte LinkDisplacement	; offset to previous nt
=$95d1					XtPtr1 ::= *
=38221					WordListLink ::= Nt0 ; remember the nt of this word for later
.95d1	a4 4c		ldy $4c		FAReduce:	ldy FIndex
.95d3	b9 57 00	lda $0057,y			lda FSMant0,y		; zero?
.95d6	f0 2f		beq $9607			beq _ok
.95d8	b9 4d 00	lda $004d,y			lda FSExp,y		; get exponent
.95db	30 2a		bmi $9607			bmi _ok			; small?
.95dd	c9 01		cmp #$01			cmp #1			; maybe need mirror?
.95df	30 26		bmi $9607			bmi _ok			;if exponent <=0
.95e1	f0 24		beq $9607			beq _ok
.95e3	c9 02		cmp #$02			cmp #2			; maybe need rotation?
.95e5	b0 22		bcs $9609			bcs _exp2
.95e7	b9 57 00	lda $0057,y			lda FSMant0,y
.95ea	c9 65		cmp #$65			cmp #$65		;in -pi/2..pi/2 ?
.95ec	90 19		bcc $9607			bcc _ok
.95ee	c9 9b		cmp #$9b			cmp #$100-$65
.95f0	b0 15		bcs $9607			bcs _ok
.95f2					_mir:
.95f2	20 fe 88	jsr $88fe			jsr FPi
.95f5	a4 4c		ldy $4c				ldy FIndex
.95f7	b9 58 00	lda $0058,y			lda FSMant0+1,y
.95fa	10 03		bpl $95ff			bpl _3
.95fc	20 a5 8b	jsr $8ba5			jsr FNegate
.95ff	20 d7 85	jsr $85d7	_3:		jsr FSwap
.9602	20 70 8b	jsr $8b70			jsr FMinus
.9605	38		sec				sec		; mirrored
.9606	60		rts				rts
.9607	18		clc		_ok:		clc		; not mirrored
.9608	60		rts				rts
.9609	d0 0b		bne $9616	_exp2:		bne _rot	;if exp>2 then fix
.960b	b9 57 00	lda $0057,y			lda FSMant0,y
.960e	c9 65		cmp #$65			cmp #$65	;if mant>pi or mant<-pi then fix
.9610	90 e0		bcc $95f2			bcc _mir
.9612	c9 9b		cmp #$9b			cmp #$100-$65
.9614	b0 dc		bcs $95f2			bcs _mir
.9616	20 2d 89	jsr $892d	_rot:		jsr F2Pi
.9619	20 9a 8c	jsr $8c9a			jsr FSlash
.961c	20 60 8a	jsr $8a60			jsr FIntFrc
.961f	e6 4c		inc $4c				inc FIndex	; FDrop integer part
.9621	a4 4c		ldy $4c				ldy FIndex	;if >=.5
.9623	b9 4d 00	lda $004d,y			lda FSExp,y
.9626	a8		tay				tay
.9627	30 03		bmi $962c			bmi _rot4
.9629	20 94 8b	jsr $8b94			jsr F1Minus	;  subtract 1
.962c	20 2d 89	jsr $892d	_rot4:		jsr F2Pi
.962f	20 fe 8b	jsr $8bfe			jsr FStar
.9632	4c d1 95	jmp $95d1			jmp FAReduce	; rotate done, look again
=100					CodeLen	.var *-XtPtr1
=$9635					Here1 = *	; remember here
>95cf	64					.byte CodeLen	;patch wh_CodeLength
>9635	46 53 69 6e			Name0:	.text "FSin"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=38329					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9639	c4					.byte (("FSin"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=108					LinkDisplacement = Nt0-WordListLink
>963a	10					.byte WordFlags	;wh_Flags
>963b	03					.byte 3	;wh_CodeLength
>963c	6c					  .byte LinkDisplacement	; offset to previous nt
=$963d					XtPtr1 ::= *
=38329					WordListLink ::= Nt0 ; remember the nt of this word for later
.963d	20 d1 95	jsr $95d1	FSin:		jsr FAReduce
.9640	20 53 85	jsr $8553	FSinM:		jsr FDup
.9643	20 8e 8c	jsr $8c8e			jsr FSqr	; x x^2
.9646	a9 56		lda #$56			lda #<_c
.9648	a0 96		ldy #$96			ldy #>_c
.964a	20 2b 94	jsr $942b			jsr FMPolyYA
.964d	20 fe 8b	jsr $8bfe			jsr FStar
.9650	20 64 8b	jsr $8b64			jsr F1Plus	; C0 +1.0
.9653	4c fe 8b	jmp $8bfe			jmp FStar
=25					CodeLen	.var *-XtPtr1
=$9656					Here1 = *	; remember here
>963b	19					.byte CodeLen	;patch wh_CodeLength
.9656					_c:
>9656	ba a7 21 57					.dword $5721a7ba	; 32 bit signed binary mantissa.  $40000000 = +0.5
>965a	ee						.char -18		; 8 bit signed binary exponent.  $00 = 2**0
>965b	3a 0b 2a 98					.dword $982a0b3a	; 32 bit signed binary mantissa.  $40000000 = +0.5
>965f	f4						.char -12		; 8 bit signed binary exponent.  $00 = 2**0
>9660	4c 8f 43 44					.dword $44438f4c	; 32 bit signed binary mantissa.  $40000000 = +0.5
>9664	fa						.char -6		; 8 bit signed binary exponent.  $00 = 2**0
>9665	2b ae aa aa					.dword $aaaaae2b	; 32 bit signed binary mantissa.  $40000000 = +0.5
>9669	fe						.char -2		; 8 bit signed binary exponent.  $00 = 2**0
>966a	00						.byte 0
>966b	46 43 73 63			Name0:	.text "FCsc"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=38383					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>966f	64					.byte (("FCsc"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=54					LinkDisplacement = Nt0-WordListLink
>9670	10					.byte WordFlags	;wh_Flags
>9671	03					.byte 3	;wh_CodeLength
>9672	36					  .byte LinkDisplacement	; offset to previous nt
=$9673					XtPtr1 ::= *
=38383					WordListLink ::= Nt0 ; remember the nt of this word for later
.9673	20 3d 96	jsr $963d	FCsc:		jsr FSin
.9676	4c 3e 8d	jmp $8d3e			jmp F1Slash		; 1/SIN(r1)
=6					CodeLen	.var *-XtPtr1
=$9679					Here1 = *	; remember here
>9671	06					.byte CodeLen	;patch wh_CodeLength
>9679	46 43 6f 73			Name0:	.text "FCos"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=38397					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>967d	64					.byte (("FCos"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=14					LinkDisplacement = Nt0-WordListLink
>967e	10					.byte WordFlags	;wh_Flags
>967f	03					.byte 3	;wh_CodeLength
>9680	0e					  .byte LinkDisplacement	; offset to previous nt
=$9681					XtPtr1 ::= *
=38397					WordListLink ::= Nt0 ; remember the nt of this word for later
.9681	20 0e 89	jsr $890e	FCos:		jsr FPiH
.9684	20 30 8b	jsr $8b30			jsr FPlus
.9687	4c 3d 96	jmp $963d			jmp FSin
=9					CodeLen	.var *-XtPtr1
=$968a					Here1 = *	; remember here
>967f	09					.byte CodeLen	;patch wh_CodeLength
>968a	46 53 65 63			Name0:	.text "FSec"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=38414					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>968e	64					.byte (("FSec"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=17					LinkDisplacement = Nt0-WordListLink
>968f	10					.byte WordFlags	;wh_Flags
>9690	03					.byte 3	;wh_CodeLength
>9691	11					  .byte LinkDisplacement	; offset to previous nt
=$9692					XtPtr1 ::= *
=38414					WordListLink ::= Nt0 ; remember the nt of this word for later
.9692	20 81 96	jsr $9681	FSec:		jsr FCos
.9695	4c 3e 8d	jmp $8d3e			jmp F1Slash		; 1/COS(r1)
=6					CodeLen	.var *-XtPtr1
=$9698					Here1 = *	; remember here
>9690	06					.byte CodeLen	;patch wh_CodeLength
>9698	46 53 69 6e 43 6f 73		Name0:	.text "FSinCos"	;  name of word as a string, ending at wh_NameLastChar
=7					NameLength = *-Name0
=38431					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>969f	67					.byte (("FSinCos"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=17					LinkDisplacement = Nt0-WordListLink
>96a0	10					.byte WordFlags	;wh_Flags
>96a1	03					.byte 3	;wh_CodeLength
>96a2	11					  .byte LinkDisplacement	; offset to previous nt
=$96a3					XtPtr1 ::= *
=38431					WordListLink ::= Nt0 ; remember the nt of this word for later
.96a3	20 53 85	jsr $8553	FSinCos:	jsr FDup
.96a6	20 3d 96	jsr $963d			jsr FSin
.96a9	20 d7 85	jsr $85d7			jsr FSwap
.96ac	4c 81 96	jmp $9681			jmp FCos
=12					CodeLen	.var *-XtPtr1
=$96af					Here1 = *	; remember here
>96a1	0c					.byte CodeLen	;patch wh_CodeLength
>96af	46 54 61 6e			Name0:	.text "FTan"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=38451					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>96b3	c4					.byte (("FTan"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=20					LinkDisplacement = Nt0-WordListLink
>96b4	10					.byte WordFlags	;wh_Flags
>96b5	03					.byte 3	;wh_CodeLength
>96b6	14					  .byte LinkDisplacement	; offset to previous nt
=$96b7					XtPtr1 ::= *
=38451					WordListLink ::= Nt0 ; remember the nt of this word for later
.96b7	20 d1 95	jsr $95d1	FTan:		jsr FAReduce
.96ba	90 06		bcc $96c2			bcc _30
.96bc	20 c2 96	jsr $96c2			jsr _30
.96bf	4c a5 8b	jmp $8ba5			jmp FNegate
.96c2					_30:
.96c2	20 53 85	jsr $8553			jsr FDup
.96c5	20 cb 8b	jsr $8bcb			jsr FAbs
.96c8	20 1e 89	jsr $891e			jsr FPiQ
.96cb	20 68 87	jsr $8768			jsr FLe
.96ce	e8		inx				inx			; pop f
.96cf	e8		inx				inx
.96d0	b5 24		lda $24,x			lda DStack+0,x
.96d2	d0 19		bne $96ed			bne FTanM
.96d4	20 0e 89	jsr $890e			jsr FPiH
.96d7	a4 4c		ldy $4c				ldy FIndex		; get sign
.96d9	b9 57 00	lda $0057,y			lda FSMant0,y
.96dc	10 03		bpl $96e1			bpl +
.96de	20 a5 8b	jsr $8ba5			jsr FNegate
.96e1					+
.96e1	20 d7 85	jsr $85d7			jsr FSwap
.96e4	20 70 8b	jsr $8b70			jsr FMinus
.96e7	20 ed 96	jsr $96ed			jsr FTanM
.96ea	4c 3e 8d	jmp $8d3e			jmp F1Slash
=54					CodeLen	.var *-XtPtr1
=$96ed					Here1 = *	; remember here
>96b5	36					.byte CodeLen	;patch wh_CodeLength
.96ed	20 53 85	jsr $8553	FTanM:		jsr FDup
.96f0	20 8e 8c	jsr $8c8e			jsr FSqr		; x x^2
.96f3	a9 03		lda #$03			lda #<_c
.96f5	a0 97		ldy #$97			ldy #>_c
.96f7	20 2b 94	jsr $942b			jsr FMPolyYA
.96fa	20 fe 8b	jsr $8bfe			jsr FStar
.96fd	20 64 8b	jsr $8b64			jsr F1Plus		; c0 1.0
.9700	4c fe 8b	jmp $8bfe			jmp FStar
.9703					_c:
>9703	1e ae 4d 58					.dword $584DAE1E	; 32 bit signed binary mantissa.  $40000000 = +0.5
>9707	fb						.char -5		; 8 bit signed binary exponent.  $00 = 2**0
>9708	51 0a eb 57					.dword $57EB0A51	; 32 bit signed binary mantissa.  $40000000 = +0.5
>970c	fa						.char -6		; 8 bit signed binary exponent.  $00 = 2**0
>970d	98 d9 14 77					.dword $7714D998	; 32 bit signed binary mantissa.  $40000000 = +0.5
>9711	fc						.char -4		; 8 bit signed binary exponent.  $00 = 2**0
>9712	f9 10 ea 43					.dword $43EA10F9	; 32 bit signed binary mantissa.  $40000000 = +0.5
>9716	fe						.char -2		; 8 bit signed binary exponent.  $00 = 2**0
>9717	1b e2 57 55					.dword $5557E21B	; 32 bit signed binary mantissa.  $40000000 = +0.5
>971b	ff						.char -1		; 8 bit signed binary exponent.  $00 = 2**0
>971c	00						.byte 0
>971d	46 43 6f 74			Name0:	.text "FCot"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=38561					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9721	84					.byte (("FCot"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=110					LinkDisplacement = Nt0-WordListLink
>9722	10					.byte WordFlags	;wh_Flags
>9723	03					.byte 3	;wh_CodeLength
>9724	6e					  .byte LinkDisplacement	; offset to previous nt
=$9725					XtPtr1 ::= *
=38561					WordListLink ::= Nt0 ; remember the nt of this word for later
.9725	20 b7 96	jsr $96b7	FCot:		jsr FTan
.9728	4c 3e 8d	jmp $8d3e			jmp F1Slash	; =1/TAN(r1)
=6					CodeLen	.var *-XtPtr1
=$972b					Here1 = *	; remember here
>9723	06					.byte CodeLen	;patch wh_CodeLength
>972b	46 41 43 6f 73			Name0:	.text "FACos"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=38576					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9730	65					.byte (("FACos"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=15					LinkDisplacement = Nt0-WordListLink
>9731	10					.byte WordFlags	;wh_Flags
>9732	03					.byte 3	;wh_CodeLength
>9733	0f					  .byte LinkDisplacement	; offset to previous nt
=$9734					XtPtr1 ::= *
=38576					WordListLink ::= Nt0 ; remember the nt of this word for later
.9734	a4 4c		ldy $4c		FACos:		ldy FIndex
.9736	b9 57 00	lda $0057,y			lda FSMant0,y
.9739	08		php				php			; save sign
.973a	20 cb 8b	jsr $8bcb			jsr FAbs
.973d	a9 60		lda #$60			lda #<_c
.973f	a0 97		ldy #$97			ldy #>_c
.9741	20 2b 94	jsr $942b			jsr FMPolyYA
.9744	20 d7 85	jsr $85d7			jsr FSwap
.9747	20 a5 8b	jsr $8ba5			jsr FNegate
.974a	20 64 8b	jsr $8b64			jsr F1Plus
.974d	20 24 8f	jsr $8f24			jsr FSqrt
.9750	20 fe 8b	jsr $8bfe			jsr FStar
.9753	28		plp				plp			; was r1 negative?
.9754	10 09		bpl $975f			bpl +
.9756	20 fe 88	jsr $88fe			jsr FPi
.9759	20 d7 85	jsr $85d7			jsr FSwap
.975c	20 70 8b	jsr $8b70			jsr FMinus
.975f					+
=43					CodeLen	.var *-XtPtr1
=$975f					Here1 = *	; remember here
>9732	2b					.byte CodeLen	;patch wh_CodeLength
.975f	60		rts				rts
.9760					_c:
>9760	8b 5e 9f 4b					.dword $4B9F5E8B	; 32 bit signed binary mantissa.  $40000000 = +0.5
>9764	f8						.char -8		; 8 bit signed binary exponent.  $00 = 2**0
>9765	ad cc 29 a4					.dword $A429CCAD	; 32 bit signed binary mantissa.  $40000000 = +0.5
>9769	fa						.char -6		; 8 bit signed binary exponent.  $00 = 2**0
>976a	98 a1 a3 6e					.dword $6EA3A198	; 32 bit signed binary mantissa.  $40000000 = +0.5
>976e	fb						.char -5		; 8 bit signed binary exponent.  $00 = 2**0
>976f	5a 10 e1 9b					.dword $9BE1105A	; 32 bit signed binary mantissa.  $40000000 = +0.5
>9773	fc						.char -4		; 8 bit signed binary exponent.  $00 = 2**0
>9774	c6 71 ea 5a					.dword $5AEA71C6	; 32 bit signed binary mantissa.  $40000000 = +0.5
>9778	fd						.char -3		; 8 bit signed binary exponent.  $00 = 2**0
>9779	e0 56 21 92					.dword $922156E0	; 32 bit signed binary mantissa.  $40000000 = +0.5
>977d	fe						.char -2		; 8 bit signed binary exponent.  $00 = 2**0
>977e	41 ed 87 64					.dword $6487ED41	; 32 bit signed binary mantissa.  $40000000 = +0.5
>9782	01						.char 1		; 8 bit signed binary exponent.  $00 = 2**0
>9783	00						.byte 0
>9784	46 41 53 65 63			Name0:	.text "FASec"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=38665					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9789	65					.byte (("FASec"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=89					LinkDisplacement = Nt0-WordListLink
>978a	10					.byte WordFlags	;wh_Flags
>978b	03					.byte 3	;wh_CodeLength
>978c	59					  .byte LinkDisplacement	; offset to previous nt
=$978d					XtPtr1 ::= *
=38665					WordListLink ::= Nt0 ; remember the nt of this word for later
.978d	20 3e 8d	jsr $8d3e	FASec:		jsr F1Slash
.9790	4c 34 97	jmp $9734			jmp FACos
=6					CodeLen	.var *-XtPtr1
=$9793					Here1 = *	; remember here
>978b	06					.byte CodeLen	;patch wh_CodeLength
>9793	46 41 53 69 6e			Name0:	.text "FASin"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=38680					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9798	c5					.byte (("FASin"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=15					LinkDisplacement = Nt0-WordListLink
>9799	10					.byte WordFlags	;wh_Flags
>979a	03					.byte 3	;wh_CodeLength
>979b	0f					  .byte LinkDisplacement	; offset to previous nt
=$979c					XtPtr1 ::= *
=38680					WordListLink ::= Nt0 ; remember the nt of this word for later
.979c	20 34 97	jsr $9734	FASin:		jsr FACos
.979f	20 a5 8b	jsr $8ba5			jsr FNegate
.97a2	20 0e 89	jsr $890e			jsr FPiH
.97a5	4c 30 8b	jmp $8b30			jmp FPlus
=12					CodeLen	.var *-XtPtr1
=$97a8					Here1 = *	; remember here
>979a	0c					.byte CodeLen	;patch wh_CodeLength
>97a8	46 41 43 73 63			Name0:	.text "FACsc"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=38701					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>97ad	65					.byte (("FACsc"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=21					LinkDisplacement = Nt0-WordListLink
>97ae	10					.byte WordFlags	;wh_Flags
>97af	03					.byte 3	;wh_CodeLength
>97b0	15					  .byte LinkDisplacement	; offset to previous nt
=$97b1					XtPtr1 ::= *
=38701					WordListLink ::= Nt0 ; remember the nt of this word for later
.97b1	20 3e 8d	jsr $8d3e	FACsc:		jsr F1Slash
.97b4	4c 9c 97	jmp $979c			jmp FASin
=6					CodeLen	.var *-XtPtr1
=$97b7					Here1 = *	; remember here
>97af	06					.byte CodeLen	;patch wh_CodeLength
>97b7	46 41 54 61 6e			Name0:	.text "FATan"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=38716					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>97bc	c5					.byte (("FATan"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=15					LinkDisplacement = Nt0-WordListLink
>97bd	10					.byte WordFlags	;wh_Flags
>97be	03					.byte 3	;wh_CodeLength
>97bf	0f					  .byte LinkDisplacement	; offset to previous nt
=$97c0					XtPtr1 ::= *
=38716					WordListLink ::= Nt0 ; remember the nt of this word for later
.97c0					FATan:
.97c0	a4 4c		ldy $4c				ldy FIndex
.97c2	b9 4d 00	lda $004d,y			lda FSExp,y		; Abs(r1)<1 ?
.97c5	30 1b		bmi $97e2			bmi FATanM
.97c7	f0 19		beq $97e2			beq FATanM
.97c9	b9 57 00	lda $0057,y			lda FSMant0,y		; save sign
.97cc	08		php				php
.97cd	20 3e 8d	jsr $8d3e			jsr F1Slash
.97d0	20 e2 97	jsr $97e2			jsr FATanM
.97d3	20 a5 8b	jsr $8ba5			jsr FNegate
.97d6	20 0e 89	jsr $890e			jsr FPiH
.97d9	28		plp				plp
.97da	10 03		bpl $97df			bpl _18
.97dc	20 a5 8b	jsr $8ba5			jsr FNegate
.97df	4c 30 8b	jmp $8b30	_18:		jmp FPlus
.97e2	20 53 85	jsr $8553	FATanM:		jsr FDup		; x x
.97e5	20 8e 8c	jsr $8c8e			jsr FSqr		; x xsqr
.97e8	a9 f8		lda #$f8			lda #<_c
.97ea	a0 97		ldy #$97			ldy #>_c
.97ec	20 2b 94	jsr $942b			jsr FMPolyYA
.97ef	20 fe 8b	jsr $8bfe			jsr FStar		; x poly
.97f2	20 64 8b	jsr $8b64			jsr F1Plus		; x poly
.97f5	4c fe 8b	jmp $8bfe			jmp FStar
.97f8					_c:
>97f8	98 08 2d 76					.dword $762D0898	; 32 bit signed binary mantissa.  $40000000 = +0.5
>97fc	f9						.char -7		; 8 bit signed binary exponent.  $00 = 2**0
>97fd	55 a1 32 b8					.dword $B832A155	; 32 bit signed binary mantissa.  $40000000 = +0.5
>9801	fc						.char -4		; 8 bit signed binary exponent.  $00 = 2**0
>9802	a8 d7 a2 53					.dword $53A2D7A8	; 32 bit signed binary mantissa.  $40000000 = +0.5
>9806	fd						.char -3		; 8 bit signed binary exponent.  $00 = 2**0
>9807	be 91 85 bb					.dword $BB8591BE	; 32 bit signed binary mantissa.  $40000000 = +0.5
>980b	fe						.char -2		; 8 bit signed binary exponent.  $00 = 2**0
>980c	06 65 aa 65					.dword $65AA6506	; 32 bit signed binary mantissa.  $40000000 = +0.5
>9810	fe						.char -2		; 8 bit signed binary exponent.  $00 = 2**0
>9811	12 21 b0 aa					.dword $AAB02112	; 32 bit signed binary mantissa.  $40000000 = +0.5
>9815	ff						.char -1		; 8 bit signed binary exponent.  $00 = 2**0
>9816	00						.byte 0
>9817	46 41 43 6f 74			Name0:	.text "FACot"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=38812					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>981c	85					.byte (("FACot"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=96					LinkDisplacement = Nt0-WordListLink
>981d	10					.byte WordFlags	;wh_Flags
>981e	03					.byte 3	;wh_CodeLength
>981f	60					  .byte LinkDisplacement	; offset to previous nt
=$9820					XtPtr1 ::= *
=38812					WordListLink ::= Nt0 ; remember the nt of this word for later
.9820	20 3e 8d	jsr $8d3e	FACot:		jsr F1Slash
.9823	4c c0 97	jmp $97c0			jmp FATan
=6					CodeLen	.var *-XtPtr1
=$9826					Here1 = *	; remember here
>981e	06					.byte CodeLen	;patch wh_CodeLength
>9826	46 41 54 61 6e 32		Name0:	.text "FATan2"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=38828					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>982c	46					.byte (("FATan2"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=16					LinkDisplacement = Nt0-WordListLink
>982d	10					.byte WordFlags	;wh_Flags
>982e	03					.byte 3	;wh_CodeLength
>982f	10					  .byte LinkDisplacement	; offset to previous nt
=$9830					XtPtr1 ::= *
=38828					WordListLink ::= Nt0 ; remember the nt of this word for later
.9830	a4 4c		ldy $4c		FATan2:		ldy FIndex
.9832	b9 57 00	lda $0057,y			lda FSMant0+0,y	; get rx sign
.9835	f0 1c		beq $9853			beq _rxzero
.9837	0a		asl a				asl a		;   C=rx sign
.9838	b9 58 00	lda $0058,y			lda FSMant0+1,y	;   N=ry sign
.983b	08		php				php		; save signs
.983c	20 9a 8c	jsr $8c9a			jsr FSlash
.983f	20 c0 97	jsr $97c0			jsr FATan
.9842	28		plp				plp		; pop signs
.9843	b0 01		bcs $9846			bcs _rxneg
.9845	60		rts		_rts:		rts
.9846	08		php		_rxneg:		php
.9847	20 fe 88	jsr $88fe			jsr FPi
.984a	28		plp				plp
.984b	10 03		bpl $9850			bpl +
.984d	20 a5 8b	jsr $8ba5			jsr FNegate
.9850	4c 30 8b	jmp $8b30	+		jmp FPlus
.9853	e6 4c		inc $4c		_rxzero:	inc FIndex	; FDrop rx
.9855	b9 57 00	lda $0057,y			lda FSMant0,y
.9858	08		php				php
.9859	e6 4c		inc $4c				inc FIndex	; FDrop ry
.985b	20 0e 89	jsr $890e			jsr FPiH
.985e	28		plp				plp
.985f	10 e4		bpl $9845			bpl _rts
.9861	4c a5 8b	jmp $8ba5			jmp FNegate
=52					CodeLen	.var *-XtPtr1
=$9864					Here1 = *	; remember here
>982e	34					.byte CodeLen	;patch wh_CodeLength
>9864	46 53 67 6e			Name0:	.text "FSgn"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=38888					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9868	c4					.byte (("FSgn"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=60					LinkDisplacement = Nt0-WordListLink
>9869	10					.byte WordFlags	;wh_Flags
>986a	03					.byte 3	;wh_CodeLength
>986b	3c					  .byte LinkDisplacement	; offset to previous nt
=$986c					XtPtr1 ::= *
=38888					WordListLink ::= Nt0 ; remember the nt of this word for later
.986c	a4 4c		ldy $4c		FSgn:		ldy FIndex
.986e	b9 57 00	lda $0057,y			lda FSMant0,y
.9871	f0 0a		beq $987d			beq _zero
.9873	e6 4c		inc $4c				inc FIndex
.9875	b9 57 00	lda $0057,y			lda FSMant0,y
.9878	30 04		bmi $987e			bmi FM1
.987a	4c e3 88	jmp $88e3			jmp F1
.987d	60		rts		_zero:		rts
=18					CodeLen	.var *-XtPtr1
=$987e					Here1 = *	; remember here
>986a	12					.byte CodeLen	;patch wh_CodeLength
.987e	a9 80		lda #$80	FM1:		lda #$80
.9880	a0 00		ldy #$00			ldy #0
.9882	4c 92 88	jmp $8892			jmp FLitYA
=25					CodeLen	.var *-XtPtr1
=$9885					Here1 = *	; remember here
>986a	19					.byte CodeLen	;patch wh_CodeLength
>9885	46 53 69 6e 48			Name0:	.text "FSinH"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=38922					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>988a	05					.byte (("FSinH"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=34					LinkDisplacement = Nt0-WordListLink
>988b	10					.byte WordFlags	;wh_Flags
>988c	03					.byte 3	;wh_CodeLength
>988d	22					  .byte LinkDisplacement	; offset to previous nt
=$988e					XtPtr1 ::= *
=38922					WordListLink ::= Nt0 ; remember the nt of this word for later
.988e	20 53 85	jsr $8553	FSinH:		jsr FDup
.9891	20 51 95	jsr $9551			jsr FExp
.9894	20 d7 85	jsr $85d7			jsr FSwap
.9897	20 a5 8b	jsr $8ba5			jsr FNegate
.989a	20 51 95	jsr $9551			jsr FExp
.989d	20 70 8b	jsr $8b70			jsr FMinus
.98a0	4c 97 89	jmp $8997			jmp F2Slash
=21					CodeLen	.var *-XtPtr1
=$98a3					Here1 = *	; remember here
>988c	15					.byte CodeLen	;patch wh_CodeLength
>98a3	46 43 73 63 48			Name0:	.text "FCscH"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=38952					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>98a8	05					.byte (("FCscH"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=30					LinkDisplacement = Nt0-WordListLink
>98a9	10					.byte WordFlags	;wh_Flags
>98aa	03					.byte 3	;wh_CodeLength
>98ab	1e					  .byte LinkDisplacement	; offset to previous nt
=$98ac					XtPtr1 ::= *
=38952					WordListLink ::= Nt0 ; remember the nt of this word for later
.98ac	20 8e 98	jsr $988e	FCscH:		jsr FSinH
.98af	4c 3e 8d	jmp $8d3e			jmp F1Slash
=6					CodeLen	.var *-XtPtr1
=$98b2					Here1 = *	; remember here
>98aa	06					.byte CodeLen	;patch wh_CodeLength
>98b2	46 43 6f 73 48			Name0:	.text "FCosH"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=38967					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>98b7	05					.byte (("FCosH"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=15					LinkDisplacement = Nt0-WordListLink
>98b8	10					.byte WordFlags	;wh_Flags
>98b9	03					.byte 3	;wh_CodeLength
>98ba	0f					  .byte LinkDisplacement	; offset to previous nt
=$98bb					XtPtr1 ::= *
=38967					WordListLink ::= Nt0 ; remember the nt of this word for later
.98bb	20 53 85	jsr $8553	FCosH:		jsr FDup
.98be	20 51 95	jsr $9551			jsr FExp
.98c1	20 d7 85	jsr $85d7			jsr FSwap
.98c4	20 a5 8b	jsr $8ba5			jsr FNegate
.98c7	20 51 95	jsr $9551			jsr FExp
.98ca	20 30 8b	jsr $8b30			jsr FPlus
.98cd	4c 97 89	jmp $8997			jmp F2Slash
=21					CodeLen	.var *-XtPtr1
=$98d0					Here1 = *	; remember here
>98b9	15					.byte CodeLen	;patch wh_CodeLength
>98d0	46 53 65 63 48			Name0:	.text "FSecH"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=38997					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>98d5	05					.byte (("FSecH"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=30					LinkDisplacement = Nt0-WordListLink
>98d6	10					.byte WordFlags	;wh_Flags
>98d7	03					.byte 3	;wh_CodeLength
>98d8	1e					  .byte LinkDisplacement	; offset to previous nt
=$98d9					XtPtr1 ::= *
=38997					WordListLink ::= Nt0 ; remember the nt of this word for later
.98d9	20 bb 98	jsr $98bb	FSecH:		jsr FCosH
.98dc	4c 3e 8d	jmp $8d3e			jmp F1Slash
=6					CodeLen	.var *-XtPtr1
=$98df					Here1 = *	; remember here
>98d7	06					.byte CodeLen	;patch wh_CodeLength
>98df	46 54 61 6e 48			Name0:	.text "FTanH"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=39012					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>98e4	05					.byte (("FTanH"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=15					LinkDisplacement = Nt0-WordListLink
>98e5	10					.byte WordFlags	;wh_Flags
>98e6	03					.byte 3	;wh_CodeLength
>98e7	0f					  .byte LinkDisplacement	; offset to previous nt
=$98e8					XtPtr1 ::= *
=39012					WordListLink ::= Nt0 ; remember the nt of this word for later
.98e8	20 53 85	jsr $8553	FTanH:		jsr FDup
.98eb	20 a5 8b	jsr $8ba5			jsr FNegate	; X -X
.98ee	20 51 95	jsr $9551			jsr FExp	; X Exp(-X)
.98f1	20 d7 85	jsr $85d7			jsr FSwap	; Exp(-X) X
.98f4	20 51 95	jsr $9551			jsr FExp	; Exp(-X) Exp(X)
.98f7	20 76 85	jsr $8576			jsr FOver	; Exp(-X) Exp(X) Exp(-X)
.98fa	20 30 8b	jsr $8b30			jsr FPlus	; Exp(-X) Exp(X)+Exp(-X)
.98fd	20 9a 8c	jsr $8c9a			jsr FSlash	; Exp(-X)/(Exp(X)+Exp(-X))
.9900	20 8c 89	jsr $898c			jsr F2Star	; Exp(-X)/(Exp(X)+Exp(-X))*2
.9903	20 a5 8b	jsr $8ba5			jsr FNegate
.9906	4c 64 8b	jmp $8b64			jmp F1Plus
=33					CodeLen	.var *-XtPtr1
=$9909					Here1 = *	; remember here
>98e6	21					.byte CodeLen	;patch wh_CodeLength
>9909	46 43 6f 74 48			Name0:	.text "FCotH"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=39054					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>990e	05					.byte (("FCotH"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=42					LinkDisplacement = Nt0-WordListLink
>990f	10					.byte WordFlags	;wh_Flags
>9910	03					.byte 3	;wh_CodeLength
>9911	2a					  .byte LinkDisplacement	; offset to previous nt
=$9912					XtPtr1 ::= *
=39054					WordListLink ::= Nt0 ; remember the nt of this word for later
.9912	20 e8 98	jsr $98e8	FCotH:		jsr FTanH
.9915	4c 3e 8d	jmp $8d3e			jmp F1Slash
=6					CodeLen	.var *-XtPtr1
=$9918					Here1 = *	; remember here
>9910	06					.byte CodeLen	;patch wh_CodeLength
>9918	46 41 53 69 6e 48		Name0:	.text "FASinH"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=39070					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>991e	06					.byte (("FASinH"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=16					LinkDisplacement = Nt0-WordListLink
>991f	10					.byte WordFlags	;wh_Flags
>9920	03					.byte 3	;wh_CodeLength
>9921	10					  .byte LinkDisplacement	; offset to previous nt
=$9922					XtPtr1 ::= *
=39070					WordListLink ::= Nt0 ; remember the nt of this word for later
.9922	20 53 85	jsr $8553	FASinH:		jsr FDup	; X X
.9925	20 8e 8c	jsr $8c8e			jsr FSqr	; X X*X
.9928	20 64 8b	jsr $8b64			jsr F1Plus	; X X*X+1
.992b	20 24 8f	jsr $8f24			jsr FSqrt	; X sqrt(X*X+1)
.992e	20 30 8b	jsr $8b30			jsr FPlus	;
.9931	4c c4 94	jmp $94c4			jmp FLn
=18					CodeLen	.var *-XtPtr1
=$9934					Here1 = *	; remember here
>9920	12					.byte CodeLen	;patch wh_CodeLength
>9934	46 41 43 73 63 48		Name0:	.text "FACscH"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=39098					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>993a	06					.byte (("FACscH"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=28					LinkDisplacement = Nt0-WordListLink
>993b	10					.byte WordFlags	;wh_Flags
>993c	03					.byte 3	;wh_CodeLength
>993d	1c					  .byte LinkDisplacement	; offset to previous nt
=$993e					XtPtr1 ::= *
=39098					WordListLink ::= Nt0 ; remember the nt of this word for later
.993e	20 3e 8d	jsr $8d3e	FACscH:		jsr F1Slash
.9941	4c 22 99	jmp $9922			jmp FASinH
=6					CodeLen	.var *-XtPtr1
=$9944					Here1 = *	; remember here
>993c	06					.byte CodeLen	;patch wh_CodeLength
>9944	46 41 43 6f 73 48		Name0:	.text "FACosH"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=39114					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>994a	06					.byte (("FACosH"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=16					LinkDisplacement = Nt0-WordListLink
>994b	10					.byte WordFlags	;wh_Flags
>994c	03					.byte 3	;wh_CodeLength
>994d	10					  .byte LinkDisplacement	; offset to previous nt
=$994e					XtPtr1 ::= *
=39114					WordListLink ::= Nt0 ; remember the nt of this word for later
.994e	20 53 85	jsr $8553	FACosH:		jsr FDup
.9951	20 8e 8c	jsr $8c8e			jsr FSqr
.9954	20 94 8b	jsr $8b94			jsr F1Minus
.9957	20 24 8f	jsr $8f24			jsr FSqrt
.995a	20 30 8b	jsr $8b30			jsr FPlus
.995d	4c c4 94	jmp $94c4			jmp FLn
=18					CodeLen	.var *-XtPtr1
=$9960					Here1 = *	; remember here
>994c	12					.byte CodeLen	;patch wh_CodeLength
>9960	46 41 53 65 63 48		Name0:	.text "FASecH"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=39142					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9966	06					.byte (("FASecH"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=28					LinkDisplacement = Nt0-WordListLink
>9967	10					.byte WordFlags	;wh_Flags
>9968	03					.byte 3	;wh_CodeLength
>9969	1c					  .byte LinkDisplacement	; offset to previous nt
=$996a					XtPtr1 ::= *
=39142					WordListLink ::= Nt0 ; remember the nt of this word for later
.996a	20 3e 8d	jsr $8d3e	FASecH:		jsr F1Slash
.996d	4c 4e 99	jmp $994e			jmp FACosH
=6					CodeLen	.var *-XtPtr1
=$9970					Here1 = *	; remember here
>9968	06					.byte CodeLen	;patch wh_CodeLength
>9970	46 41 54 61 6e 48		Name0:	.text "FATanH"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=39158					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9976	06					.byte (("FATanH"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=16					LinkDisplacement = Nt0-WordListLink
>9977	10					.byte WordFlags	;wh_Flags
>9978	03					.byte 3	;wh_CodeLength
>9979	10					  .byte LinkDisplacement	; offset to previous nt
=$997a					XtPtr1 ::= *
=39158					WordListLink ::= Nt0 ; remember the nt of this word for later
.997a	20 53 85	jsr $8553	FAtanH:		jsr FDup	; x x
.997d	20 64 8b	jsr $8b64			jsr F1Plus	; x x+1
.9980	20 d7 85	jsr $85d7			jsr FSwap	; 1+x x
.9983	20 e3 88	jsr $88e3			jsr F1
.9986	20 d7 85	jsr $85d7			jsr FSwap
.9989	20 70 8b	jsr $8b70			jsr FMinus	; 1+x 1-x
.998c	20 9a 8c	jsr $8c9a			jsr FSlash	; (1+x)/(1-x)
.998f	20 c4 94	jsr $94c4			jsr FLn
.9992	4c 97 89	jmp $8997			jmp F2Slash
=27					CodeLen	.var *-XtPtr1
=$9995					Here1 = *	; remember here
>9978	1b					.byte CodeLen	;patch wh_CodeLength
>9995	46 41 43 6f 74 48		Name0:	.text "FACotH"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=39195					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>999b	06					.byte (("FACotH"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=37					LinkDisplacement = Nt0-WordListLink
>999c	10					.byte WordFlags	;wh_Flags
>999d	03					.byte 3	;wh_CodeLength
>999e	25					  .byte LinkDisplacement	; offset to previous nt
=$999f					XtPtr1 ::= *
=39195					WordListLink ::= Nt0 ; remember the nt of this word for later
.999f	20 3e 8d	jsr $8d3e	FACotH: 	jsr F1Slash
.99a2	4c 7a 99	jmp $997a			jmp FATanH
=6					CodeLen	.var *-XtPtr1
=$99a5					Here1 = *	; remember here
>999d	06					.byte CodeLen	;patch wh_CodeLength
=3					EFloat_Size = 3	; # of in memory byte for an E Float
>99a5	45 46 6c 6f 61 74		Name0:	.text "EFloat"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=39211					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>99ab	86					.byte (("EFloat"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=16					LinkDisplacement = Nt0-WordListLink
>99ac	10					.byte WordFlags	;wh_Flags
>99ad	03					.byte 3	;wh_CodeLength
>99ae	10					  .byte LinkDisplacement	; offset to previous nt
=$99af					XtPtr1 ::= *
=39211					WordListLink ::= Nt0 ; remember the nt of this word for later
.99af	a9 03		lda #$03	EFloat:		lda #EFloat_Size
.99b1	4c e4 c7	jmp $c7e4			jmp PushZA
=5					CodeLen	.var *-XtPtr1
=$99b4					Here1 = *	; remember here
>99ad	05					.byte CodeLen	;patch wh_CodeLength
>99b4	45 46 6c 6f 61 74 2b		Name0:	.text "EFloat+"	;  name of word as a string, ending at wh_NameLastChar
=7					NameLength = *-Name0
=39227					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>99bb	67					.byte (("EFloat+"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=16					LinkDisplacement = Nt0-WordListLink
>99bc	10					.byte WordFlags	;wh_Flags
>99bd	03					.byte 3	;wh_CodeLength
>99be	10					  .byte LinkDisplacement	; offset to previous nt
=$99bf					XtPtr1 ::= *
=39227					WordListLink ::= Nt0 ; remember the nt of this word for later
.99bf	a9 03		lda #$03	EFloatPlus:	lda #EFloat_Size
.99c1	4c 43 da	jmp $da43			jmp Plus_A
=5					CodeLen	.var *-XtPtr1
=$99c4					Here1 = *	; remember here
>99bd	05					.byte CodeLen	;patch wh_CodeLength
>99c4	45 46 6c 6f 61 74 73		Name0:	.text "EFloats"	;  name of word as a string, ending at wh_NameLastChar
=7					NameLength = *-Name0
=39243					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>99cb	67					.byte (("EFloats"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=16					LinkDisplacement = Nt0-WordListLink
>99cc	10					.byte WordFlags	;wh_Flags
>99cd	03					.byte 3	;wh_CodeLength
>99ce	10					  .byte LinkDisplacement	; offset to previous nt
=$99cf					XtPtr1 ::= *
=39243					WordListLink ::= Nt0 ; remember the nt of this word for later
.99cf	20 af 99	jsr $99af	EFloats:	jsr EFloat
.99d2	4c 73 be	jmp $be73			jmp Star
=6					CodeLen	.var *-XtPtr1
=$99d5					Here1 = *	; remember here
>99cd	06					.byte CodeLen	;patch wh_CodeLength
>99d5	45 41 6c 69 67 6e		Name0:	.text "EAlign"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=39259					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>99db	c6					.byte (("EAlign"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=0					WordFlags ::= 0	; modifiable copy, remember for later
=16					LinkDisplacement = Nt0-WordListLink
>99dc	00					.byte WordFlags	;wh_Flags
>99dd	03					.byte 3	;wh_CodeLength
>99de	10					  .byte LinkDisplacement	; offset to previous nt
=$99df					XtPtr1 ::= *
=39259					WordListLink ::= Nt0 ; remember the nt of this word for later
.99df					EAlign:
=0					CodeLen	.var *-XtPtr1
=$99df					Here1 = *	; remember here
>99dd	00					.byte CodeLen	;patch wh_CodeLength
.99df	60		rts				rts
>99e0	45 41 6c 69 67 6e 65 64		Name0:	.text "EAligned"	;  name of word as a string, ending at wh_NameLastChar
=8					NameLength = *-Name0
=39272					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>99e8	88					.byte (("EAligned"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=0					WordFlags ::= 0	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>99e9	00					.byte WordFlags	;wh_Flags
>99ea	03					.byte 3	;wh_CodeLength
>99eb	0d					  .byte LinkDisplacement	; offset to previous nt
=$99ec					XtPtr1 ::= *
=39272					WordListLink ::= Nt0 ; remember the nt of this word for later
.99ec					EAligned:
=0					CodeLen	.var *-XtPtr1
=$99ec					Here1 = *	; remember here
>99ea	00					.byte CodeLen	;patch wh_CodeLength
.99ec	60		rts				rts
>99ed	48 65 78 3e 45			Name0:	.text "Hex>E"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=39282					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>99f2	a5					.byte (("Hex>E"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=10					LinkDisplacement = Nt0-WordListLink
>99f3	10					.byte WordFlags	;wh_Flags
>99f4	03					.byte 3	;wh_CodeLength
>99f5	0a					  .byte LinkDisplacement	; offset to previous nt
=$99f6					XtPtr1 ::= *
=39282					WordListLink ::= Nt0 ; remember the nt of this word for later
.99f6	20 c8 84	jsr $84c8	PartsToE:	jsr FAllocX		; alloc FP stack entry, X= FP stack index
.99f9	a6 14		ldx $14				ldx tmp1+0		; restore data stack index
.99fb	a4 4c		ldy $4c				ldy FIndex		; Y= FP stack index
.99fd	20 c3 c3	jsr $c3c3			jsr PopA		; pop n_exp
.9a00	99 4d 00	sta $004d,y			sta FSExp,y
.9a03	b5 25		lda $25,x			lda DStack+1,x
.9a05	99 57 00	sta $0057,y			sta FSMant0,y
.9a08	b5 24		lda $24,x			lda DStack+0,x
.9a0a	99 61 00	sta $0061,y			sta FSMant1,y
.9a0d	e8		inx				inx			; Drop
.9a0e	e8		inx				inx
=25					CodeLen	.var *-XtPtr1
=$9a0f					Here1 = *	; remember here
>99f4	19					.byte CodeLen	;patch wh_CodeLength
.9a0f	60		rts				rts
>9a10	45 3e 48 65 78			Name0:	.text "E>Hex"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=39317					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9a15	05					.byte (("E>Hex"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=35					LinkDisplacement = Nt0-WordListLink
>9a16	10					.byte WordFlags	;wh_Flags
>9a17	03					.byte 3	;wh_CodeLength
>9a18	23					  .byte LinkDisplacement	; offset to previous nt
=$9a19					XtPtr1 ::= *
=39317					WordListLink ::= Nt0 ; remember the nt of this word for later
.9a19	a4 4c		ldy $4c		EToParts:	ldy FIndex	; Y= FP stack index
.9a1b	ca		dex				dex		; alloc n_mantissa
.9a1c	ca		dex				dex
.9a1d	ca		dex				dex		; alloc n_exponent
.9a1e	ca		dex				dex
.9a1f	b9 57 00	lda $0057,y			lda FSMant0,y	; copy mantissa
.9a22	95 27		sta $27,x			sta DStack+3,x
.9a24	b9 61 00	lda $0061,y			lda FSMant1,y
.9a27	95 26		sta $26,x			sta DStack+2,x
.9a29	b9 4d 00	lda $004d,y			lda FSExp,y	; copy exponent
.9a2c	95 24		sta $24,x			sta DStack+0,x
.9a2e	29 80		and #$80			and #$80	;   sign extend
.9a30	f0 02		beq $9a34			beq +
.9a32	a9 ff		lda #$ff			lda #$ff
.9a34	95 25		sta $25,x	+		sta DStack+1,x
.9a36	e6 4c		inc $4c				inc FIndex	; FDrop r
=31					CodeLen	.var *-XtPtr1
=$9a38					Here1 = *	; remember here
>9a17	1f					.byte CodeLen	;patch wh_CodeLength
.9a38	60		rts				rts
>9a39	45 2e 48 65 78			Name0:	.text "E.Hex"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=39358					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9a3e	05					.byte (("E.Hex"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=41					LinkDisplacement = Nt0-WordListLink
>9a3f	10					.byte WordFlags	;wh_Flags
>9a40	03					.byte 3	;wh_CodeLength
>9a41	29					  .byte LinkDisplacement	; offset to previous nt
=$9a42					XtPtr1 ::= *
=39358					WordListLink ::= Nt0 ; remember the nt of this word for later
.9a42	20 19 9a	jsr $9a19	EDotHex:	jsr EToParts	; get parts of r
.9a45	20 ee df	jsr $dfee			jsr Swap
.9a48	20 ec b8	jsr $b8ec			jsr Dot_Hex	; do mantissa
.9a4b	a9 3a		lda #$3a			lda #':'
.9a4d	20 1c de	jsr $de1c			jsr Emit_A
.9a50	4c cb b8	jmp $b8cb			jmp C_Dot_Hex	; do exponent
=17					CodeLen	.var *-XtPtr1
=$9a53					Here1 = *	; remember here
>9a40	11					.byte CodeLen	;patch wh_CodeLength
>9a53	45 43 6d 70 41			Name0:	.text "ECmpA"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=39384					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9a58	25					.byte (("ECmpA"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=26					LinkDisplacement = Nt0-WordListLink
>9a59	10					.byte WordFlags	;wh_Flags
>9a5a	03					.byte 3	;wh_CodeLength
>9a5b	1a					  .byte LinkDisplacement	; offset to previous nt
=$9a5c					XtPtr1 ::= *
=39384					WordListLink ::= Nt0 ; remember the nt of this word for later
.9a5c	86 14		stx $14		ECmpA:		stx tmp1		; save data stack index
.9a5e	a6 4c		ldx $4c				ldx FIndex		; X= FP stack index
.9a60	b5 57		lda $57,x			lda FSMant0+0,x		; r2 mantissa == 0 ?
.9a62	f0 29		beq $9a8d			beq _r2Zero
.9a64	b4 58		ldy $58,x			ldy FSMant0+1,x		; r1 mantissa == 0 ?
.9a66	f0 1f		beq $9a87			beq _r1Zero
.9a68	55 58		eor $58,x			eor FSMant0+1,x		; compare mantissa sign
.9a6a	30 31		bmi $9a9d			bmi _MantissaSignDifferent
.9a6c	38		sec				sec			; compare exponent
.9a6d	b5 4e		lda $4e,x			lda FSExp+1,x
.9a6f	f5 4d		sbc $4d,x			sbc FSExp+0,x
.9a71	d0 1f		bne $9a92			bne _ExponentDifferent
.9a73	98		tya				tya			; compare mantissa MSB
.9a74	f5 57		sbc $57,x			sbc FSMant0+0,x		;   always same sign so can't overflow
.9a76	d0 0b		bne $9a83			bne _13
.9a78	b5 62		lda $62,x			lda FSMant1+1,x		; compare mantissa 1
.9a7a	f5 61		sbc $61,x			sbc FSMant1+0,x
.9a7c	f0 05		beq $9a83			beq _13
.9a7e	6a		ror a		_12:		ror a
.9a7f	49 80		eor #$80	_14:		eor #$80
.9a81	09 01		ora #$01			ora #1
.9a83	a6 14		ldx $14		_13:		ldx tmp1		; restore data stack index
.9a85	a8		tay				tay			; set CPU flags
.9a86	60		rts				rts
.9a87	b5 57		lda $57,x	_r1Zero:	lda FSMant0+0,x		; return 0-r2
.9a89	d0 f4		bne $9a7f			bne _14
.9a8b	f0 f6		beq $9a83			beq _13
.9a8d	b5 58		lda $58,x	_r2Zero:	lda FSMant0+1,x		; return r1
.9a8f	4c 83 9a	jmp $9a83			jmp _13
.9a92					_ExponentDifferent:
.9a92	50 02		bvc $9a96			bvc +
.9a94	49 80		eor #$80			eor #$80
.9a96					+
.9a96	55 57		eor $57,x			eor FSMant0+0,x
.9a98	a6 14		ldx $14				ldx tmp1		; restore data stack index
.9a9a	09 01		ora #$01			ora #1			; set CPU flags
.9a9c	60		rts				rts
.9a9d					_MantissaSignDifferent:
.9a9d	98		tya				tya
.9a9e	a6 14		ldx $14				ldx tmp1		; restore data stack index
.9aa0	09 01		ora #$01			ora #1
.9aa2	60		rts				rts
=71					CodeLen	.var *-XtPtr1
=$9aa3					Here1 = *	; remember here
>9a5a	47					.byte CodeLen	;patch wh_CodeLength
>9aa3	45 4d 61 78			Name0:	.text "EMax"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=39463					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9aa7	04					.byte (("EMax"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=79					LinkDisplacement = Nt0-WordListLink
>9aa8	10					.byte WordFlags	;wh_Flags
>9aa9	03					.byte 3	;wh_CodeLength
>9aaa	4f					  .byte LinkDisplacement	; offset to previous nt
=$9aab					XtPtr1 ::= *
=39463					WordListLink ::= Nt0 ; remember the nt of this word for later
.9aab	20 5c 9a	jsr $9a5c	EMax:		jsr ECmpA
.9aae	10 2c		bpl $9adc			bpl EDrop
.9ab0	30 44		bmi $9af6			bmi ENip
=7					CodeLen	.var *-XtPtr1
=$9ab2					Here1 = *	; remember here
>9aa9	07					.byte CodeLen	;patch wh_CodeLength
>9ab2	45 4d 69 6e			Name0:	.text "EMin"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=39478					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9ab6	c4					.byte (("EMin"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=15					LinkDisplacement = Nt0-WordListLink
>9ab7	10					.byte WordFlags	;wh_Flags
>9ab8	03					.byte 3	;wh_CodeLength
>9ab9	0f					  .byte LinkDisplacement	; offset to previous nt
=$9aba					XtPtr1 ::= *
=39478					WordListLink ::= Nt0 ; remember the nt of this word for later
.9aba	20 5c 9a	jsr $9a5c	EMin:		jsr ECmpA
.9abd	30 1d		bmi $9adc			bmi EDrop
.9abf	10 35		bpl $9af6			bpl ENip
=7					CodeLen	.var *-XtPtr1
=$9ac1					Here1 = *	; remember here
>9ab8	07					.byte CodeLen	;patch wh_CodeLength
>9ac1	45 44 65 70 74 68		Name0:	.text "EDepth"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=39495					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9ac7	06					.byte (("EDepth"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=17					LinkDisplacement = Nt0-WordListLink
>9ac8	10					.byte WordFlags	;wh_Flags
>9ac9	03					.byte 3	;wh_CodeLength
>9aca	11					  .byte LinkDisplacement	; offset to previous nt
=$9acb					XtPtr1 ::= *
=39495					WordListLink ::= Nt0 ; remember the nt of this word for later
.9acb	a9 0a		lda #$0a	EDepth:		lda #FDim
.9acd	38		sec				sec
.9ace	e5 4c		sbc $4c				sbc FIndex
.9ad0	4c e4 c7	jmp $c7e4			jmp PushZA
=8					CodeLen	.var *-XtPtr1
=$9ad3					Here1 = *	; remember here
>9ac9	08					.byte CodeLen	;patch wh_CodeLength
>9ad3	45 44 72 6f 70			Name0:	.text "EDrop"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=39512					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9ad8	05					.byte (("EDrop"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=0					WordFlags ::= 0	; modifiable copy, remember for later
=17					LinkDisplacement = Nt0-WordListLink
>9ad9	00					.byte WordFlags	;wh_Flags
>9ada	03					.byte 3	;wh_CodeLength
>9adb	11					  .byte LinkDisplacement	; offset to previous nt
=$9adc					XtPtr1 ::= *
=39512					WordListLink ::= Nt0 ; remember the nt of this word for later
.9adc	e6 4c		inc $4c		EDrop:		inc FIndex
=2					CodeLen	.var *-XtPtr1
=$9ade					Here1 = *	; remember here
>9ada	02					.byte CodeLen	;patch wh_CodeLength
.9ade	60		rts				rts
>9adf	45 32 44 72 6f 70		Name0:	.text "E2Drop"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=39525					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9ae5	06					.byte (("E2Drop"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=0					WordFlags ::= 0	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>9ae6	00					.byte WordFlags	;wh_Flags
>9ae7	03					.byte 3	;wh_CodeLength
>9ae8	0d					  .byte LinkDisplacement	; offset to previous nt
=$9ae9					XtPtr1 ::= *
=39525					WordListLink ::= Nt0 ; remember the nt of this word for later
.9ae9	e6 4c		inc $4c		E2Drop:		inc FIndex
.9aeb	e6 4c		inc $4c				inc FIndex
=4					CodeLen	.var *-XtPtr1
=$9aed					Here1 = *	; remember here
>9ae7	04					.byte CodeLen	;patch wh_CodeLength
.9aed	60		rts				rts
>9aee	45 4e 69 70			Name0:	.text "ENip"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=39538					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9af2	04					.byte (("ENip"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=0					WordFlags ::= 0	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>9af3	00					.byte WordFlags	;wh_Flags
>9af4	03					.byte 3	;wh_CodeLength
>9af5	0d					  .byte LinkDisplacement	; offset to previous nt
=$9af6					XtPtr1 ::= *
=39538					WordListLink ::= Nt0 ; remember the nt of this word for later
.9af6	86 14		stx $14		ENip:		stx tmp1		; save data stack index
.9af8	a6 4c		ldx $4c				ldx FIndex		; X= FP stack index
.9afa	b5 4d		lda $4d,x			lda FSExp+0,x		; copy exponent
.9afc	95 4e		sta $4e,x			sta FSExp+1,x
.9afe	b5 57		lda $57,x			lda FSMant0+0,x		; copy mantissa
.9b00	95 58		sta $58,x			sta FSMant0+1,x
.9b02	b5 61		lda $61,x			lda FSMant1+0,x
.9b04	95 62		sta $62,x			sta FSMant1+1,x
.9b06	e6 4c		inc $4c				inc FIndex		; EDrop
.9b08	a6 14		ldx $14				ldx tmp1		; restore data stack index
=20					CodeLen	.var *-XtPtr1
=$9b0a					Here1 = *	; remember here
>9af4	14					.byte CodeLen	;patch wh_CodeLength
.9b0a	60		rts				rts
>9b0b	45 44 75 70			Name0:	.text "EDup"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=39567					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9b0f	04					.byte (("EDup"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=0					WordFlags ::= 0	; modifiable copy, remember for later
=29					LinkDisplacement = Nt0-WordListLink
>9b10	00					.byte WordFlags	;wh_Flags
>9b11	03					.byte 3	;wh_CodeLength
>9b12	1d					  .byte LinkDisplacement	; offset to previous nt
=$9b13					XtPtr1 ::= *
=39567					WordListLink ::= Nt0 ; remember the nt of this word for later
.9b13	20 c8 84	jsr $84c8	EDup:		jsr FAllocX		; alloc FP stack entry, X=fp stack index
.9b16	b5 4e		lda $4e,x			lda FSExp+1,x		; copy exponent
.9b18	95 4d		sta $4d,x			sta FSExp+0,x
.9b1a	b5 58		lda $58,x			lda FSMant0+1,x		; copy mantissa
.9b1c	95 57		sta $57,x			sta FSMant0+0,x
.9b1e	b5 62		lda $62,x			lda FSMant1+1,x
.9b20	95 61		sta $61,x			sta FSMant1+0,x
.9b22	a6 14		ldx $14				ldx tmp1+0		; restore data stack index
=17					CodeLen	.var *-XtPtr1
=$9b24					Here1 = *	; remember here
>9b11	11					.byte CodeLen	;patch wh_CodeLength
.9b24	60		rts				rts
>9b25	45 4f 76 65 72			Name0:	.text "EOver"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=39594					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9b2a	45					.byte (("EOver"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=0					WordFlags ::= 0	; modifiable copy, remember for later
=27					LinkDisplacement = Nt0-WordListLink
>9b2b	00					.byte WordFlags	;wh_Flags
>9b2c	03					.byte 3	;wh_CodeLength
>9b2d	1b					  .byte LinkDisplacement	; offset to previous nt
=$9b2e					XtPtr1 ::= *
=39594					WordListLink ::= Nt0 ; remember the nt of this word for later
.9b2e	20 c8 84	jsr $84c8	EOver:		jsr FAllocX		; alloc FP stack entry, X=fp stack index
.9b31	b5 4f		lda $4f,x			lda FSExp+2,x		; copy exponent
.9b33	95 4d		sta $4d,x			sta FSExp+0,x
.9b35	b5 59		lda $59,x			lda FSMant0+2,x		; copy mantissa
.9b37	95 57		sta $57,x			sta FSMant0+0,x
.9b39	b5 63		lda $63,x			lda FSMant1+2,x
.9b3b	95 61		sta $61,x			sta FSMant1+0,x
.9b3d	a6 14		ldx $14				ldx tmp1+0		; restore data stack index
=17					CodeLen	.var *-XtPtr1
=$9b3f					Here1 = *	; remember here
>9b2c	11					.byte CodeLen	;patch wh_CodeLength
.9b3f	60		rts				rts
>9b40	45 50 69 63 6b			Name0:	.text "EPick"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=39621					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9b45	65					.byte (("EPick"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=0					WordFlags ::= 0	; modifiable copy, remember for later
=27					LinkDisplacement = Nt0-WordListLink
>9b46	00					.byte WordFlags	;wh_Flags
>9b47	03					.byte 3	;wh_CodeLength
>9b48	1b					  .byte LinkDisplacement	; offset to previous nt
=$9b49					XtPtr1 ::= *
=39621					WordListLink ::= Nt0 ; remember the nt of this word for later
.9b49	20 c3 c3	jsr $c3c3	EPick:		jsr PopA		; pop u (desired entry #)
.9b4c	18		clc		EPickA:		clc			; Y= fp stack index of [u]
.9b4d	65 4c		adc $4c				adc FIndex
.9b4f	a8		tay		EPick3:		tay
.9b50	20 c8 84	jsr $84c8			jsr FAllocX		; alloc FP stack entry, X=fp stack index
.9b53	b9 4d 00	lda $004d,y			lda FSExp,y		; copy exponent
.9b56	95 4d		sta $4d,x			sta FSExp,x
.9b58	b9 57 00	lda $0057,y			lda FSMant0,y		; copy mantissa
.9b5b	95 57		sta $57,x			sta FSMant0,x
.9b5d	b9 61 00	lda $0061,y			lda FSMant1,y
.9b60	95 61		sta $61,x			sta FSMant1,x
.9b62	a6 14		ldx $14				ldx tmp1+0		; restore data stack index
=27					CodeLen	.var *-XtPtr1
=$9b64					Here1 = *	; remember here
>9b47	1b					.byte CodeLen	;patch wh_CodeLength
.9b64	60		rts				rts
>9b65	45 32 44 75 70			Name0:	.text "E2Dup"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=39658					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9b6a	05					.byte (("E2Dup"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=37					LinkDisplacement = Nt0-WordListLink
>9b6b	10					.byte WordFlags	;wh_Flags
>9b6c	03					.byte 3	;wh_CodeLength
>9b6d	25					  .byte LinkDisplacement	; offset to previous nt
=$9b6e					XtPtr1 ::= *
=39658					WordListLink ::= Nt0 ; remember the nt of this word for later
.9b6e	20 2e 9b	jsr $9b2e	E2Dup:		jsr EOver
.9b71	4c 2e 9b	jmp $9b2e			jmp EOver
=6					CodeLen	.var *-XtPtr1
=$9b74					Here1 = *	; remember here
>9b6c	06					.byte CodeLen	;patch wh_CodeLength
>9b74	45 53 77 61 70			Name0:	.text "ESwap"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=39673					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9b79	05					.byte (("ESwap"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=0					WordFlags ::= 0	; modifiable copy, remember for later
=15					LinkDisplacement = Nt0-WordListLink
>9b7a	00					.byte WordFlags	;wh_Flags
>9b7b	03					.byte 3	;wh_CodeLength
>9b7c	0f					  .byte LinkDisplacement	; offset to previous nt
=$9b7d					XtPtr1 ::= *
=39673					WordListLink ::= Nt0 ; remember the nt of this word for later
.9b7d	86 14		stx $14		ESwap:		stx tmp1+0		; save data stack index
.9b7f	a6 4c		ldx $4c				ldx FIndex		; X=FP stack index
.9b81	b5 4d		lda $4d,x			lda FSExp+0,x		; do FSExp
.9b83	b4 4e		ldy $4e,x			ldy FSExp+1,x
.9b85	95 4e		sta $4e,x			sta FSExp+1,x
.9b87	94 4d		sty $4d,x			sty FSExp+0,x	; sty dir,x exists
.9b89	b5 57		lda $57,x			lda FSMant0+0,x		; do FSMant0
.9b8b	b4 58		ldy $58,x			ldy FSMant0+1,x
.9b8d	95 58		sta $58,x			sta FSMant0+1,x
.9b8f	94 57		sty $57,x			sty FSMant0+0,x	; sty dir,x exists
.9b91	b5 61		lda $61,x			lda FSMant1+0,x		; do FSMant1
.9b93	b4 62		ldy $62,x			ldy FSMant1+1,x
.9b95	95 62		sta $62,x			sta FSMant1+1,x
.9b97	94 61		sty $61,x			sty FSMant1+0,x	; sty dir,x exists
.9b99	a6 14		ldx $14				ldx tmp1+0		; restore data stack index
=30					CodeLen	.var *-XtPtr1
=$9b9b					Here1 = *	; remember here
>9b7b	1e					.byte CodeLen	;patch wh_CodeLength
.9b9b	60		rts				rts
>9b9c	45 54 75 63 6b			Name0:	.text "ETuck"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=39713					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9ba1	65					.byte (("ETuck"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=40					LinkDisplacement = Nt0-WordListLink
>9ba2	10					.byte WordFlags	;wh_Flags
>9ba3	03					.byte 3	;wh_CodeLength
>9ba4	28					  .byte LinkDisplacement	; offset to previous nt
=$9ba5					XtPtr1 ::= *
=39713					WordListLink ::= Nt0 ; remember the nt of this word for later
.9ba5	20 7d 9b	jsr $9b7d	ETuck:		jsr ESwap
.9ba8	4c 2e 9b	jmp $9b2e			jmp EOver
=6					CodeLen	.var *-XtPtr1
=$9bab					Here1 = *	; remember here
>9ba3	06					.byte CodeLen	;patch wh_CodeLength
>9bab	45 52 6f 74			Name0:	.text "ERot"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=39727					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9baf	84					.byte (("ERot"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=0					WordFlags ::= 0	; modifiable copy, remember for later
=14					LinkDisplacement = Nt0-WordListLink
>9bb0	00					.byte WordFlags	;wh_Flags
>9bb1	03					.byte 3	;wh_CodeLength
>9bb2	0e					  .byte LinkDisplacement	; offset to previous nt
=$9bb3					XtPtr1 ::= *
=39727					WordListLink ::= Nt0 ; remember the nt of this word for later
.9bb3	86 14		stx $14		ERot:		stx tmp1		; save data stack index
.9bb5	a5 4c		lda $4c				lda FIndex		; for FSMant3, FSMant2, FSMant1, FSMant0, FSExp
.9bb7	18		clc				clc
.9bb8	69 14		adc #$14			adc #2*FDim
.9bba	d0 03		bne $9bbf			bne _3
.9bbc	8a		txa		_2:		txa			;    next byte
.9bbd	e9 0a		sbc #$0a			sbc #FDim
.9bbf	aa		tax		_3:		tax
.9bc0	b4 4f		ldy $4f,x			ldy FSExp+2,x		;   do a byte
.9bc2	b5 4e		lda $4e,x			lda FSExp+1,x
.9bc4	95 4f		sta $4f,x			sta FSExp+2,x
.9bc6	b5 4d		lda $4d,x			lda FSExp+0,x
.9bc8	95 4e		sta $4e,x			sta FSExp+1,x
.9bca	94 4d		sty $4d,x			sty FSExp+0,x	; sty dir,x exists
.9bcc	e4 4c		cpx $4c				cpx FIndex		; done?
.9bce	d0 ec		bne $9bbc			bne _2
.9bd0	a6 14		ldx $14				ldx tmp1		; restore param stack index
=31					CodeLen	.var *-XtPtr1
=$9bd2					Here1 = *	; remember here
>9bb1	1f					.byte CodeLen	;patch wh_CodeLength
.9bd2	60		rts				rts
>9bd3	45 2d 52 6f 74			Name0:	.text "E-Rot"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=39768					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9bd8	85					.byte (("E-Rot"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=41					LinkDisplacement = Nt0-WordListLink
>9bd9	10					.byte WordFlags	;wh_Flags
>9bda	03					.byte 3	;wh_CodeLength
>9bdb	29					  .byte LinkDisplacement	; offset to previous nt
=$9bdc					XtPtr1 ::= *
=39768					WordListLink ::= Nt0 ; remember the nt of this word for later
.9bdc	20 b3 9b	jsr $9bb3	EMRot:		jsr ERot
.9bdf	4c b3 9b	jmp $9bb3			jmp ERot
=6					CodeLen	.var *-XtPtr1
=$9be2					Here1 = *	; remember here
>9bda	06					.byte CodeLen	;patch wh_CodeLength
>9be2	45 40				Name0:	.text "E@"	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=39780					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9be4	02					.byte (("E@"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=0					WordFlags ::= 0	; modifiable copy, remember for later
=12					LinkDisplacement = Nt0-WordListLink
>9be5	00					.byte WordFlags	;wh_Flags
>9be6	03					.byte 3	;wh_CodeLength
>9be7	0c					  .byte LinkDisplacement	; offset to previous nt
=$9be8					XtPtr1 ::= *
=39780					WordListLink ::= Nt0 ; remember the nt of this word for later
.9be8	20 de c3	jsr $c3de	EAt:		jsr PopYA		; pop addr
.9beb	85 16		sta $16		EAt_YA:		sta tmp2+0		; save addr
.9bed	84 17		sty $17				sty tmp2+1
.9bef	a0 00		ldy #$00			ldy #0			; starting offset from tmp2
.9bf1	20 c8 84	jsr $84c8	EAt_Tmp2Y:	jsr FAllocX		; alloc FP stack entry, X= fp stack index
.9bf4	b1 16		lda ($16),y			lda (tmp2),y		; copy mantissa
.9bf6	95 61		sta $61,x			sta FSMant1,x
.9bf8	c8		iny				iny
.9bf9	b1 16		lda ($16),y			lda (tmp2),y
.9bfb	95 57		sta $57,x			sta FSMant0,x
.9bfd	c8		iny				iny			; copy exponent
.9bfe	b1 16		lda ($16),y			lda (tmp2),y
.9c00	95 4d		sta $4d,x			sta FSExp,x
.9c02	a6 14		ldx $14				ldx tmp1		; restore data stack index
=28					CodeLen	.var *-XtPtr1
=$9c04					Here1 = *	; remember here
>9be6	1c					.byte CodeLen	;patch wh_CodeLength
.9c04	60		rts				rts
>9c05	45 21				Name0:	.text "E!"	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=39815					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9c07	22					.byte (("E!"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=0					WordFlags ::= 0	; modifiable copy, remember for later
=35					LinkDisplacement = Nt0-WordListLink
>9c08	00					.byte WordFlags	;wh_Flags
>9c09	03					.byte 3	;wh_CodeLength
>9c0a	23					  .byte LinkDisplacement	; offset to previous nt
=$9c0b					XtPtr1 ::= *
=39815					WordListLink ::= Nt0 ; remember the nt of this word for later
.9c0b	20 de c3	jsr $c3de	EStore:		jsr PopYA		; pop addr
.9c0e	85 14		sta $14		EStore_YA:	sta tmp1+0		; save addr
.9c10	84 15		sty $15				sty tmp1+1
.9c12	a0 00		ldy #$00			ldy #0
.9c14	86 16		stx $16				stx tmp2		; save data stack index
.9c16	a6 4c		ldx $4c				ldx FIndex		; X= FP stack index
.9c18	b5 61		lda $61,x			lda FSMant1,x		; copy mantissa
.9c1a	91 14		sta ($14),y			sta (tmp1),y
.9c1c	b5 57		lda $57,x			lda FSMant0,x
.9c1e	c8		iny				iny
.9c1f	91 14		sta ($14),y			sta (tmp1),y
.9c21	b5 4d		lda $4d,x			lda FSExp,x		; copy exponent
.9c23	c8		iny				iny
.9c24	91 14		sta ($14),y			sta (tmp1),y
.9c26	e6 4c		inc $4c				inc FIndex		; FDrop
.9c28	a6 16		ldx $16				ldx tmp2		; restore data stack index
=31					CodeLen	.var *-XtPtr1
=$9c2a					Here1 = *	; remember here
>9c09	1f					.byte CodeLen	;patch wh_CodeLength
.9c2a	60		rts				rts
>9c2b	45 2c				Name0:	.text "E,"	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=39853					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9c2d	82					.byte (("E,"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=38					LinkDisplacement = Nt0-WordListLink
>9c2e	10					.byte WordFlags	;wh_Flags
>9c2f	03					.byte 3	;wh_CodeLength
>9c30	26					  .byte LinkDisplacement	; offset to previous nt
=$9c31					XtPtr1 ::= *
=39853					WordListLink ::= Nt0 ; remember the nt of this word for later
.9c31	a5 00		lda $00		EComma:		lda cp+0		; store f at Here
.9c33	a4 01		ldy $01				ldy cp+1
.9c35	20 0e 9c	jsr $9c0e			jsr EStore_YA
.9c38	a9 03		lda #$03			lda #EFloat_Size
.9c3a	4c b2 d0	jmp $d0b2			jmp Allot_ZA
=12					CodeLen	.var *-XtPtr1
=$9c3d					Here1 = *	; remember here
>9c2f	0c					.byte CodeLen	;patch wh_CodeLength
>9c3d	45 30 21			Name0:	.text "E0!"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=39872					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9c40	23					.byte (("E0!"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=19					LinkDisplacement = Nt0-WordListLink
>9c41	10					.byte WordFlags	;wh_Flags
>9c42	03					.byte 3	;wh_CodeLength
>9c43	13					  .byte LinkDisplacement	; offset to previous nt
=$9c44					XtPtr1 ::= *
=39872					WordListLink ::= Nt0 ; remember the nt of this word for later
.9c44	20 27 9e	jsr $9e27	EZStore:	jsr E0
.9c47	4c 0b 9c	jmp $9c0b			jmp EStore
=6					CodeLen	.var *-XtPtr1
=$9c4a					Here1 = *	; remember here
>9c42	06					.byte CodeLen	;patch wh_CodeLength
>9c4a	45 30 3d			Name0:	.text "E0="	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=39885					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9c4d	a3					.byte (("E0="[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>9c4e	10					.byte WordFlags	;wh_Flags
>9c4f	03					.byte 3	;wh_CodeLength
>9c50	0d					  .byte LinkDisplacement	; offset to previous nt
=$9c51					XtPtr1 ::= *
=39885					WordListLink ::= Nt0 ; remember the nt of this word for later
.9c51	a4 4c		ldy $4c		EZEq:		ldy FIndex
.9c53	b9 57 00	lda $0057,y			lda FSMant0,y
.9c56	d0 24		bne $9c7c			bne EFalse1
.9c58					ETrue1:
.9c58	e6 4c		inc $4c				inc FIndex	; EDrop
.9c5a	4c c4 c7	jmp $c7c4			jmp True	; return true
=12					CodeLen	.var *-XtPtr1
=$9c5d					Here1 = *	; remember here
>9c4f	0c					.byte CodeLen	;patch wh_CodeLength
>9c5d	45 30 3c 3e			Name0:	.text "E0<>"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=39905					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9c61	c4					.byte (("E0<>"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=20					LinkDisplacement = Nt0-WordListLink
>9c62	10					.byte WordFlags	;wh_Flags
>9c63	03					.byte 3	;wh_CodeLength
>9c64	14					  .byte LinkDisplacement	; offset to previous nt
=$9c65					XtPtr1 ::= *
=39905					WordListLink ::= Nt0 ; remember the nt of this word for later
.9c65	a4 4c		ldy $4c		EZNe:		ldy FIndex
.9c67	b9 57 00	lda $0057,y			lda FSMant0,y
.9c6a	d0 ec		bne $9c58			bne ETrue1
.9c6c	f0 0e		beq $9c7c			beq EFalse1
=9					CodeLen	.var *-XtPtr1
=$9c6e					Here1 = *	; remember here
>9c63	09					.byte CodeLen	;patch wh_CodeLength
>9c6e	45 30 3c			Name0:	.text "E0<"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=39921					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9c71	83					.byte (("E0<"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=16					LinkDisplacement = Nt0-WordListLink
>9c72	10					.byte WordFlags	;wh_Flags
>9c73	03					.byte 3	;wh_CodeLength
>9c74	10					  .byte LinkDisplacement	; offset to previous nt
=$9c75					XtPtr1 ::= *
=39921					WordListLink ::= Nt0 ; remember the nt of this word for later
.9c75	a4 4c		ldy $4c		EZLt:		ldy FIndex
.9c77	b9 57 00	lda $0057,y			lda FSMant0,y
.9c7a	30 dc		bmi $9c58			bmi ETrue1
.9c7c					EFalse1:
.9c7c	e6 4c		inc $4c				inc FIndex	; EDrop
.9c7e	4c d6 c7	jmp $c7d6			jmp False	; return false
=12					CodeLen	.var *-XtPtr1
=$9c81					Here1 = *	; remember here
>9c73	0c					.byte CodeLen	;patch wh_CodeLength
>9c81	45 30 3e 3d			Name0:	.text "E0>="	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=39941					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9c85	a4					.byte (("E0>="[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=20					LinkDisplacement = Nt0-WordListLink
>9c86	10					.byte WordFlags	;wh_Flags
>9c87	03					.byte 3	;wh_CodeLength
>9c88	14					  .byte LinkDisplacement	; offset to previous nt
=$9c89					XtPtr1 ::= *
=39941					WordListLink ::= Nt0 ; remember the nt of this word for later
.9c89	a4 4c		ldy $4c		EZGe:		ldy FIndex
.9c8b	b9 57 00	lda $0057,y			lda FSMant0,y
.9c8e	10 c8		bpl $9c58			bpl ETrue1
.9c90	30 ea		bmi $9c7c			bmi EFalse1
=9					CodeLen	.var *-XtPtr1
=$9c92					Here1 = *	; remember here
>9c87	09					.byte CodeLen	;patch wh_CodeLength
>9c92	45 30 3e			Name0:	.text "E0>"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=39957					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9c95	c3					.byte (("E0>"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=16					LinkDisplacement = Nt0-WordListLink
>9c96	10					.byte WordFlags	;wh_Flags
>9c97	03					.byte 3	;wh_CodeLength
>9c98	10					  .byte LinkDisplacement	; offset to previous nt
=$9c99					XtPtr1 ::= *
=39957					WordListLink ::= Nt0 ; remember the nt of this word for later
.9c99	a4 4c		ldy $4c		EZGt:		ldy FIndex
.9c9b	b9 57 00	lda $0057,y			lda FSMant0,y
.9c9e	30 dc		bmi $9c7c			bmi EFalse1
.9ca0	d0 b6		bne $9c58			bne ETrue1
.9ca2	f0 d8		beq $9c7c			beq EFalse1
=11					CodeLen	.var *-XtPtr1
=$9ca4					Here1 = *	; remember here
>9c97	0b					.byte CodeLen	;patch wh_CodeLength
>9ca4	45 30 3c 3d			Name0:	.text "E0<="	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=39976					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9ca8	a4					.byte (("E0<="[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=19					LinkDisplacement = Nt0-WordListLink
>9ca9	10					.byte WordFlags	;wh_Flags
>9caa	03					.byte 3	;wh_CodeLength
>9cab	13					  .byte LinkDisplacement	; offset to previous nt
=$9cac					XtPtr1 ::= *
=39976					WordListLink ::= Nt0 ; remember the nt of this word for later
.9cac	a4 4c		ldy $4c		EZLe:		ldy FIndex
.9cae	b9 57 00	lda $0057,y			lda FSMant0,y
.9cb1	30 a5		bmi $9c58			bmi ETrue1
.9cb3	d0 c7		bne $9c7c			bne EFalse1
.9cb5	f0 a1		beq $9c58			beq ETrue1
=11					CodeLen	.var *-XtPtr1
=$9cb7					Here1 = *	; remember here
>9caa	0b					.byte CodeLen	;patch wh_CodeLength
>9cb7	45 3c				Name0:	.text "E<"	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=39993					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9cb9	82					.byte (("E<"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=17					LinkDisplacement = Nt0-WordListLink
>9cba	10					.byte WordFlags	;wh_Flags
>9cbb	03					.byte 3	;wh_CodeLength
>9cbc	11					  .byte LinkDisplacement	; offset to previous nt
=$9cbd					XtPtr1 ::= *
=39993					WordListLink ::= Nt0 ; remember the nt of this word for later
.9cbd	20 5c 9a	jsr $9a5c	ELt:		jsr ECmpA
.9cc0	30 32		bmi $9cf4			bmi ETrue2
.9cc2					EFalse2:
.9cc2	e6 4c		inc $4c				inc FIndex	; EDrop
.9cc4	e6 4c		inc $4c				inc FIndex	; EDrop
.9cc6	4c d6 c7	jmp $c7d6			jmp False	; return False
=12					CodeLen	.var *-XtPtr1
=$9cc9					Here1 = *	; remember here
>9cbb	0c					.byte CodeLen	;patch wh_CodeLength
>9cc9	45 3e 3d			Name0:	.text "E>="	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=40012					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9ccc	a3					.byte (("E>="[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=19					LinkDisplacement = Nt0-WordListLink
>9ccd	10					.byte WordFlags	;wh_Flags
>9cce	03					.byte 3	;wh_CodeLength
>9ccf	13					  .byte LinkDisplacement	; offset to previous nt
=$9cd0					XtPtr1 ::= *
=40012					WordListLink ::= Nt0 ; remember the nt of this word for later
.9cd0	20 5c 9a	jsr $9a5c	EGe:		jsr ECmpA
.9cd3	10 1f		bpl $9cf4			bpl ETrue2
.9cd5	30 eb		bmi $9cc2			bmi EFalse2
=7					CodeLen	.var *-XtPtr1
=$9cd7					Here1 = *	; remember here
>9cce	07					.byte CodeLen	;patch wh_CodeLength
>9cd7	45 3e				Name0:	.text "E>"	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=40025					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9cd9	c2					.byte (("E>"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>9cda	10					.byte WordFlags	;wh_Flags
>9cdb	03					.byte 3	;wh_CodeLength
>9cdc	0d					  .byte LinkDisplacement	; offset to previous nt
=$9cdd					XtPtr1 ::= *
=40025					WordListLink ::= Nt0 ; remember the nt of this word for later
.9cdd	20 5c 9a	jsr $9a5c	EGt:		jsr ECmpA
.9ce0	30 e0		bmi $9cc2			bmi EFalse2
.9ce2	d0 10		bne $9cf4			bne ETrue2
.9ce4	f0 dc		beq $9cc2			beq EFalse2
=9					CodeLen	.var *-XtPtr1
=$9ce6					Here1 = *	; remember here
>9cdb	09					.byte CodeLen	;patch wh_CodeLength
>9ce6	45 3c 3d			Name0:	.text "E<="	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=40041					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9ce9	a3					.byte (("E<="[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=16					LinkDisplacement = Nt0-WordListLink
>9cea	10					.byte WordFlags	;wh_Flags
>9ceb	03					.byte 3	;wh_CodeLength
>9cec	10					  .byte LinkDisplacement	; offset to previous nt
=$9ced					XtPtr1 ::= *
=40041					WordListLink ::= Nt0 ; remember the nt of this word for later
.9ced	20 5c 9a	jsr $9a5c	ELe:		jsr ECmpA
.9cf0	30 02		bmi $9cf4			bmi ETrue2
.9cf2	d0 ce		bne $9cc2			bne EFalse2
.9cf4					ETrue2:
.9cf4	e6 4c		inc $4c				inc FIndex	; EDrop
.9cf6	e6 4c		inc $4c				inc FIndex	; EDrop
.9cf8	4c c4 c7	jmp $c7c4			jmp True	; return True
=14					CodeLen	.var *-XtPtr1
=$9cfb					Here1 = *	; remember here
>9ceb	0e					.byte CodeLen	;patch wh_CodeLength
>9cfb	45 3c 3e			Name0:	.text "E<>"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=40062					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9cfe	c3					.byte (("E<>"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=21					LinkDisplacement = Nt0-WordListLink
>9cff	10					.byte WordFlags	;wh_Flags
>9d00	03					.byte 3	;wh_CodeLength
>9d01	15					  .byte LinkDisplacement	; offset to previous nt
=$9d02					XtPtr1 ::= *
=40062					WordListLink ::= Nt0 ; remember the nt of this word for later
.9d02	20 5c 9a	jsr $9a5c	ENe:		jsr ECmpA
.9d05	d0 ed		bne $9cf4			bne ETrue2
.9d07	f0 b9		beq $9cc2			beq EFalse2
=7					CodeLen	.var *-XtPtr1
=$9d09					Here1 = *	; remember here
>9d00	07					.byte CodeLen	;patch wh_CodeLength
>9d09	45 3d				Name0:	.text "E="	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=40075					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9d0b	a2					.byte (("E="[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>9d0c	10					.byte WordFlags	;wh_Flags
>9d0d	03					.byte 3	;wh_CodeLength
>9d0e	0d					  .byte LinkDisplacement	; offset to previous nt
=$9d0f					XtPtr1 ::= *
=40075					WordListLink ::= Nt0 ; remember the nt of this word for later
.9d0f	20 5c 9a	jsr $9a5c	EEq:		jsr ECmpA
.9d12	d0 ae		bne $9cc2			bne EFalse2
.9d14	f0 de		beq $9cf4			beq ETrue2
=7					CodeLen	.var *-XtPtr1
=$9d16					Here1 = *	; remember here
>9d0d	07					.byte CodeLen	;patch wh_CodeLength
>9d16	45 7e 41 62 73			Name0:	.text "E~Abs"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=40091					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9d1b	65					.byte (("E~Abs"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=16					LinkDisplacement = Nt0-WordListLink
>9d1c	10					.byte WordFlags	;wh_Flags
>9d1d	03					.byte 3	;wh_CodeLength
>9d1e	10					  .byte LinkDisplacement	; offset to previous nt
=$9d1f					XtPtr1 ::= *
=40091					WordListLink ::= Nt0 ; remember the nt of this word for later
.9d1f	20 dc 9b	jsr $9bdc	ETAbs:		jsr EMRot
.9d22	20 9c a0	jsr $a09c			jsr EMinus
.9d25	20 df a0	jsr $a0df			jsr EAbs
.9d28	4c dd 9c	jmp $9cdd			jmp EGt
=12					CodeLen	.var *-XtPtr1
=$9d2b					Here1 = *	; remember here
>9d1d	0c					.byte CodeLen	;patch wh_CodeLength
>9d2b	45 7e 52 65 6c			Name0:	.text "E~Rel"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=40112					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9d30	85					.byte (("E~Rel"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=21					LinkDisplacement = Nt0-WordListLink
>9d31	10					.byte WordFlags	;wh_Flags
>9d32	03					.byte 3	;wh_CodeLength
>9d33	15					  .byte LinkDisplacement	; offset to previous nt
=$9d34					XtPtr1 ::= *
=40112					WordListLink ::= Nt0 ; remember the nt of this word for later
.9d34	20 2e 9b	jsr $9b2e	ETRel:		jsr EOver
.9d37	a9 03		lda #$03			lda #3
.9d39	20 4c 9b	jsr $9b4c			jsr EPickA
.9d3c	20 6c a0	jsr $a06c			jsr EPlus
.9d3f	20 df a0	jsr $a0df			jsr EAbs
.9d42	20 4d 8d	jsr $8d4d			jsr EStar		; r1 r2 r3*|r1+r2|
.9d45	20 dc 9b	jsr $9bdc			jsr EMRot		; r3*|r1+r2| r1 r2
.9d48	20 9c a0	jsr $a09c			jsr EMinus
.9d4b	20 df a0	jsr $a0df			jsr EAbs
.9d4e	4c dd 9c	jmp $9cdd			jmp EGt
=29					CodeLen	.var *-XtPtr1
=$9d51					Here1 = *	; remember here
>9d32	1d					.byte CodeLen	;patch wh_CodeLength
>9d51	45 7e				Name0:	.text "E~"	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=40147					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9d53	c2					.byte (("E~"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=35					LinkDisplacement = Nt0-WordListLink
>9d54	10					.byte WordFlags	;wh_Flags
>9d55	03					.byte 3	;wh_CodeLength
>9d56	23					  .byte LinkDisplacement	; offset to previous nt
=$9d57					XtPtr1 ::= *
=40147					WordListLink ::= Nt0 ; remember the nt of this word for later
.9d57	a4 4c		ldy $4c		ETilde:		ldy FIndex
.9d59	b9 57 00	lda $0057,y			lda FSMant0,y
.9d5c	30 06		bmi $9d64			bmi _10			; e3<0
.9d5e	d0 bf		bne $9d1f			bne ETAbs		; e3>0
.9d60	e6 4c		inc $4c				inc FIndex		; e3=0
.9d62	d0 ab		bne $9d0f			bne EEq
.9d64	20 c5 a0	jsr $a0c5	_10:		jsr ENegate
.9d67	4c 34 9d	jmp $9d34			jmp ETRel
=19					CodeLen	.var *-XtPtr1
=$9d6a					Here1 = *	; remember here
>9d55	13					.byte CodeLen	;patch wh_CodeLength
>9d6a	45 56 61 72 69 61 62 6c		Name0:	.text "EVariable"	;  name of word as a string, ending at wh_NameLastChar
>9d72	65
=9					NameLength = *-Name0
=40179					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9d73	a9					.byte (("EVariable"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=24					WordFlags ::= IM+NN	; modifiable copy, remember for later
=32					LinkDisplacement = Nt0-WordListLink
>9d74	18					.byte WordFlags	;wh_Flags
>9d75	03					.byte 3	;wh_CodeLength
>9d76	20					  .byte LinkDisplacement	; offset to previous nt
=$9d77					XtPtr1 ::= *
=40179					WordListLink ::= Nt0 ; remember the nt of this word for later
.9d77	20 c8 d1	jsr $d1c8	EVariable:	jsr Create		; compile word header & push PFA adr
.9d7a	20 db cb	jsr $cbdb			jsr adjust_z		; fix word code length
.9d7d	20 27 9e	jsr $9e27			jsr E0			; alloc & init data
.9d80	4c 31 9c	jmp $9c31			jmp EComma
=12					CodeLen	.var *-XtPtr1
=$9d83					Here1 = *	; remember here
>9d75	0c					.byte CodeLen	;patch wh_CodeLength
>9d83	45 4c 69 74 65 72 61 6c		Name0:	.text "ELiteral"	;  name of word as a string, ending at wh_NameLastChar
=8					NameLength = *-Name0
=40203					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9d8b	88					.byte (("ELiteral"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=24					WordFlags ::= IM+NN	; modifiable copy, remember for later
=24					LinkDisplacement = Nt0-WordListLink
>9d8c	18					.byte WordFlags	;wh_Flags
>9d8d	03					.byte 3	;wh_CodeLength
>9d8e	18					  .byte LinkDisplacement	; offset to previous nt
=$9d8f					XtPtr1 ::= *
=40203					WordListLink ::= Nt0 ; remember the nt of this word for later
.9d8f	20 a4 9d	jsr $9da4	ELiteral:	jsr ELitTest
.9d92	f0 0a		beq $9d9e			beq _Short
.9d94	a9 c7		lda #$c7			lda #<ELitI		; compile JSR FLitI
.9d96	a0 9d		ldy #$9d			ldy #>ELitI
.9d98	20 73 dd	jsr $dd73			jsr Jsr_Comma_YA
.9d9b	4c 31 9c	jmp $9c31			jmp EComma		; compile inline operand, return
.9d9e	20 aa 9d	jsr $9daa	_Short:		jsr ELitShort
.9da1	4c 73 dd	jmp $dd73			jmp Jsr_Comma_YA	; compile jsr ELitYA, & return
=21					CodeLen	.var *-XtPtr1
=$9da4					Here1 = *	; remember here
>9d8d	15					.byte CodeLen	;patch wh_CodeLength
.9da4					ELitTest:
.9da4	a4 4c		ldy $4c				ldy FIndex
.9da6	b9 61 00	lda $0061,y			lda FSMant1,y		; will short work?
.9da9	60		rts				rts
.9daa					ELitShort:
.9daa	a9 a9		lda #$a9			lda #$a9		; compile LDA #mant0
.9dac	20 39 dd	jsr $dd39			jsr C_Comma_A
.9daf	b9 57 00	lda $0057,y			lda FSMant0,y
.9db2	20 39 dd	jsr $dd39			jsr C_Comma_A
.9db5	a9 a0		lda #$a0			lda #$a0		; compile LDY #exp
.9db7	20 39 dd	jsr $dd39			jsr C_Comma_A
.9dba	b9 4d 00	lda $004d,y			lda FSExp,y
.9dbd	20 39 dd	jsr $dd39			jsr C_Comma_A
.9dc0	e6 4c		inc $4c				inc FIndex		; FDrop
.9dc2	a9 11		lda #$11			lda #<ELitYA		; point at FLitYA
.9dc4	a0 9e		ldy #$9e			ldy #>ELitYA
.9dc6	60		rts				rts
.9dc7					ELitI:
.9dc7	68		pla				pla			; tmp2= RTS addr
.9dc8	85 16		sta $16				sta tmp2+0
.9dca	18		clc				clc			; bump RTS addr over inline float data
.9dcb	69 03		adc #$03			adc #EFloat_Size
.9dcd	a8		tay				tay
.9dce	68		pla				pla
.9dcf	85 17		sta $17				sta tmp2+1
.9dd1	69 00		adc #$00			adc #0
.9dd3	48		pha				pha
.9dd4	98		tya				tya
.9dd5	48		pha				pha
.9dd6	a0 01		ldy #$01			ldy #1			; correct for RTS addr
.9dd8	4c f1 9b	jmp $9bf1			jmp EAt_Tmp2Y		; fetch inline data, & return
>9ddb	45 43 6f 6e 73 74 61 6e		Name0:	.text "EConstant"	;  name of word as a string, ending at wh_NameLastChar
>9de3	74
=9					NameLength = *-Name0
=40292					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9de4	89					.byte (("EConstant"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=89					LinkDisplacement = Nt0-WordListLink
>9de5	10					.byte WordFlags	;wh_Flags
>9de6	03					.byte 3	;wh_CodeLength
>9de7	59					  .byte LinkDisplacement	; offset to previous nt
=$9de8					XtPtr1 ::= *
=40292					WordListLink ::= Nt0 ; remember the nt of this word for later
.9de8	20 1b d1	jsr $d11b	EConstant:	jsr Header_Comma	; compile word header
.9deb	20 a4 9d	jsr $9da4			jsr ELitTest		; will short work?
.9dee	f0 0d		beq $9dfd			beq _Short
.9df0	a9 06		lda #$06			lda #<EConstantRun	; compile call
.9df2	a0 9e		ldy #$9e			ldy #>EConstantRun
.9df4	20 73 dd	jsr $dd73			jsr Jsr_Comma_YA
.9df7	20 db cb	jsr $cbdb			jsr adjust_z
.9dfa	4c 31 9c	jmp $9c31			jmp EComma		; inline operand, & return
.9dfd					_Short:
.9dfd	20 aa 9d	jsr $9daa			jsr ELitShort		; compile load value
.9e00	20 89 dd	jsr $dd89			jsr Jmp_Comma_YA	; compile JMP
.9e03	4c db cb	jmp $cbdb			jmp adjust_z
=30					CodeLen	.var *-XtPtr1
=$9e06					Here1 = *	; remember here
>9de6	1e					.byte CodeLen	;patch wh_CodeLength
.9e06					EConstantRun:
.9e06	68		pla				pla			; tmp2= pop RTS addr
.9e07	85 16		sta $16				sta tmp2+0
.9e09	68		pla				pla
.9e0a	85 17		sta $17				sta tmp2+1
.9e0c	a0 01		ldy #$01			ldy #1			; correct for RTS addr
.9e0e	4c f1 9b	jmp $9bf1			jmp EAt_Tmp2Y		; fetch inline data, & return
.9e11					ELitYA:
.9e11	20 c8 84	jsr $84c8			jsr FAllocX		; alloc FP stack entry, X=FP stack index
.9e14	95 57		sta $57,x			sta FSMant0,x		; Mant= A,0
.9e16	94 4d		sty $4d,x			sty FSExp,x	; sty dir,x exists
.9e18	a9 00		lda #$00			lda #0
.9e1a	95 61		sta $61,x			sta FSMant1,x
.9e1c	a6 14		ldx $14				ldx tmp1+0		; restore data stack index
.9e1e	60		rts				rts
>9e1f	45 30 2e 65			Name0:	.text "E0.e"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=40355					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9e23	a4					.byte (("E0.e"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=63					LinkDisplacement = Nt0-WordListLink
>9e24	10					.byte WordFlags	;wh_Flags
>9e25	03					.byte 3	;wh_CodeLength
>9e26	3f					  .byte LinkDisplacement	; offset to previous nt
=$9e27					XtPtr1 ::= *
=40355					WordListLink ::= Nt0 ; remember the nt of this word for later
.9e27	a9 00		lda #$00	E0:		lda #0			; FSMant0
.9e29	a0 80		ldy #$80			ldy #$80		; FSExp
.9e2b	d0 e4		bne $9e11			bne ELitYA
=6					CodeLen	.var *-XtPtr1
=$9e2d					Here1 = *	; remember here
>9e25	06					.byte CodeLen	;patch wh_CodeLength
>9e2d	45 31 30 30 30 2e 65		Name0:	.text "E1000.e"	;  name of word as a string, ending at wh_NameLastChar
=7					NameLength = *-Name0
=40372					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9e34	a7					.byte (("E1000.e"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=17					LinkDisplacement = Nt0-WordListLink
>9e35	10					.byte WordFlags	;wh_Flags
>9e36	03					.byte 3	;wh_CodeLength
>9e37	11					  .byte LinkDisplacement	; offset to previous nt
=$9e38					XtPtr1 ::= *
=40372					WordListLink ::= Nt0 ; remember the nt of this word for later
.9e38	a9 7d		lda #$7d	E1000:		lda #$7d
.9e3a	a0 0a		ldy #$0a			ldy #10
.9e3c	d0 d3		bne $9e11			bne ELitYA
=6					CodeLen	.var *-XtPtr1
=$9e3e					Here1 = *	; remember here
>9e36	06					.byte CodeLen	;patch wh_CodeLength
>9e3e	45 31 30 2e 65			Name0:	.text "E10.e"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=40387					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9e43	a5					.byte (("E10.e"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=15					LinkDisplacement = Nt0-WordListLink
>9e44	10					.byte WordFlags	;wh_Flags
>9e45	03					.byte 3	;wh_CodeLength
>9e46	0f					  .byte LinkDisplacement	; offset to previous nt
=$9e47					XtPtr1 ::= *
=40387					WordListLink ::= Nt0 ; remember the nt of this word for later
.9e47	a9 50		lda #$50	E10:		lda #$50
.9e49	a0 04		ldy #$04			ldy #4
.9e4b	d0 c4		bne $9e11			bne ELitYA
=6					CodeLen	.var *-XtPtr1
=$9e4d					Here1 = *	; remember here
>9e45	06					.byte CodeLen	;patch wh_CodeLength
>9e4d	45 32 2e 65			Name0:	.text "E2.e"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=40401					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9e51	a4					.byte (("E2.e"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=14					LinkDisplacement = Nt0-WordListLink
>9e52	10					.byte WordFlags	;wh_Flags
>9e53	03					.byte 3	;wh_CodeLength
>9e54	0e					  .byte LinkDisplacement	; offset to previous nt
=$9e55					XtPtr1 ::= *
=40401					WordListLink ::= Nt0 ; remember the nt of this word for later
.9e55	a9 40		lda #$40	E2:		lda #$40
.9e57	a0 02		ldy #$02			ldy #2
.9e59	d0 b6		bne $9e11			bne ELitYA
=6					CodeLen	.var *-XtPtr1
=$9e5b					Here1 = *	; remember here
>9e53	06					.byte CodeLen	;patch wh_CodeLength
>9e5b	45 31 2e 65			Name0:	.text "E1.e"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=40415					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9e5f	a4					.byte (("E1.e"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=14					LinkDisplacement = Nt0-WordListLink
>9e60	10					.byte WordFlags	;wh_Flags
>9e61	03					.byte 3	;wh_CodeLength
>9e62	0e					  .byte LinkDisplacement	; offset to previous nt
=$9e63					XtPtr1 ::= *
=40415					WordListLink ::= Nt0 ; remember the nt of this word for later
.9e63	a9 40		lda #$40	E1:		lda #$40
.9e65	a0 01		ldy #$01			ldy #1
.9e67	d0 a8		bne $9e11			bne ELitYA
=6					CodeLen	.var *-XtPtr1
=$9e69					Here1 = *	; remember here
>9e61	06					.byte CodeLen	;patch wh_CodeLength
>9e69	45 2e 31 65			Name0:	.text "E.1e"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=40429					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9e6d	a4					.byte (("E.1e"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=14					LinkDisplacement = Nt0-WordListLink
>9e6e	10					.byte WordFlags	;wh_Flags
>9e6f	03					.byte 3	;wh_CodeLength
>9e70	0e					  .byte LinkDisplacement	; offset to previous nt
=$9e71					XtPtr1 ::= *
=40429					WordListLink ::= Nt0 ; remember the nt of this word for later
.9e71	20 06 9e	jsr $9e06	E10th:		jsr eConstantRun
>9e74	67 66						.word $6667		; 16 bit signed binary mantissa.  $4000 = +0.5
>9e76	fd						.char -3		; 8 bit signed exponent.  $00 = 2**0
=6					CodeLen	.var *-XtPtr1
=$9e77					Here1 = *	; remember here
>9e6f	06					.byte CodeLen	;patch wh_CodeLength
>9e77	45 50 69			Name0:	.text "EPi"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=40442					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9e7a	23					.byte (("EPi"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>9e7b	10					.byte WordFlags	;wh_Flags
>9e7c	03					.byte 3	;wh_CodeLength
>9e7d	0d					  .byte LinkDisplacement	; offset to previous nt
=$9e7e					XtPtr1 ::= *
=40442					WordListLink ::= Nt0 ; remember the nt of this word for later
.9e7e	20 06 9e	jsr $9e06	EPi:		jsr EConstantRun
>9e81	88 64						.word $6488		; 16 bit signed binary mantissa.  $4000 = +0.5
>9e83	02						.char 2		; 8 bit signed exponent.  $00 = 2**0
=6					CodeLen	.var *-XtPtr1
=$9e84					Here1 = *	; remember here
>9e7c	06					.byte CodeLen	;patch wh_CodeLength
>9e84	45 50 69 2f 32			Name0:	.text "EPi/2"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=40457					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9e89	45					.byte (("EPi/2"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=15					LinkDisplacement = Nt0-WordListLink
>9e8a	10					.byte WordFlags	;wh_Flags
>9e8b	03					.byte 3	;wh_CodeLength
>9e8c	0f					  .byte LinkDisplacement	; offset to previous nt
=$9e8d					XtPtr1 ::= *
=40457					WordListLink ::= Nt0 ; remember the nt of this word for later
.9e8d	20 06 9e	jsr $9e06	EPiH:		jsr EConstantRun
>9e90	88 64						.word $6488		; 16 bit signed binary mantissa.  $4000 = +0.5
>9e92	01						.char 1		; 8 bit signed exponent.  $00 = 2**0
=6					CodeLen	.var *-XtPtr1
=$9e93					Here1 = *	; remember here
>9e8b	06					.byte CodeLen	;patch wh_CodeLength
>9e93	45 50 69 2f 34			Name0:	.text "EPi/4"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=40472					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9e98	85					.byte (("EPi/4"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=15					LinkDisplacement = Nt0-WordListLink
>9e99	10					.byte WordFlags	;wh_Flags
>9e9a	03					.byte 3	;wh_CodeLength
>9e9b	0f					  .byte LinkDisplacement	; offset to previous nt
=$9e9c					XtPtr1 ::= *
=40472					WordListLink ::= Nt0 ; remember the nt of this word for later
.9e9c	20 06 9e	jsr $9e06	EPiQ:		jsr EConstantRun
>9e9f	88 64						.word $6488		; 16 bit signed binary mantissa.  $4000 = +0.5
>9ea1	00						.char 0		; 8 bit signed exponent.  $00 = 2**0
=6					CodeLen	.var *-XtPtr1
=$9ea2					Here1 = *	; remember here
>9e9a	06					.byte CodeLen	;patch wh_CodeLength
>9ea2	45 32 50 69			Name0:	.text "E2Pi"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=40486					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9ea6	24					.byte (("E2Pi"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=14					LinkDisplacement = Nt0-WordListLink
>9ea7	10					.byte WordFlags	;wh_Flags
>9ea8	03					.byte 3	;wh_CodeLength
>9ea9	0e					  .byte LinkDisplacement	; offset to previous nt
=$9eaa					XtPtr1 ::= *
=40486					WordListLink ::= Nt0 ; remember the nt of this word for later
.9eaa	20 06 9e	jsr $9e06	E2Pi:		jsr EConstantRun
>9ead	88 64						.word $6488		; 16 bit signed binary mantissa.  $4000 = +0.5
>9eaf	03						.char 3		; 8 bit signed exponent.  $00 = 2**0
=6					CodeLen	.var *-XtPtr1
=$9eb0					Here1 = *	; remember here
>9ea8	06					.byte CodeLen	;patch wh_CodeLength
>9eb0	45 2e 45			Name0:	.text "E.E"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=40499					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9eb3	a3					.byte (("E.E"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>9eb4	10					.byte WordFlags	;wh_Flags
>9eb5	03					.byte 3	;wh_CodeLength
>9eb6	0d					  .byte LinkDisplacement	; offset to previous nt
=$9eb7					XtPtr1 ::= *
=40499					WordListLink ::= Nt0 ; remember the nt of this word for later
.9eb7	20 06 9e	jsr $9e06	EE:		jsr EConstantRun
>9eba	fc 56						.word $56fc		; 16 bit signed binary mantissa.  $4000 = +0.5
>9ebc	02						.char 2		; 8 bit signed exponent.  $00 = 2**0
=6					CodeLen	.var *-XtPtr1
=$9ebd					Here1 = *	; remember here
>9eb5	06					.byte CodeLen	;patch wh_CodeLength
>9ebd	45 56 61 6c 75 65		Name0:	.text "EValue"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=40515					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9ec3	a6					.byte (("EValue"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=24					WordFlags ::= IM+NN	; modifiable copy, remember for later
=16					LinkDisplacement = Nt0-WordListLink
>9ec4	18					.byte WordFlags	;wh_Flags
>9ec5	03					.byte 3	;wh_CodeLength
>9ec6	10					  .byte LinkDisplacement	; offset to previous nt
=$9ec7					XtPtr1 ::= *
=40515					WordListLink ::= Nt0 ; remember the nt of this word for later
.9ec7	20 1b d1	jsr $d11b	EValue:		jsr Header_Comma	; compile word header
.9eca	a9 d7		lda #$d7			lda #<EValue_runtime	; compile JSR EValue_runtime
.9ecc	a0 9e		ldy #$9e			ldy #>EValue_runtime
.9ece	20 73 dd	jsr $dd73			jsr Jsr_Comma_YA
.9ed1	20 db cb	jsr $cbdb			jsr adjust_z		; fix word length
.9ed4	4c 31 9c	jmp $9c31			jmp EComma		; alloc & init value
=16					CodeLen	.var *-XtPtr1
=$9ed7					Here1 = *	; remember here
>9ec5	10					.byte CodeLen	;patch wh_CodeLength
.9ed7					EValue_runtime:
.9ed7	4c 06 9e	jmp $9e06			jmp EConstantRun
>9eda	45 53 63 61 6c 65		Name0:	.text "EScale"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=40544					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9ee0	a6					.byte (("EScale"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=29					LinkDisplacement = Nt0-WordListLink
>9ee1	10					.byte WordFlags	;wh_Flags
>9ee2	03					.byte 3	;wh_CodeLength
>9ee3	1d					  .byte LinkDisplacement	; offset to previous nt
=$9ee4					XtPtr1 ::= *
=40544					WordListLink ::= Nt0 ; remember the nt of this word for later
.9ee4	20 c3 c3	jsr $c3c3	EScale:		jsr PopA		; pop n
.9ee7	86 14		stx $14		EScaleA:	stx tmp1		; save data stack index
.9ee9	a6 4c		ldx $4c				ldx FIndex		; X= FP stack index
.9eeb	b4 57		ldy $57,x			ldy FSMant0,x		; mantissa zero?
.9eed	f0 07		beq $9ef6			beq _8
.9eef	18		clc				clc
.9ef0	75 4d		adc $4d,x			adc FSExp,x
.9ef2	95 4d		sta $4d,x			sta FSExp,x
.9ef4	70 03		bvs $9ef9			bvs _overflow		; overflow or underflow?
.9ef6	a6 14		ldx $14		_8:		ldx tmp1		; restore data stack index
.9ef8	60		rts				rts
.9ef9					_overflow:
.9ef9	a6 14		ldx $14				ldx tmp1		; restore data stack index
.9efb	20 3e c4	jsr $c43e			jsr Throw_FpOutOfRange
=26					CodeLen	.var *-XtPtr1
=$9efe					Here1 = *	; remember here
>9ee2	1a					.byte CodeLen	;patch wh_CodeLength
>9efe	45 32 2a			Name0:	.text "E2*"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=40577					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9f01	43					.byte (("E2*"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=33					LinkDisplacement = Nt0-WordListLink
>9f02	10					.byte WordFlags	;wh_Flags
>9f03	03					.byte 3	;wh_CodeLength
>9f04	21					  .byte LinkDisplacement	; offset to previous nt
=$9f05					XtPtr1 ::= *
=40577					WordListLink ::= Nt0 ; remember the nt of this word for later
.9f05	a9 01		lda #$01	E2Star:		lda #1
.9f07	d0 de		bne $9ee7			bne EScaleA
=4					CodeLen	.var *-XtPtr1
=$9f09					Here1 = *	; remember here
>9f03	04					.byte CodeLen	;patch wh_CodeLength
>9f09	45 32 2f			Name0:	.text "E2/"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=40588					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9f0c	e3					.byte (("E2/"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=11					LinkDisplacement = Nt0-WordListLink
>9f0d	10					.byte WordFlags	;wh_Flags
>9f0e	03					.byte 3	;wh_CodeLength
>9f0f	0b					  .byte LinkDisplacement	; offset to previous nt
=$9f10					XtPtr1 ::= *
=40588					WordListLink ::= Nt0 ; remember the nt of this word for later
.9f10	a9 ff		lda #$ff	E2Slash:	lda #$ff
.9f12	d0 d3		bne $9ee7			bne EScaleA
=4					CodeLen	.var *-XtPtr1
=$9f14					Here1 = *	; remember here
>9f0e	04					.byte CodeLen	;patch wh_CodeLength
>9f14	45 31 30 2a			Name0:	.text "E10*"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=40600					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9f18	44					.byte (("E10*"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=12					LinkDisplacement = Nt0-WordListLink
>9f19	10					.byte WordFlags	;wh_Flags
>9f1a	03					.byte 3	;wh_CodeLength
>9f1b	0c					  .byte LinkDisplacement	; offset to previous nt
=$9f1c					XtPtr1 ::= *
=40600					WordListLink ::= Nt0 ; remember the nt of this word for later
.9f1c	20 05 9f	jsr $9f05	E10Star:	jsr E2Star
.9f1f	20 13 9b	jsr $9b13			jsr EDup
.9f22	a9 02		lda #$02			lda #2
.9f24	20 e7 9e	jsr $9ee7			jsr EScaleA
.9f27	4c 6c a0	jmp $a06c			jmp EPlus
=14					CodeLen	.var *-XtPtr1
=$9f2a					Here1 = *	; remember here
>9f1a	0e					.byte CodeLen	;patch wh_CodeLength
>9f2a	45 46 6c 6f 6f 72		Name0:	.text "EFloor"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=40624					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9f30	46					.byte (("EFloor"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=24					LinkDisplacement = Nt0-WordListLink
>9f31	10					.byte WordFlags	;wh_Flags
>9f32	03					.byte 3	;wh_CodeLength
>9f33	18					  .byte LinkDisplacement	; offset to previous nt
=$9f34					XtPtr1 ::= *
=40624					WordListLink ::= Nt0 ; remember the nt of this word for later
.9f34	a4 4c		ldy $4c		EFloor:		ldy FIndex
.9f36	b9 57 00	lda $0057,y			lda FSMant0,y		; negative?
.9f39	10 13		bpl $9f4e			bpl _a
.9f3b	b9 4d 00	lda $004d,y			lda FSExp,y		; > -1 ?
.9f3e	10 0e		bpl $9f4e			bpl _a
.9f40	a9 80		lda #$80			lda #$80		; return -1
.9f42	99 57 00	sta $0057,y			sta FSMant0,y
.9f45	a9 00		lda #$00			lda #0
.9f47	99 4d 00	sta $004d,y			sta FSExp,y
.9f4a	99 61 00	sta $0061,y			sta FSMant1,y
.9f4d	60		rts				rts
.9f4e	a9 0f		lda #$0f	_a:		lda #16-1
.9f50	20 56 9f	jsr $9f56			jsr EShiftA
.9f53	4c 16 a0	jmp $a016			jmp ENormX
=34					CodeLen	.var *-XtPtr1
=$9f56					Here1 = *	; remember here
>9f32	22					.byte CodeLen	;patch wh_CodeLength
.9f56	86 14		stx $14		EShiftA:	stx tmp1+0		; save data stack index
.9f58	a6 4c		ldx $4c				ldx FIndex		; X= FP stack index
.9f5a	85 15		sta $15		EShiftAX:	sta tmp1+1		; save desired alignment
.9f5c	38		sec				sec			; calc bit shift count
.9f5d	f5 4d		sbc $4d,x			sbc FSExp,x
.9f5f	f0 2a		beq $9f8b			beq _leave
.9f61	70 1c		bvs $9f7f			bvs _overflow
.9f63	30 26		bmi $9f8b			bmi _leave
.9f65	c9 10		cmp #$10			cmp #16
.9f67	b0 18		bcs $9f81			bcs _zero
.9f69	a8		tay				tay
.9f6a	a5 15		lda $15				lda tmp1+1
.9f6c	95 4d		sta $4d,x			sta FSExp,x
.9f6e	b5 57		lda $57,x			lda FSMant0,x
.9f70	c9 80		cmp #$80	_12:		cmp #$80		; mantissa >>=1
.9f72	6a		ror a				ror a
.9f73	76 61		ror $61,x			ror FSMant1,x
.9f75	88		dey				dey
.9f76	d0 f8		bne $9f70			bne _12
.9f78	95 57		sta $57,x			sta FSMant0,x
.9f7a	b4 4d		ldy $4d,x	_30:		ldy FSExp,x
.9f7c	a6 4c		ldx $4c				ldx FIndex		; restore fp stack index (EShiftAX could have had a funny one)
.9f7e	60		rts				rts
.9f7f	10 0a		bpl $9f8b	_overflow:	bpl _leave
.9f81	a5 15		lda $15		_zero:		lda tmp1+1		; return zero
.9f83	95 4d		sta $4d,x			sta FSExp,x
.9f85	a9 00		lda #$00			lda #0
.9f87	95 57		sta $57,x			sta FSMant0,x
.9f89	95 61		sta $61,x			sta FSMant1,x
.9f8b	18		clc		_leave:		clc
.9f8c	90 ec		bcc $9f7a			bcc _30
>9f8e	45 54 72 75 6e 63		Name0:	.text "ETrunc"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=40724					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9f94	66					.byte (("ETrunc"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=100					LinkDisplacement = Nt0-WordListLink
>9f95	10					.byte WordFlags	;wh_Flags
>9f96	03					.byte 3	;wh_CodeLength
>9f97	64					  .byte LinkDisplacement	; offset to previous nt
=$9f98					XtPtr1 ::= *
=40724					WordListLink ::= Nt0 ; remember the nt of this word for later
.9f98	a4 4c		ldy $4c		ETrunc:		ldy FIndex
.9f9a	b9 57 00	lda $0057,y			lda FSMant0,y
.9f9d	10 95		bpl $9f34			bpl EFloor
.9f9f	20 c5 a0	jsr $a0c5			jsr ENegate
.9fa2	20 34 9f	jsr $9f34			jsr EFloor
.9fa5	4c c5 a0	jmp $a0c5			jmp ENegate
>9fa8	45 52 6f 75 6e 64		Name0:	.text "ERound"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=40750					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9fae	86					.byte (("ERound"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=26					LinkDisplacement = Nt0-WordListLink
>9faf	10					.byte WordFlags	;wh_Flags
>9fb0	03					.byte 3	;wh_CodeLength
>9fb1	1a					  .byte LinkDisplacement	; offset to previous nt
=$9fb2					XtPtr1 ::= *
=40750					WordListLink ::= Nt0 ; remember the nt of this word for later
.9fb2	a9 0f		lda #$0f	ERound:		lda #15
.9fb4	20 56 9f	jsr $9f56			jsr EShiftA
.9fb7	90 05		bcc $9fbe			bcc _15
.9fb9	a6 14		ldx $14				ldx tmp1+0		; restore data stack index
.9fbb	4c 90 a0	jmp $a090			jmp E1Plus
.9fbe	4c 16 a0	jmp $a016	_15:		jmp ENormX
=15					CodeLen	.var *-XtPtr1
=$9fc1					Here1 = *	; remember here
>9fb0	0f					.byte CodeLen	;patch wh_CodeLength
>9fc1	45 49 6e 74 46 72 63		Name0:	.text "EIntFrc"	;  name of word as a string, ending at wh_NameLastChar
=7					NameLength = *-Name0
=40776					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9fc8	67					.byte (("EIntFrc"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=26					LinkDisplacement = Nt0-WordListLink
>9fc9	10					.byte WordFlags	;wh_Flags
>9fca	03					.byte 3	;wh_CodeLength
>9fcb	1a					  .byte LinkDisplacement	; offset to previous nt
=$9fcc					XtPtr1 ::= *
=40776					WordListLink ::= Nt0 ; remember the nt of this word for later
.9fcc	20 13 9b	jsr $9b13	EIntFrc:	jsr EDup	; ( e1 e1 )
.9fcf	20 34 9f	jsr $9f34			jsr EFloor	; ( e1 eint )
.9fd2	20 a5 9b	jsr $9ba5			jsr ETuck	; ( eint e1 eint )
.9fd5	20 9c a0	jsr $a09c			jsr EMinus	; ( eint efrac )
.9fd8	4c 7d 9b	jmp $9b7d			jmp ESwap	; ( efrac eint )
=15					CodeLen	.var *-XtPtr1
=$9fdb					Here1 = *	; remember here
>9fca	0f					.byte CodeLen	;patch wh_CodeLength
>9fdb	45 4d 41 6c 69 67 6e 58		Name0:	.text "EMAlignX"	;  name of word as a string, ending at wh_NameLastChar
=8					NameLength = *-Name0
=40803					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9fe3	08					.byte (("EMAlignX"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=27					LinkDisplacement = Nt0-WordListLink
>9fe4	10					.byte WordFlags	;wh_Flags
>9fe5	03					.byte 3	;wh_CodeLength
>9fe6	1b					  .byte LinkDisplacement	; offset to previous nt
=$9fe7					XtPtr1 ::= *
=40803					WordListLink ::= Nt0 ; remember the nt of this word for later
.9fe7	86 14		stx $14		EMAlignX:	stx tmp1+0	; save data stack index
.9fe9	a6 4c		ldx $4c				ldx FIndex	; load FP stack index
.9feb	e0 09		cpx #$09			cpx #FDim-1	; check FP stack for >=2 entries
.9fed	b0 19		bcs $a008			bcs Throw_FPStack_e3
.9fef	b5 4d		lda $4d,x			lda FSExp+0,x	; compare exponents
.9ff1	38		sec				sec
.9ff2	f5 4e		sbc $4e,x			sbc FSExp+1,x
.9ff4	30 03		bmi $9ff9			bmi _1		; r1 smaller?
.9ff6	d0 08		bne $a000			bne _2		; r2 smaller?
.9ff8	60		rts				rts
.9ff9					_1:
.9ff9	70 07		bvs $a002			bvs _2b		; was this a big positive #?
.9ffb	b5 4e		lda $4e,x	_1b:		lda FSExp+1,x	; make r1 like r2
.9ffd	4c 5a 9f	jmp $9f5a			jmp EShiftAX
.a000					_2:
.a000	70 f7		bvs $9ff9			bvs _1		; was this a big negative #?
.a002	b5 4d		lda $4d,x	_2b:		lda FSExp+0,x	; make r2 like r1
.a004	e8		inx				inx
.a005	4c 5a 9f	jmp $9f5a			jmp EShiftAX
=33					CodeLen	.var *-XtPtr1
=$a008					Here1 = *	; remember here
>9fe5	21					.byte CodeLen	;patch wh_CodeLength
.a008	20 34 c4	jsr $c434	Throw_FPStack_e3: jsr Throw_FPStack
>a00b	45 4e 6f 72 6d			Name0:	.text "ENorm"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=40848					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>a010	a5					.byte (("ENorm"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=45					LinkDisplacement = Nt0-WordListLink
>a011	10					.byte WordFlags	;wh_Flags
>a012	03					.byte 3	;wh_CodeLength
>a013	2d					  .byte LinkDisplacement	; offset to previous nt
=$a014					XtPtr1 ::= *
=40848					WordListLink ::= Nt0 ; remember the nt of this word for later
.a014	86 14		stx $14		ENorm:		stx tmp1+0		; save data stack index
.a016	a6 4c		ldx $4c		ENormX:		ldx FIndex		; switch to FP stack
.a018	b4 4d		ldy $4d,x			ldy FSExp,x
.a01a	b5 57		lda $57,x			lda FSMant0,x		; mantissa negative?
.a01c	30 1b		bmi $a039			bmi _Neg
.a01e	d0 05		bne $a025			bne _Pos2		; do byte shift
.a020	20 56 a0	jsr $a056			jsr _ShiftB
.a023	f0 29		beq $a04e			beq _zero		; no significant bits left?
.a025	18		clc		_Pos2:		clc
.a026	30 06		bmi $a02e			bmi _RShft
.a028	88		dey		_Pos3:		dey			; do bit shift
.a029	16 61		asl $61,x			asl FSMant1,x
.a02b	2a		rol a				rol a
.a02c	10 fa		bpl $a028			bpl _Pos3
.a02e					_RShft:
.a02e	c8		iny				iny
.a02f	6a		ror a				ror a
.a030	76 61		ror $61,x			ror FSMant1,x
.a032					_28:
.a032	95 57		sta $57,x			sta FSMant0,x
.a034	94 4d		sty $4d,x			sty FSExp,x	; sty dir,x exists
.a036	a6 14		ldx $14				ldx tmp1+0	; restore data stack index
.a038	60		rts				rts
.a039					_Neg:
.a039	c9 ff		cmp #$ff			cmp #$ff
.a03b	d0 03		bne $a040			bne _Neg2	; do byte shift
.a03d	20 56 a0	jsr $a056			jsr _ShiftB
.a040	c9 00		cmp #$00	_Neg2:		cmp #0
.a042	10 ea		bpl $a02e			bpl _RShft
.a044	88		dey		_Neg3:		dey
.a045	16 61		asl $61,x			asl FSMant1,x
.a047	2a		rol a				rol a
.a048	30 fa		bmi $a044			bmi _Neg3
.a04a	10 e2		bpl $a02e			bpl _RShft
.a04c	68		pla		_Zerop:		pla
.a04d	68		pla				pla		; pop rts addr from _ShiftB
.a04e	a9 00		lda #$00	_zero:		lda #0
.a050	95 61		sta $61,x			sta FSMant1,x
.a052	a0 80		ldy #$80			ldy #$80
.a054	d0 dc		bne $a032			bne _28
.a056					_ShiftB:
.a056	98		tya				tya		; exponent -= 8
.a057	38		sec				sec
.a058	e9 08		sbc #$08			sbc #8
.a05a	a8		tay				tay
.a05b	70 ef		bvs $a04c			bvs _zerop	;is this useful? do we need more of them?
.a05d	b5 61		lda $61,x			lda FSMant1,x
.a05f	48		pha				pha
.a060	a9 00		lda #$00			lda #0
.a062	95 61		sta $61,x			sta FSMant1,x
.a064	68		pla				pla
.a065	60		rts				rts
=82					CodeLen	.var *-XtPtr1
=$a066					Here1 = *	; remember here
>a012	52					.byte CodeLen	;patch wh_CodeLength
>a066	45 2b				Name0:	.text "E+"	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=40936					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>a068	62					.byte (("E+"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=88					LinkDisplacement = Nt0-WordListLink
>a069	10					.byte WordFlags	;wh_Flags
>a06a	03					.byte 3	;wh_CodeLength
>a06b	58					  .byte LinkDisplacement	; offset to previous nt
=$a06c					XtPtr1 ::= *
=40936					WordListLink ::= Nt0 ; remember the nt of this word for later
.a06c	20 7b 8a	jsr $8a7b	EPlus:		jsr FMAlignX	; align mantissas, X= FP stack index
.a06f	18		clc				clc		; add mantissas
.a070	b5 62		lda $62,x			lda FSMant1+1,x
.a072	75 61		adc $61,x			adc FSMant1+0,x
.a074	95 62		sta $62,x			sta FSMant1+1,x
.a076	b5 58		lda $58,x			lda FSMant0+1,x
.a078	75 57		adc $57,x			adc FSMant0+0,x
.a07a					EPlusFin:
.a07a	e8		inx				inx		; FDrop r2
.a07b	86 4c		stx $4c				stx FIndex
.a07d	50 05		bvc $a084	EPlusFin3:	bvc _19		; if overflow
.a07f	6a		ror a				ror a		;   shift mantissa right 1 bit
.a080	76 61		ror $61,x			ror FSMant1,x
.a082	f6 4d		inc $4d,x			inc FSExp,x	;   adjust exponent
.a084					_19:
.a084	95 57		sta $57,x			sta FSMant0,x
.a086	4c 16 a0	jmp $a016			jmp ENormX	; normalize, return
=29					CodeLen	.var *-XtPtr1
=$a089					Here1 = *	; remember here
>a06a	1d					.byte CodeLen	;patch wh_CodeLength
>a089	45 31 2b			Name0:	.text "E1+"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=40972					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>a08c	63					.byte (("E1+"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=36					LinkDisplacement = Nt0-WordListLink
>a08d	10					.byte WordFlags	;wh_Flags
>a08e	03					.byte 3	;wh_CodeLength
>a08f	24					  .byte LinkDisplacement	; offset to previous nt
=$a090					XtPtr1 ::= *
=40972					WordListLink ::= Nt0 ; remember the nt of this word for later
.a090	20 63 9e	jsr $9e63	E1Plus:		jsr E1
.a093	4c 6c a0	jmp $a06c			jmp EPlus
=6					CodeLen	.var *-XtPtr1
=$a096					Here1 = *	; remember here
>a08e	06					.byte CodeLen	;patch wh_CodeLength
>a096	45 2d				Name0:	.text "E-"	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=40984					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>a098	a2					.byte (("E-"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=12					LinkDisplacement = Nt0-WordListLink
>a099	10					.byte WordFlags	;wh_Flags
>a09a	03					.byte 3	;wh_CodeLength
>a09b	0c					  .byte LinkDisplacement	; offset to previous nt
=$a09c					XtPtr1 ::= *
=40984					WordListLink ::= Nt0 ; remember the nt of this word for later
.a09c	20 7b 8a	jsr $8a7b	EMinus:		jsr FMAlignX	; align mantissas
.a09f	38		sec				sec		; subtract mantissas
.a0a0	b5 62		lda $62,x			lda FSMant1+1,x
.a0a2	f5 61		sbc $61,x			sbc FSMant1+0,x
.a0a4	95 62		sta $62,x			sta FSMant1+1,x
.a0a6	b5 58		lda $58,x			lda FSMant0+1,x
.a0a8	f5 57		sbc $57,x			sbc FSMant0+0,x
.a0aa	4c 7a a0	jmp $a07a			jmp EPlusFin	; finish
=17					CodeLen	.var *-XtPtr1
=$a0ad					Here1 = *	; remember here
>a09a	11					.byte CodeLen	;patch wh_CodeLength
>a0ad	45 31 2d			Name0:	.text "E1-"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=41008					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>a0b0	a3					.byte (("E1-"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=24					LinkDisplacement = Nt0-WordListLink
>a0b1	10					.byte WordFlags	;wh_Flags
>a0b2	03					.byte 3	;wh_CodeLength
>a0b3	18					  .byte LinkDisplacement	; offset to previous nt
=$a0b4					XtPtr1 ::= *
=41008					WordListLink ::= Nt0 ; remember the nt of this word for later
.a0b4	20 63 9e	jsr $9e63	E1Minus:	jsr E1
.a0b7	4c 9c a0	jmp $a09c			jmp EMinus
=6					CodeLen	.var *-XtPtr1
=$a0ba					Here1 = *	; remember here
>a0b2	06					.byte CodeLen	;patch wh_CodeLength
>a0ba	45 4e 65 67 61 74 65		Name0:	.text "ENegate"	;  name of word as a string, ending at wh_NameLastChar
=7					NameLength = *-Name0
=41025					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>a0c1	a7					.byte (("ENegate"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=17					LinkDisplacement = Nt0-WordListLink
>a0c2	10					.byte WordFlags	;wh_Flags
>a0c3	03					.byte 3	;wh_CodeLength
>a0c4	11					  .byte LinkDisplacement	; offset to previous nt
=$a0c5					XtPtr1 ::= *
=41025					WordListLink ::= Nt0 ; remember the nt of this word for later
.a0c5	86 14		stx $14		ENegate:	stx tmp1	; save data stack index
.a0c7	a6 4c		ldx $4c				ldx FIndex	; X= FP stack index
.a0c9	38		sec				sec		; mantissa = 0 - mantissa
.a0ca	a9 00		lda #$00			lda #0
.a0cc	f5 61		sbc $61,x			sbc FSMant1,x
.a0ce	95 61		sta $61,x			sta FSMant1,x
.a0d0	a9 00		lda #$00			lda #0
.a0d2	f5 57		sbc $57,x			sbc FSMant0,x
.a0d4	4c 7d a0	jmp $a07d			jmp EPlusFin3	; finish up, return
=18					CodeLen	.var *-XtPtr1
=$a0d7					Here1 = *	; remember here
>a0c3	12					.byte CodeLen	;patch wh_CodeLength
>a0d7	45 41 62 73			Name0:	.text "EAbs"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=41051					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>a0db	64					.byte (("EAbs"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=26					LinkDisplacement = Nt0-WordListLink
>a0dc	10					.byte WordFlags	;wh_Flags
>a0dd	03					.byte 3	;wh_CodeLength
>a0de	1a					  .byte LinkDisplacement	; offset to previous nt
=$a0df					XtPtr1 ::= *
=41051					WordListLink ::= Nt0 ; remember the nt of this word for later
.a0df	a4 4c		ldy $4c		EAbs:		ldy FIndex
.a0e1	b9 57 00	lda $0057,y			lda FSMant0,y		; mantissa negative?
.a0e4	30 df		bmi $a0c5			bmi ENegate
.a0e6	60		rts				rts
=8					CodeLen	.var *-XtPtr1
=$a0e7					Here1 = *	; remember here
>a0dd	08					.byte CodeLen	;patch wh_CodeLength
.a0e7	4c 34 c4	jmp $c434	Throw_FPStack_e4: jmp Throw_FPStack
.a0ea	a4 4c		ldy $4c		EPos:		ldy FIndex		; load FP stack index
.a0ec	c0 09		cpy #$09			cpy #FDim-1		; check FP stack for 2
.a0ee	b0 f7		bcs $a0e7			bcs Throw_FPStack_e4
.a0f0	b9 57 00	lda $0057,y			lda FSMant0+0,y		; calc result sign
.a0f3	59 58 00	eor $0058,y			eor FSMant0+1,y
.a0f6	08		php				php
.a0f7	b9 58 00	lda $0058,y			lda FSMant0+1,y		; if NOS negative
.a0fa	10 07		bpl $a103			bpl +
.a0fc	e6 4c		inc $4c				inc FIndex		;   point at NOS
.a0fe	20 c5 a0	jsr $a0c5			jsr ENegate		;   negate NOS
.a101	c6 4c		dec $4c				dec FIndex		;   restore fp
.a103					+
.a103	20 df a0	jsr $a0df			jsr EAbs		; abs TOS
.a106	86 14		stx $14				stx tmp1+0		; save data stack index
.a108	a6 4c		ldx $4c				ldx FIndex		; load FP stack index
.a10a	28		plp				plp			; restore sign flag
.a10b	60		rts				rts
>a10c	46 3e 45			Name0:	.text "F>E"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=41103					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>a10f	a3					.byte (("F>E"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=0					WordFlags ::= 0	; modifiable copy, remember for later
=52					LinkDisplacement = Nt0-WordListLink
>a110	00					.byte WordFlags	;wh_Flags
>a111	03					.byte 3	;wh_CodeLength
>a112	34					  .byte LinkDisplacement	; offset to previous nt
=$a113					XtPtr1 ::= *
=41103					WordListLink ::= Nt0 ; remember the nt of this word for later
.a113					FToE:
=0					CodeLen	.var *-XtPtr1
=$a113					Here1 = *	; remember here
>a111	00					.byte CodeLen	;patch wh_CodeLength
.a113	60		rts				rts
>a114	45 3e 46			Name0:	.text "E>F"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=41111					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>a117	c3					.byte (("E>F"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=0					WordFlags ::= 0	; modifiable copy, remember for later
=8					LinkDisplacement = Nt0-WordListLink
>a118	00					.byte WordFlags	;wh_Flags
>a119	03					.byte 3	;wh_CodeLength
>a11a	08					  .byte LinkDisplacement	; offset to previous nt
=$a11b					XtPtr1 ::= *
=41111					WordListLink ::= Nt0 ; remember the nt of this word for later
.a11b	a4 4c		ldy $4c		EToF:		ldy FIndex
.a11d	a9 00		lda #$00			lda #0			; zero 2nd 16 bits of mantissa
.a11f	99 6b 00	sta $006b,y			sta FSMant2,y
.a122	99 75 00	sta $0075,y			sta FSMant3,y
=10					CodeLen	.var *-XtPtr1
=$a125					Here1 = *	; remember here
>a119	0a					.byte CodeLen	;patch wh_CodeLength
.a125	60		rts				rts
>a126	53 3e 45			Name0:	.text "S>E"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=41129					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>a129	a3					.byte (("S>E"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=18					LinkDisplacement = Nt0-WordListLink
>a12a	10					.byte WordFlags	;wh_Flags
>a12b	03					.byte 3	;wh_CodeLength
>a12c	12					  .byte LinkDisplacement	; offset to previous nt
=$a12d					XtPtr1 ::= *
=41129					WordListLink ::= Nt0 ; remember the nt of this word for later
.a12d	20 de c3	jsr $c3de	SToE:		jsr PopYA		; pop n
.a130	20 c8 84	jsr $84c8	SToEYA:		jsr FAllocX		; alloc FP stack entry
.a133	95 61		sta $61,x			sta FSMant1,x		; copy n to mantissa
.a135	94 57		sty $57,x			sty FSMant0,x	; sty dir,x exists
.a137	a9 0f		lda #$0f			lda #15			; set exponent
.a139	95 4d		sta $4d,x			sta FSExp,x
.a13b	4c 16 a0	jmp $a016			jmp ENormX		; normalize, return
=17					CodeLen	.var *-XtPtr1
=$a13e					Here1 = *	; remember here
>a12b	11					.byte CodeLen	;patch wh_CodeLength
>a13e	45 3e 53			Name0:	.text "E>S"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=41153					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>a141	63					.byte (("E>S"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=24					LinkDisplacement = Nt0-WordListLink
>a142	10					.byte WordFlags	;wh_Flags
>a143	03					.byte 3	;wh_CodeLength
>a144	18					  .byte LinkDisplacement	; offset to previous nt
=$a145					XtPtr1 ::= *
=41153					WordListLink ::= Nt0 ; remember the nt of this word for later
.a145	a4 4c		ldy $4c		EToS:		ldy FIndex
.a147	b9 57 00	lda $0057,y			lda FSMant0,y		; save sign
.a14a	08		php				php
.a14b	10 03		bpl $a150			bpl +
.a14d	20 c5 a0	jsr $a0c5			jsr ENegate
.a150					+
.a150	a9 0f		lda #$0f			lda #15
.a152	20 56 9f	jsr $9f56			jsr EShiftA
.a155	a6 14		ldx $14				ldx tmp1+0		; restore data stack index
.a157	c0 10		cpy #$10			cpy #15+1		; always positive, so unsigned compare works
.a159	b0 17		bcs $a172			bcs _overflow
.a15b	a4 4c		ldy $4c				ldy FIndex
.a15d	ca		dex				dex
.a15e	ca		dex				dex
.a15f	b9 57 00	lda $0057,y			lda FSMant0,y
.a162	95 25		sta $25,x			sta DStack+1,x
.a164	b9 61 00	lda $0061,y			lda FSMant1,y
.a167	95 24		sta $24,x			sta DStack+0,x
.a169	e6 4c		inc $4c				inc FIndex		; EDrop
.a16b	28		plp				plp			; apply saved sign
.a16c	30 01		bmi $a16f			bmi +
.a16e	60		rts				rts
.a16f	4c e4 d6	jmp $d6e4	+		jmp Negate
.a172	28		plp		_overflow:	plp			; RDrop saved sign
.a173	a9 f5		lda #$f5			lda #$100+err_OutOfRange
.a175	20 63 c4	jsr $c463			jsr ThrowA
=51					CodeLen	.var *-XtPtr1
=$a178					Here1 = *	; remember here
>a143	33					.byte CodeLen	;patch wh_CodeLength
>a178	45 52 6e 64			Name0:	.text "ERnd"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=41212					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>a17c	84					.byte (("ERnd"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=59					LinkDisplacement = Nt0-WordListLink
>a17d	10					.byte WordFlags	;wh_Flags
>a17e	03					.byte 3	;wh_CodeLength
>a17f	3b					  .byte LinkDisplacement	; offset to previous nt
=$a180					XtPtr1 ::= *
=41212					WordListLink ::= Nt0 ; remember the nt of this word for later
.a180	20 f7 82	jsr $82f7	ERnd:		jsr Rand		; generate next RndState
.a183	20 c8 84	jsr $84c8			jsr FAllocX		; alloc FP stack entry
.a186	4a		lsr a				lsr a			;   make positive
.a187	95 57		sta $57,x			sta FSMant0,x
.a189	94 61		sty $61,x			sty FSMant1,x	; sty dir,x exists
.a18b	a9 00		lda #$00			lda #0			; exponent=0
.a18d	95 4d		sta $4d,x			sta FSExp,x
.a18f	4c 16 a0	jmp $a016			jmp ENormX		; normalize, return
=18					CodeLen	.var *-XtPtr1
=$a192					Here1 = *	; remember here
>a17e	12					.byte CodeLen	;patch wh_CodeLength
>a192	45 53 71 72 74			Name0:	.text "ESqrt"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=41239					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>a197	85					.byte (("ESqrt"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=27					LinkDisplacement = Nt0-WordListLink
>a198	10					.byte WordFlags	;wh_Flags
>a199	03					.byte 3	;wh_CodeLength
>a19a	1b					  .byte LinkDisplacement	; offset to previous nt
=$a19b					XtPtr1 ::= *
=41239					WordListLink ::= Nt0 ; remember the nt of this word for later
.a19b	a4 4c		ldy $4c		ESqrt:		ldy FIndex
.a19d	b9 57 00	lda $0057,y			lda FSMant0,y		; zero?
.a1a0	d0 01		bne $a1a3			bne +
.a1a2	60		rts				rts			;   just return the zero
.a1a3					+
.a1a3	20 13 9b	jsr $9b13			jsr EDup		; get trial value
.a1a6	a4 4c		ldy $4c				ldy FIndex
.a1a8	b9 4d 00	lda $004d,y			lda FSExp,y		; halve the exponent of trial value
.a1ab	c9 80		cmp #$80			cmp #$80
.a1ad	6a		ror a				ror a
.a1ae	99 4d 00	sta $004d,y			sta FSExp,y
.a1b1	a9 09		lda #$09			lda #9			; for 9 iterations
.a1b3	48		pha		_3:		pha
.a1b4	20 6e 9b	jsr $9b6e			jsr E2Dup		;   calc new trial value
.a1b7	20 c9 8d	jsr $8dc9			jsr ESlash
.a1ba	20 6c a0	jsr $a06c			jsr EPlus
.a1bd	20 10 9f	jsr $9f10			jsr E2Slash
.a1c0	68		pla				pla			;  next
.a1c1	38		sec				sec
.a1c2	e9 01		sbc #$01			sbc #1
.a1c4	d0 ed		bne $a1b3			bne _3
.a1c6	4c f6 9a	jmp $9af6			jmp ENip		; return trial value
=46					CodeLen	.var *-XtPtr1
=$a1c9					Here1 = *	; remember here
>a199	2e					.byte CodeLen	;patch wh_CodeLength
>a1c9	28 45 2e 29			Name0:	.text "(E.)"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=41293					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>a1cd	24					.byte (("(E.)"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=54					LinkDisplacement = Nt0-WordListLink
>a1ce	10					.byte WordFlags	;wh_Flags
>a1cf	03					.byte 3	;wh_CodeLength
>a1d0	36					  .byte LinkDisplacement	; offset to previous nt
=$a1d1					XtPtr1 ::= *
=41293					WordListLink ::= Nt0 ; remember the nt of this word for later
.a1d1	20 4e a2	jsr $a24e	PEDot:		jsr pecstart		;start collecting chars, make r positive
.a1d4	20 da a1	jsr $a1da			jsr PEDotSub
.a1d7	4c 21 90	jmp $9021			jmp pfcend
.a1da					PEDotSub:
.a1da	20 5f 8f	jsr $8f5f			jsr Precision	;alloc & init work area
.a1dd	20 fb c7	jsr $c7fb			jsr One
=$27					_mantNzFound  = DStack+3	; nonzero mantissa digit processed
=$26					_NumSigDigits = DStack+2	; # of significant digits
=$24					_decimalPos   = DStack+0	; decimal point position
.a1e0	20 2e a2	jsr $a22e			jsr ELt10		; scale down to <10, counting exponent
.a1e3					_c:
.a1e3	b5 24		lda $24,x			lda _decimalPos,x	;  insert decimal point here?
.a1e5	d0 05		bne $a1ec			bne _c2
.a1e7	a9 2e		lda #$2e			lda #'.'
.a1e9	20 18 90	jsr $9018			jsr pfchar
.a1ec	d6 24		dec $24,x	_c2:		dec _decimalPos,x
.a1ee	20 13 9b	jsr $9b13			jsr EDup		;  do a digit
.a1f1	20 45 a1	jsr $a145			jsr EToS		; ( work n )
.a1f4	b5 24		lda $24,x			lda DStack+0,x
.a1f6	15 29		ora $29,x			ora _mantNzFound+2,x	;  doing significant digits?
.a1f8	95 29		sta $29,x			sta _mantNzFound+2,x
.a1fa	f0 08		beq $a204			beq _c7
.a1fc	d6 28		dec $28,x			dec _NumSigDigits+2,x
.a1fe	10 04		bpl $a204			bpl _c7
.a200	e8		inx				inx			;    drop integer
.a201	e8		inx				inx
.a202	d0 17		bne $a21b			bne _d
.a204	b5 24		lda $24,x	_c7:		lda DStack+0,x		;  store the char
.a206	09 30		ora #$30			ora #'0'
.a208	20 18 90	jsr $9018			jsr pfchar
.a20b	20 2d a1	jsr $a12d			jsr SToE		; ( work )
.a20e	20 9c a0	jsr $a09c			jsr EMinus
.a211	20 1c 9f	jsr $9f1c			jsr E10Star
.a214	a4 4c		ldy $4c				ldy FIndex		;  until mantissa==0
.a216	b9 57 00	lda $0057,y			lda FSMant0,y
.a219	d0 c8		bne $a1e3			bne _c
.a21b	d6 24		dec $24,x	_d:		dec _decimalPos,x	;do trailing zeros
.a21d	30 08		bmi $a227			bmi _d9
.a21f	a9 30		lda #$30			lda #'0'
.a221	20 18 90	jsr $9018			jsr pfchar
.a224	4c 1b a2	jmp $a21b			jmp _d
.a227	e8		inx		_d9:		inx			; drop work area
.a228	e8		inx				inx
.a229	e8		inx				inx
.a22a	e8		inx				inx
.a22b	e6 4c		inc $4c				inc FIndex		; FDrop
.a22d	60		rts				rts
=93					CodeLen	.var *-XtPtr1
=$a22e					Here1 = *	; remember here
>a1cf	5d					.byte CodeLen	;patch wh_CodeLength
.a22e					ELt10:
.a22e	a4 4c		ldy $4c		_1:		ldy FIndex		; while e1 >= 10
.a230	b9 4d 00	lda $004d,y			lda FSExp,y
.a233	30 18		bmi $a24d			bmi _9			;   exponent negative?
.a235	c9 04		cmp #$04			cmp #4
.a237	90 14		bcc $a24d			bcc _9			;   < 4 ?
.a239	d0 07		bne $a242			bne _2			;   > 4 ?
.a23b	b9 57 00	lda $0057,y			lda FSMant0,y		;   mantissa >= 10 ?
.a23e	c9 50		cmp #$50			cmp #$50
.a240	90 0b		bcc $a24d			bcc _9
.a242	f6 24		inc $24,x	_2:		inc DStack+0,x		;   exp ++
.a244	20 47 9e	jsr $9e47			jsr E10			;   e /= 10
.a247	20 c9 8d	jsr $8dc9			jsr ESlash
.a24a	4c 2e a2	jmp $a22e			jmp _1
.a24d	60		rts		_9:		rts
.a24e					pecstart:
.a24e	a9 01		lda #$01			lda #1
.a250	8d 34 03	sta $0334			sta ToHold
.a253	a4 4c		ldy $4c				ldy FIndex		; if e1 negative
.a255	b9 57 00	lda $0057,y			lda FSMant0,y
.a258	10 08		bpl $a262			bpl _19
.a25a	a9 2d		lda #$2d			lda #'-'		;   append sign
.a25c	20 18 90	jsr $9018			jsr pfchar
.a25f	4c c5 a0	jmp $a0c5			jmp ENegate		;   make positive, return
.a262	60		rts		_19:		rts
>a263	45 2e				Name0:	.text "E."	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=41445					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>a265	c2					.byte (("E."[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=152					LinkDisplacement = Nt0-WordListLink
>a266	10					.byte WordFlags	;wh_Flags
>a267	03					.byte 3	;wh_CodeLength
>a268	98					  .byte LinkDisplacement	; offset to previous nt
=$a269					XtPtr1 ::= *
=41445					WordListLink ::= Nt0 ; remember the nt of this word for later
.a269	20 d1 a1	jsr $a1d1	EDot:		jsr PEDot
.a26c	20 d7 c1	jsr $c1d7	EDot2:		jsr Count
.a26f	20 34 de	jsr $de34			jsr Type
.a272	4c 28 de	jmp $de28			jmp Space
=12					CodeLen	.var *-XtPtr1
=$a275					Here1 = *	; remember here
>a267	0c					.byte CodeLen	;patch wh_CodeLength
>a275	45 2e 53			Name0:	.text "E.S"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=41464					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>a278	63					.byte (("E.S"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=19					LinkDisplacement = Nt0-WordListLink
>a279	10					.byte WordFlags	;wh_Flags
>a27a	03					.byte 3	;wh_CodeLength
>a27b	13					  .byte LinkDisplacement	; offset to previous nt
=$a27c					XtPtr1 ::= *
=41464					WordListLink ::= Nt0 ; remember the nt of this word for later
.a27c	a9 09		lda #$09	EDotS:		lda #FDim-1	; for each FP stack entry
.a27e	d0 0b		bne $a28b			bne _8
.a280	48		pha		_2:		pha
.a281	20 4f 9b	jsr $9b4f			jsr EPick3	;   print it
.a284	20 69 a2	jsr $a269			jsr EDot
.a287	68		pla				pla		;  next
.a288	38		sec				sec
.a289	e9 01		sbc #$01			sbc #1
.a28b	c5 4c		cmp $4c		_8:		cmp FIndex
.a28d	b0 f1		bcs $a280			bcs _2
=19					CodeLen	.var *-XtPtr1
=$a28f					Here1 = *	; remember here
>a27a	13					.byte CodeLen	;patch wh_CodeLength
.a28f	60		rts				rts
>a290	28 45 53 2e 29			Name0:	.text "(ES.)"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=41493					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>a295	25					.byte (("(ES.)"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=29					LinkDisplacement = Nt0-WordListLink
>a296	10					.byte WordFlags	;wh_Flags
>a297	03					.byte 3	;wh_CodeLength
>a298	1d					  .byte LinkDisplacement	; offset to previous nt
=$a299					XtPtr1 ::= *
=41493					WordListLink ::= Nt0 ; remember the nt of this word for later
.a299	20 f2 c7	jsr $c7f2	PESDot:		jsr Zero		; alloc work area
=$24					_exp    = DStack+0
.a29c	20 4e a2	jsr $a24e			jsr pecstart		; start collecting chars, make r positive
.a29f	20 2e a2	jsr $a22e			jsr ELt10		; scale down to <10
.a2a2	a4 4c		ldy $4c		_c1:		ldy FIndex		; while r < 1
.a2a4	b9 57 00	lda $0057,y			lda FSMant0,y		;   mantissa == 0 ?
.a2a7	f0 0f		beq $a2b8			beq _c9
.a2a9	b9 4d 00	lda $004d,y			lda FSExp,y		;   exp < 1 ?
.a2ac	f0 02		beq $a2b0			beq _c2
.a2ae	10 08		bpl $a2b8			bpl _c9
.a2b0	d6 24		dec $24,x	_c2:		dec DStack+0,x		;  exp -= 1
.a2b2	20 1c 9f	jsr $9f1c			jsr E10Star		;  r *= 10
.a2b5	4c a2 a2	jmp $a2a2			jmp _c1
.a2b8					_c9:
.a2b8	20 da a1	jsr $a1da	PESDotM:	jsr PEDotSub		; do mantissa
.a2bb	a9 45		lda #$45			lda #'E'
.a2bd	20 18 90	jsr $9018			jsr pfchar		; do exponent
.a2c0	b5 24		lda $24,x			lda DStack+0,x		;   _exp
.a2c2	20 2e 90	jsr $902e			jsr pfciA
.a2c5	e8		inx				inx			; Drop work area
.a2c6	e8		inx				inx
.a2c7	4c 21 90	jmp $9021			jmp pfcend		; finish string
=49					CodeLen	.var *-XtPtr1
=$a2ca					Here1 = *	; remember here
>a297	31					.byte CodeLen	;patch wh_CodeLength
>a2ca	45 53 2e			Name0:	.text "ES."	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=41549					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>a2cd	c3					.byte (("ES."[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=56					LinkDisplacement = Nt0-WordListLink
>a2ce	10					.byte WordFlags	;wh_Flags
>a2cf	03					.byte 3	;wh_CodeLength
>a2d0	38					  .byte LinkDisplacement	; offset to previous nt
=$a2d1					XtPtr1 ::= *
=41549					WordListLink ::= Nt0 ; remember the nt of this word for later
.a2d1	20 99 a2	jsr $a299	ESDot:		jsr PESDot
.a2d4	4c 6c a2	jmp $a26c			jmp EDot2
=6					CodeLen	.var *-XtPtr1
=$a2d7					Here1 = *	; remember here
>a2cf	06					.byte CodeLen	;patch wh_CodeLength
>a2d7	28 45 45 2e 29			Name0:	.text "(EE.)"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=41564					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>a2dc	25					.byte (("(EE.)"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=15					LinkDisplacement = Nt0-WordListLink
>a2dd	10					.byte WordFlags	;wh_Flags
>a2de	03					.byte 3	;wh_CodeLength
>a2df	0f					  .byte LinkDisplacement	; offset to previous nt
=$a2e0					XtPtr1 ::= *
=41564					WordListLink ::= Nt0 ; remember the nt of this word for later
.a2e0	20 f2 c7	jsr $c7f2	PEEDot:		jsr Zero		; alloc work area
=$24					_exp    = DStack+0
.a2e3	20 4e a2	jsr $a24e			jsr pecstart		; start collecting chars, make r positive
.a2e6	a4 4c		ldy $4c		_30:		ldy FIndex		; while r < 1
.a2e8	b9 57 00	lda $0057,y			lda FSMant0,y
.a2eb	f0 16		beq $a303			beq _39
.a2ed	b9 4d 00	lda $004d,y			lda FSExp,y
.a2f0	f0 02		beq $a2f4			beq _31
.a2f2	10 0f		bpl $a303			bpl _39
.a2f4	d6 24		dec $24,x	_31:		dec _exp,x		;  exp -= 3
.a2f6	d6 24		dec $24,x			dec _exp,x
.a2f8	d6 24		dec $24,x			dec _exp,x
.a2fa	20 38 9e	jsr $9e38			jsr E1000		;  r *= 1000
.a2fd	20 4d 8d	jsr $8d4d			jsr EStar
.a300	4c e6 a2	jmp $a2e6			jmp _30
.a303					_39:
.a303	a4 4c		ldy $4c		_a:		ldy FIndex		; while r >= 1000
.a305	b9 4d 00	lda $004d,y			lda FSExp,y
.a308	30 1c		bmi $a326			bmi _a9			; exponent negative?
.a30a	c9 0a		cmp #$0a			cmp #10
.a30c	90 18		bcc $a326			bcc _a9			;   < 10 ?
.a30e	d0 07		bne $a317			bne _a2			;   > 10 ?
.a310	b9 57 00	lda $0057,y			lda FSMant0,y
.a313	c9 7d		cmp #$7d			cmp #$7d
.a315	90 0f		bcc $a326			bcc _a9
.a317	f6 24		inc $24,x	_a2:		inc _exp,x		;   exp += 3
.a319	f6 24		inc $24,x			inc _exp,x
.a31b	f6 24		inc $24,x			inc _exp,x
.a31d	20 38 9e	jsr $9e38			jsr E1000		;   r /= 1000
.a320	20 c9 8d	jsr $8dc9			jsr ESlash
.a323	4c 03 a3	jmp $a303			jmp _a
.a326					_a9:
.a326	4c b8 a2	jmp $a2b8			jmp PESDotM
=73					CodeLen	.var *-XtPtr1
=$a329					Here1 = *	; remember here
>a2de	49					.byte CodeLen	;patch wh_CodeLength
>a329	45 45 2e			Name0:	.text "EE."	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=41644					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>a32c	c3					.byte (("EE."[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=80					LinkDisplacement = Nt0-WordListLink
>a32d	10					.byte WordFlags	;wh_Flags
>a32e	03					.byte 3	;wh_CodeLength
>a32f	50					  .byte LinkDisplacement	; offset to previous nt
=$a330					XtPtr1 ::= *
=41644					WordListLink ::= Nt0 ; remember the nt of this word for later
.a330	20 e0 a2	jsr $a2e0	EEDot:		jsr PEEDot
.a333	4c 6c a2	jmp $a26c			jmp EDot2
=6					CodeLen	.var *-XtPtr1
=$a336					Here1 = *	; remember here
>a32e	06					.byte CodeLen	;patch wh_CodeLength
>a336	45 27				Name0:	.text "E'"	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=41656					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>a338	e2					.byte (("E'"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=24					WordFlags ::= IM+NN	; modifiable copy, remember for later
=12					LinkDisplacement = Nt0-WordListLink
>a339	18					.byte WordFlags	;wh_Flags
>a33a	03					.byte 3	;wh_CodeLength
>a33b	0c					  .byte LinkDisplacement	; offset to previous nt
=$a33c					XtPtr1 ::= *
=41656					WordListLink ::= Nt0 ; remember the nt of this word for later
.a33c	20 82 ca	jsr $ca82	EQuote:		jsr Parse_Name		; get string
.a33f	20 60 a3	jsr $a360			jsr ToEFloat		; convert
.a342	b5 24		lda $24,x			lda DStack+0,x		; error?
.a344	f0 0a		beq $a350			beq _Err
.a346	e8		inx				inx
.a347	e8		inx				inx
.a348	a5 0a		lda $0a				lda State		; compiling?
.a34a	d0 01		bne $a34d			bne _compile
.a34c	60		rts				rts
.a34d	4c 8f 9d	jmp $9d8f	_compile:	jmp ELiteral		; compile a FP literal
.a350	a9 36		lda #$36	_Err:		lda #100+err_FPInvalidArg
.a352	20 63 c4	jsr $c463			jsr ThrowA
=25					CodeLen	.var *-XtPtr1
=$a355					Here1 = *	; remember here
>a33a	19					.byte CodeLen	;patch wh_CodeLength
>a355	3e 45 46 6c 6f 61 74		Name0:	.text ">EFloat"	;  name of word as a string, ending at wh_NameLastChar
=7					NameLength = *-Name0
=41692					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>a35c	87					.byte ((">EFloat"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=36					LinkDisplacement = Nt0-WordListLink
>a35d	10					.byte WordFlags	;wh_Flags
>a35e	03					.byte 3	;wh_CodeLength
>a35f	24					  .byte LinkDisplacement	; offset to previous nt
=$a360					XtPtr1 ::= *
=41692					WordListLink ::= Nt0 ; remember the nt of this word for later
.a360					ToEFloat:
.a360	20 f2 c7	jsr $c7f2			jsr Zero	; alloc & init workspace
.a363	20 f2 c7	jsr $c7f2			jsr Zero
.a366	20 f2 c7	jsr $c7f2			jsr Zero
=$2c					_addr		= DStack+8
=$2a					_len		= DStack+6
=$29					_mantfound 	= DStack+5		;mantissa digits found
=$28					_exponent 	= DStack+4		;exponent
=$27					_decimalPos 	= DStack+3		;decimal point position
=$26					_DecPointFound1 = DStack+2
=$25					_MantissaNegative1 = DStack+1
=$24					_ExponentNegative1 = DStack+0
.a369	20 27 9e	jsr $9e27			jsr E0			; init result
.a36c	20 3d a4	jsr $a43d	_11:		jsr _GetChar		; get mantissa prefix
.a36f	b0 56		bcs $a3c7			bcs _trueb ;_finishb
.a371	c9 20		cmp #$20			cmp #' '
.a373	f0 f7		beq $a36c			beq _11
.a375	c9 2b		cmp #$2b			cmp #'+'
.a377	f0 06		beq $a37f			beq _20
.a379	c9 2d		cmp #$2d			cmp #'-'
.a37b	d0 07		bne $a384			bne _21
.a37d	95 25		sta $25,x			sta _MantissaNegative1,x ; remember mantissa is negative
.a37f	20 3d a4	jsr $a43d	_20:		jsr _GetChar		; do next mantissa digits
.a382	b0 46		bcs $a3ca			bcs _finishb
.a384	c9 2e		cmp #$2e	_21:		cmp #'.'
.a386	f0 31		beq $a3b9			beq _27
.a388	c9 45		cmp #$45			cmp #'E'
.a38a	f0 41		beq $a3cd			beq _30
.a38c	c9 65		cmp #$65			cmp #'e'
.a38e	f0 3d		beq $a3cd			beq _30
.a390	c9 44		cmp #$44			cmp #'D'
.a392	f0 39		beq $a3cd			beq _30
.a394	c9 64		cmp #$64			cmp #'d'
.a396	f0 35		beq $a3cd			beq _30
.a398	38		sec				sec			;   a digit?
.a399	e9 30		sbc #$30			sbc #'0'
.a39b	90 24		bcc $a3c1			bcc _fail
.a39d	c9 0a		cmp #$0a			cmp #9+1
.a39f	b0 20		bcs $a3c1			bcs _fail
.a3a1	48		pha				pha			; append digit to mantissa
.a3a2	20 1c 9f	jsr $9f1c			jsr E10Star
.a3a5	68		pla				pla
.a3a6	a0 00		ldy #$00			ldy #0
.a3a8	20 30 a1	jsr $a130			jsr SToEYA
.a3ab	20 6c a0	jsr $a06c			jsr EPlus
.a3ae	f6 29		inc $29,x			inc _mantfound,x	; remember we found a mantissa digit
.a3b0	b5 26		lda $26,x			lda _DecPointFound1,x	; if mantissa decimal point found
.a3b2	f0 02		beq $a3b6			beq +
.a3b4	d6 27		dec $27,x			dec _decimalPos,x	;   increment decimal point position
.a3b6					+
.a3b6	4c 7f a3	jmp $a37f			jmp _20
.a3b9					_27:
.a3b9	b4 26		ldy $26,x			ldy _DecPointFound1,x	; already have one?
.a3bb	d0 04		bne $a3c1			bne _fail
.a3bd	95 26		sta $26,x			sta _DecPointFound1,x	; we have one now!
.a3bf	f0 be		beq $a37f			beq _20
.a3c1					_fail:
.a3c1	e6 4c		inc $4c				inc FIndex		; EDrop
.a3c3	a9 00		lda #$00			lda #0			;return false
.a3c5	f0 69		beq $a430			beq _return
.a3c7	4c 2e a4	jmp $a42e	_trueb:		jmp _true
.a3ca	4c fb a3	jmp $a3fb	_finishb:	jmp _finish
.a3cd					_30:
.a3cd	20 3d a4	jsr $a43d			jsr _GetChar
.a3d0	b0 29		bcs $a3fb			bcs _finish
.a3d2	c9 2b		cmp #$2b			cmp #'+'
.a3d4	f0 06		beq $a3dc			beq _40
.a3d6	c9 2d		cmp #$2d			cmp #'-'
.a3d8	d0 07		bne $a3e1			bne _41
.a3da	95 24		sta $24,x			sta _ExponentNegative1,x ; remember exponent is negative
.a3dc	20 3d a4	jsr $a43d	_40:		jsr _GetChar		;get exponent digits
.a3df	b0 1a		bcs $a3fb			bcs _finish
.a3e1	38		sec		_41:		sec			;  digit?
.a3e2	e9 30		sbc #$30			sbc #'0'
.a3e4	90 db		bcc $a3c1			bcc _fail
.a3e6	c9 0a		cmp #$0a			cmp #9+1
.a3e8	b0 d7		bcs $a3c1			bcs _fail
.a3ea	85 14		sta $14				sta tmp1
.a3ec	16 28		asl $28,x			asl _exponent,x		;  exponent *= 10
.a3ee	b5 28		lda $28,x			lda _exponent,x
.a3f0	0a		asl a				asl a
.a3f1	0a		asl a				asl a
.a3f2	75 28		adc $28,x			adc _exponent,x
.a3f4	65 14		adc $14				adc tmp1		;  + digit
.a3f6	95 28		sta $28,x			sta _exponent,x
.a3f8	4c dc a3	jmp $a3dc			jmp _40
.a3fb					_finish:
.a3fb	b5 29		lda $29,x			lda _mantfound,x	;some mantissa digits found?
.a3fd	f0 c2		beq $a3c1			beq _fail
.a3ff	b5 24		lda $24,x			lda _ExponentNegative1,x ;apply exponent sign
.a401	f0 07		beq $a40a			beq +
.a403	a9 00		lda #$00			lda #0
.a405	38		sec				sec
.a406	f5 28		sbc $28,x			sbc _exponent,x
.a408	95 28		sta $28,x			sta _exponent,x
.a40a					+
.a40a	b5 28		lda $28,x			lda _exponent,x		;apply decimal position to exponent
.a40c	18		clc				clc
.a40d	75 27		adc $27,x			adc _decimalPos,x
.a40f	95 28		sta $28,x			sta _exponent,x
.a411	4c 19 a4	jmp $a419			jmp _93
.a414	20 1c 9f	jsr $9f1c	_93b:		jsr E10Star		;apply exponent to mantissa
.a417	d6 28		dec $28,x			dec _exponent,x
.a419	f0 0a		beq $a425	_93:		beq _94
.a41b	10 f7		bpl $a414			bpl _93b
.a41d	20 47 9e	jsr $9e47	_94b:		jsr E10
.a420	20 c9 8d	jsr $8dc9			jsr ESlash
.a423	f6 28		inc $28,x			inc _exponent,x
.a425	30 f6		bmi $a41d	_94:		bmi _94b
.a427					_95:
.a427	b5 25		lda $25,x			lda _MantissaNegative1,x ;apply mantissa sign
.a429	f0 03		beq $a42e			beq +
.a42b	20 c5 a0	jsr $a0c5			jsr ENegate
.a42e					+
.a42e	a9 ff		lda #$ff	_true:		lda #$ff		;return true
.a430					_return:
.a430	95 2c		sta $2c,x			sta _addr+0,x		; replace _addr with flag
.a432	95 2d		sta $2d,x			sta _addr+1,x
.a434	e8		inx				inx			; Drop work
.a435	e8		inx				inx
.a436	e8		inx				inx			; 2Drop work
.a437	e8		inx				inx
.a438	e8		inx				inx
.a439	e8		inx				inx
.a43a	e8		inx				inx			; Drop len
.a43b	e8		inx				inx
.a43c	60		rts				rts
.a43d					_GetChar:
.a43d	38		sec				sec
.a43e	b5 2a		lda $2a,x			lda _len,x
.a440	f0 0b		beq $a44d			beq _gc_rts		; if end, return C=1
.a442	d6 2a		dec $2a,x			dec _len,x
.a444	a1 2c		lda ($2c,x)			lda (_addr,x)
.a446	f6 2c		inc $2c,x			inc _addr+0,x
.a448	d0 02		bne $a44c			bne +
.a44a	f6 2d		inc $2d,x			inc _addr+1,x
.a44c					+
.a44c	18		clc				clc			; get char, return C=0
.a44d	60		rts		_gc_rts:	rts
>a44e	45 4b 65 79			Name0:	.text "EKey"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=41938					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>a452	24					.byte (("EKey"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=246					LinkDisplacement = Nt0-WordListLink
>a453	10					.byte WordFlags	;wh_Flags
>a454	03					.byte 3	;wh_CodeLength
>a455	f6					  .byte LinkDisplacement	; offset to previous nt
=$a456					XtPtr1 ::= *
=41938					WordListLink ::= Nt0 ; remember the nt of this word for later
.a456					EKey:
.a456	20 62 da	jsr $da62			jsr Here		; ( addr )
.a459	20 62 da	jsr $da62			jsr Here		; ( addr addr )
.a45c	a9 28		lda #$28			lda #40			; ( addr addr 40 )
.a45e	20 e4 c7	jsr $c7e4			jsr PushZA
.a461	20 d9 d2	jsr $d2d9			jsr Accept		; ( addr len )
.a464	20 60 a3	jsr $a360			jsr ToEFloat		; ( true | false)
.a467	e8		inx				inx			; err?
.a468	e8		inx				inx
.a469	b5 22		lda $22,x			lda DStack-2,x
.a46b	f0 01		beq $a46e			beq _err
.a46d	60		rts				rts
.a46e	20 b8 c8	jsr $c8b8	_err:		jsr SLiteral_runtime
.a471	4c 77 a4	jmp $a477			  jmp +
>a474	20 3f 20					  .text " ? "
.a477	20 34 de	jsr $de34	+		jsr Type
.a47a	4c 56 a4	jmp $a456			jmp EKey
>a47d	45 4d 50 6f 6c 79		Name0:	.text "EMPoly"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=41987					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>a483	26					.byte (("EMPoly"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=49					LinkDisplacement = Nt0-WordListLink
>a484	10					.byte WordFlags	;wh_Flags
>a485	03					.byte 3	;wh_CodeLength
>a486	31					  .byte LinkDisplacement	; offset to previous nt
=$a487					XtPtr1 ::= *
=41987					WordListLink ::= Nt0 ; remember the nt of this word for later
.a487	20 de c3	jsr $c3de	EMPoly:		jsr PopYA
.a48a	20 b5 c7	jsr $c7b5	EMPolyYA:	jsr PushYA		; push coefficent addr
.a48d	20 eb 9b	jsr $9beb			jsr EAt_YA		; fetch 1st coefficent
.a490	4c a3 a4	jmp $a4a3			jmp _4
.a493	20 2e 9b	jsr $9b2e	_2:		jsr EOver
.a496	20 4d 8d	jsr $8d4d			jsr EStar
.a499	b5 24		lda $24,x			lda DStack+0,x		; fetch next coefficent
.a49b	b4 25		ldy $25,x			ldy DStack+1,x
.a49d	20 eb 9b	jsr $9beb			jsr EAt_YA
.a4a0	20 6c a0	jsr $a06c			jsr EPlus
.a4a3	a9 03		lda #$03	_4:		lda #EFloat_Size	; bump coefficent ptr
.a4a5	20 43 da	jsr $da43			jsr Plus_A
.a4a8	a1 24		lda ($24,x)			lda (DStack+0,x)	; end of coefficent list?
.a4aa	d0 e7		bne $a493			bne _2
.a4ac	e8		inx				inx			; Drop coefficent ptr
.a4ad	e8		inx				inx
=39					CodeLen	.var *-XtPtr1
=$a4ae					Here1 = *	; remember here
>a485	27					.byte CodeLen	;patch wh_CodeLength
.a4ae	60		rts				rts
>a4af	45 4c 6f 67 32 4d 31 4d		Name0:	.text "ELog2M1M"	;  name of word as a string, ending at wh_NameLastChar
=8					NameLength = *-Name0
=42039					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>a4b7	a8					.byte (("ELog2M1M"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=52					LinkDisplacement = Nt0-WordListLink
>a4b8	10					.byte WordFlags	;wh_Flags
>a4b9	03					.byte 3	;wh_CodeLength
>a4ba	34					  .byte LinkDisplacement	; offset to previous nt
=$a4bb					XtPtr1 ::= *
=42039					WordListLink ::= Nt0 ; remember the nt of this word for later
.a4bb	a9 c5		lda #$c5	ELog2M1M:	lda #<_c
.a4bd	a0 a4		ldy #$a4			ldy #>_c
.a4bf	20 8a a4	jsr $a48a			jsr EMPolyYA
.a4c2	4c 4d 8d	jmp $8d4d			jmp EStar
=10					CodeLen	.var *-XtPtr1
=$a4c5					Here1 = *	; remember here
>a4b9	0a					.byte CodeLen	;patch wh_CodeLength
.a4c5					_c:
>a4c5	e6 ab						.word $abe6		; 16 bit signed binary mantissa.  $4000 = +0.5
>a4c7	fd						.char -3		; 8 bit signed exponent.  $00 = 2**0
>a4c8	39 52						.word $5239		; 16 bit signed binary mantissa.  $4000 = +0.5
>a4ca	ff						.char -1		; 8 bit signed exponent.  $00 = 2**0
>a4cb	3e a9						.word $a93e		; 16 bit signed binary mantissa.  $4000 = +0.5
>a4cd	00						.char 0		; 8 bit signed exponent.  $00 = 2**0
>a4ce	14 5c						.word $5c14		; 16 bit signed binary mantissa.  $4000 = +0.5
>a4d0	01						.char 1		; 8 bit signed exponent.  $00 = 2**0
>a4d1	00					.byte 0
>a4d2	45 4c 6f 67 32			Name0:	.text "ELog2"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=42071					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>a4d7	45					.byte (("ELog2"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=32					LinkDisplacement = Nt0-WordListLink
>a4d8	10					.byte WordFlags	;wh_Flags
>a4d9	03					.byte 3	;wh_CodeLength
>a4da	20					  .byte LinkDisplacement	; offset to previous nt
=$a4db					XtPtr1 ::= *
=42071					WordListLink ::= Nt0 ; remember the nt of this word for later
.a4db	a4 4c		ldy $4c		ELog2:		ldy FIndex
.a4dd	b9 57 00	lda $0057,y			lda FSMant0,y	; bad param?
.a4e0	30 20		bmi $a502			bmi _OutOfRange
.a4e2	f0 1e		beq $a502			beq _OutOfRange
.a4e4	b9 4d 00	lda $004d,y			lda FSExp,y
.a4e7	48		pha				pha		; remember orig exponent
.a4e8	a9 01		lda #$01			lda #1
.a4ea	99 4d 00	sta $004d,y			sta FSExp,y	; set to 1
.a4ed	20 b4 a0	jsr $a0b4			jsr E1Minus
.a4f0	20 bb a4	jsr $a4bb			jsr ELog2M1M
.a4f3	a0 00		ldy #$00			ldy #0		; add orig exponent to float
.a4f5	68		pla				pla
.a4f6	38		sec				sec
.a4f7	e9 01		sbc #$01			sbc #1
.a4f9	10 01		bpl $a4fc			bpl +
.a4fb	88		dey				dey
.a4fc					+
.a4fc	20 30 a1	jsr $a130			jsr SToEYA
.a4ff	4c 6c a0	jmp $a06c			jmp EPlus
.a502	4c 3e c4	jmp $c43e	_OutOfRange:	jmp Throw_FpOutOfRange
=42					CodeLen	.var *-XtPtr1
=$a505					Here1 = *	; remember here
>a4d9	2a					.byte CodeLen	;patch wh_CodeLength
>a505	45 4c 6e			Name0:	.text "ELn"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=42120					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>a508	c3					.byte (("ELn"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=49					LinkDisplacement = Nt0-WordListLink
>a509	10					.byte WordFlags	;wh_Flags
>a50a	03					.byte 3	;wh_CodeLength
>a50b	31					  .byte LinkDisplacement	; offset to previous nt
=$a50c					XtPtr1 ::= *
=42120					WordListLink ::= Nt0 ; remember the nt of this word for later
.a50c	20 db a4	jsr $a4db	ELn:		jsr ELog2
.a50f	20 c7 9d	jsr $9dc7			jsr ELitI
>a512	b9 58						.word $58b9		; 16 bit signed binary mantissa.  $4000 = +0.5
>a514	00						.char 0		; 8 bit signed exponent.  $00 = 2**0
.a515	4c 4d 8d	jmp $8d4d			jmp EStar
=12					CodeLen	.var *-XtPtr1
=$a518					Here1 = *	; remember here
>a50a	0c					.byte CodeLen	;patch wh_CodeLength
>a518	45 4c 6e 50 31			Name0:	.text "ELnP1"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=42141					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>a51d	25					.byte (("ELnP1"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=21					LinkDisplacement = Nt0-WordListLink
>a51e	10					.byte WordFlags	;wh_Flags
>a51f	03					.byte 3	;wh_CodeLength
>a520	15					  .byte LinkDisplacement	; offset to previous nt
=$a521					XtPtr1 ::= *
=42141					WordListLink ::= Nt0 ; remember the nt of this word for later
.a521	20 90 a0	jsr $a090	ElnP1:		jsr E1Plus
.a524	4c 0c a5	jmp $a50c			jmp ELn
=6					CodeLen	.var *-XtPtr1
=$a527					Here1 = *	; remember here
>a51f	06					.byte CodeLen	;patch wh_CodeLength
>a527	45 4c 6f 67			Name0:	.text "ELog"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=42155					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>a52b	e4					.byte (("ELog"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=14					LinkDisplacement = Nt0-WordListLink
>a52c	10					.byte WordFlags	;wh_Flags
>a52d	03					.byte 3	;wh_CodeLength
>a52e	0e					  .byte LinkDisplacement	; offset to previous nt
=$a52f					XtPtr1 ::= *
=42155					WordListLink ::= Nt0 ; remember the nt of this word for later
.a52f	20 db a4	jsr $a4db	ELog:		jsr ELog2
.a532	20 c7 9d	jsr $9dc7			jsr ELitI
>a535	10 4d						.word $4d10		; 16 bit signed binary mantissa.  $4000 = +0.5
>a537	ff						.char -1		; 8 bit signed exponent.  $00 = 2**0
.a538	4c 4d 8d	jmp $8d4d			jmp EStar
=12					CodeLen	.var *-XtPtr1
=$a53b					Here1 = *	; remember here
>a52d	0c					.byte CodeLen	;patch wh_CodeLength
>a53b	45 45 78 70 32 4d 31 4d		Name0:	.text "EExp2M1M"	;  name of word as a string, ending at wh_NameLastChar
=8					NameLength = *-Name0
=42179					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>a543	a8					.byte (("EExp2M1M"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=24					LinkDisplacement = Nt0-WordListLink
>a544	10					.byte WordFlags	;wh_Flags
>a545	03					.byte 3	;wh_CodeLength
>a546	18					  .byte LinkDisplacement	; offset to previous nt
=$a547					XtPtr1 ::= *
=42179					WordListLink ::= Nt0 ; remember the nt of this word for later
.a547	a9 51		lda #$51	EExp2M1M:	lda #<_c
.a549	a0 a5		ldy #$a5			ldy #>_c
.a54b	20 8a a4	jsr $a48a			jsr EMPolyYA
.a54e	4c 4d 8d	jmp $8d4d			jmp EStar
=10					CodeLen	.var *-XtPtr1
=$a551					Here1 = *	; remember here
>a545	0a					.byte CodeLen	;patch wh_CodeLength
.a551					_c:
>a551	26 51						.word $5126		; 16 bit signed binary mantissa.  $4000 = +0.5
>a553	fd						.char -3		; 8 bit signed exponent.  $00 = 2**0
>a554	21 73						.word $7321		; 16 bit signed binary mantissa.  $4000 = +0.5
>a556	fe						.char -2		; 8 bit signed exponent.  $00 = 2**0
>a557	13 59						.word $5913		; 16 bit signed binary mantissa.  $4000 = +0.5
>a559	00						.char 0		; 8 bit signed exponent.  $00 = 2**0
>a55a	00					.byte 0
>a55b	45 45 78 70 32			Name0:	.text "EExp2"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=42208					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>a560	45					.byte (("EExp2"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=29					LinkDisplacement = Nt0-WordListLink
>a561	10					.byte WordFlags	;wh_Flags
>a562	03					.byte 3	;wh_CodeLength
>a563	1d					  .byte LinkDisplacement	; offset to previous nt
=$a564					XtPtr1 ::= *
=42208					WordListLink ::= Nt0 ; remember the nt of this word for later
.a564	20 cc 9f	jsr $9fcc	EExp2:		jsr EIntFrc	; ( f: r_rem r_int )
.a567	20 45 a1	jsr $a145			jsr EToS
.a56a	20 47 a5	jsr $a547			jsr EExp2M1M
.a56d	20 90 a0	jsr $a090			jsr E1Plus
.a570	20 c3 c3	jsr $c3c3			jsr PopA
.a573	a4 4c		ldy $4c				ldy FIndex
.a575	18		clc				clc
.a576	79 4d 00	adc $004d,y			adc FSExp,y
.a579	99 4d 00	sta $004d,y			sta FSExp,y
=24					CodeLen	.var *-XtPtr1
=$a57c					Here1 = *	; remember here
>a562	18					.byte CodeLen	;patch wh_CodeLength
.a57c	60		rts				rts
>a57d	45 45 78 70			Name0:	.text "EExp"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=42241					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>a581	04					.byte (("EExp"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=33					LinkDisplacement = Nt0-WordListLink
>a582	10					.byte WordFlags	;wh_Flags
>a583	03					.byte 3	;wh_CodeLength
>a584	21					  .byte LinkDisplacement	; offset to previous nt
=$a585					XtPtr1 ::= *
=42241					WordListLink ::= Nt0 ; remember the nt of this word for later
.a585					EExp:
.a585	20 c7 9d	jsr $9dc7			jsr ELitI
>a588	55 5c						.word $5c55		; 16 bit signed binary mantissa.  $4000 = +0.5
>a58a	01						.char 1		; 8 bit signed exponent.  $00 = 2**0
.a58b	20 4d 8d	jsr $8d4d			jsr EStar
.a58e	4c 64 a5	jmp $a564			jmp EExp2
=12					CodeLen	.var *-XtPtr1
=$a591					Here1 = *	; remember here
>a583	0c					.byte CodeLen	;patch wh_CodeLength
>a591	45 45 78 70 4d 31		Name0:	.text "EExpM1"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=42263					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>a597	26					.byte (("EExpM1"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=22					LinkDisplacement = Nt0-WordListLink
>a598	10					.byte WordFlags	;wh_Flags
>a599	03					.byte 3	;wh_CodeLength
>a59a	16					  .byte LinkDisplacement	; offset to previous nt
=$a59b					XtPtr1 ::= *
=42263					WordListLink ::= Nt0 ; remember the nt of this word for later
.a59b	20 85 a5	jsr $a585	EExpM1:		jsr EExp
.a59e	4c b4 a0	jmp $a0b4			jmp E1Minus
=6					CodeLen	.var *-XtPtr1
=$a5a1					Here1 = *	; remember here
>a599	06					.byte CodeLen	;patch wh_CodeLength
>a5a1	45 41 4c 6f 67			Name0:	.text "EALog"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=42278					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>a5a6	e5					.byte (("EALog"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=15					LinkDisplacement = Nt0-WordListLink
>a5a7	10					.byte WordFlags	;wh_Flags
>a5a8	03					.byte 3	;wh_CodeLength
>a5a9	0f					  .byte LinkDisplacement	; offset to previous nt
=$a5aa					XtPtr1 ::= *
=42278					WordListLink ::= Nt0 ; remember the nt of this word for later
.a5aa					EALog:
.a5aa	20 c7 9d	jsr $9dc7			jsr ELitI
>a5ad	4d 6a						.word $6a4d		; 16 bit signed binary mantissa.  $4000 = +0.5
>a5af	02						.char 2		; 8 bit signed exponent.  $00 = 2**0
.a5b0	20 4d 8d	jsr $8d4d			jsr EStar
.a5b3	4c 64 a5	jmp $a564			jmp EExp2
=12					CodeLen	.var *-XtPtr1
=$a5b6					Here1 = *	; remember here
>a5a8	0c					.byte CodeLen	;patch wh_CodeLength
>a5b6	45 2a 2a			Name0:	.text "E**"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=42297					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>a5b9	43					.byte (("E**"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=19					LinkDisplacement = Nt0-WordListLink
>a5ba	10					.byte WordFlags	;wh_Flags
>a5bb	03					.byte 3	;wh_CodeLength
>a5bc	13					  .byte LinkDisplacement	; offset to previous nt
=$a5bd					XtPtr1 ::= *
=42297					WordListLink ::= Nt0 ; remember the nt of this word for later
.a5bd	20 7d 9b	jsr $9b7d	EPower:		jsr ESwap
.a5c0	20 db a4	jsr $a4db			jsr ELog2
.a5c3	20 4d 8d	jsr $8d4d			jsr EStar
.a5c6	4c 64 a5	jmp $a564			jmp EExp2
=12					CodeLen	.var *-XtPtr1
=$a5c9					Here1 = *	; remember here
>a5bb	0c					.byte CodeLen	;patch wh_CodeLength
>a5c9	45 44 65 67 32 52 61 64		Name0:	.text "EDeg2Rad"	;  name of word as a string, ending at wh_NameLastChar
=8					NameLength = *-Name0
=42321					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>a5d1	88					.byte (("EDeg2Rad"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=24					LinkDisplacement = Nt0-WordListLink
>a5d2	10					.byte WordFlags	;wh_Flags
>a5d3	03					.byte 3	;wh_CodeLength
>a5d4	18					  .byte LinkDisplacement	; offset to previous nt
=$a5d5					XtPtr1 ::= *
=42321					WordListLink ::= Nt0 ; remember the nt of this word for later
.a5d5					EDeg2Rad:
.a5d5	20 c7 9d	jsr $9dc7			jsr ELitI
>a5d8	7d 47						.word $477d		; 16 bit signed binary mantissa.  $4000 = +0.5
>a5da	fb						.char -5		; 8 bit signed exponent.  $00 = 2**0
.a5db	4c 4d 8d	jmp $8d4d			jmp EStar
=9					CodeLen	.var *-XtPtr1
=$a5de					Here1 = *	; remember here
>a5d3	09					.byte CodeLen	;patch wh_CodeLength
>a5de	45 52 61 64 32 44 65 67		Name0:	.text "ERad2Deg"	;  name of word as a string, ending at wh_NameLastChar
=8					NameLength = *-Name0
=42342					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>a5e6	e8					.byte (("ERad2Deg"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=21					LinkDisplacement = Nt0-WordListLink
>a5e7	10					.byte WordFlags	;wh_Flags
>a5e8	03					.byte 3	;wh_CodeLength
>a5e9	15					  .byte LinkDisplacement	; offset to previous nt
=$a5ea					XtPtr1 ::= *
=42342					WordListLink ::= Nt0 ; remember the nt of this word for later
.a5ea					ERad2Deg:
.a5ea	20 c7 9d	jsr $9dc7			jsr ELitI
>a5ed	97 72						.word $7297		; 16 bit signed binary mantissa.  $4000 = +0.5
>a5ef	06						.char 6		; 8 bit signed exponent.  $00 = 2**0
.a5f0	4c 4d 8d	jmp $8d4d			jmp EStar
=9					CodeLen	.var *-XtPtr1
=$a5f3					Here1 = *	; remember here
>a5e8	09					.byte CodeLen	;patch wh_CodeLength
>a5f3	45 41 52 65 64 75 63 65		Name0:	.text "EAReduce"	;  name of word as a string, ending at wh_NameLastChar
=8					NameLength = *-Name0
=42363					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>a5fb	a8					.byte (("EAReduce"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=21					LinkDisplacement = Nt0-WordListLink
>a5fc	10					.byte WordFlags	;wh_Flags
>a5fd	03					.byte 3	;wh_CodeLength
>a5fe	15					  .byte LinkDisplacement	; offset to previous nt
=$a5ff					XtPtr1 ::= *
=42363					WordListLink ::= Nt0 ; remember the nt of this word for later
.a5ff	a4 4c		ldy $4c		EAReduce:	ldy FIndex
.a601	b9 57 00	lda $0057,y			lda FSMant0,y		; zero?
.a604	f0 2f		beq $a635			beq _ok
.a606	b9 4d 00	lda $004d,y			lda FSExp,y		; get exponent
.a609	30 2a		bmi $a635			bmi _ok			; small?
.a60b	c9 01		cmp #$01			cmp #1			; maybe need mirror?
.a60d	30 26		bmi $a635			bmi _ok			;if exponent <=0
.a60f	f0 24		beq $a635			beq _ok
.a611	c9 02		cmp #$02			cmp #2			; maybe need rotation?
.a613	b0 22		bcs $a637			bcs _exp2
.a615	b9 57 00	lda $0057,y			lda FSMant0,y
.a618	c9 65		cmp #$65			cmp #$65		;in -pi/2..pi/2 ?
.a61a	90 19		bcc $a635			bcc _ok
.a61c	c9 9b		cmp #$9b			cmp #$100-$65
.a61e	b0 15		bcs $a635			bcs _ok
.a620					_mir:
.a620	20 7e 9e	jsr $9e7e			jsr EPi
.a623	a4 4c		ldy $4c				ldy FIndex
.a625	b9 58 00	lda $0058,y			lda FSMant0+1,y
.a628	10 03		bpl $a62d			bpl _3
.a62a	20 c5 a0	jsr $a0c5			jsr ENegate
.a62d	20 7d 9b	jsr $9b7d	_3:		jsr ESwap
.a630	20 9c a0	jsr $a09c			jsr EMinus
.a633	38		sec				sec		; mirrored
.a634	60		rts				rts
.a635	18		clc		_ok:		clc		; not mirrored
.a636	60		rts				rts
.a637	d0 0b		bne $a644	_exp2:		bne _rot	;if exp>2 then fix
.a639	b9 57 00	lda $0057,y			lda FSMant0,y
.a63c	c9 65		cmp #$65			cmp #$65	;if mant>pi or mant<-pi then fix
.a63e	90 e0		bcc $a620			bcc _mir
.a640	c9 9b		cmp #$9b			cmp #$100-$65
.a642	b0 dc		bcs $a620			bcs _mir
.a644	20 aa 9e	jsr $9eaa	_rot:		jsr E2Pi
.a647	20 c9 8d	jsr $8dc9			jsr ESlash
.a64a	20 cc 9f	jsr $9fcc			jsr EIntFrc
.a64d	e6 4c		inc $4c				inc FIndex	; FDrop integer part
.a64f	a4 4c		ldy $4c				ldy FIndex	;if >=.5
.a651	b9 4d 00	lda $004d,y			lda FSExp,y
.a654	a8		tay				tay
.a655	30 03		bmi $a65a			bmi _rot4
.a657	20 b4 a0	jsr $a0b4			jsr E1Minus	;  subtract 1
.a65a	20 aa 9e	jsr $9eaa	_rot4:		jsr E2Pi
.a65d	20 4d 8d	jsr $8d4d			jsr EStar
.a660	4c ff a5	jmp $a5ff			jmp EAReduce	; rotate done, look again
=100					CodeLen	.var *-XtPtr1
=$a663					Here1 = *	; remember here
>a5fd	64					.byte CodeLen	;patch wh_CodeLength
>a663	45 53 69 6e			Name0:	.text "ESin"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=42471					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>a667	c4					.byte (("ESin"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=108					LinkDisplacement = Nt0-WordListLink
>a668	10					.byte WordFlags	;wh_Flags
>a669	03					.byte 3	;wh_CodeLength
>a66a	6c					  .byte LinkDisplacement	; offset to previous nt
=$a66b					XtPtr1 ::= *
=42471					WordListLink ::= Nt0 ; remember the nt of this word for later
.a66b	20 ff a5	jsr $a5ff	ESin:		jsr EAReduce
.a66e	20 13 9b	jsr $9b13	ESinM:		jsr EDup
.a671	20 bd 8d	jsr $8dbd			jsr ESqr	; x x^2
.a674	a9 84		lda #$84			lda #<_c
.a676	a0 a6		ldy #$a6			ldy #>_c
.a678	20 8a a4	jsr $a48a			jsr EMPolyYA
.a67b	20 4d 8d	jsr $8d4d			jsr EStar
.a67e	20 90 a0	jsr $a090			jsr E1Plus	; C0 +1.0
.a681	4c 4d 8d	jmp $8d4d			jmp EStar
=25					CodeLen	.var *-XtPtr1
=$a684					Here1 = *	; remember here
>a669	19					.byte CodeLen	;patch wh_CodeLength
.a684					_c:
>a684	65 7c						.word $7c65		; 16 bit signed binary mantissa.  $4000 = +0.5
>a686	f9						.char -7		; 8 bit signed exponent.  $00 = 2**0
>a687	01 ab						.word $ab01		; 16 bit signed binary mantissa.  $4000 = +0.5
>a689	fe						.char -2		; 8 bit signed exponent.  $00 = 2**0
>a68a	00					.byte 0			; end
>a68b	45 43 73 63			Name0:	.text "ECsc"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=42511					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>a68f	64					.byte (("ECsc"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=40					LinkDisplacement = Nt0-WordListLink
>a690	10					.byte WordFlags	;wh_Flags
>a691	03					.byte 3	;wh_CodeLength
>a692	28					  .byte LinkDisplacement	; offset to previous nt
=$a693					XtPtr1 ::= *
=42511					WordListLink ::= Nt0 ; remember the nt of this word for later
.a693	20 6b a6	jsr $a66b	ECsc:		jsr ESin
.a696	4c 23 8e	jmp $8e23			jmp E1Slash		; 1/SIN(r1)
=6					CodeLen	.var *-XtPtr1
=$a699					Here1 = *	; remember here
>a691	06					.byte CodeLen	;patch wh_CodeLength
>a699	45 43 6f 73			Name0:	.text "ECos"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=42525					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>a69d	64					.byte (("ECos"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=14					LinkDisplacement = Nt0-WordListLink
>a69e	10					.byte WordFlags	;wh_Flags
>a69f	03					.byte 3	;wh_CodeLength
>a6a0	0e					  .byte LinkDisplacement	; offset to previous nt
=$a6a1					XtPtr1 ::= *
=42525					WordListLink ::= Nt0 ; remember the nt of this word for later
.a6a1	20 8d 9e	jsr $9e8d	ECos:		jsr EPiH
.a6a4	20 6c a0	jsr $a06c			jsr EPlus
.a6a7	4c 6b a6	jmp $a66b			jmp ESin
=9					CodeLen	.var *-XtPtr1
=$a6aa					Here1 = *	; remember here
>a69f	09					.byte CodeLen	;patch wh_CodeLength
>a6aa	45 53 65 63			Name0:	.text "ESec"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=42542					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>a6ae	64					.byte (("ESec"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=17					LinkDisplacement = Nt0-WordListLink
>a6af	10					.byte WordFlags	;wh_Flags
>a6b0	03					.byte 3	;wh_CodeLength
>a6b1	11					  .byte LinkDisplacement	; offset to previous nt
=$a6b2					XtPtr1 ::= *
=42542					WordListLink ::= Nt0 ; remember the nt of this word for later
.a6b2	20 a1 a6	jsr $a6a1	ESec:		jsr ECos
.a6b5	4c 23 8e	jmp $8e23			jmp E1Slash		; 1/COS(r1)
=6					CodeLen	.var *-XtPtr1
=$a6b8					Here1 = *	; remember here
>a6b0	06					.byte CodeLen	;patch wh_CodeLength
>a6b8	45 53 69 6e 43 6f 73		Name0:	.text "ESinCos"	;  name of word as a string, ending at wh_NameLastChar
=7					NameLength = *-Name0
=42559					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>a6bf	67					.byte (("ESinCos"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=17					LinkDisplacement = Nt0-WordListLink
>a6c0	10					.byte WordFlags	;wh_Flags
>a6c1	03					.byte 3	;wh_CodeLength
>a6c2	11					  .byte LinkDisplacement	; offset to previous nt
=$a6c3					XtPtr1 ::= *
=42559					WordListLink ::= Nt0 ; remember the nt of this word for later
.a6c3	20 53 85	jsr $8553	ESinCos:	jsr FDup
.a6c6	20 3d 96	jsr $963d			jsr FSin
.a6c9	20 d7 85	jsr $85d7			jsr FSwap
.a6cc	4c 81 96	jmp $9681			jmp FCos
=12					CodeLen	.var *-XtPtr1
=$a6cf					Here1 = *	; remember here
>a6c1	0c					.byte CodeLen	;patch wh_CodeLength
>a6cf	45 54 61 6e			Name0:	.text "ETan"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=42579					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>a6d3	c4					.byte (("ETan"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=20					LinkDisplacement = Nt0-WordListLink
>a6d4	10					.byte WordFlags	;wh_Flags
>a6d5	03					.byte 3	;wh_CodeLength
>a6d6	14					  .byte LinkDisplacement	; offset to previous nt
=$a6d7					XtPtr1 ::= *
=42579					WordListLink ::= Nt0 ; remember the nt of this word for later
.a6d7	20 ff a5	jsr $a5ff	ETan:		jsr EAReduce
.a6da	90 06		bcc $a6e2			bcc _30
.a6dc	20 e2 a6	jsr $a6e2			jsr _30
.a6df	4c c5 a0	jmp $a0c5			jmp ENegate
.a6e2					_30:
.a6e2	20 13 9b	jsr $9b13			jsr EDup
.a6e5	20 df a0	jsr $a0df			jsr EAbs
.a6e8	20 9c 9e	jsr $9e9c			jsr EPiQ
.a6eb	20 ed 9c	jsr $9ced			jsr ELe
.a6ee	e8		inx				inx			; pop f
.a6ef	e8		inx				inx
.a6f0	b5 24		lda $24,x			lda DStack+0,x
.a6f2	d0 19		bne $a70d			bne ETanM
.a6f4	20 8d 9e	jsr $9e8d			jsr EPiH
.a6f7	a4 4c		ldy $4c				ldy FIndex		; get sign
.a6f9	b9 57 00	lda $0057,y			lda FSMant0,y
.a6fc	10 03		bpl $a701			bpl +
.a6fe	20 c5 a0	jsr $a0c5			jsr ENegate
.a701					+
.a701	20 7d 9b	jsr $9b7d			jsr ESwap
.a704	20 9c a0	jsr $a09c			jsr EMinus
.a707	20 0d a7	jsr $a70d			jsr ETanM
.a70a	4c 23 8e	jmp $8e23			jmp E1Slash
=54					CodeLen	.var *-XtPtr1
=$a70d					Here1 = *	; remember here
>a6d5	36					.byte CodeLen	;patch wh_CodeLength
.a70d	20 13 9b	jsr $9b13	ETanM:		jsr EDup
.a710	20 bd 8d	jsr $8dbd			jsr ESqr		; x x^2
.a713	a9 23		lda #$23			lda #<_c
.a715	a0 a7		ldy #$a7			ldy #>_c
.a717	20 8a a4	jsr $a48a			jsr EMPolyYA
.a71a	20 4d 8d	jsr $8d4d			jsr EStar
.a71d	20 90 a0	jsr $a090			jsr E1Plus		; c0 1.0
.a720	4c 4d 8d	jmp $8d4d			jmp EStar
=76					CodeLen	.var *-XtPtr1
=$a723					Here1 = *	; remember here
>a6d5	4c					.byte CodeLen	;patch wh_CodeLength
.a723					_c:
>a723	b6 64						.word $64b6		; 16 bit signed binary mantissa.  $4000 = +0.5
>a725	fd						.char -3		; 8 bit signed exponent.  $00 = 2**0
>a726	50 73						.word $7350		; 16 bit signed binary mantissa.  $4000 = +0.5
>a728	fd						.char -3		; 8 bit signed exponent.  $00 = 2**0
>a729	09 56						.word $5609		; 16 bit signed binary mantissa.  $4000 = +0.5
>a72b	ff						.char -1		; 8 bit signed exponent.  $00 = 2**0
>a72c	00					.byte 0			; end
>a72d	45 43 6f 74			Name0:	.text "ECot"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=42673					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>a731	84					.byte (("ECot"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=94					LinkDisplacement = Nt0-WordListLink
>a732	10					.byte WordFlags	;wh_Flags
>a733	03					.byte 3	;wh_CodeLength
>a734	5e					  .byte LinkDisplacement	; offset to previous nt
=$a735					XtPtr1 ::= *
=42673					WordListLink ::= Nt0 ; remember the nt of this word for later
.a735	20 d7 a6	jsr $a6d7	ECot:		jsr ETan
.a738	4c 23 8e	jmp $8e23			jmp E1Slash	; =1/TAN(r1)
=6					CodeLen	.var *-XtPtr1
=$a73b					Here1 = *	; remember here
>a733	06					.byte CodeLen	;patch wh_CodeLength
>a73b	45 41 43 6f 73			Name0:	.text "EACos"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=42688					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>a740	65					.byte (("EACos"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=15					LinkDisplacement = Nt0-WordListLink
>a741	10					.byte WordFlags	;wh_Flags
>a742	03					.byte 3	;wh_CodeLength
>a743	0f					  .byte LinkDisplacement	; offset to previous nt
=$a744					XtPtr1 ::= *
=42688					WordListLink ::= Nt0 ; remember the nt of this word for later
.a744	a4 4c		ldy $4c		EACos:		ldy FIndex
.a746	b9 57 00	lda $0057,y			lda FSMant0,y
.a749	08		php				php			; save sign
.a74a	20 df a0	jsr $a0df			jsr EAbs
.a74d	a9 70		lda #$70			lda #<_c
.a74f	a0 a7		ldy #$a7			ldy #>_c
.a751	20 8a a4	jsr $a48a			jsr EMPolyYA
.a754	20 7d 9b	jsr $9b7d			jsr ESwap
.a757	20 c5 a0	jsr $a0c5			jsr ENegate
.a75a	20 90 a0	jsr $a090			jsr E1Plus
.a75d	20 9b a1	jsr $a19b			jsr ESqrt
.a760	20 4d 8d	jsr $8d4d			jsr EStar
.a763	28		plp				plp			; was r1 negative?
.a764	10 09		bpl $a76f			bpl +
.a766	20 7e 9e	jsr $9e7e			jsr EPi
.a769	20 7d 9b	jsr $9b7d			jsr ESwap
.a76c	20 9c a0	jsr $a09c			jsr EMinus
.a76f					+
=43					CodeLen	.var *-XtPtr1
=$a76f					Here1 = *	; remember here
>a742	2b					.byte CodeLen	;patch wh_CodeLength
.a76f	60		rts				rts
.a770					_c:
>a770	e6 b2						.word $b2e6		; 16 bit signed binary mantissa.  $4000 = +0.5
>a772	fb						.char -5		; 8 bit signed exponent.  $00 = 2**0
>a773	92 4c						.word $4c92		; 16 bit signed binary mantissa.  $4000 = +0.5
>a775	fd						.char -3		; 8 bit signed exponent.  $00 = 2**0
>a776	2f 93						.word $932f		; 16 bit signed binary mantissa.  $4000 = +0.5
>a778	fe						.char -2		; 8 bit signed exponent.  $00 = 2**0
>a779	88 64						.word $6488		; 16 bit signed binary mantissa.  $4000 = +0.5
>a77b	01						.char 1		; 8 bit signed exponent.  $00 = 2**0
>a77c	00					.byte 0			; end
>a77d	45 41 53 65 63			Name0:	.text "EASec"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=42754					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>a782	65					.byte (("EASec"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=66					LinkDisplacement = Nt0-WordListLink
>a783	10					.byte WordFlags	;wh_Flags
>a784	03					.byte 3	;wh_CodeLength
>a785	42					  .byte LinkDisplacement	; offset to previous nt
=$a786					XtPtr1 ::= *
=42754					WordListLink ::= Nt0 ; remember the nt of this word for later
.a786	20 23 8e	jsr $8e23	EASec:		jsr E1Slash
.a789	4c 44 a7	jmp $a744			jmp EACos
=6					CodeLen	.var *-XtPtr1
=$a78c					Here1 = *	; remember here
>a784	06					.byte CodeLen	;patch wh_CodeLength
>a78c	45 41 53 69 6e			Name0:	.text "EASin"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=42769					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>a791	c5					.byte (("EASin"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=15					LinkDisplacement = Nt0-WordListLink
>a792	10					.byte WordFlags	;wh_Flags
>a793	03					.byte 3	;wh_CodeLength
>a794	0f					  .byte LinkDisplacement	; offset to previous nt
=$a795					XtPtr1 ::= *
=42769					WordListLink ::= Nt0 ; remember the nt of this word for later
.a795	20 44 a7	jsr $a744	EASin:		jsr EACos
.a798	20 c5 a0	jsr $a0c5			jsr ENegate
.a79b	20 8d 9e	jsr $9e8d			jsr EPiH
.a79e	4c 6c a0	jmp $a06c			jmp EPlus
=12					CodeLen	.var *-XtPtr1
=$a7a1					Here1 = *	; remember here
>a793	0c					.byte CodeLen	;patch wh_CodeLength
>a7a1	45 41 43 73 63			Name0:	.text "EACsc"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=42790					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>a7a6	65					.byte (("EACsc"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=21					LinkDisplacement = Nt0-WordListLink
>a7a7	10					.byte WordFlags	;wh_Flags
>a7a8	03					.byte 3	;wh_CodeLength
>a7a9	15					  .byte LinkDisplacement	; offset to previous nt
=$a7aa					XtPtr1 ::= *
=42790					WordListLink ::= Nt0 ; remember the nt of this word for later
.a7aa	20 23 8e	jsr $8e23	EACsc:		jsr E1Slash
.a7ad	4c 95 a7	jmp $a795			jmp EASin
=6					CodeLen	.var *-XtPtr1
=$a7b0					Here1 = *	; remember here
>a7a8	06					.byte CodeLen	;patch wh_CodeLength
>a7b0	45 41 54 61 6e			Name0:	.text "EATan"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=42805					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>a7b5	c5					.byte (("EATan"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=15					LinkDisplacement = Nt0-WordListLink
>a7b6	10					.byte WordFlags	;wh_Flags
>a7b7	03					.byte 3	;wh_CodeLength
>a7b8	0f					  .byte LinkDisplacement	; offset to previous nt
=$a7b9					XtPtr1 ::= *
=42805					WordListLink ::= Nt0 ; remember the nt of this word for later
.a7b9					EATan:
.a7b9	a4 4c		ldy $4c				ldy FIndex
.a7bb	b9 4d 00	lda $004d,y			lda FSExp,y		; Abs(r1)<1 ?
.a7be	30 1b		bmi $a7db			bmi EATanM
.a7c0	f0 19		beq $a7db			beq EATanM
.a7c2	b9 57 00	lda $0057,y			lda FSMant0,y		; save sign
.a7c5	08		php				php
.a7c6	20 23 8e	jsr $8e23			jsr E1Slash
.a7c9	20 db a7	jsr $a7db			jsr EATanM
.a7cc	20 c5 a0	jsr $a0c5			jsr ENegate
.a7cf	20 8d 9e	jsr $9e8d			jsr EPiH
.a7d2	28		plp				plp
.a7d3	10 03		bpl $a7d8			bpl _18
.a7d5	20 c5 a0	jsr $a0c5			jsr ENegate
.a7d8	4c 6c a0	jmp $a06c	_18:		jmp EPlus
.a7db	20 13 9b	jsr $9b13	EATanM:		jsr EDup		; x x
.a7de	20 bd 8d	jsr $8dbd			jsr ESqr		; x xsqr
.a7e1	a9 f1		lda #$f1			lda #<_c
.a7e3	a0 a7		ldy #$a7			ldy #>_c
.a7e5	20 8a a4	jsr $a48a			jsr EMPolyYA
.a7e8	20 4d 8d	jsr $8d4d			jsr EStar		; x poly
.a7eb	20 90 a0	jsr $a090			jsr E1Plus		; x poly
.a7ee	4c 4d 8d	jmp $8d4d			jmp EStar
.a7f1					_c:
>a7f1	4f a9						.word $a94f		; 16 bit signed binary mantissa.  $4000 = +0.5
>a7f3	fc						.char -4		; 8 bit signed exponent.  $00 = 2**0
>a7f4	8e 4e						.word $4e8e		; 16 bit signed binary mantissa.  $4000 = +0.5
>a7f6	fe						.char -2		; 8 bit signed exponent.  $00 = 2**0
>a7f7	9f ac						.word $ac9f		; 16 bit signed binary mantissa.  $4000 = +0.5
>a7f9	ff						.char -1		; 8 bit signed exponent.  $00 = 2**0
>a7fa	00					.byte 0			; end
>a7fb	45 41 43 6f 74			Name0:	.text "EACot"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=42880					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>a800	85					.byte (("EACot"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=75					LinkDisplacement = Nt0-WordListLink
>a801	10					.byte WordFlags	;wh_Flags
>a802	03					.byte 3	;wh_CodeLength
>a803	4b					  .byte LinkDisplacement	; offset to previous nt
=$a804					XtPtr1 ::= *
=42880					WordListLink ::= Nt0 ; remember the nt of this word for later
.a804	20 23 8e	jsr $8e23	EACot:		jsr E1Slash
.a807	4c b9 a7	jmp $a7b9			jmp EATan
=6					CodeLen	.var *-XtPtr1
=$a80a					Here1 = *	; remember here
>a802	06					.byte CodeLen	;patch wh_CodeLength
>a80a	45 41 54 61 6e 32		Name0:	.text "EATan2"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=42896					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>a810	46					.byte (("EATan2"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=16					LinkDisplacement = Nt0-WordListLink
>a811	10					.byte WordFlags	;wh_Flags
>a812	03					.byte 3	;wh_CodeLength
>a813	10					  .byte LinkDisplacement	; offset to previous nt
=$a814					XtPtr1 ::= *
=42896					WordListLink ::= Nt0 ; remember the nt of this word for later
.a814	a4 4c		ldy $4c		EATan2:		ldy FIndex
.a816	b9 57 00	lda $0057,y			lda FSMant0+0,y	; get rx sign
.a819	f0 1c		beq $a837			beq _rxzero
.a81b	0a		asl a				asl a		;   C=rx sign
.a81c	b9 58 00	lda $0058,y			lda FSMant0+1,y	;   N=ry sign
.a81f	08		php				php		; save signs
.a820	20 c9 8d	jsr $8dc9			jsr ESlash
.a823	20 b9 a7	jsr $a7b9			jsr EATan
.a826	28		plp				plp		; pop signs
.a827	b0 01		bcs $a82a			bcs _rxneg
.a829	60		rts		_rts:		rts
.a82a	08		php		_rxneg:		php
.a82b	20 fe 88	jsr $88fe			jsr FPi
.a82e	28		plp				plp
.a82f	10 03		bpl $a834			bpl +
.a831	20 c5 a0	jsr $a0c5			jsr ENegate
.a834	4c 6c a0	jmp $a06c	+		jmp EPlus
.a837	e6 4c		inc $4c		_rxzero:	inc FIndex	; FDrop rx
.a839	b9 57 00	lda $0057,y			lda FSMant0,y
.a83c	08		php				php
.a83d	e6 4c		inc $4c				inc FIndex	; FDrop ry
.a83f	20 8d 9e	jsr $9e8d			jsr EPiH
.a842	28		plp				plp
.a843	10 e4		bpl $a829			bpl _rts
.a845	4c c5 a0	jmp $a0c5			jmp ENegate
=52					CodeLen	.var *-XtPtr1
=$a848					Here1 = *	; remember here
>a812	34					.byte CodeLen	;patch wh_CodeLength
>a848	45 53 67 6e			Name0:	.text "ESgn"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=42956					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>a84c	c4					.byte (("ESgn"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=60					LinkDisplacement = Nt0-WordListLink
>a84d	10					.byte WordFlags	;wh_Flags
>a84e	03					.byte 3	;wh_CodeLength
>a84f	3c					  .byte LinkDisplacement	; offset to previous nt
=$a850					XtPtr1 ::= *
=42956					WordListLink ::= Nt0 ; remember the nt of this word for later
.a850	a4 4c		ldy $4c		ESgn:		ldy FIndex
.a852	b9 57 00	lda $0057,y			lda FSMant0,y
.a855	f0 0a		beq $a861			beq _zero
.a857	e6 4c		inc $4c				inc FIndex
.a859	b9 57 00	lda $0057,y			lda FSMant0,y
.a85c	30 04		bmi $a862			bmi EM1
.a85e	4c 63 9e	jmp $9e63			jmp E1
.a861	60		rts		_zero:		rts
=18					CodeLen	.var *-XtPtr1
=$a862					Here1 = *	; remember here
>a84e	12					.byte CodeLen	;patch wh_CodeLength
.a862	a9 80		lda #$80	EM1:		lda #$80
.a864	a0 00		ldy #$00			ldy #0
.a866	4c 11 9e	jmp $9e11			jmp ELitYA
>a869	45 53 69 6e 48			Name0:	.text "ESinH"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=42990					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>a86e	05					.byte (("ESinH"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=34					LinkDisplacement = Nt0-WordListLink
>a86f	10					.byte WordFlags	;wh_Flags
>a870	03					.byte 3	;wh_CodeLength
>a871	22					  .byte LinkDisplacement	; offset to previous nt
=$a872					XtPtr1 ::= *
=42990					WordListLink ::= Nt0 ; remember the nt of this word for later
.a872	20 13 9b	jsr $9b13	ESinH:		jsr EDup
.a875	20 85 a5	jsr $a585			jsr EExp
.a878	20 7d 9b	jsr $9b7d			jsr ESwap
.a87b	20 c5 a0	jsr $a0c5			jsr ENegate
.a87e	20 85 a5	jsr $a585			jsr EExp
.a881	20 9c a0	jsr $a09c			jsr EMinus
.a884	4c 10 9f	jmp $9f10			jmp E2Slash
=21					CodeLen	.var *-XtPtr1
=$a887					Here1 = *	; remember here
>a870	15					.byte CodeLen	;patch wh_CodeLength
>a887	45 43 73 63 48			Name0:	.text "ECscH"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=43020					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>a88c	05					.byte (("ECscH"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=30					LinkDisplacement = Nt0-WordListLink
>a88d	10					.byte WordFlags	;wh_Flags
>a88e	03					.byte 3	;wh_CodeLength
>a88f	1e					  .byte LinkDisplacement	; offset to previous nt
=$a890					XtPtr1 ::= *
=43020					WordListLink ::= Nt0 ; remember the nt of this word for later
.a890	20 72 a8	jsr $a872	ECscH:		jsr ESinH
.a893	4c 23 8e	jmp $8e23			jmp E1Slash
=6					CodeLen	.var *-XtPtr1
=$a896					Here1 = *	; remember here
>a88e	06					.byte CodeLen	;patch wh_CodeLength
>a896	45 43 6f 73 48			Name0:	.text "ECosH"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=43035					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>a89b	05					.byte (("ECosH"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=15					LinkDisplacement = Nt0-WordListLink
>a89c	10					.byte WordFlags	;wh_Flags
>a89d	03					.byte 3	;wh_CodeLength
>a89e	0f					  .byte LinkDisplacement	; offset to previous nt
=$a89f					XtPtr1 ::= *
=43035					WordListLink ::= Nt0 ; remember the nt of this word for later
.a89f	20 13 9b	jsr $9b13	ECosH:		jsr EDup
.a8a2	20 85 a5	jsr $a585			jsr EExp
.a8a5	20 7d 9b	jsr $9b7d			jsr ESwap
.a8a8	20 c5 a0	jsr $a0c5			jsr ENegate
.a8ab	20 85 a5	jsr $a585			jsr EExp
.a8ae	20 6c a0	jsr $a06c			jsr EPlus
.a8b1	4c 10 9f	jmp $9f10			jmp E2Slash
=21					CodeLen	.var *-XtPtr1
=$a8b4					Here1 = *	; remember here
>a89d	15					.byte CodeLen	;patch wh_CodeLength
>a8b4	45 53 65 63 48			Name0:	.text "ESecH"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=43065					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>a8b9	05					.byte (("ESecH"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=30					LinkDisplacement = Nt0-WordListLink
>a8ba	10					.byte WordFlags	;wh_Flags
>a8bb	03					.byte 3	;wh_CodeLength
>a8bc	1e					  .byte LinkDisplacement	; offset to previous nt
=$a8bd					XtPtr1 ::= *
=43065					WordListLink ::= Nt0 ; remember the nt of this word for later
.a8bd	20 9f a8	jsr $a89f	ESecH:		jsr ECosH
.a8c0	4c 23 8e	jmp $8e23			jmp E1Slash
=6					CodeLen	.var *-XtPtr1
=$a8c3					Here1 = *	; remember here
>a8bb	06					.byte CodeLen	;patch wh_CodeLength
>a8c3	45 54 61 6e 48			Name0:	.text "ETanH"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=43080					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>a8c8	05					.byte (("ETanH"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=15					LinkDisplacement = Nt0-WordListLink
>a8c9	10					.byte WordFlags	;wh_Flags
>a8ca	03					.byte 3	;wh_CodeLength
>a8cb	0f					  .byte LinkDisplacement	; offset to previous nt
=$a8cc					XtPtr1 ::= *
=43080					WordListLink ::= Nt0 ; remember the nt of this word for later
.a8cc	20 13 9b	jsr $9b13	ETanH:		jsr EDup
.a8cf	20 c5 a0	jsr $a0c5			jsr ENegate	; X -X
.a8d2	20 85 a5	jsr $a585			jsr EExp	; X Exp(-X)
.a8d5	20 7d 9b	jsr $9b7d			jsr ESwap	; Exp(-X) X
.a8d8	20 85 a5	jsr $a585			jsr EExp	; Exp(-X) Exp(X)
.a8db	20 2e 9b	jsr $9b2e			jsr EOver	; Exp(-X) Exp(X) Exp(-X)
.a8de	20 6c a0	jsr $a06c			jsr EPlus	; Exp(-X) Exp(X)+Exp(-X)
.a8e1	20 c9 8d	jsr $8dc9			jsr ESlash	; Exp(-X)/(Exp(X)+Exp(-X))
.a8e4	20 05 9f	jsr $9f05			jsr E2Star	; Exp(-X)/(Exp(X)+Exp(-X))*2
.a8e7	20 c5 a0	jsr $a0c5			jsr ENegate
.a8ea	4c 90 a0	jmp $a090			jmp E1Plus
=33					CodeLen	.var *-XtPtr1
=$a8ed					Here1 = *	; remember here
>a8ca	21					.byte CodeLen	;patch wh_CodeLength
>a8ed	45 43 6f 74 48			Name0:	.text "ECotH"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=43122					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>a8f2	05					.byte (("ECotH"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=42					LinkDisplacement = Nt0-WordListLink
>a8f3	10					.byte WordFlags	;wh_Flags
>a8f4	03					.byte 3	;wh_CodeLength
>a8f5	2a					  .byte LinkDisplacement	; offset to previous nt
=$a8f6					XtPtr1 ::= *
=43122					WordListLink ::= Nt0 ; remember the nt of this word for later
.a8f6	20 cc a8	jsr $a8cc	ECotH:		jsr ETanH
.a8f9	4c 23 8e	jmp $8e23			jmp E1Slash
=6					CodeLen	.var *-XtPtr1
=$a8fc					Here1 = *	; remember here
>a8f4	06					.byte CodeLen	;patch wh_CodeLength
>a8fc	45 41 53 69 6e 48		Name0:	.text "EASinH"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=43138					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>a902	06					.byte (("EASinH"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=16					LinkDisplacement = Nt0-WordListLink
>a903	10					.byte WordFlags	;wh_Flags
>a904	03					.byte 3	;wh_CodeLength
>a905	10					  .byte LinkDisplacement	; offset to previous nt
=$a906					XtPtr1 ::= *
=43138					WordListLink ::= Nt0 ; remember the nt of this word for later
.a906	20 13 9b	jsr $9b13	EASinH:		jsr EDup	; X X
.a909	20 bd 8d	jsr $8dbd			jsr ESqr	; X X*X
.a90c	20 90 a0	jsr $a090			jsr E1Plus	; X X*X+1
.a90f	20 9b a1	jsr $a19b			jsr ESqrt	; X sqrt(X*X+1)
.a912	20 6c a0	jsr $a06c			jsr EPlus	;
.a915	4c 0c a5	jmp $a50c			jmp ELn
=18					CodeLen	.var *-XtPtr1
=$a918					Here1 = *	; remember here
>a904	12					.byte CodeLen	;patch wh_CodeLength
>a918	45 41 43 73 63 48		Name0:	.text "EACscH"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=43166					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>a91e	06					.byte (("EACscH"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=28					LinkDisplacement = Nt0-WordListLink
>a91f	10					.byte WordFlags	;wh_Flags
>a920	03					.byte 3	;wh_CodeLength
>a921	1c					  .byte LinkDisplacement	; offset to previous nt
=$a922					XtPtr1 ::= *
=43166					WordListLink ::= Nt0 ; remember the nt of this word for later
.a922	20 23 8e	jsr $8e23	EACscH:		jsr E1Slash
.a925	4c 06 a9	jmp $a906			jmp EASinH
=6					CodeLen	.var *-XtPtr1
=$a928					Here1 = *	; remember here
>a920	06					.byte CodeLen	;patch wh_CodeLength
>a928	45 41 43 6f 73 48		Name0:	.text "EACosH"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=43182					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>a92e	06					.byte (("EACosH"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=16					LinkDisplacement = Nt0-WordListLink
>a92f	10					.byte WordFlags	;wh_Flags
>a930	03					.byte 3	;wh_CodeLength
>a931	10					  .byte LinkDisplacement	; offset to previous nt
=$a932					XtPtr1 ::= *
=43182					WordListLink ::= Nt0 ; remember the nt of this word for later
.a932	20 13 9b	jsr $9b13	EACosH:		jsr EDup
.a935	20 bd 8d	jsr $8dbd			jsr ESqr
.a938	20 b4 a0	jsr $a0b4			jsr E1Minus
.a93b	20 9b a1	jsr $a19b			jsr ESqrt
.a93e	20 6c a0	jsr $a06c			jsr EPlus
.a941	4c 0c a5	jmp $a50c			jmp ELn
=18					CodeLen	.var *-XtPtr1
=$a944					Here1 = *	; remember here
>a930	12					.byte CodeLen	;patch wh_CodeLength
>a944	45 41 53 65 63 48		Name0:	.text "EASecH"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=43210					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>a94a	06					.byte (("EASecH"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=28					LinkDisplacement = Nt0-WordListLink
>a94b	10					.byte WordFlags	;wh_Flags
>a94c	03					.byte 3	;wh_CodeLength
>a94d	1c					  .byte LinkDisplacement	; offset to previous nt
=$a94e					XtPtr1 ::= *
=43210					WordListLink ::= Nt0 ; remember the nt of this word for later
.a94e	20 23 8e	jsr $8e23	EASecH:		jsr E1Slash
.a951	4c 32 a9	jmp $a932			jmp EACosH
=6					CodeLen	.var *-XtPtr1
=$a954					Here1 = *	; remember here
>a94c	06					.byte CodeLen	;patch wh_CodeLength
>a954	45 41 54 61 6e 48		Name0:	.text "EATanH"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=43226					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>a95a	06					.byte (("EATanH"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=16					LinkDisplacement = Nt0-WordListLink
>a95b	10					.byte WordFlags	;wh_Flags
>a95c	03					.byte 3	;wh_CodeLength
>a95d	10					  .byte LinkDisplacement	; offset to previous nt
=$a95e					XtPtr1 ::= *
=43226					WordListLink ::= Nt0 ; remember the nt of this word for later
.a95e	20 13 9b	jsr $9b13	EAtanH:		jsr EDup	; x x
.a961	20 90 a0	jsr $a090			jsr E1Plus	; x x+1
.a964	20 7d 9b	jsr $9b7d			jsr ESwap	; 1+x x
.a967	20 63 9e	jsr $9e63			jsr E1
.a96a	20 7d 9b	jsr $9b7d			jsr ESwap
.a96d	20 9c a0	jsr $a09c			jsr EMinus	; 1+x 1-x
.a970	20 c9 8d	jsr $8dc9			jsr ESlash	; (1+x)/(1-x)
.a973	20 0c a5	jsr $a50c			jsr ELn
.a976	4c 10 9f	jmp $9f10			jmp E2Slash
=27					CodeLen	.var *-XtPtr1
=$a979					Here1 = *	; remember here
>a95c	1b					.byte CodeLen	;patch wh_CodeLength
>a979	45 41 43 6f 74 48		Name0:	.text "EACotH"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=43263					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>a97f	06					.byte (("EACotH"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=37					LinkDisplacement = Nt0-WordListLink
>a980	10					.byte WordFlags	;wh_Flags
>a981	03					.byte 3	;wh_CodeLength
>a982	25					  .byte LinkDisplacement	; offset to previous nt
=$a983					XtPtr1 ::= *
=43263					WordListLink ::= Nt0 ; remember the nt of this word for later
.a983	20 23 8e	jsr $8e23	EACotH: 	jsr E1Slash
.a986	4c 5e a9	jmp $a95e			jmp EATanH
=6					CodeLen	.var *-XtPtr1
=$a989					Here1 = *	; remember here
>a981	06					.byte CodeLen	;patch wh_CodeLength
>a989	45 64				Name0:	.text "Ed"	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=43275					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>a98b	82					.byte (("Ed"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=12					LinkDisplacement = Nt0-WordListLink
>a98c	10					.byte WordFlags	;wh_Flags
>a98d	03					.byte 3	;wh_CodeLength
>a98e	0c					  .byte LinkDisplacement	; offset to previous nt
=$a98f					XtPtr1 ::= *
=43275					WordListLink ::= Nt0 ; remember the nt of this word for later
.a98f	4c 92 a9	jmp $a992	Ed:		jmp ed6502
=3					CodeLen	.var *-XtPtr1
=$a992					Here1 = *	; remember here
>a98d	03					.byte CodeLen	;patch wh_CodeLength
=$1e					ed_head	 = editor1  ; pointer to first list element (addr) (2 bytes)
=$20					ed_cur	 = editor2  ; current line number (1 is first line) (2 bytes)
=$22					ed_flags = editor3  ; Flags used by ed, where
.a992					ed6502:
.a992	ad 00 03	lda $0300			lda base
.a995	85 23		sta $23				sta editor3+1
.a997	20 b1 c1	jsr $c1b1			jsr Decimal
.a99a	a9 00		lda #$00			lda #0
.a99c	85 1e		sta $1e				sta ed_head
.a99e	85 1f		sta $1f				sta ed_head+1
.a9a0	85 20		sta $20				sta ed_cur
.a9a2	85 21		sta $21				sta ed_cur+1
.a9a4	85 22		sta $22				sta ed_flags
.a9a6	20 f2 c7	jsr $c7f2			jsr Zero
.a9a9	20 f2 c7	jsr $c7f2			jsr Zero		; ( addr-t u-t )
.a9ac	20 4c bb	jsr $bb4c			jsr CR
.a9af					ed_input_loop:
.a9af	a9 7e		lda #$7e			lda #$ff-%10000001
.a9b1	25 22		and $22				and ed_flags
.a9b3	85 22		sta $22				sta ed_flags
.a9b5	20 54 ae	jsr $ae54			jsr ed_get_input
.a9b8	a5 06		lda $06				lda ciblen+0
.a9ba	d0 1e		bne $a9da			bne _command_mode
.a9bc	a5 20		lda $20				lda ed_cur+0
.a9be	a4 21		ldy $21				ldy ed_cur+1
.a9c0	20 b5 c7	jsr $c7b5			jsr PushYA		; ( addr-t u-t u )
.a9c3	a9 80		lda #$80			lda #%10000000
.a9c5	05 22		ora $22				ora ed_flags
.a9c7	85 22		sta $22				sta ed_flags
.a9c9	20 95 da	jsr $da95			jsr One_Plus		; ( addr-t u-t u+1 )
.a9cc	20 6f ae	jsr $ae6f			jsr ed_is_valid_line
.a9cf	b0 03		bcs $a9d4			bcs +
.a9d1	4c 44 ae	jmp $ae44			jmp ed_error_1drop	; New line number is not legal, abort
.a9d4					+
.a9d4	20 f2 c7	jsr $c7f2			jsr Zero		; ( addr-t u-t u+1 0 )
.a9d7	4c 99 aa	jmp $aa99			jmp _line_number_only_from_external
.a9da					_command_mode:
.a9da	20 f2 c7	jsr $c7f2			jsr Zero		; parameter 1 is NOS ( addr-t u-t 0 )
.a9dd	20 f2 c7	jsr $c7f2			jsr Zero		; parameter 2 is TOS ( addr-t u-t 0 0 )
.a9e0	a0 00		ldy #$00			ldy #0			; get char
.a9e2	b1 04		lda ($04),y			lda (cib),y
.a9e4	c9 2e		cmp #$2e			cmp #'.'
.a9e6	d0 31		bne $aa19			bne _prefix_dollar
.a9e8	20 63 ae	jsr $ae63			jsr ed_have_text
.a9eb	a5 20		lda $20				lda ed_cur
.a9ed	95 26		sta $26,x			sta DStack+2,x
.a9ef	a5 21		lda $21				lda ed_cur+1
.a9f1	95 27		sta $27,x			sta DStack+3,x		; ( addr-t u-t cur 0 )
.a9f3	a9 80		lda #$80			lda #%10000000
.a9f5	05 22		ora $22				ora ed_flags
.a9f7	85 22		sta $22				sta ed_flags
.a9f9	a5 06		lda $06				lda ciblen
.a9fb	c9 01		cmp #$01			cmp #1			; sets Z if A was 1
.a9fd	d0 03		bne $aa02			bne +
.a9ff	4c 99 aa	jmp $aa99			jmp _line_number_only_from_external
.aa02					+
.aa02	a5 04		lda $04				lda cib+0
.aa04	a4 05		ldy $05				ldy cib+1
.aa06	20 b5 c7	jsr $c7b5			jsr PushYA
.aa09	a5 06		lda $06				lda ciblen+0
.aa0b	a4 07		ldy $07				ldy ciblen+1
.aa0d	20 b5 c7	jsr $c7b5			jsr PushYA
.aa10	20 6f da	jsr $da6f			jsr One_Minus		; ( addr-t u-t para1 0 addr u-1 )
.aa13	20 a0 da	jsr $daa0			jsr NOS_One_Plus	; ( addr-t u-t para1 0 addr+1 u-1 )
.aa16	4c eb aa	jmp $aaeb			jmp _check_for_para2
.aa19					_prefix_dollar:
.aa19	c9 24		cmp #$24			cmp #'$'
.aa1b	d0 1f		bne $aa3c			bne _prefix_percent
.aa1d	20 63 ae	jsr $ae63			jsr ed_have_text
.aa20	e8		inx				inx
.aa21	e8		inx				inx			; ( addr-t u-t 0 )
.aa22	20 90 ae	jsr $ae90			jsr ed_last_line	; ( addr-t u-t 0 para1 )
.aa25	20 ee df	jsr $dfee			jsr Swap		; ( addr-t u-t para1 0 )
.aa28	a9 80		lda #$80			lda #%10000000
.aa2a	05 22		ora $22				ora ed_flags
.aa2c	85 22		sta $22				sta ed_flags
.aa2e	a5 06		lda $06				lda ciblen
.aa30	c9 01		cmp #$01			cmp #1			; sets Z if A was 1
.aa32	d0 03		bne $aa37			bne +
.aa34	4c 99 aa	jmp $aa99			jmp _line_number_only_from_external
.aa37					+
.aa37	a0 01		ldy #$01			ldy #1
.aa39	4c 61 ab	jmp $ab61			jmp _check_command
.aa3c					_prefix_percent:
.aa3c	c9 25		cmp #$25			cmp #'%'
.aa3e	f0 04		beq $aa44			beq _whole_text
.aa40	c9 2c		cmp #$2c			cmp #','
.aa42	d0 1b		bne $aa5f			bne _prefix_semicolon
.aa44					_whole_text:
.aa44	20 63 ae	jsr $ae63			jsr ed_have_text
.aa47	a9 01		lda #$01			lda #1
.aa49	95 26		sta $26,x			sta DStack+2,x		; LSB of NOS is para 1
.aa4b	a9 00		lda #$00			lda #0
.aa4d	95 27		sta $27,x			sta DStack+3,x		; ( addr-t u-t para1 0 )
.aa4f					_semicolon_entry:
.aa4f	e8		inx				inx
.aa50	e8		inx				inx			; DROP ( addr-t u-t para1 )
.aa51	20 90 ae	jsr $ae90			jsr ed_last_line	  ; ( addr-t u-t para1 para2 )
.aa54	a9 80		lda #$80			lda #%10000000
.aa56	05 22		ora $22				ora ed_flags
.aa58	85 22		sta $22				sta ed_flags
.aa5a	a0 01		ldy #$01			ldy #1
.aa5c	4c 61 ab	jmp $ab61			jmp _check_command
.aa5f					_prefix_semicolon:
.aa5f	c9 3b		cmp #$3b			cmp #';'
.aa61	d0 0e		bne $aa71			bne _prefix_number
.aa63	20 63 ae	jsr $ae63			jsr ed_have_text
.aa66	a5 20		lda $20				lda ed_cur
.aa68	95 26		sta $26,x			sta DStack+2,x
.aa6a	a5 21		lda $21				lda ed_cur+1
.aa6c	95 27		sta $27,x			sta DStack+3,x		; ( addr-t u-t cur 0 )
.aa6e	4c 4f aa	jmp $aa4f			jmp _semicolon_entry
.aa71					_prefix_number:
.aa71	20 f2 c7	jsr $c7f2			jsr Zero
.aa74	20 f2 c7	jsr $c7f2			jsr Zero		; ( addr-t u-t 0 0 0 0 )
.aa77	a5 04		lda $04				lda cib+0
.aa79	a4 05		ldy $05				ldy cib+1
.aa7b	20 b5 c7	jsr $c7b5			jsr PushYA
.aa7e	a5 06		lda $06				lda ciblen+0
.aa80	a4 07		ldy $07				ldy ciblen+1
.aa82	20 b5 c7	jsr $c7b5			jsr PushYA		; ( addr-t u-t 0 0 0 0 cib ciblen )
.aa85	20 34 c0	jsr $c034			jsr To_Number		; ( addr-t u-t 0 0 ud addr2 u2 )
.aa88	b5 24		lda $24,x			lda DStack+0,x
.aa8a	15 25		ora $25,x			ora DStack+1,x
.aa8c	d0 25		bne $aab3			bne _have_unconverted_chars
.aa8e	20 6d d5	jsr $d56d			jsr Two_Drop		; ( addr-t u-t 0 0 ud )
.aa91	20 1f d0	jsr $d01f			jsr D_To_S		; ( addr-t u-t 0 0 u )
.aa94	20 d3 de	jsr $ded3			jsr Not_Rot		; ( addr-t u-t u 0 0 )
.aa97	e8		inx				inx
.aa98	e8		inx				inx			; ( addr-t u-t u 0 ) drop through
.aa99					_line_number_only_from_external:
.aa99	20 ee df	jsr $dfee			jsr Swap		; ( addr-t u-t 0 u )
.aa9c	20 6f ae	jsr $ae6f			jsr ed_is_valid_line
.aa9f	b0 03		bcs $aaa4			bcs +
.aaa1	4c 42 ae	jmp $ae42			jmp ed_error_2drop
.aaa4					+
.aaa4	20 ee df	jsr $dfee			jsr Swap		; ( addr-t u-t u 0 )
.aaa7	20 cf ae	jsr $aecf			jsr ed_para1_to_cur
.aaaa	a9 80		lda #$80			lda #%10000000
.aaac	05 22		ora $22				ora ed_flags
.aaae	85 22		sta $22				sta ed_flags
.aab0	4c 2d ad	jmp $ad2d			jmp ed_cmd_p_from_external
.aab3					_have_unconverted_chars:
.aab3	a5 06		lda $06				lda ciblen+0
.aab5	d5 24		cmp $24,x			cmp DStack+0,x
.aab7	d0 16		bne $aacf			bne _no_command_yet
.aab9	a5 07		lda $07				lda ciblen+1
.aabb	d5 25		cmp $25,x			cmp DStack+1,x
.aabd	d0 10		bne $aacf			bne _no_command_yet
.aabf	8a		txa				txa
.aac0	18		clc				clc
.aac1	69 08		adc #$08			adc #8
.aac3	aa		tax				tax			; ( addr-t u-t 0 0 )
.aac4	a9 7f		lda #$7f			lda #$ff-%10000000
.aac6	25 22		and $22				and ed_flags
.aac8	85 22		sta $22				sta ed_flags
.aaca	a0 00		ldy #$00			ldy #0
.aacc	4c 61 ab	jmp $ab61			jmp _check_command
.aacf					_no_command_yet:
.aacf	20 3d df	jsr $df3d			jsr To_R		; >R ( ... 0 0 ud addr2 ) (R: u2)
.aad2	20 d3 de	jsr $ded3			jsr Not_Rot		; -ROT ( ... 0 0 addr2 ud ) (R: u2)
.aad5	20 1f d0	jsr $d01f			jsr D_To_S		; D>S  ( ... 0 0 addr2 para1 ) (R: u2)
.aad8	b5 24		lda $24,x			lda DStack+0,x		; LSB
.aada	95 2a		sta $2a,x			sta DStack+6,x
.aadc	b5 25		lda $25,x			lda DStack+1,x		; MSB
.aade	95 2b		sta $2b,x			sta DStack+7,x		; ( ... para1 0 addr2 para1 ) (R: u2)
.aae0	e8		inx				inx
.aae1	e8		inx				inx			; ( addr-t u-t para1 0 addr2 ) (R: u2)
.aae2	20 5b df	jsr $df5b			jsr R_From		; R> ( addr-t u-t para1 0 addr2 u2 ) fall through
.aae5	a9 80		lda #$80			lda #%10000000
.aae7	05 22		ora $22				ora ed_flags
.aae9	85 22		sta $22				sta ed_flags
.aaeb					_check_for_para2:
.aaeb	a1 26		lda ($26,x)			lda (DStack+2,x)
.aaed	c9 2c		cmp #$2c			cmp #','
.aaef	f0 0c		beq $aafd			beq _got_comma
.aaf1	38		sec				sec
.aaf2	a5 06		lda $06				lda ciblen
.aaf4	f5 24		sbc $24,x			sbc DStack+0,x
.aaf6	a8		tay				tay
.aaf7	20 6d d5	jsr $d56d			jsr Two_Drop		; Remove the leftover stuff from >NUMBER
.aafa	4c 61 ab	jmp $ab61			jmp _check_command
.aafd					_got_comma:
.aafd	20 a0 da	jsr $daa0			jsr NOS_One_Plus	; ( addr-t u-t para1 0 addr2+1 u2 )
.ab00	20 6f da	jsr $da6f			jsr One_Minus		; ( addr-t u-t para1 0 addr2+1 u2-1 )
.ab03	a1 26		lda ($26,x)			lda (DStack+2,x)
.ab05	c9 24		cmp #$24			cmp #'$'
.ab07	d0 16		bne $ab1f			bne _para2_not_dollar
.ab09	38		sec				sec
.ab0a	a5 06		lda $06				lda ciblen
.ab0c	f5 26		sbc $26,x			sbc DStack+2,x
.ab0e	a8		tay				tay
.ab0f	c8		iny				iny
.ab10	98		tya				tya
.ab11	48		pha				pha
.ab12	8a		txa				txa
.ab13	18		clc				clc
.ab14	69 06		adc #$06			adc #6
.ab16	aa		tax				tax			; ( addr-t u-t para1 )
.ab17	20 90 ae	jsr $ae90			jsr ed_last_line	  ; ( addr-t u-t para1 para2 )
.ab1a	68		pla				pla
.ab1b	a8		tay				tay
.ab1c	4c 61 ab	jmp $ab61			jmp _check_command
.ab1f					_para2_not_dollar:
.ab1f	20 3d df	jsr $df3d			jsr To_R		; >R ( ... para1 0 addr2+1 ) (R: u2-1)
.ab22	20 f2 c7	jsr $c7f2			jsr Zero		; 0 ( ... para1 0 addr2+1 0 ) (R: u2-1)
.ab25	20 f2 c7	jsr $c7f2			jsr Zero		; 0 ( ... para1 0 addr2+1 0 0 ) (R: u2-1)
.ab28	20 ae de	jsr $deae			jsr Rot		; ROT ( ... para1 0 0 0 addr2+1 ) (R: u2-1)
.ab2b	20 5b df	jsr $df5b			jsr R_From		; R> ( ... para1 0 0 0 addr2+1 u2-1)
.ab2e	20 cd df	jsr $dfcd			jsr Dup		; DUP ( ... para1 0 0 0 addr2+1 u2-1 u2-1)
.ab31	20 3d df	jsr $df3d			jsr To_R		; >R ( ... para1 0 0 0 addr2+1 u2-1 ) (R: u2-1)
.ab34	20 34 c0	jsr $c034			jsr To_Number	; >NUMBER ( ... para1 0 ud addr3 u3 ) (R: u2-1)
.ab37	20 cd df	jsr $dfcd			jsr Dup		; DUP ( ... para1 0 ud addr3 u3 u3 ) (R: u2-1)
.ab3a	20 5b df	jsr $df5b			jsr R_From		; R> ( ... para1 0 ud addr3 u3 u3 u2-1 )
.ab3d	20 79 d8	jsr $d879			jsr Equal		; = ( ... para1 0 ud addr3 u3 f )
.ab40	b5 24		lda $24,x			lda DStack+0,x
.ab42	15 25		ora $25,x			ora DStack+1,x
.ab44	f0 08		beq $ab4e			beq _second_number
.ab46	8a		txa				txa
.ab47	18		clc				clc
.ab48	69 0c		adc #$0c			adc #12
.ab4a	aa		tax				tax			; back to ( addr-t u-t )
.ab4b	4c 46 ae	jmp $ae46			jmp ed_error
.ab4e					_second_number:
.ab4e	e8		inx				inx
.ab4f	e8		inx				inx			; ( addr-t u-t para1 0 ud addr3 u3 )
.ab50	38		sec				sec
.ab51	a5 06		lda $06				lda ciblen
.ab53	f5 24		sbc $24,x			sbc DStack+0,x
.ab55	48		pha				pha
.ab56	20 6d d5	jsr $d56d			jsr Two_drop		; 2DROP ( addr-t u-t para1 0 ud )
.ab59	20 1f d0	jsr $d01f			jsr D_To_S		; D>S  ( addr-t u-t para1 0 para2 )
.ab5c	20 c8 d9	jsr $d9c8			jsr Nip			; NIP ( addr-t u-t para1 para2 )
.ab5f	68		pla				pla
.ab60	a8		tay				tay
.ab61					_check_command:
.ab61	24 22		bit $22				bit ed_flags
.ab63	30 08		bmi $ab6d			bmi _check_command_have_arg
.ab65	a5 20		lda $20				lda ed_cur+0
.ab67	95 26		sta $26,x			sta DStack+2,x
.ab69	a5 21		lda $21				lda ed_cur+1
.ab6b	95 27		sta $27,x			sta DStack+3,x
.ab6d					_check_command_have_arg:
.ab6d	b1 04		lda ($04),y			lda (cib),y		; get mystery char from input
.ab6f	85 14		sta $14				sta tmp1+0
.ab71	85 15		sta $15				sta tmp1+1		; We need X for awhile, so it has to
.ab73	a2 ff		ldx #$ff			ldx #$ff		; for each char
.ab75	e8		inx		_cmd_loop:	inx			;   next char
.ab76	bd f3 ae	lda $aef3,x			lda ed_cmd_list,x
.ab79	f0 13		beq $ab8e			beq _illegal_command	;   end of list?
.ab7b	c5 14		cmp $14				cmp tmp1+0
.ab7d	d0 f6		bne $ab75			bne _cmd_loop		;   not found?
.ab7f	8a		txa				txa
.ab80	0a		asl a				asl
.ab81	aa		tax				tax			; X * 2 for table
.ab82	bd ff ae	lda $aeff,x			lda ed_cmd_table+1,x
.ab85	48		pha				pha
.ab86	bd fe ae	lda $aefe,x			lda ed_Cmd_table+0,x
.ab89	48		pha				pha
.ab8a	a6 15		ldx $15				ldx tmp1+1		; restore X
.ab8c	08		php				php
.ab8d	40		rti				rti			; jump to command routine
.ab8e					_illegal_command:
.ab8e	4c 42 ae	jmp $ae42			jmp ed_error_2drop
.ab91					ed_next_command:
.ab91	20 6d d5	jsr $d56d			jsr Two_Drop		; ( addr-t u-t ) Fall through
.ab94					_next_command_empty:
.ab94	4c af a9	jmp $a9af			jmp ed_input_loop
.ab97					ed_all_done:
.ab97	a9 00		lda #$00			lda #0
.ab99	85 06		sta $06				sta ciblen
.ab9b	85 07		sta $07				sta ciblen+1
.ab9d	20 6d d5	jsr $d56d			jsr Two_drop			; ( addr-t u-t )
.aba0	a5 23		lda $23				lda editor3+1
.aba2	8d 00 03	sta $0300			sta base
.aba5	60		rts				rts
.aba6					ed_cmd_a:
.aba6	e8		inx				inx
.aba7	e8		inx				inx			;  DROP ( addr-t u-t para1 )
.aba8					ed_entry_cmd_i:
.aba8					ed_cmd_a_have_para:
.aba8	20 b4 ae	jsr $aeb4			jsr ed_num_to_addr	  ;  ( addr-t u-t addr1 )
.abab	20 4c bb	jsr $bb4c			jsr CR
.abae					_next_string_loop:
.abae	20 54 ae	jsr $ae54			jsr ed_get_input
.abb1	a0 00		ldy #$00			ldy #0
.abb3	b1 04		lda ($04),y			lda (cib),y
.abb5	c9 2e		cmp #$2e			cmp #'.'
.abb7	d0 18		bne $abd1			bne _add_line
.abb9	a4 06		ldy $06				ldy ciblen
.abbb	c0 01		cpy #$01			cpy #1
.abbd	d0 12		bne $abd1			bne _add_line
.abbf	a4 07		ldy $07				ldy ciblen+1
.abc1	d0 0e		bne $abd1			bne _add_line
.abc3	e8		inx				inx
.abc4	e8		inx				inx
.abc5	a9 40		lda #$40			lda #%01000000
.abc7	05 22		ora $22				ora ed_flags
.abc9	85 22		sta $22				sta ed_flags
.abcb	20 4c bb	jsr $bb4c			jsr CR
.abce	4c af a9	jmp $a9af			jmp ed_input_loop
.abd1					_add_line:
.abd1	20 cd df	jsr $dfcd			jsr Dup			; ( addr-t u-t addr1 addr1 )
.abd4	20 62 da	jsr $da62			jsr Here		; ( addr-t u-t addr1 addr1 here )
.abd7	20 ee df	jsr $dfee			jsr Swap		; ( addr-t u-t addr1 here addr1 )
.abda	20 f5 de	jsr $def5			jsr Fetch		; ( addr-t u-t addr1 here addr2 )
.abdd	20 4d dd	jsr $dd4d			jsr Comma		; ( addr-t u-t addr1 here )
.abe0	20 15 dd	jsr $dd15			jsr Tuck		; TUCK ( addr-t u-t here addr1 here )
.abe3	20 ee df	jsr $dfee			jsr Swap		; ( addr-t u-t here here addr1 )
.abe6	20 0e df	jsr $df0e			jsr Store		; ( addr-t u-t here )
.abe9	20 62 da	jsr $da62			jsr Here		; HERE ( addr-t u-t here here2)
.abec	a9 04		lda #$04			lda #4
.abee	20 b2 d0	jsr $d0b2			jsr Allot_ZA
.abf1	e6 20		inc $20				inc ed_cur
.abf3	d0 02		bne $abf7			bne +
.abf5	e6 21		inc $21				inc ed_cur+1
.abf7					+
.abf7	20 62 da	jsr $da62			jsr Here	; ( addr-t u-t here here2 here3 )
.abfa	a5 04		lda $04				lda cib+0
.abfc	a4 05		ldy $05				ldy cib+1
.abfe	20 b5 c7	jsr $c7b5			jsr PushYA	; ( addr-t u-t here here2 here3 cib )
.ac01	20 a4 df	jsr $dfa4			jsr Over	; ( addr-t u-t here here2 here3 cib here3 )
.ac04	a5 06		lda $06				lda ciblen+0
.ac06	a4 07		ldy $07				ldy ciblen+1
.ac08	20 b5 c7	jsr $c7b5			jsr PushYA	; ( addr-t u-t here here2 here3 cib here3 ciblen )
.ac0b	20 5f bd	jsr $bd5f			jsr Move	; ( addr-t u-t here here2 here3 )
.ac0e	18		clc				clc
.ac0f	a5 00		lda $00				lda cp
.ac11	65 06		adc $06				adc ciblen
.ac13	85 00		sta $00				sta cp
.ac15	90 06		bcc $ac1d			bcc +
.ac17	a5 01		lda $01				lda cp+1
.ac19	65 07		adc $07				adc ciblen+1
.ac1b	85 01		sta $01				sta cp+1
.ac1d					+
.ac1d	20 a4 df	jsr $dfa4			jsr Over		; ( addr-t u-t here here2 here3 here2 )
.ac20	20 0e df	jsr $df0e			jsr Store		; ( addr-t u-t here here2 )
.ac23	20 41 da	jsr $da41			jsr Cell_Plus		; ( addr-t u-t here here2+2 )
.ac26	20 cd df	jsr $dfcd			jsr Dup			; ( addr-t u-t here here2+2 here2+2 )
.ac29	a5 06		lda $06				lda ciblen
.ac2b	95 26		sta $26,x			sta DStack+2,x
.ac2d	a5 07		lda $07				lda ciblen+1
.ac2f	95 27		sta $27,x			sta DStack+3,x		; ( addr-t u-t here ciblen here2+2 )
.ac31	20 0e df	jsr $df0e			jsr Store		; ( addr-t u-t here )
.ac34	20 4c bb	jsr $bb4c			jsr CR			; Add a line feed for visuals
.ac37	4c ae ab	jmp $abae			jmp _next_string_loop
.ac3a					ed_cmd_d:
.ac3a	20 63 ae	jsr $ae63			jsr ed_have_text
.ac3d	20 a6 ae	jsr $aea6			jsr ed_no_line_zero
.ac40	b5 24		lda $24,x			lda DStack+0,x
.ac42	15 25		ora $25,x			ora DStack+1,x
.ac44	d0 09		bne $ac4f			bne +
.ac46	20 a4 df	jsr $dfa4			jsr Over		; ( addr-t u-t para1 0 para1 )
.ac49	20 84 ac	jsr $ac84			jsr _cmd_d_common	; ( addr-t u-t para1 0 )
.ac4c	4c 78 ac	jmp $ac78			jmp _cmd_d_done
.ac4f					+
.ac4f	20 6f ae	jsr $ae6f			jsr ed_is_valid_line	  ; result is in C flag
.ac52	b0 03		bcs $ac57			bcs _cmd_d_loop
.ac54	4c 42 ae	jmp $ae42			jmp ed_error_2drop
.ac57					_cmd_d_loop:
.ac57	b5 24		lda $24,x			lda DStack+0,x		; para1 > para2 ?
.ac59	d5 26		cmp $26,x			cmp DStack+2,x
.ac5b	b5 25		lda $25,x			lda DStack+1,x
.ac5d	f5 27		sbc $27,x			sbc DStack+3,x
.ac5f	90 0c		bcc $ac6d			bcc _cmd_d_done_with_flag
.ac61	20 cd df	jsr $dfcd			jsr Dup		; DUP ( addr-t u-t para1 para2 para2 )
.ac64	20 84 ac	jsr $ac84			jsr _cmd_d_common	; ( addr-t u-t para1 para2 )
.ac67	20 6f da	jsr $da6f			jsr One_minus	; 1- ( addr-t u-t para1 para2-1 )
.ac6a	4c 57 ac	jmp $ac57			jmp _cmd_d_loop
.ac6d					_cmd_d_done_with_flag:
.ac6d	20 7c da	jsr $da7c			jsr NOS_One_Minus
.ac70	b5 26		lda $26,x			lda DStack+2,x
.ac72	85 20		sta $20				sta ed_cur
.ac74	b5 27		lda $27,x			lda DStack+3,x
.ac76	85 21		sta $21				sta ed_cur+1		; drop through to _cmd_d_done
.ac78					_cmd_d_done:
.ac78	a9 40		lda #$40			lda #%01000000
.ac7a	05 22		ora $22				ora ed_flags
.ac7c	85 22		sta $22				sta ed_flags
.ac7e	20 4c bb	jsr $bb4c			jsr CR
.ac81	4c 91 ab	jmp $ab91			jmp ed_next_command
.ac84					_cmd_d_common:
.ac84	20 cd df	jsr $dfcd			jsr Dup			; ( addr-t u-t u u )
.ac87	20 b4 ae	jsr $aeb4			jsr ed_num_to_addr	; ( addr-t u-t u addr )
.ac8a	20 f5 de	jsr $def5			jsr Fetch		; ( addr-t u-t u addr1 )
.ac8d	20 ee df	jsr $dfee			jsr Swap		; ( addr-t u-t addr1 u )
.ac90	20 6f da	jsr $da6f			jsr One_minus		; ( addr-t u-t addr1 u-1 )
.ac93	20 b4 ae	jsr $aeb4			jsr ed_num_to_addr	; ( addr-t u-t addr1 addr-1 )
.ac96	4c 0e df	jmp $df0e			jmp Store		; ( addr-t u-t )
.ac99					ed_cmd_equ:
.ac99	a5 1e		lda $1e				lda ed_head
.ac9b	05 1f		ora $1f				ora ed_head+1
.ac9d	d0 06		bne $aca5			bne _cmd_equ_have_text
.ac9f	20 f2 c7	jsr $c7f2			jsr Zero		; ( addr-t u-t para1 para2 0 )
.aca2	4c c5 ac	jmp $acc5			jmp _cmd_equ_done
.aca5					_cmd_equ_have_text:
.aca5	20 a6 ae	jsr $aea6			jsr ed_no_line_zero
.aca8	24 22		bit $22				bit ed_flags
.acaa	30 0a		bmi $acb6			bmi _cmd_equ_have_para
.acac	a5 20		lda $20				lda ed_cur+0		; ( addr-t u-t para1 para2 ? )
.acae	a4 21		ldy $21				ldy ed_cur+1
.acb0	20 b5 c7	jsr $c7b5			jsr PushYA
.acb3	4c c5 ac	jmp $acc5			jmp _cmd_equ_done	; ( addr-t u-t para1 para2 cur )
.acb6					_cmd_equ_have_para:
.acb6	b5 24		lda $24,x			lda DStack+0,x
.acb8	15 25		ora $25,x			ora DStack+1,x
.acba	d0 06		bne $acc2			bne _cmd_equ_two_paras
.acbc	20 a4 df	jsr $dfa4			jsr Over		; ( addr-t u-t para1 para2 para1)
.acbf	4c c5 ac	jmp $acc5			jmp _cmd_equ_done
.acc2					_cmd_equ_two_paras:
.acc2	20 cd df	jsr $dfcd			jsr Dup			; ( addr-t u-t para1 para2 para2) drop through
.acc5					_cmd_equ_done:
.acc5	20 4c bb	jsr $bb4c			jsr CR			; number goes on new line
.acc8	20 4d dc	jsr $dc4d			jsr U_Dot		; ( addr-t u-t para1 para2 )
.accb	20 4c bb	jsr $bb4c			jsr CR
.acce	4c 91 ab	jmp $ab91			jmp ed_next_command
.acd1					ed_cmd_f:
.acd1	24 22		bit $22				bit ed_flags
.acd3	30 18		bmi $aced			bmi _cmd_f_have_para
.acd5	20 4c bb	jsr $bb4c			jsr CR
.acd8	20 3d df	jsr $df3d			jsr To_R		; ( addr-t u-t 0 ) ( R: 0 )
.acdb	20 ae de	jsr $deae			jsr Rot			; ( u-t 0 addr-t ) ( R: 0 )
.acde	20 cd df	jsr $dfcd			jsr Dup			; ( u-t 0 addr-t addr-t ) ( R: 0 )
.ace1	20 4d dc	jsr $dc4d			jsr U_Dot		; ( u-t 0 addr-t ) ( R: 0 )
.ace4	20 d3 de	jsr $ded3			jsr Not_Rot		; ( addr-t u-t 0 ) ( R: 0 )
.ace7	20 5b df	jsr $df5b			jsr R_From		; ( addr-t u-t 0 0 )
.acea	4c fe ac	jmp $acfe			jmp _cmd_f_done
.aced					_cmd_f_have_para:
.aced	20 a4 df	jsr $dfa4			jsr Over
.acf0	20 4c bb	jsr $bb4c			jsr CR
.acf3	20 4d dc	jsr $dc4d			jsr U_Dot
.acf6	b5 26		lda $26,x			lda DStack+2,x
.acf8	95 2a		sta $2a,x			sta DStack+6,x
.acfa	b5 27		lda $27,x			lda DStack+3,x
.acfc	95 2b		sta $2b,x			sta DStack+7,x		; fall through to _cmd_f_done
.acfe					_cmd_f_done:
.acfe	20 4c bb	jsr $bb4c			jsr CR
.ad01	4c 91 ab	jmp $ab91			jmp ed_next_command
.ad04					ed_cmd_i:
.ad04	e8		inx				inx
.ad05	e8		inx				inx			;  DROP ( addr-t u-t para1 )
.ad06	24 22		bit $22				bit ed_flags
.ad08	30 08		bmi $ad12			bmi _cmd_i_have_para
.ad0a	a5 20		lda $20				lda ed_cur
.ad0c	95 24		sta $24,x			sta DStack+0,x
.ad0e	a5 21		lda $21				lda ed_cur+1
.ad10	95 25		sta $25,x			sta DStack+1,x		;  ( addr-t u-t cur ) drop through
.ad12					_cmd_i_have_para:
.ad12	b5 24		lda $24,x			lda DStack+0,x
.ad14	15 25		ora $25,x			ora DStack+1,x
.ad16	f0 09		beq $ad21			beq _cmd_i_done
.ad18	20 6f da	jsr $da6f			jsr One_minus		; ( addr-t u-t para1-1 )
.ad1b	20 f2 c7	jsr $c7f2			jsr Zero		; ( addr-t u-t para1-1 0 )
.ad1e	20 ae d9	jsr $d9ae			jsr Max			; ( addr-t u-t para1-1 | 0 )
.ad21					_cmd_i_done:
.ad21	4c a8 ab	jmp $aba8			jmp ed_entry_cmd_i
.ad24					ed_cmd_n:
.ad24	a9 01		lda #$01			lda #%00000001
.ad26	05 22		ora $22				ora ed_flags
.ad28	85 22		sta $22				sta ed_flags
.ad2a	4c 33 ad	jmp $ad33			jmp ed_cmd_p_entry_for_cmd_n
.ad2d					ed_cmd_p:
.ad2d					ed_cmd_p_from_external:
.ad2d	a9 fe		lda #$fe			lda #$ff-%00000001
.ad2f	25 22		and $22				and ed_flags
.ad31	85 22		sta $22				sta ed_flags
.ad33					ed_cmd_p_entry_for_cmd_n:
.ad33	20 63 ae	jsr $ae63			jsr ed_have_text
.ad36	20 a6 ae	jsr $aea6			jsr ed_no_line_zero
.ad39	20 4c bb	jsr $bb4c			jsr CR
.ad3c	b5 24		lda $24,x			lda DStack+0,x
.ad3e	15 25		ora $25,x			ora DStack+1,x
.ad40	d0 11		bne $ad53			bne _cmd_p_loop
.ad42	b5 26		lda $26,x			lda DStack+2,x
.ad44	85 20		sta $20				sta ed_cur
.ad46	b5 27		lda $27,x			lda DStack+3,x
.ad48	85 21		sta $21				sta ed_cur+1
.ad4a	20 a4 df	jsr $dfa4			jsr Over		; ( addr-t u-t para1 para2 para1 )
.ad4d	20 74 ad	jsr $ad74			jsr _cmd_p_common	; ( addr-t u-t para1 para2 )
.ad50	4c 71 ad	jmp $ad71			jmp _cmd_p_all_done
.ad53					_cmd_p_loop:
.ad53	b5 24		lda $24,x			lda DStack+0,x		; para1 > para2 ?
.ad55	d5 26		cmp $26,x			cmp DStack+2,x
.ad57	b5 25		lda $25,x			lda DStack+1,x
.ad59	f5 27		sbc $27,x			sbc DStack+3,x
.ad5b	90 0c		bcc $ad69			bcc _cmd_p_done
.ad5d	20 a4 df	jsr $dfa4			jsr Over		; ( addr-t u-t para1 para2 para1 )
.ad60	20 74 ad	jsr $ad74			jsr _cmd_p_common	; ( addr-t u-t para1 para2 )
.ad63	20 a0 da	jsr $daa0			jsr NOS_One_Plus
.ad66	4c 53 ad	jmp $ad53			jmp _cmd_p_loop
.ad69					_cmd_p_done:
.ad69	b5 24		lda $24,x			lda DStack+0,x
.ad6b	85 20		sta $20				sta ed_cur
.ad6d	b5 25		lda $25,x			lda DStack+1,x
.ad6f	85 21		sta $21				sta ed_cur+1
.ad71					_cmd_p_all_done:
.ad71	4c 91 ab	jmp $ab91			jmp ed_next_command
.ad74					_cmd_p_common:
.ad74	a5 22		lda $22				lda ed_flags
.ad76	4a		lsr a				lsr			; bit 0 now in carry
.ad77	90 0b		bcc $ad84			bcc _cmd_p_common_no_num
.ad79	20 cd df	jsr $dfcd			jsr Dup			; ( addr-t u-t para1 para1 )
.ad7c	20 4d dc	jsr $dc4d			jsr U_Dot		; ( addr-t u-t para1 )
.ad7f	a9 09		lda #$09			lda #AscHT
.ad81	20 1c de	jsr $de1c			jsr Emit_A
.ad84					_cmd_p_common_no_num:
.ad84	20 b4 ae	jsr $aeb4			jsr ed_num_to_addr	  ; ( addr-t u-t addr )
.ad87	4c d8 ae	jmp $aed8			jmp ed_print_addr
.ad8a					ed_cmd_q:
.ad8a	24 22		bit $22				bit ed_flags		; bit 6 is change flag
.ad8c	50 03		bvc $ad91			bvc +
.ad8e	4c 42 ae	jmp $ae42			jmp ed_error_2drop
.ad91					+
.ad91	4c 97 ab	jmp $ab97			jmp ed_all_done		   ; can't fall thru because of PLX
.ad94					ed_cmd_qq:
.ad94	4c 97 ab	jmp $ab97			jmp ed_all_done
.ad97					ed_cmd_w:
.ad97	20 63 ae	jsr $ae63			jsr ed_have_text
.ad9a	24 22		bit $22				bit ed_flags		; parameter given?
.ad9c	30 12		bmi $adb0			bmi _cmd_w_have_para
.ad9e	b5 2b		lda $2b,x			lda DStack+7,x		; $0000 thru $00ff ?
.ada0	d0 03		bne $ada5			bne +
.ada2	4c 42 ae	jmp $ae42			jmp ed_error_2drop
.ada5					+
.ada5	b5 2a		lda $2a,x			lda DStack+6,x
.ada7	95 26		sta $26,x			sta DStack+2,x
.ada9	b5 2b		lda $2b,x			lda DStack+7,x
.adab	95 27		sta $27,x			sta DStack+3,x		; ( addr-t u-t addr-t ? )
.adad	4c b8 ad	jmp $adb8			jmp _cmd_w_para_ready
.adb0					_cmd_w_have_para:
.adb0	b5 26		lda $26,x			lda DStack+2,x
.adb2	95 2a		sta $2a,x			sta DStack+6,x
.adb4	b5 27		lda $27,x			lda DStack+3,x
.adb6	95 2b		sta $2b,x			sta DStack+7,x		; drop through to _cmd_w_para_ready
.adb8					_cmd_w_para_ready:
.adb8	a9 1e		lda #$1e			lda #<ed_head
.adba	95 24		sta $24,x			sta DStack+0,x
.adbc	a9 00		lda #$00			lda #>ed_head
.adbe	95 25		sta $25,x			sta DStack+1,x		; ( addr-t u-t addr-t addr-h )
.adc0	20 a4 df	jsr $dfa4			jsr Over		; ( addr-t u-t addr-t addr-h addr-t )
.adc3	20 3d df	jsr $df3d			jsr To_R		; ( addr-t u-t addr-t addr-h ) ( R: addr-t )
.adc6					_cmd_w_loop:
.adc6	20 f5 de	jsr $def5			jsr Fetch		; ( addr-t u-t addr-t addr1 ) ( R: addr-t )
.adc9	b5 24		lda $24,x			lda DStack+0,x
.adcb	15 25		ora $25,x			ora DStack+1,x
.adcd	f0 4d		beq $ae1c			beq _cmd_w_eol
.adcf	20 f1 dc	jsr $dcf1			jsr Two_dup		; ( addr-t addr-1 addr-t addr-1 ) ( R: addr-t addr-1 addr-t )
.add2	20 9f d6	jsr $d69f			jsr Two_to_r		; ( addr-t addr-1 ) (R: ... )
.add5	20 41 da	jsr $da41			jsr Cell_Plus		; ( addr-t addr1+2 ) (R: ... )
.add8	20 cd df	jsr $dfcd			jsr Dup			; ( addr-t addr1+2 addr1+2 ) ( R: ... )
.addb	20 f5 de	jsr $def5			jsr Fetch		; ( addr-t addr1+2 addr-s ) ( R: ... )
.adde	20 ee df	jsr $dfee			jsr Swap		; ( addr-t addr-s addr1+2 ) ( R: ... )
.ade1	20 41 da	jsr $da41			jsr Cell_Plus		; ( addr-t addr-s addr1+2 ) (R: ... )
.ade4	20 f5 de	jsr $def5			jsr Fetch		; ( addr-t addr-s u-s ) ( R: ... )
.ade7	20 d3 de	jsr $ded3			jsr Not_Rot		; ( u-s addr-t addr-s ) ( R: ... )
.adea	20 ee df	jsr $dfee			jsr Swap		; ( u-s addr-s addr-t ) ( R: ... )
.aded	20 ae de	jsr $deae			jsr Rot			; (addr-s addr-t u-s ) ( R: ... )
.adf0	20 cd df	jsr $dfcd			jsr Dup			; (addr-s addr-t u-s u-s ) ( R: ... )
.adf3	20 3d df	jsr $df3d			jsr To_R		; (addr-s addr-t u-s ) ( R: ... u-s )
.adf6	20 5f bd	jsr $bd5f			jsr Move		; ( )( R: addr-t addr-1 addr-t )
.adf9	20 5b df	jsr $df5b			jsr R_From		; ( u-s )  ( R: addr-t addr-h addr-t )
.adfc	20 7b d6	jsr $d67b			jsr Two_r_from		; ( u-s addr-t addr-h ) ( R: addr-t )
.adff	20 d3 de	jsr $ded3			jsr Not_Rot		; ( addr-h u-s addr-t ) ( R: addr-t )
.ae02	20 ea db	jsr $dbea			jsr Plus		; ( addr-h addr-t1 ) ( R: addr-t )
.ae05	20 cd df	jsr $dfcd			jsr Dup			; ( addr-h addr-t1 addr-t1 ) ( R: addr-t )
.ae08	a9 0a		lda #$0a			lda #AscLF
.ae0a	20 e4 c7	jsr $c7e4			jsr PushZA		; ( addr-h addr-t1 addr-t1 c ) ( R: addr-t )
.ae0d	20 ee df	jsr $dfee			jsr Swap		; ( addr-h addr-t1 c addr-t1 ) ( R: addr-t )
.ae10	20 0e df	jsr $df0e			jsr Store		; ( addr-h addr-t1 ) ( R: addr-t )
.ae13	20 95 da	jsr $da95			jsr One_plus		; ( addr-h addr-t1+1 ) ( R: addr-t )
.ae16	20 ee df	jsr $dfee			jsr Swap		; ( addr-t1+1 addr-h ) ( R: addr-t )
.ae19	4c c6 ad	jmp $adc6			jmp _cmd_w_loop
.ae1c					_cmd_w_eol:
.ae1c	20 ee df	jsr $dfee			jsr Swap		; ( addr-t u-t addr-n addr-tn ) ( R: addr-t )
.ae1f	20 5b df	jsr $df5b			jsr R_From		; ( addr-t u-t addr-n addr-tn addr-t )
.ae22	20 03 dc	jsr $dc03			jsr Minus		; ( addr-t u-t addr-n u )
.ae25	b5 24		lda $24,x			lda DStack+0,x
.ae27	95 28		sta $28,x			sta DStack+4,x
.ae29	b5 25		lda $25,x			lda DStack+1,x
.ae2b	95 29		sta $29,x			sta DStack+5,x		; ( addr-t u addr-n u )
.ae2d	20 4c bb	jsr $bb4c			jsr CR
.ae30	20 cd df	jsr $dfcd			jsr Dup			; ( addr-t u addr-n u u )
.ae33	20 4d dc	jsr $dc4d			jsr U_Dot		; ( addr-t u addr-n u )
.ae36	20 4c bb	jsr $bb4c			jsr CR
.ae39	a9 bf		lda #$bf			lda #$ff-%01000000
.ae3b	25 22		and $22				and ed_flags
.ae3d	85 22		sta $22				sta ed_flags
.ae3f	4c 91 ab	jmp $ab91			jmp ed_next_command
.ae42					ed_error_2drop:
.ae42	e8		inx				inx			; Drop para2
.ae43	e8		inx				inx
.ae44					ed_error_1drop:
.ae44	e8		inx				inx			; Drop para1
.ae45	e8		inx				inx
.ae46					ed_error:
.ae46	20 4c bb	jsr $bb4c			jsr CR
.ae49	a9 3f		lda #$3f			lda #'?'
.ae4b	20 1c de	jsr $de1c			jsr Emit_A
.ae4e	20 4c bb	jsr $bb4c			jsr CR
.ae51	4c af a9	jmp $a9af			jmp ed_input_loop
.ae54					ed_get_input:
.ae54	20 92 d2	jsr $d292			jsr Refill		;  ( addr-t u-t f )
.ae57	b5 24		lda $24,x			lda DStack+0,x
.ae59	d0 05		bne $ae60			bne +
.ae5b	68		pla				pla
.ae5c	68		pla				pla
.ae5d	4c 44 ae	jmp $ae44			jmp ed_error_1drop
.ae60					+
.ae60	e8		inx				inx
.ae61	e8		inx				inx
.ae62	60		rts				rts
.ae63					ed_have_text:
.ae63	a5 1e		lda $1e				lda ed_head
.ae65	05 1f		ora $1f				ora ed_head+1
.ae67	d0 05		bne $ae6e			bne +
.ae69	68		pla				pla
.ae6a	68		pla				pla
.ae6b	4c 46 ae	jmp $ae46			jmp ed_error
.ae6e					+
.ae6e	60		rts				rts
.ae6f					ed_is_valid_line:
.ae6f	38		sec				sec				; default is legal line number
.ae70	b5 24		lda $24,x			lda DStack+0,x
.ae72	15 25		ora $25,x			ora DStack+1,x
.ae74	f0 18		beq $ae8e			beq _nope_zero	; ( n )
.ae76	20 cd df	jsr $dfcd			jsr Dup				; ( n n )
.ae79	20 90 ae	jsr $ae90			jsr ed_last_line		; ( n n last )
.ae7c	20 ee df	jsr $dfee			jsr Swap			; ( n last n )
.ae7f	20 ad d8	jsr $d8ad			jsr Less_Than			; ( n f )
.ae82	b5 24		lda $24,x			lda DStack+0,x			; 0 flag is good
.ae84	15 25		ora $25,x			ora DStack+1,x
.ae86	d0 04		bne $ae8c			bne _too_small
.ae88	e8		inx				inx
.ae89	e8		inx				inx			; DROP flag ( n )
.ae8a	38		sec				sec			; signal valid
.ae8b	60		rts				rts
.ae8c					_too_small:
.ae8c	e8		inx				inx
.ae8d	e8		inx				inx
.ae8e					_nope_zero:
.ae8e	18		clc				clc			; signal not valid
.ae8f	60		rts				rts
.ae90					ed_last_line:
.ae90	20 f2 c7	jsr $c7f2			jsr Zero		; Set counter to zero
.ae93	a9 1e		lda #$1e			lda #ed_head
.ae95	20 e4 c7	jsr $c7e4			jsr PushZA		; ( count addr )
.ae98					_loop:
.ae98	20 f5 de	jsr $def5			jsr Fetch		; ( count addr|0 )
.ae9b	b5 25		lda $25,x			lda DStack+1,x		; at end-of-list?
.ae9d	f0 06		beq $aea5			beq _done
.ae9f	20 a0 da	jsr $daa0			jsr NOS_One_Plus	; Increase counter
.aea2	4c 98 ae	jmp $ae98			jmp _loop		; continue
.aea5					_done:
.aea5	60		rts				rts
.aea6					ed_no_line_zero:
.aea6	b5 26		lda $26,x			lda DStack+2,x
.aea8	15 27		ora $27,x			ora DStack+3,x
.aeaa	d0 07		bne $aeb3			bne _done
.aeac	24 22		bit $22				bit ed_flags
.aeae	10 03		bpl $aeb3			bpl _done
.aeb0	4c 42 ae	jmp $ae42			jmp ed_error_2drop
.aeb3					_done:
.aeb3	60		rts				rts
.aeb4					ed_num_to_addr:
.aeb4	a9 1e		lda #$1e			lda #ed_head
.aeb6	20 e4 c7	jsr $c7e4			jsr PushZA		; ( u addr-h )
.aeb9	4c c6 ae	jmp $aec6			jmp _test
.aebc					_loop:
.aebc	20 f5 de	jsr $def5			jsr Fetch		; @ ( u addr1 )
.aebf	b5 25		lda $25,x			lda DStack+1,x		; at end of list?
.aec1	f0 09		beq $aecc			beq _finished
.aec3	20 7c da	jsr $da7c			jsr NOS_One_Minus	; decrement the line count
.aec6	b5 26		lda $26,x	_test:		lda DStack+2,x		; is the nth element we're looking for?
.aec8	15 27		ora $27,x			ora DStack+3,x
.aeca	d0 f0		bne $aebc			bne _loop
.aecc					_finished:
.aecc	4c c8 d9	jmp $d9c8			jmp Nip			; ( addr )
.aecf					ed_para1_to_cur:
.aecf	b5 26		lda $26,x			lda DStack+2,x
.aed1	85 20		sta $20				sta ed_cur
.aed3	b5 27		lda $27,x			lda DStack+3,x
.aed5	85 21		sta $21				sta ed_cur+1
.aed7	60		rts				rts
.aed8					ed_print_addr:
.aed8	20 41 da	jsr $da41			jsr Cell_Plus		; ( addr+2 )
.aedb	20 cd df	jsr $dfcd			jsr Dup			; ( addr+2 addr+2 )
.aede	20 41 da	jsr $da41			jsr Cell_Plus		; ( addr+2 addr+4 )
.aee1	20 f5 de	jsr $def5			jsr Fetch		; ( addr+2 u-s )
.aee4	20 ee df	jsr $dfee			jsr Swap		; ( u-s addr+2 )
.aee7	20 f5 de	jsr $def5			jsr Fetch		; ( u-s addr-s )
.aeea	20 ee df	jsr $dfee			jsr Swap		; ( addr-s u-s )
.aeed	20 34 de	jsr $de34			jsr Type
.aef0	4c 4c bb	jmp $bb4c			jmp CR
>aef3	61 66 69 64 70 6e 3d 77		ed_cmd_list:	.text "afidpn=wqQ", 0
>aefb	71 51 00
.aefe					ed_cmd_table:
>aefe	a6 ab d1 ac 04 ad 3a ac				.word ed_cmd_a, ed_cmd_f, ed_cmd_i, ed_cmd_d, ed_cmd_p, ed_cmd_n
>af06	2d ad 24 ad
>af0a	99 ac 97 ad 8a ad 94 ad				.word ed_cmd_equ, ed_cmd_w, ed_cmd_q, ed_cmd_qq
.af12					ed6502_end:
>af12	53 65 65 4c 61 74 65 73		Name0:	.text "SeeLatest"	;  name of word as a string, ending at wh_NameLastChar
>af1a	74
=9					NameLength = *-Name0
=44699					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>af1b	89					.byte (("SeeLatest"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=1424					LinkDisplacement = Nt0-WordListLink
=$11						  WordFlags ::= WordFlags | FP
>af1c	11					.byte WordFlags	;wh_Flags
>af1d	03					.byte 3	;wh_CodeLength
>af1e	0b a9					  .word WordListLink
=$af20					XtPtr1 ::= *
=44699					WordListLink ::= Nt0 ; remember the nt of this word for later
.af20	20 54 ca	jsr $ca54	SeeLatest:	jsr current_to_dp
.af23	a5 10		lda $10				lda dp+0
.af25	a4 11		ldy $11				ldy dp+1
.af27	20 b5 c7	jsr $c7b5			jsr PushYA
.af2a	4c 37 af	jmp $af37			jmp See3
=13					CodeLen	.var *-XtPtr1
=$af2d					Here1 = *	; remember here
>af1d	0d					.byte CodeLen	;patch wh_CodeLength
>af2d	53 65 65			Name0:	.text "See"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=44720					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>af30	a3					.byte (("See"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=21					LinkDisplacement = Nt0-WordListLink
>af31	10					.byte WordFlags	;wh_Flags
>af32	03					.byte 3	;wh_CodeLength
>af33	15					  .byte LinkDisplacement	; offset to previous nt
=$af34					XtPtr1 ::= *
=44720					WordListLink ::= Nt0 ; remember the nt of this word for later
.af34					See:
.af34	20 47 cc	jsr $cc47			jsr Tick_Nt		; ( nt )
.af37	20 4c bb	jsr $bb4c	See3:		jsr CR
.af3a	ad 00 03	lda $0300			lda base		; Save the current number base
.af3d	48		pha				pha
.af3e	a9 ce		lda #$ce			lda #<str_see_nt	; print nt
.af40	a0 ea		ldy #$ea			ldy #>str_see_nt
.af42	20 50 de	jsr $de50			jsr Print_ASCIIZ_YA_no_lf
.af45	20 cd df	jsr $dfcd			jsr Dup			; ( nt nt )
.af48	20 ec b8	jsr $b8ec			jsr Dot_Hex
.af4b	20 28 de	jsr $de28			jsr Space		; ( nt )
.af4e	20 cd df	jsr $dfcd			jsr Dup			; ( nt nt )
.af51	20 a9 cd	jsr $cda9			jsr Name_To_Int		; ( nt xt )
.af54	a9 d4		lda #$d4			lda #<str_see_xt	; print xt
.af56	a0 ea		ldy #$ea			ldy #>str_see_xt
.af58	20 50 de	jsr $de50			jsr Print_ASCIIZ_YA_no_lf
.af5b	20 cd df	jsr $dfcd			jsr Dup			; ( nt xt xt )
.af5e	20 ec b8	jsr $b8ec			jsr Dot_Hex
.af61	20 4c bb	jsr $bb4c			jsr CR			; ( nt xt )
.af64	a9 c7		lda #$c7			lda #<str_see_flags
.af66	a0 ea		ldy #$ea			ldy #>str_see_flags
.af68	20 50 de	jsr $de50			jsr Print_ASCIIZ_YA_no_lf
.af6b	20 a4 df	jsr $dfa4			jsr Over		; ( nt xt nt )
.af6e	a9 81		lda #$81			lda #Wh_Flags
.af70	20 43 da	jsr $da43			jsr Plus_A		; ( nt xt ^flags )
.af73	a1 24		lda ($24,x)			lda (DStack+0,x)	; ( nt xt ^flags )
.af75	95 24		sta $24,x			sta DStack+0,x		; ( nt xt flags )
.af77	a0 0e		ldy #$0e			ldy #2*7		; for bit 7..0
.af79	20 28 de	jsr $de28	_flag_loop:	jsr Space
.af7c	b9 e0 af	lda $afe0,y			lda _FlagLabels+0,y	;   print label
.af7f	20 1c de	jsr $de1c			jsr Emit_A
.af82	b9 e1 af	lda $afe1,y			lda _FlagLabels+1,y
.af85	20 1c de	jsr $de1c			jsr Emit_A
.af88	a9 3d		lda #$3d			lda #'='
.af8a	20 1c de	jsr $de1c			jsr Emit_A
.af8d	16 24		asl $24,x			asl DStack+0,x		;   c = flag, rotate the rest
.af8f	a9 00		lda #$00			lda #0
.af91	69 30		adc #$30			adc #'0'
.af93	20 1c de	jsr $de1c			jsr Emit_A
.af96	88		dey				dey
.af97	88		dey				dey
.af98	10 df		bpl $af79			bpl _flag_loop
.af9a	e8		inx				inx
.af9b	e8		inx				inx			; ( nt xt )
.af9c	20 4c bb	jsr $bb4c			jsr CR
.af9f	a9 da		lda #$da			lda #<str_see_size	; print size
.afa1	a0 ea		ldy #$ea			ldy #>str_see_size
.afa3	20 50 de	jsr $de50			jsr Print_ASCIIZ_YA_no_lf
.afa6	20 ee df	jsr $dfee			jsr Swap		; ( xt nt )
.afa9	20 05 bb	jsr $bb05			jsr WordSize		; ( xt u )
.afac	20 b1 c1	jsr $c1b1			jsr Decimal
.afaf	b5 24		lda $24,x			lda DStack+0,x		; if = 255
.afb1	c9 ff		cmp #$ff			cmp #$ff
.afb3	d0 11		bne $afc6			bne _size5
.afb5	20 b8 c8	jsr $c8b8			jsr sliteral_runtime	;   type "large"
.afb8	4c c0 af	jmp $afc0			  jmp _size2
>afbb	6c 61 72 67 65					  .text "large"
.afc0	20 34 de	jsr $de34	_size2:		jsr Type
.afc3	4c cc af	jmp $afcc			jmp _size9		;  else
.afc6	20 cd df	jsr $dfcd	_size5:		jsr Dup			;    type size
.afc9	20 4d dc	jsr $dc4d			jsr U_Dot
.afcc					_size9:
.afcc	20 4c bb	jsr $bb4c			jsr CR
.afcf	68		pla				pla			; restore base
.afd0	8d 00 03	sta $0300			sta base
.afd3	20 f1 dc	jsr $dcf1			jsr Two_dup
.afd6	20 46 b8	jsr $b846			jsr Dump		; dump
.afd9	20 4c bb	jsr $bb4c			jsr CR
.afdc	20 5a e8	jsr $e85a			jsr DisAsm		; disassemble
=171					CodeLen	.var *-XtPtr1
=$afdf					Here1 = *	; remember here
>af32	ab					.byte CodeLen	;patch wh_CodeLength
.afdf	60		rts				rts
>afe0	46 50 44 42 43 4f 49 4d		_FlagLabels:	.text "FPDBCOIMNNANUF__"
>afe8	4e 4e 41 4e 55 46 5f 5f
>aff0	46 6f 72 74 68 2d 57 6f		Name0:	.text "Forth-WordList"	;  name of word as a string, ending at wh_NameLastChar
>aff8	72 64 4c 69 73 74
=14					NameLength = *-Name0
=44926					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>affe	8e					.byte (("Forth-WordList"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=206					LinkDisplacement = Nt0-WordListLink
>afff	10					.byte WordFlags	;wh_Flags
>b000	03					.byte 3	;wh_CodeLength
>b001	ce					  .byte LinkDisplacement	; offset to previous nt
=$b002					XtPtr1 ::= *
=44926					WordListLink ::= Nt0 ; remember the nt of this word for later
.b002	4c f2 c7	jmp $c7f2	Forth_WordList:	jmp Zero
=3					CodeLen	.var *-XtPtr1
=$b005					Here1 = *	; remember here
>b000	03					.byte CodeLen	;patch wh_CodeLength
>b005	45 64 69 74 6f 72 2d 57		Name0:	.text "Editor-WordList"	;  name of word as a string, ending at wh_NameLastChar
>b00d	6f 72 64 4c 69 73 74
=15					NameLength = *-Name0
=44948					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>b014	8f					.byte (("Editor-WordList"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=22					LinkDisplacement = Nt0-WordListLink
>b015	10					.byte WordFlags	;wh_Flags
>b016	03					.byte 3	;wh_CodeLength
>b017	16					  .byte LinkDisplacement	; offset to previous nt
=$b018					XtPtr1 ::= *
=44948					WordListLink ::= Nt0 ; remember the nt of this word for later
.b018	4c fb c7	jmp $c7fb	Editor_WordList: jmp One
=3					CodeLen	.var *-XtPtr1
=$b01b					Here1 = *	; remember here
>b016	03					.byte CodeLen	;patch wh_CodeLength
>b01b	41 73 73 65 6d 62 6c 65		Name0:	.text "Assembler-WordList"	;  name of word as a string, ending at wh_NameLastChar
>b023	72 2d 57 6f 72 64 4c 69 73 74
=18					NameLength = *-Name0
=44973					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>b02d	92					.byte (("Assembler-WordList"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=25					LinkDisplacement = Nt0-WordListLink
>b02e	10					.byte WordFlags	;wh_Flags
>b02f	03					.byte 3	;wh_CodeLength
>b030	19					  .byte LinkDisplacement	; offset to previous nt
=$b031					XtPtr1 ::= *
=44973					WordListLink ::= Nt0 ; remember the nt of this word for later
.b031	4c 04 c8	jmp $c804	Assembler_WordList: jmp Two
=3					CodeLen	.var *-XtPtr1
=$b034					Here1 = *	; remember here
>b02f	03					.byte CodeLen	;patch wh_CodeLength
>b034	52 6f 6f 74 2d 57 6f 72		Name0:	.text "Root-Wordlist"	;  name of word as a string, ending at wh_NameLastChar
>b03c	64 6c 69 73 74
=13					NameLength = *-Name0
=44993					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>b041	8d					.byte (("Root-Wordlist"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=20					LinkDisplacement = Nt0-WordListLink
>b042	10					.byte WordFlags	;wh_Flags
>b043	03					.byte 3	;wh_CodeLength
>b044	14					  .byte LinkDisplacement	; offset to previous nt
=$b045					XtPtr1 ::= *
=44993					WordListLink ::= Nt0 ; remember the nt of this word for later
.b045	a9 03		lda #$03	Root_WordList:	lda #wid_Root
.b047	4c e4 c7	jmp $c7e4			jmp PushZA
=5					CodeLen	.var *-XtPtr1
=$b04a					Here1 = *	; remember here
>b043	05					.byte CodeLen	;patch wh_CodeLength
>b04a	57 6f 72 64 4c 69 73 74		Name0:	.text "WordList"	;  name of word as a string, ending at wh_NameLastChar
=8					NameLength = *-Name0
=45010					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>b052	88					.byte (("WordList"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=17					LinkDisplacement = Nt0-WordListLink
>b053	10					.byte WordFlags	;wh_Flags
>b054	03					.byte 3	;wh_CodeLength
>b055	11					  .byte LinkDisplacement	; offset to previous nt
=$b056					XtPtr1 ::= *
=45010					WordListLink ::= Nt0 ; remember the nt of this word for later
.b056	ad 11 03	lda $0311	WordList:	lda Num_wordlistsV	; Get the current number of wordlists
.b059	c9 0c		cmp #$0c			cmp #max_wordlists	; already full?
.b05b	b0 06		bcs $b063			bcs _err
.b05d	ee 11 03	inc $0311			inc Num_WordlistsV	; increment wordlist count
.b060	4c e4 c7	jmp $c7e4			jmp PushZA		; put it on the stack as wid.
.b063	a9 66		lda #$66	_err:		lda #$100+err_TooManyWordlists	;   throw an error
.b065	4c 63 c4	jmp $c463			jmp ThrowA
=18					CodeLen	.var *-XtPtr1
=$b068					Here1 = *	; remember here
>b054	12					.byte CodeLen	;patch wh_CodeLength
>b068	44 65 66 69 6e 69 74 69		Name0:	.text "Definitions"	;  name of word as a string, ending at wh_NameLastChar
>b070	6f 6e 73
=11					NameLength = *-Name0
=45043					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>b073	6b					.byte (("Definitions"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=33					LinkDisplacement = Nt0-WordListLink
>b074	10					.byte WordFlags	;wh_Flags
>b075	03					.byte 3	;wh_CodeLength
>b076	21					  .byte LinkDisplacement	; offset to previous nt
=$b077					XtPtr1 ::= *
=45043					WordListLink ::= Nt0 ; remember the nt of this word for later
.b077	ad 2b 03	lda $032b	Definitions:	lda Search_OrderV+0	; Transfer SEARCH_ORDER[0] to
.b07a	8d 10 03	sta $0310			sta CurrentV		;   byte variable CURRENT.
=6					CodeLen	.var *-XtPtr1
=$b07d					Here1 = *	; remember here
>b075	06					.byte CodeLen	;patch wh_CodeLength
.b07d	60		rts				rts
>b07e	53 65 74 2d 43 75 72 72		Name0:	.text "Set-Current"	;  name of word as a string, ending at wh_NameLastChar
>b086	65 6e 74
=11					NameLength = *-Name0
=45065					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>b089	8b					.byte (("Set-Current"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=22					LinkDisplacement = Nt0-WordListLink
>b08a	10					.byte WordFlags	;wh_Flags
>b08b	03					.byte 3	;wh_CodeLength
>b08c	16					  .byte LinkDisplacement	; offset to previous nt
=$b08d					XtPtr1 ::= *
=45065					WordListLink ::= Nt0 ; remember the nt of this word for later
.b08d	20 c3 c3	jsr $c3c3	Set_Current:	jsr PopA	; pop wid
.b090	8d 10 03	sta $0310			sta CurrentV	; only the LSB is used.
=6					CodeLen	.var *-XtPtr1
=$b093					Here1 = *	; remember here
>b08b	06					.byte CodeLen	;patch wh_CodeLength
.b093	60		rts				rts
>b094	47 65 74 2d 43 75 72 72		Name0:	.text "Get-Current"	;  name of word as a string, ending at wh_NameLastChar
>b09c	65 6e 74
=11					NameLength = *-Name0
=45087					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>b09f	8b					.byte (("Get-Current"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=22					LinkDisplacement = Nt0-WordListLink
>b0a0	10					.byte WordFlags	;wh_Flags
>b0a1	03					.byte 3	;wh_CodeLength
>b0a2	16					  .byte LinkDisplacement	; offset to previous nt
=$b0a3					XtPtr1 ::= *
=45087					WordListLink ::= Nt0 ; remember the nt of this word for later
.b0a3					Get_Current:
.b0a3	ad 10 03	lda $0310			lda CurrentV
.b0a6	4c e4 c7	jmp $c7e4			jmp PushZA	; CURRENT is a byte variable
=6					CodeLen	.var *-XtPtr1
=$b0a9					Here1 = *	; remember here
>b0a1	06					.byte CodeLen	;patch wh_CodeLength
>b0a9	4f 72 64 65 72			Name0:	.text "Order"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=45102					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>b0ae	45					.byte (("Order"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=15					LinkDisplacement = Nt0-WordListLink
>b0af	10					.byte WordFlags	;wh_Flags
>b0b0	03					.byte 3	;wh_CodeLength
>b0b1	0f					  .byte LinkDisplacement	; offset to previous nt
=$b0b2					XtPtr1 ::= *
=45102					WordListLink ::= Nt0 ; remember the nt of this word for later
.b0b2					Order:
.b0b2	20 4c bb	jsr $bb4c			jsr CR
.b0b5	a0 00		ldy #$00			ldy #0			; for each search_orderV entry
.b0b7	f0 0b		beq $b0c4			beq _test
.b0b9	98		tya		_loop:		tya
.b0ba	48		pha				pha
.b0bb	b9 2b 03	lda $032b,y			lda Search_orderV,y
.b0be	20 cf b0	jsr $b0cf			jsr print_wid_stringA	; internal helper function
.b0c1	68		pla				pla
.b0c2	a8		tay				tay
.b0c3	c8		iny				iny			;  next
.b0c4	cc 2a 03	cpy $032a	_test:		cpy Num_orderV
.b0c7	90 f0		bcc $b0b9			bcc _loop
.b0c9	20 4c bb	jsr $bb4c			jsr CR
.b0cc	ad 10 03	lda $0310			lda CurrentV		; print the current wordlist.
.b0cf					print_wid_stringA:
.b0cf	c9 04		cmp #$04			cmp #wid_Root+1		; do we have a string?
.b0d1	90 06		bcc $b0d9			bcc _string
.b0d3	20 e4 c7	jsr $c7e4			jsr PushZA		; print the WID number
.b0d6	4c 4d dc	jmp $dc4d			jmp U_Dot		; JSR/RTS
.b0d9	0a		asl a		_string:	asl			; Get the word index based on WID 0 to 3
.b0da	a8		tay				tay
.b0db	ca		dex				dex			; TOS= word nt
.b0dc	ca		dex				dex
.b0dd	b9 f5 b0	lda $b0f5,y			lda _wid_Table+0,y
.b0e0	95 24		sta $24,x			sta DStack+0,x
.b0e2	b9 f6 b0	lda $b0f6,y			lda _wid_Table+1,y
.b0e5	95 25		sta $25,x			sta DStack+1,x		; ( nt )
.b0e7	20 f2 cd	jsr $cdf2			jsr Name_To_String	; ( addr u )
.b0ea	a9 f7		lda #$f7			lda #$100-9		;   cut off "_wordlist"
.b0ec	20 85 da	jsr $da85			jsr Minus_A
.b0ef	20 34 de	jsr $de34			jsr Type		; Print
.b0f2	4c 28 de	jmp $de28			jmp Space
=67					CodeLen	.var *-XtPtr1
=$b0f5					Here1 = *	; remember here
>b0b0	43					.byte CodeLen	;patch wh_CodeLength
.b0f5					_wid_Table:
>b0f5	7e af					.word forth_wordlist-wh_LinkNt-1	; WID 0:
>b0f7	94 af					.word editor_wordlist-wh_LinkNt-1	; WID 1:
>b0f9	ad af					.word assembler_wordlist-wh_LinkNt-1	; WID 2:
>b0fb	c1 af					.word root_wordlist-wh_LinkNt-1		; WID 3:
>b0fd	46 6f 72 74 68			Name0:	.text "Forth"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=45186					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>b102	05					.byte (("Forth"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=84					LinkDisplacement = Nt0-WordListLink
>b103	10					.byte WordFlags	;wh_Flags
>b104	03					.byte 3	;wh_CodeLength
>b105	54					  .byte LinkDisplacement	; offset to previous nt
=$b106					XtPtr1 ::= *
=45186					WordListLink ::= Nt0 ; remember the nt of this word for later
.b106	a9 00		lda #$00	Forth:		lda #wid_Forth
.b108	8d 2b 03	sta $032b			sta Search_OrderV+0
=5					CodeLen	.var *-XtPtr1
=$b10b					Here1 = *	; remember here
>b104	05					.byte CodeLen	;patch wh_CodeLength
.b10b	60		rts				rts
>b10c	50 72 65 76 69 6f 75 73		Name0:	.text "Previous"	;  name of word as a string, ending at wh_NameLastChar
=8					NameLength = *-Name0
=45204					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>b114	68					.byte (("Previous"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=18					LinkDisplacement = Nt0-WordListLink
>b115	10					.byte WordFlags	;wh_Flags
>b116	03					.byte 3	;wh_CodeLength
>b117	12					  .byte LinkDisplacement	; offset to previous nt
=$b118					XtPtr1 ::= *
=45204					WordListLink ::= Nt0 ; remember the nt of this word for later
.b118	20 96 b1	jsr $b196	Previous:	jsr Get_Order
.b11b	20 c8 d9	jsr $d9c8			jsr Nip
.b11e	20 6f da	jsr $da6f			jsr One_minus
.b121	4c 6f b1	jmp $b16f			jmp Set_Order
=12					CodeLen	.var *-XtPtr1
=$b124					Here1 = *	; remember here
>b116	0c					.byte CodeLen	;patch wh_CodeLength
>b124	41 6c 73 6f			Name0:	.text "Also"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=45224					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>b128	e4					.byte (("Also"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=20					LinkDisplacement = Nt0-WordListLink
>b129	10					.byte WordFlags	;wh_Flags
>b12a	03					.byte 3	;wh_CodeLength
>b12b	14					  .byte LinkDisplacement	; offset to previous nt
=$b12c					XtPtr1 ::= *
=45224					WordListLink ::= Nt0 ; remember the nt of this word for later
.b12c	20 96 b1	jsr $b196	Also:		jsr Get_Order
.b12f	20 a4 df	jsr $dfa4			jsr Over
.b132	20 ee df	jsr $dfee			jsr Swap
.b135	20 95 da	jsr $da95			jsr One_plus
.b138	4c 6f b1	jmp $b16f			jmp Set_Order
=15					CodeLen	.var *-XtPtr1
=$b13b					Here1 = *	; remember here
>b12a	0f					.byte CodeLen	;patch wh_CodeLength
>b13b	3e 4f 72 64 65 72		Name0:	.text ">Order"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=45249					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>b141	46					.byte ((">Order"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=25					LinkDisplacement = Nt0-WordListLink
>b142	10					.byte WordFlags	;wh_Flags
>b143	03					.byte 3	;wh_CodeLength
>b144	19					  .byte LinkDisplacement	; offset to previous nt
=$b145					XtPtr1 ::= *
=45249					WordListLink ::= Nt0 ; remember the nt of this word for later
.b145	20 2c b1	jsr $b12c	To_Order:	jsr Also		; make room in search list
.b148	20 c3 c3	jsr $c3c3			jsr PopA
.b14b	8d 2b 03	sta $032b			sta Search_OrderV+0	; set 1st search entry
=9					CodeLen	.var *-XtPtr1
=$b14e					Here1 = *	; remember here
>b143	09					.byte CodeLen	;patch wh_CodeLength
.b14e	60		rts				rts
>b14f	4f 6e 6c 79			Name0:	.text "Only"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=45267					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>b153	24					.byte (("Only"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=18					LinkDisplacement = Nt0-WordListLink
>b154	10					.byte WordFlags	;wh_Flags
>b155	03					.byte 3	;wh_CodeLength
>b156	12					  .byte LinkDisplacement	; offset to previous nt
=$b157					XtPtr1 ::= *
=45267					WordListLink ::= Nt0 ; remember the nt of this word for later
.b157	a9 01		lda #$01	Only:		lda #1
.b159	8d 2a 03	sta $032a			sta Num_orderV	; set count
.b15c	a9 03		lda #$03			lda #wid_Root
.b15e	8d 2b 03	sta $032b			sta Search_OrderV+0 ; set 1st search entry
=10					CodeLen	.var *-XtPtr1
=$b161					Here1 = *	; remember here
>b155	0a					.byte CodeLen	;patch wh_CodeLength
.b161	60		rts				rts
>b162	53 65 74 2d 4f 72 64 65		Name0:	.text "Set-Order"	;  name of word as a string, ending at wh_NameLastChar
>b16a	72
=9					NameLength = *-Name0
=45291					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>b16b	49					.byte (("Set-Order"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=24					LinkDisplacement = Nt0-WordListLink
>b16c	10					.byte WordFlags	;wh_Flags
>b16d	03					.byte 3	;wh_CodeLength
>b16e	18					  .byte LinkDisplacement	; offset to previous nt
=$b16f					XtPtr1 ::= *
=45291					WordListLink ::= Nt0 ; remember the nt of this word for later
.b16f					Set_Order:
.b16f	20 c3 c3	jsr $c3c3			jsr PopA	; pop count
.b172	a8		tay				tay		; was it -1 ?
.b173	30 e2		bmi $b157			bmi Only
.b175	8d 2a 03	sta $032a			sta Num_orderV	; Set #ORDER - the number of wordlists in the search order.
.b178	a0 00		ldy #$00			ldy #0
.b17a	f0 07		beq $b183			beq _test
.b17c					_loop:
.b17c	20 c3 c3	jsr $c3c3			jsr PopA		; The search order is a byte array
.b17f	99 2b 03	sta $032b,y			sta Search_OrderV,y	; so only save the LSB
.b182	c8		iny				iny
.b183					_test:
.b183	cc 2a 03	cpy $032a			cpy Num_orderV
.b186	d0 f4		bne $b17c			bne _loop
=25					CodeLen	.var *-XtPtr1
=$b188					Here1 = *	; remember here
>b16d	19					.byte CodeLen	;patch wh_CodeLength
.b188	60		rts				rts
>b189	47 65 74 2d 4f 72 64 65		Name0:	.text "Get-Order"	;  name of word as a string, ending at wh_NameLastChar
>b191	72
=9					NameLength = *-Name0
=45330					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>b192	49					.byte (("Get-Order"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=39					LinkDisplacement = Nt0-WordListLink
>b193	10					.byte WordFlags	;wh_Flags
>b194	03					.byte 3	;wh_CodeLength
>b195	27					  .byte LinkDisplacement	; offset to previous nt
=$b196					XtPtr1 ::= *
=45330					WordListLink ::= Nt0 ; remember the nt of this word for later
.b196					Get_Order:
.b196	ac 2a 03	ldy $032a			ldy Num_OrderV	; Get #ORDER - the number of wordlists in the search order.
.b199	f0 09		beq $b1a4			beq _done	; If zero, there are no wordlists.
.b19b					_loop:
.b19b	b9 2a 03	lda $032a,y			lda Search_OrderV-1,y	; Put that wordlist id on the stack.
.b19e	20 e4 c7	jsr $c7e4			jsr PushZA
.b1a1	88		dey				dey
.b1a2	d0 f7		bne $b19b			bne _loop		; See if that was the last one to process (first in the list).
.b1a4					_done:
.b1a4	ad 2a 03	lda $032a			lda Num_OrderV		; Push the number of items
.b1a7	4c e4 c7	jmp $c7e4			jmp PushZA
=20					CodeLen	.var *-XtPtr1
=$b1aa					Here1 = *	; remember here
>b194	14					.byte CodeLen	;patch wh_CodeLength
>b1aa	53 65 61 72 63 68 2d 57		Name0:	.text "Search-Wordlist"	;  name of word as a string, ending at wh_NameLastChar
>b1b2	6f 72 64 6c 69 73 74
=15					NameLength = *-Name0
=45369					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>b1b9	8f					.byte (("Search-Wordlist"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=39					LinkDisplacement = Nt0-WordListLink
>b1ba	10					.byte WordFlags	;wh_Flags
>b1bb	03					.byte 3	;wh_CodeLength
>b1bc	27					  .byte LinkDisplacement	; offset to previous nt
=$b1bd					XtPtr1 ::= *
=45369					WordListLink ::= Nt0 ; remember the nt of this word for later
.b1bd					Search_WordList:
.b1bd	20 c3 c3	jsr $c3c3			jsr PopA		; Pop wid
.b1c0	48		pha				pha			; ( addr u )
.b1c1	20 a2 cc	jsr $cca2			jsr swl_prepare 	; ( )
.b1c4	68		pla				pla			; get wid
.b1c5	20 cb cc	jsr $cccb			jsr swl_search_wordlist ; tmp1= nt of matching word
.b1c8	f0 11		beq $b1db			beq _NotFound
.b1ca	20 ac cd	jsr $cdac			jsr Name_To_Int_T	; ( xt )
.b1cd	a0 81		ldy #$81			ldy #Wh_Flags		; get flags
.b1cf	b1 14		lda ($14),y			lda (tmp1),y
.b1d1	29 08		and #$08			and #IM
.b1d3	d0 03		bne $b1d8			bne _immediate		; bit set, we're immediate
.b1d5	4c c4 c7	jmp $c7c4			jmp True		; Word is not immediate, return -1
.b1d8	4c fb c7	jmp $c7fb	_immediate:	jmp One			; Word is immediate, return 1
.b1db	4c f2 c7	jmp $c7f2	_NotFound:	jmp Zero		; Word not found, return 0
=33					CodeLen	.var *-XtPtr1
=$b1de					Here1 = *	; remember here
>b1bb	21					.byte CodeLen	;patch wh_CodeLength
>0339					BlockReadV: .word ?	; Vector to block reading routine
>033b					BlockWriteV: .word ?	; Vector to block writing routine
>033d					BuffBlockNumV: .word ?	; Block number current in BlockBuffer
>033f					BuffStatusV: .word ?	; Status of BlockBuffer (bit 0 = used, bit 1 = dirty)
>0341					BlockBuffer: .fill 1024
.b1de					BlockInit:
.b1de	a9 00		lda #$00			lda #0
.b1e0	8d 3f 03	sta $033f			sta BuffStatusV
.b1e3	a9 45		lda #$45			lda #<Platform_Block_Read
.b1e5	a0 f1		ldy #$f1			ldy #>Platform_Block_Read
.b1e7	8d 39 03	sta $0339			sta BlockReadV+0
.b1ea	8c 3a 03	sty $033a			sty BlockReadV+1
.b1ed	a9 70		lda #$70			lda #<Platform_Block_Write
.b1ef	a0 f1		ldy #$f1			ldy #>Platform_Block_Write
.b1f1	8d 3b 03	sta $033b			sta BlockWriteV+0
.b1f4	8c 3c 03	sty $033c			sty BlockWriteV+1
.b1f7	60		rts				rts
>0741					RamDriveV: .word ?	; ptr to RamDrive storage area
=0					io_blk_status = 0
=0					io_blk_action = 0
=0					io_blk_number = 0
=0					io_blk_buffer = 0
>b1f8	42 6c 6f 63 6b 2d 52 61		Name0:	.text "Block-RamDrive-Init"	;  name of word as a string, ending at wh_NameLastChar
>b200	6d 44 72 69 76 65 2d 49 6e 69 74
=19					NameLength = *-Name0
=45451					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>b20b	93					.byte (("Block-RamDrive-Init"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=80					WordFlags ::= UF+NN	; modifiable copy, remember for later
=82					LinkDisplacement = Nt0-WordListLink
>b20c	50					.byte WordFlags	;wh_Flags
>b20d	03					.byte 3	;wh_CodeLength
>b20e	52					  .byte LinkDisplacement	; offset to previous nt
=$b20f					XtPtr1 ::= *
=45451					WordListLink ::= Nt0 ; remember the nt of this word for later
.b20f					Block_RamDrive_Init:
.b20f	a9 0a		lda #$0a			lda #10			; Calculate how many bytes are needed for numblocks blocks
.b211	20 87 db	jsr $db87			jsr LShift_A
.b214	20 62 da	jsr $da62			jsr Here		; ( size addr )
.b217	8d 41 07	sta $0741			sta RamDriveV+0
.b21a	8c 42 07	sty $0742			sty RamDriveV+1
.b21d	20 a4 df	jsr $dfa4			jsr Over
.b220	20 c1 d0	jsr $d0c1			jsr Allot		; Create ramdrive buffer
.b223	20 ee df	jsr $dfee			jsr Swap		; blank the buffer
.b226	20 38 ce	jsr $ce38			jsr Blank
.b229	a9 3e		lda #$3e			lda #<_read		; set block read vector
.b22b	a0 b2		ldy #$b2			ldy #>_read
.b22d	8d 39 03	sta $0339			sta BlockReadV+0
.b230	8c 3a 03	sty $033a			sty BlockReadV+1
.b233	a9 4e		lda #$4e			lda #<_write		; set block write vector
.b235	a0 b2		ldy #$b2			ldy #>_write
.b237	8d 3b 03	sta $033b			sta BlockWriteV+0
.b23a	8c 3c 03	sty $033c			sty BlockWriteV+1
.b23d	60		rts				rts
=47					CodeLen	.var *-XtPtr1
=$b23e					Here1 = *	; remember here
>b20d	2f					.byte CodeLen	;patch wh_CodeLength
.b23e					_read:
.b23e	20 5b b2	jsr $b25b			jsr _addr
.b241	20 ee df	jsr $dfee			jsr Swap
.b244	a9 00		lda #$00			lda #0
.b246	a0 04		ldy #$04			ldy #>1024
.b248	20 b5 c7	jsr $c7b5			jsr PushYA
.b24b	4c 5f bd	jmp $bd5f			jmp Move
.b24e					_write:
.b24e	20 5b b2	jsr $b25b			jsr _addr
.b251	a9 00		lda #$00			lda #0
.b253	a0 04		ldy #$04			ldy #>1024
.b255	20 b5 c7	jsr $c7b5			jsr PushYA
.b258	4c 5f bd	jmp $bd5f			jmp Move
.b25b					_addr:
.b25b	a9 0a		lda #$0a			lda #10
.b25d	20 87 db	jsr $db87			jsr LShift_A
.b260	20 72 b2	jsr $b272			jsr RamDrive
.b263	4c ea db	jmp $dbea			jmp Plus
>b266	52 61 6d 44 72 69 76 65		Name0:	.text "RamDrive"	;  name of word as a string, ending at wh_NameLastChar
=8					NameLength = *-Name0
=45550					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>b26e	a8					.byte (("RamDrive"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=99					LinkDisplacement = Nt0-WordListLink
>b26f	10					.byte WordFlags	;wh_Flags
>b270	03					.byte 3	;wh_CodeLength
>b271	63					  .byte LinkDisplacement	; offset to previous nt
=$b272					XtPtr1 ::= *
=45550					WordListLink ::= Nt0 ; remember the nt of this word for later
.b272	ad 41 07	lda $0741	RamDrive:	lda RamDriveV+0
.b275	ac 42 07	ldy $0742			ldy RamDriveV+1
.b278	4c b5 c7	jmp $c7b5			jmp PushYA
=9					CodeLen	.var *-XtPtr1
=$b27b					Here1 = *	; remember here
>b270	09					.byte CodeLen	;patch wh_CodeLength
>b27b	42 75 66 66 53 74 61 74		Name0:	.text "BuffStatus"	;  name of word as a string, ending at wh_NameLastChar
>b283	75 73
=10					NameLength = *-Name0
=45573					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>b285	6a					.byte (("BuffStatus"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=23					LinkDisplacement = Nt0-WordListLink
>b286	10					.byte WordFlags	;wh_Flags
>b287	03					.byte 3	;wh_CodeLength
>b288	17					  .byte LinkDisplacement	; offset to previous nt
=$b289					XtPtr1 ::= *
=45573					WordListLink ::= Nt0 ; remember the nt of this word for later
.b289	a0 03		ldy #$03	BuffStatus:	ldy #>BuffStatusV
.b28b	a9 3f		lda #$3f			lda #<BuffStatusV
.b28d	4c b5 c7	jmp $c7b5			jmp PushYA
=7					CodeLen	.var *-XtPtr1
=$b290					Here1 = *	; remember here
>b287	07					.byte CodeLen	;patch wh_CodeLength
>b290	42 75 66 66 42 6c 6f 63		Name0:	.text "BuffBlockNum"	;  name of word as a string, ending at wh_NameLastChar
>b298	6b 4e 75 6d
=12					NameLength = *-Name0
=45596					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>b29c	ac					.byte (("BuffBlockNum"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=23					LinkDisplacement = Nt0-WordListLink
>b29d	10					.byte WordFlags	;wh_Flags
>b29e	03					.byte 3	;wh_CodeLength
>b29f	17					  .byte LinkDisplacement	; offset to previous nt
=$b2a0					XtPtr1 ::= *
=45596					WordListLink ::= Nt0 ; remember the nt of this word for later
.b2a0	a0 03		ldy #$03	BuffBlockNum:	ldy #>BuffBlockNumV
.b2a2	a9 3d		lda #$3d			lda #<BuffBlockNumV
.b2a4	4c b5 c7	jmp $c7b5			jmp PushYA
=7					CodeLen	.var *-XtPtr1
=$b2a7					Here1 = *	; remember here
>b29e	07					.byte CodeLen	;patch wh_CodeLength
>b2a7	42 6c 6b 42 75 66 66 65		Name0:	.text "BlkBuffer"	;  name of word as a string, ending at wh_NameLastChar
>b2af	72
=9					NameLength = *-Name0
=45616					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>b2b0	49					.byte (("BlkBuffer"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=20					LinkDisplacement = Nt0-WordListLink
>b2b1	10					.byte WordFlags	;wh_Flags
>b2b2	03					.byte 3	;wh_CodeLength
>b2b3	14					  .byte LinkDisplacement	; offset to previous nt
=$b2b4					XtPtr1 ::= *
=45616					WordListLink ::= Nt0 ; remember the nt of this word for later
.b2b4	a0 03		ldy #$03	BlkBuffer:	ldy #>BlockBuffer
.b2b6	a9 41		lda #$41			lda #<BlockBuffer
.b2b8	4c b5 c7	jmp $c7b5			jmp PushYA
=7					CodeLen	.var *-XtPtr1
=$b2bb					Here1 = *	; remember here
>b2b2	07					.byte CodeLen	;patch wh_CodeLength
>b2bb	53 63 72			Name0:	.text "Scr"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=45630					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>b2be	43					.byte (("Scr"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=14					LinkDisplacement = Nt0-WordListLink
>b2bf	10					.byte WordFlags	;wh_Flags
>b2c0	03					.byte 3	;wh_CodeLength
>b2c1	0e					  .byte LinkDisplacement	; offset to previous nt
=$b2c2					XtPtr1 ::= *
=45630					WordListLink ::= Nt0 ; remember the nt of this word for later
.b2c2	a0 03		ldy #$03	Scr:		ldy #>ScrV
.b2c4	a9 0e		lda #$0e			lda #<ScrV
.b2c6	4c b5 c7	jmp $c7b5			jmp PushYA
=7					CodeLen	.var *-XtPtr1
=$b2c9					Here1 = *	; remember here
>b2c0	07					.byte CodeLen	;patch wh_CodeLength
>b2c9	42 6c 6b			Name0:	.text "Blk"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=45644					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>b2cc	63					.byte (("Blk"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=14					LinkDisplacement = Nt0-WordListLink
>b2cd	10					.byte WordFlags	;wh_Flags
>b2ce	03					.byte 3	;wh_CodeLength
>b2cf	0e					  .byte LinkDisplacement	; offset to previous nt
=$b2d0					XtPtr1 ::= *
=45644					WordListLink ::= Nt0 ; remember the nt of this word for later
.b2d0	a0 03		ldy #$03	Blk:		ldy #>BlkV
.b2d2	a9 0c		lda #$0c			lda #<BlkV
.b2d4	4c b5 c7	jmp $c7b5			jmp PushYA
=7					CodeLen	.var *-XtPtr1
=$b2d7					Here1 = *	; remember here
>b2ce	07					.byte CodeLen	;patch wh_CodeLength
>b2d7	42 6c 6f 63 6b 2d 57 72		Name0:	.text "Block-Write"	;  name of word as a string, ending at wh_NameLastChar
>b2df	69 74 65
=11					NameLength = *-Name0
=45666					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>b2e2	ab					.byte (("Block-Write"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=22					LinkDisplacement = Nt0-WordListLink
>b2e3	10					.byte WordFlags	;wh_Flags
>b2e4	03					.byte 3	;wh_CodeLength
>b2e5	16					  .byte LinkDisplacement	; offset to previous nt
=$b2e6					XtPtr1 ::= *
=45666					WordListLink ::= Nt0 ; remember the nt of this word for later
.b2e6	6c 3b 03	jmp ($033b)	Block_Write:	jmp (BlockWriteV)	; Execute the BLOCK-READ-VECTOR
=3					CodeLen	.var *-XtPtr1
=$b2e9					Here1 = *	; remember here
>b2e4	03					.byte CodeLen	;patch wh_CodeLength
>b2e9	42 6c 6f 63 6b 2d 52 65		Name0:	.text "Block-Read"	;  name of word as a string, ending at wh_NameLastChar
>b2f1	61 64
=10					NameLength = *-Name0
=45683					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>b2f3	8a					.byte (("Block-Read"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=17					LinkDisplacement = Nt0-WordListLink
>b2f4	10					.byte WordFlags	;wh_Flags
>b2f5	03					.byte 3	;wh_CodeLength
>b2f6	11					  .byte LinkDisplacement	; offset to previous nt
=$b2f7					XtPtr1 ::= *
=45683					WordListLink ::= Nt0 ; remember the nt of this word for later
.b2f7	6c 39 03	jmp ($0339)	Block_Read:	jmp (BlockReadV)	; Execute the BLOCK-READ-VECTOR
=3					CodeLen	.var *-XtPtr1
=$b2fa					Here1 = *	; remember here
>b2f5	03					.byte CodeLen	;patch wh_CodeLength
>b2fa	42 6c 6f 63 6b 2d 57 72		Name0:	.text "Block-Write-Vector"	;  name of word as a string, ending at wh_NameLastChar
>b302	69 74 65 2d 56 65 63 74 6f 72
=18					NameLength = *-Name0
=45708					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>b30c	52					.byte (("Block-Write-Vector"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=25					LinkDisplacement = Nt0-WordListLink
>b30d	10					.byte WordFlags	;wh_Flags
>b30e	03					.byte 3	;wh_CodeLength
>b30f	19					  .byte LinkDisplacement	; offset to previous nt
=$b310					XtPtr1 ::= *
=45708					WordListLink ::= Nt0 ; remember the nt of this word for later
.b310					Block_Write_Vector:
.b310	a0 03		ldy #$03			ldy #>BlockWriteV
.b312	a9 3b		lda #$3b			lda #<BlockWriteV	; Get the BLOCK-WRITE-VECTOR address
.b314	4c b5 c7	jmp $c7b5			jmp PushYA
=7					CodeLen	.var *-XtPtr1
=$b317					Here1 = *	; remember here
>b30e	07					.byte CodeLen	;patch wh_CodeLength
>b317	42 6c 6f 63 6b 2d 52 65		Name0:	.text "Block-Read-Vector"	;  name of word as a string, ending at wh_NameLastChar
>b31f	61 64 2d 56 65 63 74 6f 72
=17					NameLength = *-Name0
=45736					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>b328	51					.byte (("Block-Read-Vector"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=28					LinkDisplacement = Nt0-WordListLink
>b329	10					.byte WordFlags	;wh_Flags
>b32a	03					.byte 3	;wh_CodeLength
>b32b	1c					  .byte LinkDisplacement	; offset to previous nt
=$b32c					XtPtr1 ::= *
=45736					WordListLink ::= Nt0 ; remember the nt of this word for later
.b32c					Block_Read_Vector:
.b32c	a0 03		ldy #$03			ldy #>BlockReadV
.b32e	a9 39		lda #$39			lda #<BlockReadV	; Get the BLOCK-READ-VECTOR address
.b330	4c b5 c7	jmp $c7b5			jmp PushYA
=7					CodeLen	.var *-XtPtr1
=$b333					Here1 = *	; remember here
>b32a	07					.byte CodeLen	;patch wh_CodeLength
>b333	53 61 76 65 2d 42 75 66		Name0:	.text "Save-Buffers"	;  name of word as a string, ending at wh_NameLastChar
>b33b	66 65 72 73
=12					NameLength = *-Name0
=45759					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>b33f	6c					.byte (("Save-Buffers"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=0					WordFlags ::= 0	; modifiable copy, remember for later
=23					LinkDisplacement = Nt0-WordListLink
>b340	00					.byte WordFlags	;wh_Flags
>b341	03					.byte 3	;wh_CodeLength
>b342	17					  .byte LinkDisplacement	; offset to previous nt
=$b343					XtPtr1 ::= *
=45759					WordListLink ::= Nt0 ; remember the nt of this word for later
.b343					Save_Buffers:
.b343	ad 3f 03	lda $033f			lda BuffStatusV+0 ; Only bits 0 and 1 are used, so only
.b346	c9 03		cmp #$03			cmp #3		; LSB is needed.
.b348	d0 11		bne $b35b			bne _done	; Either not used or not dirty = done!
.b34a	20 b4 b2	jsr $b2b4			jsr BlkBuffer
.b34d	20 a0 b2	jsr $b2a0			jsr BuffBlockNum
.b350	20 f5 de	jsr $def5			jsr Fetch
.b353	20 e6 b2	jsr $b2e6			jsr Block_Write
.b356	a9 01		lda #$01			lda #1
.b358	8d 3f 03	sta $033f			sta BuffStatusV+0
.b35b					_done:
=24					CodeLen	.var *-XtPtr1
=$b35b					Here1 = *	; remember here
>b341	18					.byte CodeLen	;patch wh_CodeLength
.b35b	60		rts				rts
>b35c	42 6c 6f 63 6b			Name0:	.text "Block"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=45793					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>b361	65					.byte (("Block"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=0					WordFlags ::= 0	; modifiable copy, remember for later
=34					LinkDisplacement = Nt0-WordListLink
>b362	00					.byte WordFlags	;wh_Flags
>b363	03					.byte 3	;wh_CodeLength
>b364	22					  .byte LinkDisplacement	; offset to previous nt
=$b365					XtPtr1 ::= *
=45793					WordListLink ::= Nt0 ; remember the nt of this word for later
.b365					Block:
.b365	ad 3d 03	lda $033d			lda BuffBlockNumV+0	; check the LSB
.b368	d5 24		cmp $24,x			cmp DStack+0,x
.b36a	d0 0e		bne $b37a			bne _not_in_buffer
.b36c	ad 3e 03	lda $033e			lda BuffBlockNumV+1	; check the MSB
.b36f	d5 25		cmp $25,x			cmp DStack+1,x
.b371	d0 07		bne $b37a			bne _not_in_buffer
.b373	ad 3f 03	lda $033f			lda BuffStatusV+0
.b376	29 01		and #$01			and #1		; Check the in-use flag (bit 0)
.b378	d0 2d		bne $b3a7			bne _done	; It's already in the buffer and in use.
.b37a					_not_in_buffer:
.b37a	ad 3f 03	lda $033f			lda BuffStatusV+0 ; Only bits 0 and 1 are used, so only
.b37d	c9 03		cmp #$03			cmp #3		; LSB is needed.
.b37f	d0 0c		bne $b38d			bne _buffer_available ; Unused or not dirty = available
.b381	20 b4 b2	jsr $b2b4			jsr BlkBuffer
.b384	20 a0 b2	jsr $b2a0			jsr BuffBlockNum
.b387	20 f5 de	jsr $def5			jsr Fetch
.b38a	20 e6 b2	jsr $b2e6			jsr Block_Write
.b38d					_buffer_available:
.b38d	b5 24		lda $24,x			lda DStack+0,x
.b38f	8d 3d 03	sta $033d			sta BuffBlockNumV+0
.b392	b5 25		lda $25,x			lda DStack+1,x
.b394	8d 3e 03	sta $033e			sta BuffBlockNumV+1
.b397	20 b4 b2	jsr $b2b4			jsr BlkBuffer
.b39a	20 ee df	jsr $dfee			jsr Swap
.b39d	20 f7 b2	jsr $b2f7			jsr Block_Read
.b3a0	a9 01		lda #$01			lda #1
.b3a2	8d 3f 03	sta $033f			sta BuffStatusV+0
.b3a5	ca		dex				dex
.b3a6	ca		dex				dex
.b3a7					_done:
.b3a7	a9 41		lda #$41			lda #<BlockBuffer
.b3a9	95 24		sta $24,x			sta DStack+0,x
.b3ab	a9 03		lda #$03			lda #>BlockBuffer
.b3ad	95 25		sta $25,x			sta DStack+1,x
=74					CodeLen	.var *-XtPtr1
=$b3af					Here1 = *	; remember here
>b363	4a					.byte CodeLen	;patch wh_CodeLength
.b3af	60		rts				rts
>b3b0	55 70 64 61 74 65		Name0:	.text "Update"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=45878					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>b3b6	a6					.byte (("Update"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=0					WordFlags ::= 0	; modifiable copy, remember for later
=85					LinkDisplacement = Nt0-WordListLink
>b3b7	00					.byte WordFlags	;wh_Flags
>b3b8	03					.byte 3	;wh_CodeLength
>b3b9	55					  .byte LinkDisplacement	; offset to previous nt
=$b3ba					XtPtr1 ::= *
=45878					WordListLink ::= Nt0 ; remember the nt of this word for later
.b3ba					Update:
.b3ba	ad 3f 03	lda $033f			lda BuffStatusV+0
.b3bd	09 02		ora #$02			ora #2		; Turn on dirty flag (bit 2)
.b3bf	8d 3f 03	sta $033f			sta BuffStatusV+0
=8					CodeLen	.var *-XtPtr1
=$b3c2					Here1 = *	; remember here
>b3b8	08					.byte CodeLen	;patch wh_CodeLength
.b3c2	60		rts				rts
>b3c3	42 75 66 66 65 72		Name0:	.text "Buffer"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=45897					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>b3c9	46					.byte (("Buffer"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=19					LinkDisplacement = Nt0-WordListLink
>b3ca	10					.byte WordFlags	;wh_Flags
>b3cb	03					.byte 3	;wh_CodeLength
>b3cc	13					  .byte LinkDisplacement	; offset to previous nt
=$b3cd					XtPtr1 ::= *
=45897					WordListLink ::= Nt0 ; remember the nt of this word for later
.b3cd					Buffer:
.b3cd	ad 3f 03	lda $033f			lda BuffStatusV+0 ; Only bits 0 and 1 are used, so only
.b3d0	c9 03		cmp #$03			cmp #3		; LSB is needed.
.b3d2	d0 0c		bne $b3e0			bne _buffer_available ; Unused or not dirty = available
.b3d4	20 b4 b2	jsr $b2b4			jsr BlkBuffer
.b3d7	20 a0 b2	jsr $b2a0			jsr BuffBlockNum
.b3da	20 f5 de	jsr $def5			jsr Fetch
.b3dd	20 e6 b2	jsr $b2e6			jsr Block_Write
.b3e0					_buffer_available:
.b3e0	b5 24		lda $24,x			lda DStack+0,x
.b3e2	8d 3d 03	sta $033d			sta BuffBlockNumV+0
.b3e5	b5 25		lda $25,x			lda DStack+1,x
.b3e7	8d 3e 03	sta $033e			sta BuffBlockNumV+1
.b3ea	a9 01		lda #$01			lda #1
.b3ec	8d 3f 03	sta $033f			sta BuffStatusV+0
.b3ef					_done:
.b3ef	a9 41		lda #$41			lda #<BlockBuffer
.b3f1	95 24		sta $24,x			sta DStack+0,x
.b3f3	a9 03		lda #$03			lda #>BlockBuffer
.b3f5	95 25		sta $25,x			sta DStack+1,x
=42					CodeLen	.var *-XtPtr1
=$b3f7					Here1 = *	; remember here
>b3cb	2a					.byte CodeLen	;patch wh_CodeLength
.b3f7	60		rts				rts
>b3f8	45 6d 70 74 79 2d 42 75		Name0:	.text "Empty-Buffers"	;  name of word as a string, ending at wh_NameLastChar
>b400	66 66 65 72 73
=13					NameLength = *-Name0
=45957					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>b405	6d					.byte (("Empty-Buffers"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=60					LinkDisplacement = Nt0-WordListLink
>b406	10					.byte WordFlags	;wh_Flags
>b407	03					.byte 3	;wh_CodeLength
>b408	3c					  .byte LinkDisplacement	; offset to previous nt
=$b409					XtPtr1 ::= *
=45957					WordListLink ::= Nt0 ; remember the nt of this word for later
.b409	a9 00		lda #$00	Empty_Buffers:	lda #0		; Set the buffer status to empty.
.b40b	8d 3f 03	sta $033f			sta BuffStatusV+0 ; Only LSB is used.
=5					CodeLen	.var *-XtPtr1
=$b40e					Here1 = *	; remember here
>b407	05					.byte CodeLen	;patch wh_CodeLength
.b40e	60		rts				rts
>b40f	46 6c 75 73 68			Name0:	.text "Flush"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=45972					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>b414	05					.byte (("Flush"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=15					LinkDisplacement = Nt0-WordListLink
>b415	10					.byte WordFlags	;wh_Flags
>b416	03					.byte 3	;wh_CodeLength
>b417	0f					  .byte LinkDisplacement	; offset to previous nt
=$b418					XtPtr1 ::= *
=45972					WordListLink ::= Nt0 ; remember the nt of this word for later
.b418	20 43 b3	jsr $b343	Flush:		jsr Save_Buffers
.b41b	4c 09 b4	jmp $b409			jmp Empty_Buffers
=6					CodeLen	.var *-XtPtr1
=$b41e					Here1 = *	; remember here
>b416	06					.byte CodeLen	;patch wh_CodeLength
>b41e	4c 6f 61 64			Name0:	.text "Load"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=45986					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>b422	84					.byte (("Load"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=14					LinkDisplacement = Nt0-WordListLink
>b423	10					.byte WordFlags	;wh_Flags
>b424	03					.byte 3	;wh_CodeLength
>b425	0e					  .byte LinkDisplacement	; offset to previous nt
=$b426					XtPtr1 ::= *
=45986					WordListLink ::= Nt0 ; remember the nt of this word for later
.b426					Load:
.b426	20 07 c4	jsr $c407			jsr underflow_1
.b429	ad 0d 03	lda $030d			lda BlkV+1		; Save the current value of BLK on the return stack.
.b42c	48		pha				pha
.b42d	ad 0c 03	lda $030c			lda BlkV+0
.b430	48		pha				pha
.b431	b5 24		lda $24,x			lda DStack+0,x		; Set BLK to the given block/screen number.
.b433	8d 0c 03	sta $030c			sta BlkV+0
.b436	b5 25		lda $25,x			lda DStack+1,x
.b438	8d 0d 03	sta $030d			sta BlkV+1
.b43b	20 65 b3	jsr $b365			jsr Block		; Load that block into a buffer
.b43e	a9 00		lda #$00			lda #<1024		; block length.
.b440	a0 04		ldy #$04			ldy #>1024
.b442	20 b5 c7	jsr $c7b5			jsr PushYA
.b445	38		sec				sec		; Set a flag to not zero BLK
.b446	20 e8 bf	jsr $bfe8			jsr load_evaluate
.b449	68		pla				pla
.b44a	8d 0c 03	sta $030c			sta BlkV+0
.b44d	68		pla				pla
.b44e	8d 0d 03	sta $030d			sta BlkV+1
.b451	0d 0c 03	ora $030c			ora BlkV+0
.b454	f0 13		beq $b469			beq _done
.b456	ad 0c 03	lda $030c			lda BlkV+0
.b459	ac 0d 03	ldy $030d			ldy BlkV+1
.b45c	20 b5 c7	jsr $c7b5			jsr PushYA
.b45f	20 65 b3	jsr $b365			jsr Block
.b462	20 de c3	jsr $c3de			jsr PopYA	; Pop the buffer address.
.b465	85 04		sta $04				sta cib+0
.b467	84 05		sty $05				sty cib+1
.b469					_done:
=67					CodeLen	.var *-XtPtr1
=$b469					Here1 = *	; remember here
>b424	43					.byte CodeLen	;patch wh_CodeLength
.b469	60		rts				rts
>b46a	54 68 72 75			Name0:	.text "Thru"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=46062					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>b46e	a4					.byte (("Thru"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=76					LinkDisplacement = Nt0-WordListLink
>b46f	10					.byte WordFlags	;wh_Flags
>b470	03					.byte 3	;wh_CodeLength
>b471	4c					  .byte LinkDisplacement	; offset to previous nt
=$b472					XtPtr1 ::= *
=46062					WordListLink ::= Nt0 ; remember the nt of this word for later
.b472	20 1b c4	jsr $c41b	Thru:		jsr underflow_2
.b475	20 3d df	jsr $df3d			jsr To_R
.b478					_loop:
.b478	b5 25		lda $25,x			lda DStack+1,x		; copy to return stack
.b47a	48		pha				pha
.b47b	b5 24		lda $24,x			lda DStack+0,x
.b47d	48		pha				pha
.b47e	20 26 b4	jsr $b426			jsr Load		; Load this screen.
.b481	20 5b df	jsr $df5b			jsr R_From		; Get the screen # we just loaded.
.b484	20 95 da	jsr $da95			jsr One_plus		; increment
.b487	86 14		stx $14				stx tmp1
.b489	ba		tsx				tsx
.b48a	8a		txa				txa
.b48b	a8		tay				tay
.b48c	a6 14		ldx $14				ldx tmp1
.b48e	b9 01 01	lda $0101,y			lda RStack+1,y
.b491	d5 24		cmp $24,x			cmp DStack+0,x
.b493	b9 02 01	lda $0102,y			lda RStack+2,y
.b496	f5 25		sbc $25,x			sbc DStack+1,x
.b498	b0 de		bcs $b478			bcs _loop
.b49a	e8		inx				inx			; Drop index
.b49b	e8		inx				inx
.b49c	68		pla				pla			; RDrop limit
.b49d	68		pla				pla
=44					CodeLen	.var *-XtPtr1
=$b49e					Here1 = *	; remember here
>b470	2c					.byte CodeLen	;patch wh_CodeLength
.b49e	60		rts				rts
>b49f	4c 69 73 74			Name0:	.text "List"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=46115					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>b4a3	84					.byte (("List"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=53					LinkDisplacement = Nt0-WordListLink
>b4a4	10					.byte WordFlags	;wh_Flags
>b4a5	03					.byte 3	;wh_CodeLength
>b4a6	35					  .byte LinkDisplacement	; offset to previous nt
=$b4a7					XtPtr1 ::= *
=46115					WordListLink ::= Nt0 ; remember the nt of this word for later
.b4a7	20 de c3	jsr $c3de	List:		jsr PopYA	; Save the screen number
.b4aa	8d 0e 03	sta $030e			sta ScrV+0
.b4ad	8c 0f 03	sty $030f			sty ScrV+1
.b4b0					ListScr:
.b4b0	20 c2 b2	jsr $b2c2			jsr Scr
.b4b3	20 f5 de	jsr $def5			jsr Fetch
.b4b6	20 65 b3	jsr $b365			jsr Block	; Get the current screen contents.
.b4b9	20 4c bb	jsr $bb4c			jsr CR
.b4bc	20 b8 c8	jsr $c8b8			jsr SLiteral_Runtime
.b4bf	4c ca b4	jmp $b4ca			  jmp +				; for SLiteral_Runtime
>b4c2	53 63 72 65 65 6e 20 23				  .text "Screen #"		; for SLiteral_Runtime
.b4ca					+
.b4ca	20 34 de	jsr $de34			jsr Type
.b4cd	20 c2 b2	jsr $b2c2			jsr Scr		; print screen number
.b4d0	20 f5 de	jsr $def5			jsr Fetch
.b4d3	a9 04		lda #$04			lda #4		;    in 4 positions
.b4d5	20 7f dc	jsr $dc7f			jsr U_Dot_R_A
.b4d8	a9 00		lda #$00			lda #0			; line #
.b4da					_line_loop:
.b4da	48		pha				pha
.b4db	20 4c bb	jsr $bb4c			jsr CR
.b4de	68		pla				pla		; Print the line number
.b4df	48		pha				pha
.b4e0	20 e4 c7	jsr $c7e4			jsr PushZA
.b4e3	a9 02		lda #$02			lda #2		;   in 2 positions
.b4e5	20 7f dc	jsr $dc7f			jsr U_Dot_R_A
.b4e8	20 28 de	jsr $de28			jsr Space
.b4eb	20 cd df	jsr $dfcd			jsr Dup		; Print one line using the address on the stack.
.b4ee	a9 40		lda #$40			lda #64
.b4f0	20 e4 c7	jsr $c7e4			jsr PushZA
.b4f3	20 34 de	jsr $de34			jsr Type
.b4f6	a9 40		lda #$40			lda #64		; move address to the next line.
.b4f8	20 43 da	jsr $da43			jsr Plus_A
.b4fb	68		pla				pla		; Increment the line number
.b4fc	18		clc				clc
.b4fd	69 01		adc #$01			adc #1
.b4ff	c9 10		cmp #$10			cmp #16		; See if we are done.
.b501	d0 d7		bne $b4da			bne _line_loop
.b503	e8		inx				inx		; Drop the address
.b504	e8		inx				inx
.b505	4c 4c bb	jmp $bb4c			jmp CR
=97					CodeLen	.var *-XtPtr1
=$b508					Here1 = *	; remember here
>b4a5	61					.byte CodeLen	;patch wh_CodeLength
>b508	44 65 66 65 72			Name0:	.text "Defer"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=46221					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>b50d	45					.byte (("Defer"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=106					LinkDisplacement = Nt0-WordListLink
>b50e	10					.byte WordFlags	;wh_Flags
>b50f	03					.byte 3	;wh_CodeLength
>b510	6a					  .byte LinkDisplacement	; offset to previous nt
=$b511					XtPtr1 ::= *
=46221					WordListLink ::= Nt0 ; remember the nt of this word for later
.b511					Defer:
.b511	20 1b d1	jsr $d11b			jsr Header_Comma	; compile word header
.b514	a9 1e		lda #$1e			lda #<_undefined	; compile "jmp _undefined" (patched later)
.b516	a0 b5		ldy #$b5			ldy #>_undefined
.b518	20 89 dd	jsr $dd89			jsr Jmp_Comma_YA
.b51b	4c db cb	jmp $cbdb			jmp adjust_z		; set word length
=13					CodeLen	.var *-XtPtr1
=$b51e					Here1 = *	; remember here
>b50f	0d					.byte CodeLen	;patch wh_CodeLength
.b51e					_undefined:
.b51e	a9 6a		lda #$6a			lda #$100+err_Defer	; throw exception
.b520	4c 63 c4	jmp $c463			jmp ThrowA
>b523	44 65 66 65 72 21		Name0:	.text "Defer!"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=46249					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>b529	26					.byte (("Defer!"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=28					LinkDisplacement = Nt0-WordListLink
>b52a	10					.byte WordFlags	;wh_Flags
>b52b	03					.byte 3	;wh_CodeLength
>b52c	1c					  .byte LinkDisplacement	; offset to previous nt
=$b52d					XtPtr1 ::= *
=46249					WordListLink ::= Nt0 ; remember the nt of this word for later
.b52d	20 de c3	jsr $c3de	Defer_Store:	jsr PopYA		; pop DEFERs xt
.b530	85 14		sta $14		Defer_Store_YA:	sta tmp1+0
.b532	84 15		sty $15				sty tmp1+1
.b534	b5 24		lda $24,x			lda DStack+0,x		; DEFERs JMP abs operand= xt2
.b536	a0 01		ldy #$01			ldy #1
.b538	91 14		sta ($14),y			sta (tmp1),y
.b53a	b5 25		lda $25,x			lda DStack+1,x
.b53c	c8		iny				iny
.b53d	91 14		sta ($14),y			sta (tmp1),y
.b53f	4c 0b e0	jmp $e00b			jmp Drop		; Drop xt2
=21					CodeLen	.var *-XtPtr1
=$b542					Here1 = *	; remember here
>b52b	15					.byte CodeLen	;patch wh_CodeLength
>b542	44 65 66 65 72 40		Name0:	.text "Defer@"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=46280					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>b548	06					.byte (("Defer@"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=0					WordFlags ::= 0	; modifiable copy, remember for later
=31					LinkDisplacement = Nt0-WordListLink
>b549	00					.byte WordFlags	;wh_Flags
>b54a	03					.byte 3	;wh_CodeLength
>b54b	1f					  .byte LinkDisplacement	; offset to previous nt
=$b54c					XtPtr1 ::= *
=46280					WordListLink ::= Nt0 ; remember the nt of this word for later
.b54c	20 de c3	jsr $c3de	Defer_Fetch:	jsr PopYA	; pop DEFERs xt
.b54f	85 14		sta $14		Defer_Fetch_YA:	sta tmp1+0
.b551	84 15		sty $15				sty tmp1+1
.b553	ca		dex				dex		; push DEFERs JMP abs operand
.b554	ca		dex				dex
.b555	a0 01		ldy #$01			ldy #1
.b557	b1 14		lda ($14),y			lda (tmp1),y
.b559	95 24		sta $24,x			sta DStack+0,x
.b55b	c8		iny				iny
.b55c	b1 14		lda ($14),y			lda (tmp1),y
.b55e	95 25		sta $25,x			sta DStack+1,x
=20					CodeLen	.var *-XtPtr1
=$b560					Here1 = *	; remember here
>b54a	14					.byte CodeLen	;patch wh_CodeLength
.b560	60		rts				rts
>b561	49 73				Name0:	.text "Is"	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=46307					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>b563	62					.byte (("Is"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=24					WordFlags ::= IM+NN	; modifiable copy, remember for later
=27					LinkDisplacement = Nt0-WordListLink
>b564	18					.byte WordFlags	;wh_Flags
>b565	03					.byte 3	;wh_CodeLength
>b566	1b					  .byte LinkDisplacement	; offset to previous nt
=$b567					XtPtr1 ::= *
=46307					WordListLink ::= Nt0 ; remember the nt of this word for later
.b567	20 41 cc	jsr $cc41	Is:		jsr Tick		; get xt of "name"
.b56a	a5 0a		lda $0a				lda state		; Check STATE
.b56c	f0 bf		beq $b52d			beq Defer_Store		; interpreting, put xt in the DEFER word
.b56e					_compiling:
.b56e	20 9c c7	jsr $c79c			jsr ldya_immed_comma	; compile LDY #; LDA # of the xt of "name"
.b571	a0 b5		ldy #$b5			ldy #>Defer_Store_YA	; Postpone DEFER! by compiling a JSR to it.
.b573	a9 30		lda #$30			lda #<Defer_Store_YA
.b575	4c 73 dd	jmp $dd73			jmp Jsr_Comma_YA
=17					CodeLen	.var *-XtPtr1
=$b578					Here1 = *	; remember here
>b565	11					.byte CodeLen	;patch wh_CodeLength
>b578	41 63 74 69 6f 6e 2d 4f		Name0:	.text "Action-Of"	;  name of word as a string, ending at wh_NameLastChar
>b580	66
=9					NameLength = *-Name0
=46337					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>b581	c9					.byte (("Action-Of"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=24					WordFlags ::= IM+NN	; modifiable copy, remember for later
=30					LinkDisplacement = Nt0-WordListLink
>b582	18					.byte WordFlags	;wh_Flags
>b583	03					.byte 3	;wh_CodeLength
>b584	1e					  .byte LinkDisplacement	; offset to previous nt
=$b585					XtPtr1 ::= *
=46337					WordListLink ::= Nt0 ; remember the nt of this word for later
.b585					Action_Of:
.b585	20 41 cc	jsr $cc41			jsr Tick		; get xt of "name"
.b588	a5 0a		lda $0a				lda state		; Check STATE
.b58a	f0 c0		beq $b54c			beq Defer_Fetch		; interpreting, get xt in the DEFER word
.b58c					_compiling:
.b58c	20 9c c7	jsr $c79c			jsr ldya_immed_comma	; compile LDY #; LDA # of the xt of "name"
.b58f	a0 b5		ldy #$b5			ldy #>Defer_Fetch_YA	; Postpone DEFER@ by compiling a JSR to it.
.b591	a9 4f		lda #$4f			lda #<Defer_Fetch_YA
.b593	4c 73 dd	jmp $dd73			jmp Jsr_Comma_YA
=17					CodeLen	.var *-XtPtr1
=$b596					Here1 = *	; remember here
>b583	11					.byte CodeLen	;patch wh_CodeLength
>b596	55 73 65 72 41 64 64 72		Name0:	.text "UserAddr"	;  name of word as a string, ending at wh_NameLastChar
=8					NameLength = *-Name0
=46366					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>b59e	48					.byte (("UserAddr"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=29					LinkDisplacement = Nt0-WordListLink
>b59f	10					.byte WordFlags	;wh_Flags
>b5a0	03					.byte 3	;wh_CodeLength
>b5a1	1d					  .byte LinkDisplacement	; offset to previous nt
=$b5a2					XtPtr1 ::= *
=46366					WordListLink ::= Nt0 ; remember the nt of this word for later
.b5a2	a0 02		ldy #$02	UserAddr:	ldy #>User0
.b5a4	a9 ff		lda #$ff			lda #<User0
.b5a6	4c b5 c7	jmp $c7b5			jmp PushYA
=7					CodeLen	.var *-XtPtr1
=$b5a9					Here1 = *	; remember here
>b5a0	07					.byte CodeLen	;patch wh_CodeLength
>b5a9	42 75 66 66 65 72 3a		Name0:	.text "Buffer:"	;  name of word as a string, ending at wh_NameLastChar
=7					NameLength = *-Name0
=46384					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>b5b0	47					.byte (("Buffer:"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=18					LinkDisplacement = Nt0-WordListLink
>b5b1	10					.byte WordFlags	;wh_Flags
>b5b2	03					.byte 3	;wh_CodeLength
>b5b3	12					  .byte LinkDisplacement	; offset to previous nt
=$b5b4					XtPtr1 ::= *
=46384					WordListLink ::= Nt0 ; remember the nt of this word for later
.b5b4	20 c8 d1	jsr $d1c8	Buffer_Colon:	jsr Create
.b5b7	4c c1 d0	jmp $d0c1			jmp Allot
=6					CodeLen	.var *-XtPtr1
=$b5ba					Here1 = *	; remember here
>b5b2	06					.byte CodeLen	;patch wh_CodeLength
>b5ba	43 61 73 65			Name0:	.text "Case"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=46398					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>b5be	a4					.byte (("Case"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=28					WordFlags ::= IM+CO+NN	; modifiable copy, remember for later
=14					LinkDisplacement = Nt0-WordListLink
>b5bf	1c					.byte WordFlags	;wh_Flags
>b5c0	03					.byte 3	;wh_CodeLength
>b5c1	0e					  .byte LinkDisplacement	; offset to previous nt
=$b5c2					XtPtr1 ::= *
=46398					WordListLink ::= Nt0 ; remember the nt of this word for later
.b5c2	4c f2 c7	jmp $c7f2	Case:		jmp Zero	; init jmp fixup chain
=3					CodeLen	.var *-XtPtr1
=$b5c5					Here1 = *	; remember here
>b5c0	03					.byte CodeLen	;patch wh_CodeLength
>b5c5	45 6e 64 43 61 73 65		Name0:	.text "EndCase"	;  name of word as a string, ending at wh_NameLastChar
=7					NameLength = *-Name0
=46412					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>b5cc	a7					.byte (("EndCase"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=28					WordFlags ::= IM+CO+NN	; modifiable copy, remember for later
=14					LinkDisplacement = Nt0-WordListLink
>b5cd	1c					.byte WordFlags	;wh_Flags
>b5ce	03					.byte 3	;wh_CodeLength
>b5cf	0e					  .byte LinkDisplacement	; offset to previous nt
=$b5d0					XtPtr1 ::= *
=46412					WordListLink ::= Nt0 ; remember the nt of this word for later
.b5d0					EndCase:
.b5d0	20 63 dd	jsr $dd63			jsr Drop_Comma
.b5d3					_loop:
.b5d3	b5 25		lda $25,x			lda DStack+1,x	; while addr fixup entries left
.b5d5	f0 06		beq $b5dd			beq _done
.b5d7	20 46 b6	jsr $b646			jsr Then	;   fixup another one
.b5da	4c d3 b5	jmp $b5d3			jmp _loop
.b5dd					_done:
.b5dd	e8		inx				inx		; Drop the 0
.b5de	e8		inx				inx
=15					CodeLen	.var *-XtPtr1
=$b5df					Here1 = *	; remember here
>b5ce	0f					.byte CodeLen	;patch wh_CodeLength
.b5df	60		rts				rts
>b5e0	4f 66				Name0:	.text "Of"	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=46434					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>b5e2	c2					.byte (("Of"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=28					WordFlags ::= IM+CO+NN	; modifiable copy, remember for later
=22					LinkDisplacement = Nt0-WordListLink
>b5e3	1c					.byte WordFlags	;wh_Flags
>b5e4	03					.byte 3	;wh_CodeLength
>b5e5	16					  .byte LinkDisplacement	; offset to previous nt
=$b5e6					XtPtr1 ::= *
=46434					WordListLink ::= Nt0 ; remember the nt of this word for later
.b5e6					Of:
.b5e6	a0 b5		ldy #$b5			ldy #>_runtime		; Check if value is equal to this case.
.b5e8	a9 f0		lda #$f0			lda #<_runtime
.b5ea	20 73 dd	jsr $dd73			jsr Jsr_Comma_YA
.b5ed	4c 14 b6	jmp $b614			jmp zbranch_jmp0_comma	; save addr ptr; compile jmp abs
=10					CodeLen	.var *-XtPtr1
=$b5f0					Here1 = *	; remember here
>b5e4	0a					.byte CodeLen	;patch wh_CodeLength
.b5f0					_runtime:
.b5f0	e8		inx				inx		; Drop x2
.b5f1	e8		inx				inx
.b5f2	b5 22		lda $22,x			lda DStack-2,x	; compare x1 with x2
.b5f4	d5 24		cmp $24,x			cmp DStack+0,x
.b5f6	d0 06		bne $b5fe			bne _NotEq
.b5f8	b5 23		lda $23,x			lda DStack-1,x
.b5fa	d5 25		cmp $25,x			cmp DStack+1,x
.b5fc	f0 30		beq $b62e			beq zbranch_run2 ; Drop x1 & return to after the jmp abs
.b5fe	60		rts		_NotEq:		rts		; return to the jmp abs to next test
>b5ff	45 6e 64 4f 66			Name0:	.text "EndOf"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=46468					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>b604	c5					.byte (("EndOf"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=28					WordFlags ::= IM+CO+NN	; modifiable copy, remember for later
=34					LinkDisplacement = Nt0-WordListLink
>b605	1c					.byte WordFlags	;wh_Flags
>b606	03					.byte 3	;wh_CodeLength
>b607	22					  .byte LinkDisplacement	; offset to previous nt
=$b608					XtPtr1 ::= *
=46468					WordListLink ::= Nt0 ; remember the nt of this word for later
.b608	4c 57 b6	jmp $b657	EndOf:		jmp Else
=3					CodeLen	.var *-XtPtr1
=$b60b					Here1 = *	; remember here
>b606	03					.byte CodeLen	;patch wh_CodeLength
>b60b	49 66				Name0:	.text "If"	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=46477					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>b60d	c2					.byte (("If"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=28					WordFlags ::= IM+CO+NN	; modifiable copy, remember for later
=9					LinkDisplacement = Nt0-WordListLink
>b60e	1c					.byte WordFlags	;wh_Flags
>b60f	03					.byte 3	;wh_CodeLength
>b610	09					  .byte LinkDisplacement	; offset to previous nt
=$b611					XtPtr1 ::= *
=46477					WordListLink ::= Nt0 ; remember the nt of this word for later
.b611					If:
.b611	20 21 b6	jsr $b621	If3:		jsr zbranch_jsr_comma	; Compile a 0BRANCH
.b614					zbranch_jmp0_comma:
.b614	20 62 da	jsr $da62			jsr Here		; save ptr to address for else/then
.b617	20 95 da	jsr $da95			jsr One_Plus
.b61a	a0 c3		ldy #$c3			ldy #>Abort		; compile jmp abs
.b61c	a9 b6		lda #$b6			lda #<Abort		; THEN or ELSE will fix address later.
.b61e	4c 89 dd	jmp $dd89			jmp Jmp_Comma_YA
=16					CodeLen	.var *-XtPtr1
=$b621					Here1 = *	; remember here
>b60f	10					.byte CodeLen	;patch wh_CodeLength
=$dd86					zbranch_jmp_comma = Jmp_Comma		; compile jmp abs
.b621					zbranch_jsr_comma:
.b621	a0 b6		ldy #$b6			ldy #>_runtime
.b623	a9 28		lda #$28			lda #<_runtime
.b625	4c 73 dd	jmp $dd73			jmp Jsr_Comma_YA
.b628					_runtime:
.b628	b5 24		lda $24,x			lda DStack+0,x		;flag is false?
.b62a	15 25		ora $25,x			ora DStack+1,x
.b62c	f0 0d		beq $b63b			beq zbranch_run_done
.b62e	18		clc		zbranch_run2:	clc			; move RTS addr over the next jmp abs.
.b62f	68		pla				pla
.b630	69 03		adc #$03			adc #3
.b632	90 06		bcc $b63a			bcc +
.b634	a8		tay				tay
.b635	68		pla				pla
.b636	69 00		adc #$00			adc #0
.b638	48		pha				pha
.b639	98		tya				tya
.b63a	48		pha		+		pha
.b63b					zbranch_run_done:
.b63b	e8		inx				inx			; Drop f
.b63c	e8		inx				inx
.b63d	60		rts				rts
>b63e	54 68 65 6e			Name0:	.text "Then"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=46530					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>b642	c4					.byte (("Then"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=28					WordFlags ::= IM+CO+NN	; modifiable copy, remember for later
=53					LinkDisplacement = Nt0-WordListLink
>b643	1c					.byte WordFlags	;wh_Flags
>b644	03					.byte 3	;wh_CodeLength
>b645	35					  .byte LinkDisplacement	; offset to previous nt
=$b646					XtPtr1 ::= *
=46530					WordListLink ::= Nt0 ; remember the nt of this word for later
.b646					Then:
.b646	20 62 da	jsr $da62			jsr Here
.b649	20 ee df	jsr $dfee			jsr Swap
.b64c	4c 0e df	jmp $df0e			jmp Store
=9					CodeLen	.var *-XtPtr1
=$b64f					Here1 = *	; remember here
>b644	09					.byte CodeLen	;patch wh_CodeLength
>b64f	45 6c 73 65			Name0:	.text "Else"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=46547					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>b653	a4					.byte (("Else"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=28					WordFlags ::= IM+CO+NN	; modifiable copy, remember for later
=17					LinkDisplacement = Nt0-WordListLink
>b654	1c					.byte WordFlags	;wh_Flags
>b655	03					.byte 3	;wh_CodeLength
>b656	11					  .byte LinkDisplacement	; offset to previous nt
=$b657					XtPtr1 ::= *
=46547					WordListLink ::= Nt0 ; remember the nt of this word for later
.b657					Else:
.b657	20 14 b6	jsr $b614			jsr zbranch_jmp0_comma	; compile jmp 0, push addr of addr
.b65a	20 62 da	jsr $da62			jsr Here
.b65d	20 ae de	jsr $deae			jsr Rot
.b660	4c 0e df	jmp $df0e			jmp Store
=12					CodeLen	.var *-XtPtr1
=$b663					Here1 = *	; remember here
>b655	0c					.byte CodeLen	;patch wh_CodeLength
>b663	42 65 67 69 6e			Name0:	.text "Begin"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=46568					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>b668	c5					.byte (("Begin"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=28					WordFlags ::= NN+CO+IM	; modifiable copy, remember for later
=21					LinkDisplacement = Nt0-WordListLink
>b669	1c					.byte WordFlags	;wh_Flags
>b66a	03					.byte 3	;wh_CodeLength
>b66b	15					  .byte LinkDisplacement	; offset to previous nt
=$b66c					XtPtr1 ::= *
=46568					WordListLink ::= Nt0 ; remember the nt of this word for later
.b66c	20 62 da	jsr $da62	Begin:		jsr Here	; remember the loop starting location
.b66f	a9 6c		lda #$6c			lda #<Begin	; pairing marker
.b671	4c e4 c7	jmp $c7e4			jmp PushZA
=8					CodeLen	.var *-XtPtr1
=$b674					Here1 = *	; remember here
>b66a	08					.byte CodeLen	;patch wh_CodeLength
>b674	41 67 61 69 6e			Name0:	.text "Again"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=46585					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>b679	c5					.byte (("Again"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=92					WordFlags ::= NN+CO+IM+UF	; modifiable copy, remember for later
=17					LinkDisplacement = Nt0-WordListLink
>b67a	5c					.byte WordFlags	;wh_Flags
>b67b	03					.byte 3	;wh_CodeLength
>b67c	11					  .byte LinkDisplacement	; offset to previous nt
=$b67d					XtPtr1 ::= *
=46585					WordListLink ::= Nt0 ; remember the nt of this word for later
.b67d	20 1b c4	jsr $c41b	Again:		jsr underflow_2
.b680	a9 6c		lda #$6c			lda #<Begin	; check pairing
.b682	20 f3 c1	jsr $c1f3			jsr QPairCtlA
.b685	4c 86 dd	jmp $dd86			jmp Jmp_Comma	; Compile a jmp abs.
=11					CodeLen	.var *-XtPtr1
=$b688					Here1 = *	; remember here
>b67b	0b					.byte CodeLen	;patch wh_CodeLength
>b688	55 6e 74 69 6c			Name0:	.text "Until"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=46605					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>b68d	85					.byte (("Until"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=28					WordFlags ::= IM+CO+NN	; modifiable copy, remember for later
=20					LinkDisplacement = Nt0-WordListLink
>b68e	1c					.byte WordFlags	;wh_Flags
>b68f	03					.byte 3	;wh_CodeLength
>b690	14					  .byte LinkDisplacement	; offset to previous nt
=$b691					XtPtr1 ::= *
=46605					WordListLink ::= Nt0 ; remember the nt of this word for later
.b691	a9 6c		lda #$6c	Until:		lda #<Begin		; check pairing
.b693	20 f3 c1	jsr $c1f3			jsr QPairCtlA
.b696	4c cd b6	jmp $b6cd			jmp ZBranch_Comma	; The address to loop back to is on the stack.
=8					CodeLen	.var *-XtPtr1
=$b699					Here1 = *	; remember here
>b68f	08					.byte CodeLen	;patch wh_CodeLength
>b699	57 68 69 6c 65			Name0:	.text "While"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=46622					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>b69e	a5					.byte (("While"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=28					WordFlags ::= IM+CO+NN	; modifiable copy, remember for later
=17					LinkDisplacement = Nt0-WordListLink
>b69f	1c					.byte WordFlags	;wh_Flags
>b6a0	03					.byte 3	;wh_CodeLength
>b6a1	11					  .byte LinkDisplacement	; offset to previous nt
=$b6a2					XtPtr1 ::= *
=46622					WordListLink ::= Nt0 ; remember the nt of this word for later
.b6a2	a9 6c		lda #$6c	While:		lda #<Begin	; check pairing
.b6a4	20 f3 c1	jsr $c1f3			jsr QPairCtlA
.b6a7	20 11 b6	jsr $b611			jsr If3		; Compile a 0branch & jmp, push addr of addr
.b6aa	20 ee df	jsr $dfee			jsr Swap	; Swap the two addresses on the stack.
.b6ad	a9 6c		lda #$6c			lda #<Begin	; pairing marker
.b6af	4c e4 c7	jmp $c7e4			jmp PushZA
=16					CodeLen	.var *-XtPtr1
=$b6b2					Here1 = *	; remember here
>b6a0	10					.byte CodeLen	;patch wh_CodeLength
>b6b2	52 65 70 65 61 74		Name0:	.text "Repeat"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=46648					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>b6b8	86					.byte (("Repeat"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=28					WordFlags ::= IM+CO+NN	; modifiable copy, remember for later
=26					LinkDisplacement = Nt0-WordListLink
>b6b9	1c					.byte WordFlags	;wh_Flags
>b6ba	03					.byte 3	;wh_CodeLength
>b6bb	1a					  .byte LinkDisplacement	; offset to previous nt
=$b6bc					XtPtr1 ::= *
=46648					WordListLink ::= Nt0 ; remember the nt of this word for later
.b6bc	a9 6c		lda #$6c	Repeat:		lda #<Begin	; check pairing
.b6be	20 f3 c1	jsr $c1f3			jsr QPairCtlA
.b6c1	20 86 dd	jsr $dd86			jsr Jmp_Comma	; compile the jmp back
.b6c4	20 62 da	jsr $da62			jsr Here	; patch the WHILE jmp operand
.b6c7	20 ee df	jsr $dfee			jsr Swap
.b6ca	4c 0e df	jmp $df0e			jmp Store
=17					CodeLen	.var *-XtPtr1
=$b6cd					Here1 = *	; remember here
>b6ba	11					.byte CodeLen	;patch wh_CodeLength
.b6cd					ZBranch_Comma:
.b6cd	a9 e8		lda #$e8			lda #$e8		; compile inx; inx
.b6cf	a8		tay				tay
.b6d0	20 50 dd	jsr $dd50			jsr Comma_YA
.b6d3	a9 b5		lda #$b5			lda #$b5		; compile lda DStack-2,x
.b6d5	a0 22		ldy #$22			ldy #DStack-2
.b6d7	20 50 dd	jsr $dd50			jsr Comma_YA
.b6da	a9 15		lda #$15			lda #$15		; compile ora DStack-1,x
.b6dc	a0 23		ldy #$23			ldy #DStack-1
.b6de	20 50 dd	jsr $dd50			jsr Comma_YA
.b6e1	a9 f0		lda #$f0			lda #$f0		; BEQ
.b6e3	d0 0e		bne $b6f3			bne Branch_CommaA
>b6e5	42 72 61 6e 63 68 2c		Name0:	.text "Branch,"	;  name of word as a string, ending at wh_NameLastChar
=7					NameLength = *-Name0
=46700					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>b6ec	87					.byte (("Branch,"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=52					LinkDisplacement = Nt0-WordListLink
>b6ed	10					.byte WordFlags	;wh_Flags
>b6ee	03					.byte 3	;wh_CodeLength
>b6ef	34					  .byte LinkDisplacement	; offset to previous nt
=$b6f0					XtPtr1 ::= *
=46700					WordListLink ::= Nt0 ; remember the nt of this word for later
.b6f0	20 c3 c3	jsr $c3c3			jsr PopA		; pop opcode to A
.b6f3					Branch_CommaA:
.b6f3	48		pha				pha			; save branch opcode
.b6f4	38		sec				sec			; AY= displacement+2
.b6f5	b5 24		lda $24,x			lda DStack+0,x
.b6f7	e5 00		sbc $00				sbc cp+0
.b6f9	a8		tay				tay
.b6fa	b5 25		lda $25,x			lda DStack+1,x
.b6fc	e5 01		sbc $01				sbc cp+1
.b6fe	c9 ff		cmp #$ff			cmp #$ff		; offset maybe in range?
.b700	f0 0b		beq $b70d			beq _rev
.b702	68		pla		_2byte:		pla			; restore branch opcode
.b703	49 20		eor #$20			eor #$20		; reverse branch sense
.b705	a0 03		ldy #$03			ldy #3			; compile Bcc *+5
.b707	20 50 dd	jsr $dd50			jsr Comma_YA
.b70a	4c 86 dd	jmp $dd86			jmp Jmp_Comma		; compile JMP abs
.b70d	c0 82		cpy #$82	_rev:		cpy #$80+2		; offset in range?
.b70f	90 f1		bcc $b702			bcc _2byte
.b711	e8		inx		_1byte:		inx			; Drop address
.b712	e8		inx				inx
.b713	88		dey				dey			; fix displacement
.b714	88		dey				dey
.b715	68		pla				pla			; restore branch opcode
.b716	4c 50 dd	jmp $dd50			jmp Comma_YA		; compile Bcc
>b719	57 6f 72 64			Name0:	.text "Word"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=46749					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>b71d	84					.byte (("Word"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=49					LinkDisplacement = Nt0-WordListLink
>b71e	10					.byte WordFlags	;wh_Flags
>b71f	03					.byte 3	;wh_CodeLength
>b720	31					  .byte LinkDisplacement	; offset to previous nt
=$b721					XtPtr1 ::= *
=46749					WordListLink ::= Nt0 ; remember the nt of this word for later
.b721					Word:
.b721	20 07 c4	jsr $c407			jsr underflow_1
.b724	a4 08		ldy $08				ldy toin+0		; >IN
.b726	c4 06		cpy $06		_DelimLoop:	cpy ciblen+0		; quit if end of input
.b728	f0 09		beq $b733			beq _found_char
.b72a	b1 04		lda ($04),y			lda (cib),y
.b72c	d5 24		cmp $24,x			cmp DStack+0,x		; ASCII of delimiter
.b72e	d0 03		bne $b733			bne _found_char
.b730	c8		iny				iny
.b731	d0 f3		bne $b726			bne _DelimLoop
.b733					_found_char:
.b733	84 08		sty $08				sty toin+0		; Save index of where word starts
.b735	20 c9 ca	jsr $cac9			jsr Parse		; The real work is done by parse
.b738	20 c3 c3	jsr $c3c3			jsr PopA		; pop u
.b73b	85 16		sta $16				sta tmp2+0
.b73d	20 e9 c3	jsr $c3e9			jsr PopTmp1		; pop addr
.b740	20 62 da	jsr $da62			jsr Here		; Return caddr
.b743	a5 16		lda $16				lda tmp2+0
.b745	a0 00		ldy #$00			ldy #0			; Save length of string
.b747	f0 03		beq $b74c			beq _CopyStart
.b749	b1 14		lda ($14),y	_CopyLoop:	lda (tmp1),y
.b74b	c8		iny				iny
.b74c	20 39 dd	jsr $dd39	_CopyStart:	jsr C_Comma_A
.b74f	c4 16		cpy $16				cpy tmp2+0
.b751	90 f6		bcc $b749			bcc _CopyLoop
=50					CodeLen	.var *-XtPtr1
=$b753					Here1 = *	; remember here
>b71f	32					.byte CodeLen	;patch wh_CodeLength
.b753	60		rts				rts
>b754	28				Name0:	.text "("	;  name of word as a string, ending at wh_NameLastChar
=1					NameLength = *-Name0
=46805					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>b755	01					.byte (("("[-1]&7)<<5)+NameLength	;wh_HashNameLen
=24					WordFlags ::= IM+NN	; modifiable copy, remember for later
=56					LinkDisplacement = Nt0-WordListLink
>b756	18					.byte WordFlags	;wh_Flags
>b757	03					.byte 3	;wh_CodeLength
>b758	38					  .byte LinkDisplacement	; offset to previous nt
=$b759					XtPtr1 ::= *
=46805					WordListLink ::= Nt0 ; remember the nt of this word for later
.b759	a9 29		lda #$29	Paren:		lda #')'		; separator
.b75b	20 cc ca	jsr $cacc			jsr Parse_A		; get string
.b75e	4c 6d d5	jmp $d56d			jmp Two_drop		; 2Drop the result.
=8					CodeLen	.var *-XtPtr1
=$b761					Here1 = *	; remember here
>b757	08					.byte CodeLen	;patch wh_CodeLength
>b761	2e 28				Name0:	.text ".("	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=46819					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>b763	02					.byte ((".("[-1]&7)<<5)+NameLength	;wh_HashNameLen
=24					WordFlags ::= IM+NN	; modifiable copy, remember for later
=14					LinkDisplacement = Nt0-WordListLink
>b764	18					.byte WordFlags	;wh_Flags
>b765	03					.byte 3	;wh_CodeLength
>b766	0e					  .byte LinkDisplacement	; offset to previous nt
=$b767					XtPtr1 ::= *
=46819					WordListLink ::= Nt0 ; remember the nt of this word for later
.b767	a9 29		lda #$29	Dot_paren:	lda #')'		; separator
.b769	20 cc ca	jsr $cacc			jsr Parse_A		; get string
.b76c	4c 34 de	jmp $de34			jmp Type		; type the string
=8					CodeLen	.var *-XtPtr1
=$b76f					Here1 = *	; remember here
>b765	08					.byte CodeLen	;patch wh_CodeLength
>b76f	48 61 73 68			Name0:	.text "Hash"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=46835					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>b773	04					.byte (("Hash"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=16					LinkDisplacement = Nt0-WordListLink
>b774	10					.byte WordFlags	;wh_Flags
>b775	03					.byte 3	;wh_CodeLength
>b776	10					  .byte LinkDisplacement	; offset to previous nt
=$b777					XtPtr1 ::= *
=46835					WordListLink ::= Nt0 ; remember the nt of this word for later
.b777	20 c3 c3	jsr $c3c3	Hash:		jsr PopA		; save length
.b77a	85 16		sta $16				sta tmp2+0
.b77c	b5 24		lda $24,x			lda DStack+0,x		; copy addr
.b77e	b4 25		ldy $25,x			ldy DStack+1,x
.b780	85 14		sta $14				sta tmp1+0
.b782	84 15		sty $15				sty tmp1+1
.b784	a9 b3		lda #$b3			lda #$b3		; init hash
.b786	95 24		sta $24,x			sta DStack+0,x
.b788	95 25		sta $25,x			sta DStack+1,x
.b78a	a0 00		ldy #$00			ldy #0			; for each char
.b78c	f0 15		beq $b7a3			beq _next
.b78e	b1 14		lda ($14),y	_loop:		lda (tmp1),y		;   get char
.b790	c9 61		cmp #$61			cmp #'a'		;   uppercase
.b792	90 06		bcc $b79a			bcc _3
.b794	c9 7b		cmp #$7b			cmp #'z'+1
.b796	b0 02		bcs $b79a			bcs _3
.b798	29 df		and #$df			and #$df
.b79a	16 24		asl $24,x	_3:		asl DStack+0,x		;   add to hash
.b79c	36 25		rol $25,x			rol DStack+1,x
.b79e	75 24		adc $24,x			adc DStack+0,x
.b7a0	95 24		sta $24,x			sta DStack+0,x
.b7a2	c8		iny				iny
.b7a3	c4 16		cpy $16		_Next:		cpy tmp2+0
.b7a5	90 e7		bcc $b78e			bcc _loop
=48					CodeLen	.var *-XtPtr1
=$b7a7					Here1 = *	; remember here
>b775	30					.byte CodeLen	;patch wh_CodeLength
.b7a7	60		rts				rts
>b7a8	45 6e 76 69 72 6f 6e 6d		Name0:	.text "Environment?"	;  name of word as a string, ending at wh_NameLastChar
>b7b0	65 6e 74 3f
=12					NameLength = *-Name0
=46900					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>b7b4	ec					.byte (("Environment?"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=65					LinkDisplacement = Nt0-WordListLink
>b7b5	10					.byte WordFlags	;wh_Flags
>b7b6	03					.byte 3	;wh_CodeLength
>b7b7	41					  .byte LinkDisplacement	; offset to previous nt
=$b7b8					XtPtr1 ::= *
=46900					WordListLink ::= Nt0 ; remember the nt of this word for later
.b7b8					Environment_Q:
.b7b8	20 77 b7	jsr $b777			jsr Hash		; ( hash )
.b7bb	a0 00		ldy #$00			ldy #0			; Y= table index
.b7bd	f0 0a		beq $b7c9			beq _entry_test
.b7bf	98		tya		_entry_next:	tya
.b7c0	c0 34		cpy #$34			cpy #_table_dbl		; if double
.b7c2	90 02		bcc $b7c6			bcc +
.b7c4	69 01		adc #$01			adc #6-4-1		;   skip double
.b7c6	69 04		adc #$04	+		adc #4			;   skip single
.b7c8	a8		tay		_3:		tay
.b7c9	b9 fd b7	lda $b7fd,y	_entry_test:	lda _Table+0,y		; match?
.b7cc	f0 28		beq $b7f6			beq _notfound
.b7ce	d5 24		cmp $24,x			cmp DStack+0,x
.b7d0	d0 ed		bne $b7bf			bne _entry_next
.b7d2	b9 fe b7	lda $b7fe,y			lda _Table+1,y
.b7d5	d5 25		cmp $25,x			cmp DStack+1,x
.b7d7	d0 e6		bne $b7bf			bne _entry_next
.b7d9	b9 ff b7	lda $b7ff,y			lda _Table+2,y
.b7dc	95 24		sta $24,x			sta DStack+0,x
.b7de	b9 00 b8	lda $b800,y			lda _Table+3,y
.b7e1	95 25		sta $25,x			sta DStack+1,x
.b7e3	c0 34		cpy #$34			cpy #_table_dbl		; single or double data?
.b7e5	90 0c		bcc $b7f3			bcc _single
.b7e7	ca		dex				dex			;  push 2nd cell
.b7e8	ca		dex				dex
.b7e9	b9 01 b8	lda $b801,y			lda _Table+4,y
.b7ec	95 24		sta $24,x			sta DStack+0,x
.b7ee	b9 02 b8	lda $b802,y			lda _Table+5,y
.b7f1	95 25		sta $25,x			sta DStack+1,x
.b7f3					_single:
.b7f3	4c c4 c7	jmp $c7c4			jmp True		; return True
.b7f6					_notfound:
.b7f6	a9 00		lda #$00			lda #0			; return 0
.b7f8	95 24		sta $24,x			sta DStack+0,x
.b7fa	95 25		sta $25,x			sta DStack+1,x
.b7fc	60		rts				rts
=69					CodeLen	.var *-XtPtr1
=$b7fd					Here1 = *	; remember here
>b7b6	45					.byte CodeLen	;patch wh_CodeLength
.b7fd					_Table:
>b7fd	5e e6 ff 7f				.word $e65e,$7fff	; "/COUNTED-STRING"
>b801	be 79 ff 00				.word $79BE,$ff		; "/HOLD"
>b805	b9 3c 54 00				.word $3cb9,padoffset	; "/PAD"
>b809	8b 81 08 00				.word $818b,8		; "ADDRESS-UNIT-BITS"
>b80d	57 fc 00 00				.word $fc57,0		; "FLOORED"	we have symmetric)
>b811	4f fb ff 00				.word $fb4f,$ff		; "MAX-CHAR"
>b815	56 7f ff 7f				.word $7f56,$7fff	; "MAX-N"
>b819	5d 7f ff ff				.word $7f5d,$ffff	; "MAX-U"
>b81d	38 ce 80 00				.word $ce38,$80		; "RETURN-STACK-CELLS"
>b821	f2 c0 14 00				.word $c0f2,DDim	; "STACK-CELLS"
>b825	36 e3 09 00				.word $e336,9		; "WORDLISTS"
>b829	4a f2 ff ff				.word $f24a,$ffff	; "FLOATING"		flag	no	   floating-point word set present
>b82d	01 99 0a 00				.word $9901,FDim	; "FLOATING-STACK"	n	yes	   If n = zero, floating-point numbers are
=52					_table_dbl = *-_Table	; These return a double-cell number
>b831	4c 7f ff ff ff 7f			.word $7f4c,$ffff,$7fff	; "MAX-D"
>b837	fe fe ff ff ff ff			.word $fefe,$ffff,$ffff	; "MAX-UD"
>b83d	00					.byte 0		; end of list
>b83e	44 75 6d 70			Name0:	.text "Dump"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=47042					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>b842	04					.byte (("Dump"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=142					LinkDisplacement = Nt0-WordListLink
>b843	10					.byte WordFlags	;wh_Flags
>b844	03					.byte 3	;wh_CodeLength
>b845	8e					  .byte LinkDisplacement	; offset to previous nt
=$b846					XtPtr1 ::= *
=47042					WordListLink ::= Nt0 ; remember the nt of this word for later
.b846	20 1b c4	jsr $c41b	Dump:		jsr underflow_2
.b849	ca		dex				dex			; alloc work area
.b84a	ca		dex				dex
.b84b					_row:
.b84b	20 4c bb	jsr $bb4c			jsr CR
.b84e	b5 29		lda $29,x			lda DStack+5,x		; print address number
.b850	20 ce b8	jsr $b8ce			jsr C_Dot_Hex_A
.b853	b5 28		lda $28,x			lda DStack+4,x
.b855	20 ce b8	jsr $b8ce			jsr C_Dot_Hex_A
.b858	20 28 de	jsr $de28			jsr Space
.b85b	20 28 de	jsr $de28			jsr Space
.b85e	a9 00		lda #$00			lda #0
.b860	95 24		sta $24,x			sta DStack+0,x
.b862					_loop:
.b862	b5 26		lda $26,x			lda DStack+2,x
.b864	15 27		ora $27,x			ora DStack+3,x
.b866	f0 36		beq $b89e			beq _all_printed
.b868	a1 28		lda ($28,x)			lda (DStack+4,x)
.b86a	20 ce b8	jsr $b8ce			jsr C_Dot_Hex_A
.b86d	20 28 de	jsr $de28			jsr Space
.b870	a1 28		lda ($28,x)			lda (DStack+4,x)
.b872	20 f4 b8	jsr $b8f4			jsr is_printable
.b875	b0 02		bcs $b879			bcs _printable
.b877	a9 2e		lda #$2e			lda #'.'		 ; Print dot if not printable
.b879					_printable:
.b879	b4 24		ldy $24,x			ldy DStack+0,x
.b87b	91 00		sta ($00),y			sta (cp),y
.b87d	c0 07		cpy #$07			cpy #7
.b87f	d0 03		bne $b884			bne +
.b881	20 28 de	jsr $de28			jsr Space
.b884					+
.b884	f6 28		inc $28,x			inc DStack+4,x
.b886	d0 02		bne $b88a			bne +
.b888	f6 29		inc $29,x			inc DStack+5,x
.b88a					+
.b88a	20 7c da	jsr $da7c			jsr NOS_One_Minus	; loop counter
.b88d	f6 24		inc $24,x			inc DStack+0,x
.b88f	b5 24		lda $24,x			lda DStack+0,x
.b891	c9 10		cmp #$10			cmp #16
.b893	90 cd		bcc $b862			bcc _loop		; next byte
.b895	20 28 de	jsr $de28			jsr Space
.b898	20 ad b8	jsr $b8ad			jsr dump_print_ascii
.b89b	4c 4b b8	jmp $b84b			jmp _row		; new row
.b89e					_all_printed:
.b89e	b5 24		lda $24,x			lda DStack+0,x
.b8a0	f0 06		beq $b8a8			beq _done
.b8a2	20 28 de	jsr $de28			jsr Space
.b8a5	20 ad b8	jsr $b8ad			jsr dump_print_ascii
.b8a8					_done:
.b8a8	e8		inx				inx			; drop work area
.b8a9	e8		inx				inx
.b8aa	4c 6d d5	jmp $d56d			jmp Two_drop		; one byte less than 4x INX
.b8ad					dump_print_ascii:
.b8ad	a0 00		ldy #$00			ldy #0
.b8af					_loop:
.b8af	b1 00		lda ($00),y			lda (cp),y
.b8b1	20 1c de	jsr $de1c			jsr Emit_A
.b8b4	c8		iny				iny
.b8b5	c0 08		cpy #$08			cpy #8
.b8b7	d0 03		bne $b8bc			bne +
.b8b9	20 28 de	jsr $de28			jsr Space
.b8bc					+
.b8bc	98		tya				tya
.b8bd	d5 24		cmp $24,x			cmp DStack+0,x
.b8bf	90 ee		bcc $b8af			bcc _loop
.b8c1	60		rts				rts
=124					CodeLen	.var *-XtPtr1
=$b8c2					Here1 = *	; remember here
>b844	7c					.byte CodeLen	;patch wh_CodeLength
>b8c2	43 2e 48 65 78			Name0:	.text "C.Hex"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=47175					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>b8c7	05					.byte (("C.Hex"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=133					LinkDisplacement = Nt0-WordListLink
>b8c8	10					.byte WordFlags	;wh_Flags
>b8c9	03					.byte 3	;wh_CodeLength
>b8ca	85					  .byte LinkDisplacement	; offset to previous nt
=$b8cb					XtPtr1 ::= *
=47175					WordListLink ::= Nt0 ; remember the nt of this word for later
.b8cb	20 c3 c3	jsr $c3c3	C_Dot_Hex:	jsr PopA
.b8ce	48		pha		C_Dot_Hex_A:	pha
.b8cf	4a		lsr a				lsr		; convert high nibble first
.b8d0	4a		lsr a				lsr
.b8d1	4a		lsr a				lsr
.b8d2	4a		lsr a				lsr
.b8d3	20 d7 b8	jsr $b8d7			jsr _nibble_to_ascii
.b8d6	68		pla				pla
.b8d7					_nibble_to_ascii:
.b8d7	29 0f		and #$0f			and #$0F	; only use lower nibble
.b8d9	c9 0a		cmp #$0a			cmp #9+1
.b8db	90 02		bcc $b8df			bcc +
.b8dd	69 06		adc #$06			adc #6
.b8df	69 30		adc #$30	+		adc #'0'
.b8e1	4c 1c de	jmp $de1c			jmp Emit_A
=25					CodeLen	.var *-XtPtr1
=$b8e4					Here1 = *	; remember here
>b8c9	19					.byte CodeLen	;patch wh_CodeLength
>b8e4	2e 48 65 78			Name0:	.text ".Hex"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=47208					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>b8e8	04					.byte ((".Hex"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=33					LinkDisplacement = Nt0-WordListLink
>b8e9	10					.byte WordFlags	;wh_Flags
>b8ea	03					.byte 3	;wh_CodeLength
>b8eb	21					  .byte LinkDisplacement	; offset to previous nt
=$b8ec					XtPtr1 ::= *
=47208					WordListLink ::= Nt0 ; remember the nt of this word for later
.b8ec	b5 25		lda $25,x	Dot_Hex:	lda DStack+1,x	; do hi byte
.b8ee	20 ce b8	jsr $b8ce			jsr C_Dot_Hex_A
.b8f1	4c cb b8	jmp $b8cb			jmp C_Dot_Hex	; do lo byte
=8					CodeLen	.var *-XtPtr1
=$b8f4					Here1 = *	; remember here
>b8ea	08					.byte CodeLen	;patch wh_CodeLength
.b8f4					is_printable:
.b8f4	c9 20		cmp #$20	                cmp #AscSP              ; $20
.b8f6	90 07		bcc $b8ff	                bcc _done
.b8f8	c9 80		cmp #$80	                cmp #$7F + 1             ; '~'
.b8fa	b0 02		bcs $b8fe	                bcs _failed
.b8fc	38		sec		                sec
.b8fd	60		rts		                rts
.b8fe	18		clc		_failed:	clc
.b8ff	60		rts		_done:		rts
>b900	2e 53				Name0:	.text ".S"	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=47234					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>b902	62					.byte ((".S"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=26					LinkDisplacement = Nt0-WordListLink
>b903	10					.byte WordFlags	;wh_Flags
>b904	03					.byte 3	;wh_CodeLength
>b905	1a					  .byte LinkDisplacement	; offset to previous nt
=$b906					XtPtr1 ::= *
=47234					WordListLink ::= Nt0 ; remember the nt of this word for later
.b906					Dot_s:
.b906	a9 3c		lda #$3c			lda #'<'
.b908	20 1c de	jsr $de1c			jsr Emit_A
.b90b	20 5c d2	jsr $d25c			jsr Depth	; ( -- u )
.b90e	20 66 dc	jsr $dc66			jsr print_u
.b911	a9 3e		lda #$3e			lda #'>'
.b913	20 1c de	jsr $de1c			jsr Emit_A
.b916	20 28 de	jsr $de28			jsr Space
.b919	a0 28		ldy #$28			ldy #DDim*2		; for each cell on the stack
.b91b	88		dey		_loop:		dey
.b91c	88		dey				dey
.b91d	86 14		stx $14				stx tmp1
.b91f	c4 14		cpy $14				cpy tmp1
.b921	90 15		bcc $b938			bcc _done
.b923	98		tya				tya			; save index
.b924	48		pha				pha
.b925	ca		dex				dex			; push stack[index]
.b926	ca		dex				dex
.b927	b9 24 00	lda $0024,y			lda DStack+0,y
.b92a	95 24		sta $24,x			sta DStack+0,x
.b92c	b9 25 00	lda $0025,y			lda DStack+1,y
.b92f	95 25		sta $25,x			sta DStack+1,x
.b931	20 1c dc	jsr $dc1c			jsr Dot
.b934	68		pla				pla			; restore index
.b935	a8		tay				tay
.b936	d0 e3		bne $b91b			bne _loop
.b938					_done:
=50					CodeLen	.var *-XtPtr1
=$b938					Here1 = *	; remember here
>b904	32					.byte CodeLen	;patch wh_CodeLength
.b938	60		rts				rts
>b939	43 6f 6d 70 61 72 65		Name0:	.text "Compare"	;  name of word as a string, ending at wh_NameLastChar
=7					NameLength = *-Name0
=47296					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>b940	a7					.byte (("Compare"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=80					WordFlags ::= UF+NN	; modifiable copy, remember for later
=62					LinkDisplacement = Nt0-WordListLink
>b941	50					.byte WordFlags	;wh_Flags
>b942	03					.byte 3	;wh_CodeLength
>b943	3e					  .byte LinkDisplacement	; offset to previous nt
=$b944					XtPtr1 ::= *
=47296					WordListLink ::= Nt0 ; remember the nt of this word for later
.b944					Compare:
.b944	20 25 c4	jsr $c425			jsr underflow_4
.b947	b5 24		lda $24,x			lda DStack+0,x		; tmp3+1= u2.lo
.b949	85 19		sta $19				sta tmp3+1
.b94b	b5 26		lda $26,x			lda DStack+2,x		; tmp2= addr2
.b94d	b4 27		ldy $27,x			ldy DStack+3,x
.b94f	85 16		sta $16				sta tmp2+0
.b951	84 17		sty $17				sty tmp2+1
.b953	b5 28		lda $28,x			lda DStack+4,x		; tmp3+0= u1.lo
.b955	85 18		sta $18				sta tmp3+0
.b957	b5 2a		lda $2a,x			lda DStack+6,x		; tmp1= addr1
.b959	b4 2b		ldy $2b,x			ldy DStack+7,x
.b95b	85 14		sta $14				sta tmp1+0
.b95d	84 15		sty $15				sty tmp1+1
.b95f	a0 00		ldy #$00			ldy #0		; for each char
.b961					_loop:
.b961	c4 18		cpy $18				cpy tmp3+0	; string1 empty?
.b963	f0 13		beq $b978			beq _str1
.b965					_L1:
.b965	c4 19		cpy $19				cpy tmp3+1	; string2 empty?
.b967	f0 27		beq $b990			beq _str2
.b969					_L2:
.b969	b1 14		lda ($14),y			lda (tmp1),y	; Are they different?
.b96b	d1 16		cmp ($16),y			cmp (tmp2),y
.b96d	d0 19		bne $b988			bne _neq
.b96f	c8		iny				iny		; to next char
.b970	d0 ef		bne $b961			bne _loop
.b972	e6 15		inc $15				inc tmp1+1	; to next page
.b974	e6 17		inc $17				inc tmp2+1
.b976	d0 e9		bne $b961			bne _loop
.b978	d6 29		dec $29,x	_str1:		dec DStack+5,x	; string1 really empty?
.b97a	10 e9		bpl $b965			bpl _L1
.b97c	c4 19		cpy $19				cpy tmp3+1	; string2 empty?
.b97e	d0 0a		bne $b98a			bne _less
.b980	b5 25		lda $25,x			lda DStack+1,x
.b982	d0 06		bne $b98a			bne _less
.b984	a9 00		lda #$00	_equal:		lda #0		; Return 0
.b986	f0 0e		beq $b996			beq _gt2
.b988	b0 0a		bcs $b994	_neq:		bcs _greater
.b98a	a9 ff		lda #$ff	_less:		lda #$FF	; Return -1
.b98c	95 2a		sta $2a,x			sta DStack+6,x
.b98e	d0 0a		bne $b99a			bne _done
.b990	d6 25		dec $25,x	_str2:		dec DStack+1,x	; is string2 empty?
.b992	10 d5		bpl $b969			bpl _L2
.b994	a9 01		lda #$01	_greater:	lda #1		; Return 1
.b996	95 2a		sta $2a,x	_gt2:		sta DStack+6,x
.b998	a9 00		lda #$00			lda #0
.b99a	95 2b		sta $2b,x	_done:		sta DStack+7,x
.b99c	8a		txa				txa		; Remove all but the result from the stack.
.b99d	18		clc				clc
.b99e	69 06		adc #$06			adc #6
.b9a0	aa		tax				tax
=93					CodeLen	.var *-XtPtr1
=$b9a1					Here1 = *	; remember here
>b942	5d					.byte CodeLen	;patch wh_CodeLength
.b9a1	60		rts				rts
>b9a2	53 65 61 72 63 68		Name0:	.text "Search"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=47400					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>b9a8	06					.byte (("Search"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=104					LinkDisplacement = Nt0-WordListLink
>b9a9	10					.byte WordFlags	;wh_Flags
>b9aa	03					.byte 3	;wh_CodeLength
>b9ab	68					  .byte LinkDisplacement	; offset to previous nt
=$b9ac					XtPtr1 ::= *
=47400					WordListLink ::= Nt0 ; remember the nt of this word for later
.b9ac					Search:
.b9ac	20 25 c4	jsr $c425			jsr underflow_4
.b9af	b5 24		lda $24,x			lda DStack+0,x
.b9b1	15 25		ora $25,x			ora DStack+1,x
.b9b3	d0 09		bne $b9be			bne _start_search
.b9b5	e8		inx				inx		; Drop u2
.b9b6	e8		inx				inx
.b9b7	a9 ff		lda #$ff			lda #$FF	; overwrite addr2 with a true flag
.b9b9	95 24		sta $24,x			sta DStack+0,x
.b9bb	95 25		sta $25,x			sta DStack+1,x
.b9bd	60		rts				rts
.b9be					_start_search:
.b9be	20 f2 c7	jsr $c7f2			jsr Zero
.b9c1					_search_loop:
.b9c1	18		clc				clc
.b9c2	b5 24		lda $24,x			lda DStack+0,x
.b9c4	75 26		adc $26,x			adc DStack+2,x
.b9c6	85 14		sta $14				sta tmp1+0
.b9c8	b5 25		lda $25,x			lda DStack+1,x
.b9ca	75 27		adc $27,x			adc DStack+3,x
.b9cc	85 15		sta $15				sta tmp1+1
.b9ce	d5 2b		cmp $2b,x			cmp DStack+7,x
.b9d0	90 13		bcc $b9e5			bcc _init_comparison ; Obviously less
.b9d2	d0 06		bne $b9da			bne _not_found
.b9d4	b5 2a		lda $2a,x			lda DStack+6,x
.b9d6	c5 14		cmp $14				cmp tmp1
.b9d8	b0 0b		bcs $b9e5			bcs _init_comparison
.b9da					_not_found:
.b9da	e8		inx				inx		; Remove offset
.b9db	e8		inx				inx
.b9dc	e8		inx				inx		; Remove u2
.b9dd	e8		inx				inx
.b9de	a9 00		lda #$00			lda #0
.b9e0	95 24		sta $24,x			sta DStack+0,x	; Turn addr2 into a false flag
.b9e2	95 25		sta $25,x			sta DStack+1,x
.b9e4	60		rts				rts
.b9e5					_init_comparison:
.b9e5	18		clc				clc
.b9e6	b5 2c		lda $2c,x			lda DStack+8,x
.b9e8	75 24		adc $24,x			adc DStack+0,x
.b9ea	85 14		sta $14				sta tmp1
.b9ec	b5 2d		lda $2d,x			lda DStack+9,x
.b9ee	75 25		adc $25,x			adc DStack+1,x
.b9f0	85 15		sta $15				sta tmp1+1
.b9f2	b5 28		lda $28,x			lda DStack+4,x
.b9f4	85 16		sta $16				sta tmp2
.b9f6	b5 29		lda $29,x			lda DStack+5,x
.b9f8	85 17		sta $17				sta tmp2+1
.b9fa	b5 26		lda $26,x			lda DStack+2,x
.b9fc	85 18		sta $18				sta tmp3+0
.b9fe	b5 27		lda $27,x			lda DStack+3,x
.ba00	85 19		sta $19				sta tmp3+1
.ba02					_comparison_loop:
.ba02	a0 00		ldy #$00			ldy #0
.ba04	b1 14		lda ($14),y			lda (tmp1),y
.ba06	d1 16		cmp ($16),y			cmp (tmp2),y
.ba08	f0 06		beq $ba10			beq _letters_match
.ba0a	20 95 da	jsr $da95			jsr One_plus
.ba0d	4c c1 b9	jmp $b9c1			jmp _search_loop
.ba10					_letters_match:
.ba10	e6 14		inc $14				inc tmp1
.ba12	d0 02		bne $ba16			bne +
.ba14	e6 15		inc $15				inc tmp1+1
.ba16					+
.ba16	e6 16		inc $16				inc tmp2
.ba18	d0 02		bne $ba1c			bne +
.ba1a	e6 17		inc $17				inc tmp2+1
.ba1c					+
.ba1c	a5 18		lda $18				lda tmp3
.ba1e	d0 02		bne $ba22			bne +
.ba20	c6 19		dec $19				dec tmp3+1
.ba22					+
.ba22	c6 18		dec $18				dec tmp3
.ba24	a5 18		lda $18				lda tmp3
.ba26	05 19		ora $19				ora tmp3+1
.ba28	d0 d8		bne $ba02			bne _comparison_loop ; Check the next letter
.ba2a	18		clc				clc
.ba2b	b5 24		lda $24,x			lda DStack+0,x
.ba2d	75 2c		adc $2c,x			adc DStack+8,x
.ba2f	95 2c		sta $2c,x			sta DStack+8,x
.ba31	b5 25		lda $25,x			lda DStack+1,x
.ba33	75 2d		adc $2d,x			adc DStack+9,x
.ba35	95 2d		sta $2d,x			sta DStack+9,x
.ba37	38		sec				sec
.ba38	b5 2a		lda $2a,x			lda DStack+6,x
.ba3a	f5 24		sbc $24,x			sbc DStack+0,x
.ba3c	95 2a		sta $2a,x			sta DStack+6,x
.ba3e	b5 2b		lda $2b,x			lda DStack+7,x
.ba40	f5 25		sbc $25,x			sbc DStack+1,x
.ba42	95 2b		sta $2b,x			sta DStack+7,x
.ba44	e8		inx				inx		; drop offset
.ba45	e8		inx				inx
.ba46	e8		inx				inx		; drop u2
.ba47	e8		inx				inx
.ba48	a9 ff		lda #$ff			lda #$FF
.ba4a	95 24		sta $24,x			sta DStack+0,x	; Turn addr2 into a true flag.
.ba4c	95 25		sta $25,x			sta DStack+1,x
=162					CodeLen	.var *-XtPtr1
=$ba4e					Here1 = *	; remember here
>b9aa	a2					.byte CodeLen	;patch wh_CodeLength
.ba4e	60		rts				rts
>ba4f	4d 61 72 6b 65 72		Name0:	.text "Marker"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=47573					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>ba55	46					.byte (("Marker"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=24					WordFlags ::= IM+NN	; modifiable copy, remember for later
=173					LinkDisplacement = Nt0-WordListLink
>ba56	18					.byte WordFlags	;wh_Flags
>ba57	03					.byte 3	;wh_CodeLength
>ba58	ad					  .byte LinkDisplacement	; offset to previous nt
=$ba59					XtPtr1 ::= *
=47573					WordListLink ::= Nt0 ; remember the nt of this word for later
.ba59					Marker:
.ba59	20 62 da	jsr $da62			jsr Here		; Save original CP, which
.ba5c	20 29 d1	jsr $d129			jsr Header_Build	; compile a word header, but don't link into wordlist
.ba5f	a0 ba		ldy #$ba			ldy #>_runtime		; compile JSR _runtime
.ba61	a9 79		lda #$79			lda #<_runtime
.ba63	20 73 dd	jsr $dd73			jsr Jsr_Comma_YA
.ba66	20 4d dd	jsr $dd4d			jsr Comma		; Append original CP
.ba69	a0 00		ldy #$00			ldy #0			; Start at CURRENT
.ba6b	b9 10 03	lda $0310,y	_loop:		lda CurrentV,y
.ba6e	20 39 dd	jsr $dd39			jsr C_Comma_A
.ba71	c8		iny				iny
.ba72	c0 24		cpy #$24			cpy #MarkEnd-CurrentV	; One past the end of the search order.
.ba74	90 f5		bcc $ba6b			bcc _loop
.ba76	4c 1e d1	jmp $d11e			jmp Header_Link		; link built header into current dictionary
=32					CodeLen	.var *-XtPtr1
=$ba79					Here1 = *	; remember here
>ba57	20					.byte CodeLen	;patch wh_CodeLength
.ba79					_runtime:
.ba79	68		pla				pla		; Pop the RTS address off the stack
.ba7a	85 14		sta $14				sta tmp1+0
.ba7c	68		pla				pla
.ba7d	85 15		sta $15				sta tmp1+1
.ba7f	a0 01		ldy #$01			ldy #1		; start just aftet JSR _runtime
.ba81	b1 14		lda ($14),y			lda (tmp1),y	; CP was stored first
.ba83	85 00		sta $00				sta cp+0
.ba85	c8		iny				iny
.ba86	b1 14		lda ($14),y			lda (tmp1),y
.ba88	85 01		sta $01				sta cp+1
.ba8a	c8		iny				iny
.ba8b					_rloop:
.ba8b	b1 14		lda ($14),y			lda (tmp1),y
.ba8d	99 0d 03	sta $030d,y			sta CurrentV-2-1,y
.ba90	c8		iny				iny
.ba91	c0 27		cpy #$27			cpy #MarkEnd-CurrentV+2+1 ; One past the end of the search order.
.ba93	90 f6		bcc $ba8b			bcc _rloop
.ba95	60		rts				rts
>ba96	57 6f 72 64 73			Name0:	.text "Words"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=47643					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>ba9b	65					.byte (("Words"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=70					LinkDisplacement = Nt0-WordListLink
>ba9c	10					.byte WordFlags	;wh_Flags
>ba9d	03					.byte 3	;wh_CodeLength
>ba9e	46					  .byte LinkDisplacement	; offset to previous nt
=$ba9f					XtPtr1 ::= *
=47643					WordListLink ::= Nt0 ; remember the nt of this word for later
.ba9f					Words:
.ba9f	a9 ff		lda #$ff			lda #$ff
.baa1	20 e4 c7	jsr $c7e4			jsr PushZA		; Alloc space for line size & wordlist #
.baa4	ca		dex				dex			; Alloc space for a nt
.baa5	ca		dex				dex
.baa6					_wordlist_next:
.baa6	20 4c bb	jsr $bb4c			jsr CR			; start wordlist on new line
.baa9	f6 26		inc $26,x			inc DStack+2,x		; step to next search wordlist
.baab	b4 26		ldy $26,x			ldy DStack+2,x		; Y= wordlist index
.baad	cc 2a 03	cpy $032a			cpy Num_OrderV
.bab0	b0 44		bcs $baf6			bcs _wordslist_done	; ran out of search wordlist entries?
.bab2	b9 2b 03	lda $032b,y			lda Search_OrderV,y	; A= SEARCH-ORDER[Y]	Get the current wordlist id
.bab5	0a		asl a				asl			; TOS= WORDLISTS[A]
.bab6	a8		tay				tay
.bab7	b9 12 03	lda $0312,y			lda WordlistsV+0,y
.baba	95 24		sta $24,x			sta DStack+0,x
.babc	b9 13 03	lda $0313,y			lda WordlistsV+1,y
.babf	95 25		sta $25,x			sta DStack+1,x
.bac1	f0 e3		beq $baa6			beq _wordlist_next	; end of list?
.bac3					_word_loop:
.bac3	20 cd df	jsr $dfcd			jsr Dup			; ( wordlist# nt nt )
.bac6	20 f2 cd	jsr $cdf2			jsr Name_To_String	; ( wordlist# nt addr u )
.bac9	b5 2b		lda $2b,x			lda DStack+7,x
.bacb	38		sec				sec			; don't forget the space between words
.bacc	75 24		adc $24,x			adc DStack+0,x
.bace	c9 4e		cmp #$4e			cmp #MAX_LINE_LENGTH-1
.bad0	90 05		bcc $bad7			bcc +
.bad2	20 4c bb	jsr $bb4c			jsr CR
.bad5	b5 24		lda $24,x			lda DStack+0,x		; After going to next line, start
.bad7	95 2b		sta $2b,x	+		sta DStack+7,x
.bad9	20 34 de	jsr $de34			jsr Type		; ( wordlist# nt )
.badc	20 28 de	jsr $de28			jsr Space
.badf	b5 24		lda $24,x			lda DStack+0,x
.bae1	85 14		sta $14				sta tmp1+0
.bae3	b5 25		lda $25,x			lda DStack+1,x
.bae5	85 15		sta $15				sta tmp1+1
.bae7	20 95 82	jsr $8295			jsr LinkNext		; tmp1= next word nt in list
.baea	a5 14		lda $14				lda tmp1+0
.baec	95 24		sta $24,x			sta DStack+0,x
.baee	a5 15		lda $15				lda tmp1+1
.baf0	95 25		sta $25,x			sta DStack+1,x
.baf2	d0 cf		bne $bac3			bne _word_loop		; end of list?
.baf4	f0 b0		beq $baa6			beq _wordlist_next
.baf6					_wordslist_done:
.baf6	4c 6d d5	jmp $d56d			jmp Two_Drop
=90					CodeLen	.var *-XtPtr1
=$baf9					Here1 = *	; remember here
>ba9d	5a					.byte CodeLen	;patch wh_CodeLength
>baf9	57 6f 72 64 53 69 7a 65		Name0:	.text "WordSize"	;  name of word as a string, ending at wh_NameLastChar
=8					NameLength = *-Name0
=47745					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>bb01	a8					.byte (("WordSize"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=102					LinkDisplacement = Nt0-WordListLink
>bb02	10					.byte WordFlags	;wh_Flags
>bb03	03					.byte 3	;wh_CodeLength
>bb04	66					  .byte LinkDisplacement	; offset to previous nt
=$bb05					XtPtr1 ::= *
=47745					WordListLink ::= Nt0 ; remember the nt of this word for later
.bb05	20 e9 c3	jsr $c3e9	WordSize:	jsr PopTmp1
.bb08	a0 82		ldy #$82			ldy #Wh_CodeLength
.bb0a	b1 14		lda ($14),y			lda (tmp1),y
.bb0c	4c e4 c7	jmp $c7e4			jmp PushZA
=10					CodeLen	.var *-XtPtr1
=$bb0f					Here1 = *	; remember here
>bb03	0a					.byte CodeLen	;patch wh_CodeLength
>bb0f	41 6c 69 67 6e 65 64		Name0:	.text "Aligned"	;  name of word as a string, ending at wh_NameLastChar
=7					NameLength = *-Name0
=47766					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>bb16	87					.byte (("Aligned"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=0					WordFlags ::= 0	; modifiable copy, remember for later
=21					LinkDisplacement = Nt0-WordListLink
>bb17	00					.byte WordFlags	;wh_Flags
>bb18	03					.byte 3	;wh_CodeLength
>bb19	15					  .byte LinkDisplacement	; offset to previous nt
=$bb1a					XtPtr1 ::= *
=47766					WordListLink ::= Nt0 ; remember the nt of this word for later
.bb1a					Aligned:
=0					CodeLen	.var *-XtPtr1
=$bb1a					Here1 = *	; remember here
>bb18	00					.byte CodeLen	;patch wh_CodeLength
.bb1a	60		rts				rts
>bb1b	41 6c 69 67 6e			Name0:	.text "Align"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=47776					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>bb20	c5					.byte (("Align"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=0					WordFlags ::= 0	; modifiable copy, remember for later
=10					LinkDisplacement = Nt0-WordListLink
>bb21	00					.byte WordFlags	;wh_Flags
>bb22	03					.byte 3	;wh_CodeLength
>bb23	0a					  .byte LinkDisplacement	; offset to previous nt
=$bb24					XtPtr1 ::= *
=47776					WordListLink ::= Nt0 ; remember the nt of this word for later
.bb24					Align:
=0					CodeLen	.var *-XtPtr1
=$bb24					Here1 = *	; remember here
>bb22	00					.byte CodeLen	;patch wh_CodeLength
.bb24	60		rts				rts
>bb25	4f 75 74 70 75 74		Name0:	.text "Output"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=47787					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>bb2b	86					.byte (("Output"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=11					LinkDisplacement = Nt0-WordListLink
>bb2c	10					.byte WordFlags	;wh_Flags
>bb2d	03					.byte 3	;wh_CodeLength
>bb2e	0b					  .byte LinkDisplacement	; offset to previous nt
=$bb2f					XtPtr1 ::= *
=47787					WordListLink ::= Nt0 ; remember the nt of this word for later
.bb2f					xt_output:
.bb2f	a0 03		ldy #$03			ldy #>output
.bb31	a9 06		lda #$06			lda #<output
.bb33	4c b5 c7	jmp $c7b5			jmp PushYA
=7					CodeLen	.var *-XtPtr1
=$bb36					Here1 = *	; remember here
>bb2d	07					.byte CodeLen	;patch wh_CodeLength
>bb36	49 6e 70 75 74			Name0:	.text "Input"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=47803					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>bb3b	85					.byte (("Input"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=16					LinkDisplacement = Nt0-WordListLink
>bb3c	10					.byte WordFlags	;wh_Flags
>bb3d	03					.byte 3	;wh_CodeLength
>bb3e	10					  .byte LinkDisplacement	; offset to previous nt
=$bb3f					XtPtr1 ::= *
=47803					WordListLink ::= Nt0 ; remember the nt of this word for later
.bb3f	a0 03		ldy #$03	xt_input:	ldy #>input
.bb41	a9 08		lda #$08			lda #<input
.bb43	4c b5 c7	jmp $c7b5			jmp PushYA
=7					CodeLen	.var *-XtPtr1
=$bb46					Here1 = *	; remember here
>bb3d	07					.byte CodeLen	;patch wh_CodeLength
>bb46	43 52				Name0:	.text "CR"	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=47816					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>bb48	42					.byte (("CR"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>bb49	10					.byte WordFlags	;wh_Flags
>bb4a	03					.byte 3	;wh_CodeLength
>bb4b	0d					  .byte LinkDisplacement	; offset to previous nt
=$bb4c					XtPtr1 ::= *
=47816					WordListLink ::= Nt0 ; remember the nt of this word for later
.bb4c					CR:
.bb4c	a9 0a		lda #$0a			lda #AscLF
.bb4e	20 1c de	jsr $de1c			jsr Emit_A
=5					CodeLen	.var *-XtPtr1
=$bb51					Here1 = *	; remember here
>bb4a	05					.byte CodeLen	;patch wh_CodeLength
.bb51	60		rts				rts
>bb52	50 61 67 65			Name0:	.text "Page"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=47830					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>bb56	a4					.byte (("Page"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=14					LinkDisplacement = Nt0-WordListLink
>bb57	10					.byte WordFlags	;wh_Flags
>bb58	03					.byte 3	;wh_CodeLength
>bb59	0e					  .byte LinkDisplacement	; offset to previous nt
=$bb5a					XtPtr1 ::= *
=47830					WordListLink ::= Nt0 ; remember the nt of this word for later
.bb5a	20 b8 c8	jsr $c8b8	Page:		jsr SLiteral_Runtime
.bb5d	4c 6a bb	jmp $bb6a			  jmp +
>bb60	1b 5b 32 4a					  .text AscESC,"[2J"	; ANSI clear screen
>bb64	1b 5b 31 3b 31 48				  .text AscESC,"[1;1H"	; move cursor to top left of screen
.bb6a	4c 34 de	jmp $de34	+		jmp Type
=19					CodeLen	.var *-XtPtr1
=$bb6d					Here1 = *	; remember here
>bb58	13					.byte CodeLen	;patch wh_CodeLength
>bb6d	41 74 2d 58 59			Name0:	.text "At-XY"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=47858					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>bb72	25					.byte (("At-XY"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=28					LinkDisplacement = Nt0-WordListLink
>bb73	10					.byte WordFlags	;wh_Flags
>bb74	03					.byte 3	;wh_CodeLength
>bb75	1c					  .byte LinkDisplacement	; offset to previous nt
=$bb76					XtPtr1 ::= *
=47858					WordListLink ::= Nt0 ; remember the nt of this word for later
.bb76					At_XY:
.bb76	20 1b c4	jsr $c41b			jsr underflow_2
.bb79	ad 00 03	lda $0300			lda base	; Save the BASE
.bb7c	48		pha				pha
.bb7d	20 b1 c1	jsr $c1b1			jsr Decimal	; ANSI escape code values need to be in decimal.
.bb80	a9 1b		lda #$1b			lda #AscESC
.bb82	20 1c de	jsr $de1c			jsr Emit_A
.bb85	a9 5b		lda #$5b			lda #'['
.bb87	20 1c de	jsr $de1c			jsr Emit_A
.bb8a	f6 24		inc $24,x			inc DStack+0,x	; AT-XY is zero based, but ANSI is 1 based
.bb8c	20 66 dc	jsr $dc66			jsr print_u
.bb8f	a9 3b		lda #$3b			lda #';'
.bb91	20 1c de	jsr $de1c			jsr Emit_A
.bb94	f6 24		inc $24,x			inc DStack+0,x	; AT-XY is zero based, but ANSI is 1 based
.bb96	20 66 dc	jsr $dc66			jsr print_u
.bb99	a9 48		lda #$48			lda #'H'
.bb9b	20 1c de	jsr $de1c			jsr Emit_A
.bb9e	68		pla				pla		; Restore the base
.bb9f	8d 00 03	sta $0300			sta base
=44					CodeLen	.var *-XtPtr1
=$bba2					Here1 = *	; remember here
>bb74	2c					.byte CodeLen	;patch wh_CodeLength
.bba2	60		rts				rts
>bba3	50 61 64			Name0:	.text "Pad"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=47910					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>bba6	83					.byte (("Pad"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=0					WordFlags ::= 0	; modifiable copy, remember for later
=52					LinkDisplacement = Nt0-WordListLink
>bba7	00					.byte WordFlags	;wh_Flags
>bba8	03					.byte 3	;wh_CodeLength
>bba9	34					  .byte LinkDisplacement	; offset to previous nt
=$bbaa					XtPtr1 ::= *
=47910					WordListLink ::= Nt0 ; remember the nt of this word for later
.bbaa	ca		dex		Pad:		dex		; push cp+PadOffset
.bbab	ca		dex				dex
.bbac	18		clc				clc
.bbad	a5 00		lda $00				lda cp+0
.bbaf	69 54		adc #$54			adc #PadOffset
.bbb1	95 24		sta $24,x			sta DStack+0,x
.bbb3	a5 01		lda $01				lda cp+1
.bbb5	69 00		adc #$00			adc #0
.bbb7	95 25		sta $25,x			sta DStack+1,x
=15					CodeLen	.var *-XtPtr1
=$bbb9					Here1 = *	; remember here
>bba8	0f					.byte CodeLen	;patch wh_CodeLength
.bbb9	60		rts				rts
>bbba	3c 23				Name0:	.text "<#"	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=47932					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>bbbc	62					.byte (("<#"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=0					WordFlags ::= 0	; modifiable copy, remember for later
=22					LinkDisplacement = Nt0-WordListLink
>bbbd	00					.byte WordFlags	;wh_Flags
>bbbe	03					.byte 3	;wh_CodeLength
>bbbf	16					  .byte LinkDisplacement	; offset to previous nt
=$bbc0					XtPtr1 ::= *
=47932					WordListLink ::= Nt0 ; remember the nt of this word for later
.bbc0					Less_Number_Sign:
.bbc0	a9 54		lda #$54			lda #PadOffset		; init hold buffer index
.bbc2	8d 34 03	sta $0334			sta ToHold
=5					CodeLen	.var *-XtPtr1
=$bbc5					Here1 = *	; remember here
>bbbe	05					.byte CodeLen	;patch wh_CodeLength
.bbc5	60		rts				rts
>bbc6	23 3e				Name0:	.text "#>"	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=47944					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>bbc8	c2					.byte (("#>"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=12					LinkDisplacement = Nt0-WordListLink
>bbc9	10					.byte WordFlags	;wh_Flags
>bbca	03					.byte 3	;wh_CodeLength
>bbcb	0c					  .byte LinkDisplacement	; offset to previous nt
=$bbcc					XtPtr1 ::= *
=47944					WordListLink ::= Nt0 ; remember the nt of this word for later
.bbcc					Number_Sign_Greater:
.bbcc	20 1b c4	jsr $c41b			jsr underflow_2		; double number
.bbcf	18		clc				clc			; addr= cp + ToHold
.bbd0	a5 00		lda $00				lda cp+0
.bbd2	6d 34 03	adc $0334			adc ToHold
.bbd5	95 26		sta $26,x			sta DStack+2,x
.bbd7	a5 01		lda $01				lda cp+1
.bbd9	69 00		adc #$00			adc #0
.bbdb	95 27		sta $27,x			sta DStack+3,x
.bbdd	38		sec				sec			; u= PadOffset - ToHold
.bbde	a9 54		lda #$54			lda #PadOffset
.bbe0	ed 34 03	sbc $0334			sbc ToHold
.bbe3	95 24		sta $24,x			sta DStack+0,x
.bbe5	a9 00		lda #$00			lda #0
.bbe7	95 25		sta $25,x			sta DStack+1,x
=29					CodeLen	.var *-XtPtr1
=$bbe9					Here1 = *	; remember here
>bbca	1d					.byte CodeLen	;patch wh_CodeLength
.bbe9	60		rts				rts
>bbea	48 6f 6c 64			Name0:	.text "Hold"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=47982					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>bbee	84					.byte (("Hold"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=0					WordFlags ::= 0	; modifiable copy, remember for later
=38					LinkDisplacement = Nt0-WordListLink
>bbef	00					.byte WordFlags	;wh_Flags
>bbf0	03					.byte 3	;wh_CodeLength
>bbf1	26					  .byte LinkDisplacement	; offset to previous nt
=$bbf2					XtPtr1 ::= *
=47982					WordListLink ::= Nt0 ; remember the nt of this word for later
.bbf2	20 c3 c3	jsr $c3c3	Hold:		jsr PopA
.bbf5	ce 34 03	dec $0334	Hold_A:		dec ToHold
.bbf8	ac 34 03	ldy $0334			ldy ToHold
.bbfb	91 00		sta ($00),y			sta (cp),y
=11					CodeLen	.var *-XtPtr1
=$bbfd					Here1 = *	; remember here
>bbf0	0b					.byte CodeLen	;patch wh_CodeLength
.bbfd	60		rts				rts
>bbfe	23				Name0:	.text "#"	;  name of word as a string, ending at wh_NameLastChar
=1					NameLength = *-Name0
=47999					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>bbff	61					.byte (("#"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=80					WordFlags ::= UF+NN	; modifiable copy, remember for later
=17					LinkDisplacement = Nt0-WordListLink
>bc00	50					.byte WordFlags	;wh_Flags
>bc01	03					.byte 3	;wh_CodeLength
>bc02	11					  .byte LinkDisplacement	; offset to previous nt
=$bc03					XtPtr1 ::= *
=47999					WordListLink ::= Nt0 ; remember the nt of this word for later
.bc03					Number_Sign:
.bc03	20 1b c4	jsr $c41b			jsr underflow_2		; double number
.bc06	a9 00		lda #$00			lda #0			;   init remainder
.bc08	18		clc				clc
.bc09	a0 21		ldy #$21			ldy #32+1		;   for each bit
.bc0b					_div1:
.bc0b	2a		rol a				rol a			;     shift remainder
.bc0c	cd 00 03	cmp $0300			cmp base		;     will it fit?
.bc0f	90 03		bcc $bc14			bcc _div7
.bc11	ed 00 03	sbc $0300			sbc base
.bc14					_div7:
.bc14	36 26		rol $26,x			rol DStack+2,x		;     shift ud
.bc16	36 27		rol $27,x			rol DStack+3,x
.bc18	36 24		rol $24,x			rol DStack+0,x
.bc1a	36 25		rol $25,x			rol DStack+1,x
.bc1c	88		dey				dey			;    next bit
.bc1d	d0 ec		bne $bc0b			bne _div1
.bc1f	c9 0a		cmp #$0a			cmp #9+1		; alternatively this could use s_abc_upper
.bc21	90 02		bcc $bc25			bcc +
.bc23	69 06		adc #$06			adc #7-1
.bc25	69 30		adc #$30	+		adc #'0'
.bc27	d0 cc		bne $bbf5			bne Hold_A
=38					CodeLen	.var *-XtPtr1
=$bc29					Here1 = *	; remember here
>bc01	26					.byte CodeLen	;patch wh_CodeLength
>bc29	23 53				Name0:	.text "#S"	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=48043					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>bc2b	62					.byte (("#S"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=0					WordFlags ::= 0	; modifiable copy, remember for later
=44					LinkDisplacement = Nt0-WordListLink
>bc2c	00					.byte WordFlags	;wh_Flags
>bc2d	03					.byte 3	;wh_CodeLength
>bc2e	2c					  .byte LinkDisplacement	; offset to previous nt
=$bc2f					XtPtr1 ::= *
=48043					WordListLink ::= Nt0 ; remember the nt of this word for later
.bc2f					Number_Sign_S:
.bc2f					_loop:
.bc2f	20 03 bc	jsr $bc03			jsr Number_sign	; convert a single number ("#")
.bc32	b5 24		lda $24,x			lda DStack+0,x	; until d is zero
.bc34	15 25		ora $25,x			ora DStack+1,x
.bc36	15 26		ora $26,x			ora DStack+2,x
.bc38	15 27		ora $27,x			ora DStack+3,x
.bc3a	d0 f3		bne $bc2f			bne _loop
=13					CodeLen	.var *-XtPtr1
=$bc3c					Here1 = *	; remember here
>bc2d	0d					.byte CodeLen	;patch wh_CodeLength
.bc3c	60		rts				rts
>bc3d	53 69 67 6e			Name0:	.text "Sign"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=48065					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>bc41	c4					.byte (("Sign"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=22					LinkDisplacement = Nt0-WordListLink
>bc42	10					.byte WordFlags	;wh_Flags
>bc43	03					.byte 3	;wh_CodeLength
>bc44	16					  .byte LinkDisplacement	; offset to previous nt
=$bc45					XtPtr1 ::= *
=48065					WordListLink ::= Nt0 ; remember the nt of this word for later
.bc45	20 de c3	jsr $c3de	Sign:		jsr PopYA
.bc48	98		tya				tya		; test MSB of TOS
.bc49					Sign_P:
.bc49	30 01		bmi $bc4c			bmi _minus
.bc4b	60		rts				rts
.bc4c	a9 2d		lda #$2d	_minus:		lda #'-'	; add minus sign
.bc4e	d0 a5		bne $bbf5			bne hold_a
=11					CodeLen	.var *-XtPtr1
=$bc50					Here1 = *	; remember here
>bc43	0b					.byte CodeLen	;patch wh_CodeLength
>bc50	43 6c 65 61 76 65		Name0:	.text "Cleave"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=48086					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>bc56	a6					.byte (("Cleave"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=21					LinkDisplacement = Nt0-WordListLink
>bc57	10					.byte WordFlags	;wh_Flags
>bc58	03					.byte 3	;wh_CodeLength
>bc59	15					  .byte LinkDisplacement	; offset to previous nt
=$bc5a					XtPtr1 ::= *
=48086					WordListLink ::= Nt0 ; remember the nt of this word for later
.bc5a	20 1b c4	jsr $c41b	Cleave:		jsr underflow_2
.bc5d	20 1b d5	jsr $d51b			jsr Minus_leading	; -LEADING ( addr u )
.bc60	20 11 d4	jsr $d411			jsr Input_To_R	; save old imput state
.bc63	b5 24		lda $24,x			lda DStack+0,x	; u is new ciblen
.bc65	85 06		sta $06				sta ciblen
.bc67	b5 25		lda $25,x			lda DStack+1,x
.bc69	85 07		sta $07				sta ciblen+1
.bc6b	b5 26		lda $26,x			lda DStack+2,x	; addr is new cib
.bc6d	85 04		sta $04				sta cib
.bc6f	b5 27		lda $27,x			lda DStack+3,x
.bc71	85 05		sta $05				sta cib+1
.bc73	a9 00		lda #$00			lda #0
.bc75	85 08		sta $08				sta toin	; >IN pointer is zero
.bc77	85 09		sta $09				sta toin+1
.bc79	20 82 ca	jsr $ca82			jsr parse_name	; ( addr u addr-s u-s )
.bc7c	b5 24		lda $24,x			lda DStack+0,x
.bc7e	15 25		ora $25,x			ora DStack+1,x
.bc80	f0 23		beq $bca5			beq _done
.bc82	38		sec				sec
.bc83	b5 28		lda $28,x			lda DStack+4,x	; LSB of original u
.bc85	f5 24		sbc $24,x			sbc DStack+0,x
.bc87	95 28		sta $28,x			sta DStack+4,x
.bc89	b5 29		lda $29,x			lda DStack+5,x	; MSB of original u
.bc8b	f5 25		sbc $25,x			sbc DStack+1,x
.bc8d	95 29		sta $29,x			sta DStack+5,x
.bc8f	18		clc				clc
.bc90	b5 2a		lda $2a,x			lda DStack+6,x	; LSB of original addr
.bc92	75 24		adc $24,x			adc DStack+0,x
.bc94	95 2a		sta $2a,x			sta DStack+6,x
.bc96	b5 2b		lda $2b,x			lda DStack+7,x	; MSB of original addr
.bc98	75 25		adc $25,x			adc DStack+1,x
.bc9a	95 2b		sta $2b,x			sta DStack+7,x
.bc9c	20 7f d5	jsr $d57f			jsr Two_swap		; ( addr-s u-s addr u )
.bc9f	20 1b d5	jsr $d51b			jsr Minus_leading
.bca2	20 7f d5	jsr $d57f			jsr Two_swap		; ( addr u addr-s u-s )
.bca5					_done:
.bca5	20 32 d4	jsr $d432			jsr R_To_Input
=78					CodeLen	.var *-XtPtr1
=$bca8					Here1 = *	; remember here
>bc58	4e					.byte CodeLen	;patch wh_CodeLength
.bca8	60		rts				rts
>bca9	48 65 78 53 74 6f 72 65		Name0:	.text "HexStore"	;  name of word as a string, ending at wh_NameLastChar
=8					NameLength = *-Name0
=48177					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>bcb1	a8					.byte (("HexStore"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=91					LinkDisplacement = Nt0-WordListLink
>bcb2	10					.byte WordFlags	;wh_Flags
>bcb3	03					.byte 3	;wh_CodeLength
>bcb4	5b					  .byte LinkDisplacement	; offset to previous nt
=$bcb5					XtPtr1 ::= *
=48177					WordListLink ::= Nt0 ; remember the nt of this word for later
.bcb5	20 20 c4	jsr $c420	Hexstore:	jsr underflow_3
.bcb8	20 cd df	jsr $dfcd			jsr Dup		; Save copy of original address
.bcbb	20 9f d6	jsr $d69f			jsr Two_to_r		; ( addr1 u1 ) ( R: addr2 addr2 )
.bcbe					_loop:
.bcbe	b5 24		lda $24,x			lda DStack+0,x
.bcc0	15 25		ora $25,x			ora DStack+1,x
.bcc2	f0 37		beq $bcfb			beq _done
.bcc4	20 5a bc	jsr $bc5a			jsr Cleave		; ( addr1 u1 addr3 u3 ) ( R: addr2 addr2 )
.bcc7	20 9f d6	jsr $d69f			jsr Two_to_r
.bcca	20 f2 c7	jsr $c7f2			jsr Zero
.bccd	20 f2 c7	jsr $c7f2			jsr Zero
.bcd0	20 7b d6	jsr $d67b			jsr Two_r_from	; ( addr1 u1 0 0 addr3 u3 ) ( R: addr2 addr2 )
.bcd3	20 34 c0	jsr $c034			jsr To_Number	; ( addr1 u1 n n addr4 u4 ) ( R: addr2 addr2 )
.bcd6	b5 24		lda $24,x			lda DStack+0,x
.bcd8	15 25		ora $25,x			ora DStack+1,x
.bcda	d0 18		bne $bcf4			bne _have_chars_left
.bcdc	20 6d d5	jsr $d56d			jsr Two_drop		; ( addr1 u1 n n ) ( R: addr2 addr2 )
.bcdf	20 1f d0	jsr $d01f			jsr D_To_S		; ( addr1 u1 n ) ( R: addr2 addr2 )
.bce2	20 76 df	jsr $df76			jsr R_Fetch		; ( addr1 u1 n addr2 ) ( R: addr2 addr2 )
.bce5	20 b2 dd	jsr $ddb2			jsr C_Store		; ( addr1 u1 ) ( R: addr2 addr2 )
.bce8	20 5b df	jsr $df5b			jsr R_From		; R>
.bceb	20 95 da	jsr $da95			jsr One_plus		; 1+
.bcee	20 3d df	jsr $df3d			jsr To_R		; >R ( addr1 u1 ) ( R: addr2+1 addr2 )
.bcf1	4c be bc	jmp $bcbe			jmp _loop
.bcf4					_have_chars_left:
.bcf4	8a		txa				txa
.bcf5	18		clc				clc
.bcf6	69 08		adc #$08			adc #8
.bcf8	aa		tax				tax
.bcf9	d0 c3		bne $bcbe			bne _loop
.bcfb					_done:
.bcfb	e8		inx				inx
.bcfc	e8		inx				inx
.bcfd	e8		inx				inx
.bcfe	e8		inx				inx			; 2DROP
.bcff	20 7b d6	jsr $d67b			jsr Two_r_from		; ( addr2+n addr2 )
.bd02	20 ee df	jsr $dfee			jsr Swap
.bd05	4c 03 dc	jmp $dc03			jmp Minus		; ( n )
=83					CodeLen	.var *-XtPtr1
=$bd08					Here1 = *	; remember here
>bcb3	53					.byte CodeLen	;patch wh_CodeLength
.bd08	4c 2a c4	jmp $c42a	Throw_Stack_24: jmp Throw_Stack
>bd0b	57 69 74 68 69 6e		Name0:	.text "Within"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=48273					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>bd11	c6					.byte (("Within"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=96					LinkDisplacement = Nt0-WordListLink
>bd12	10					.byte WordFlags	;wh_Flags
>bd13	03					.byte 3	;wh_CodeLength
>bd14	60					  .byte LinkDisplacement	; offset to previous nt
=$bd15					XtPtr1 ::= *
=48273					WordListLink ::= Nt0 ; remember the nt of this word for later
.bd15					Within:
.bd15	e0 23		cpx #$23		cpx #(DDim-3)*2+1	; far enough below end of data stack (& not negative)?
.bd17	b0 ef		bcs $bd08		bcs Throw_Stack_24
.bd19	20 a4 df	jsr $dfa4			jsr Over
.bd1c	20 03 dc	jsr $dc03			jsr Minus
.bd1f	20 3d df	jsr $df3d			jsr To_R
.bd22	20 03 dc	jsr $dc03			jsr Minus
.bd25	20 5b df	jsr $df5b			jsr R_From
.bd28	4c cf d8	jmp $d8cf			jmp U_Less_Than
=22					CodeLen	.var *-XtPtr1
=$bd2b					Here1 = *	; remember here
>bd13	16					.byte CodeLen	;patch wh_CodeLength
>bd2b	5c				Name0:	.text "\"	;  name of word as a string, ending at wh_NameLastChar
=1					NameLength = *-Name0
=48300					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>bd2c	81					.byte (("\"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=24					WordFlags ::= IM+NN	; modifiable copy, remember for later
=27					LinkDisplacement = Nt0-WordListLink
>bd2d	18					.byte WordFlags	;wh_Flags
>bd2e	03					.byte 3	;wh_CodeLength
>bd2f	1b					  .byte LinkDisplacement	; offset to previous nt
=$bd30					XtPtr1 ::= *
=48300					WordListLink ::= Nt0 ; remember the nt of this word for later
.bd30					Backslash:
.bd30	ad 0c 03	lda $030c			lda BlkV+0		; interpreting a block?
.bd33	0d 0d 03	ora $030d			ora BlkV+1
.bd36	f0 16		beq $bd4e			beq _not_block
.bd38	a5 08		lda $08				lda toin+0
.bd3a	29 3f		and #$3f			and #$3F
.bd3c	c9 02		cmp #$02			cmp #2
.bd3e	90 0d		bcc $bd4d			bcc _rts
.bd40	a5 08		lda $08		                lda toin+0		; Move toin to next multiple of 64.
.bd42	29 c0		and #$c0	                and #$C0        	;   Clear lower bits to move to beginning of line.
.bd44	18		clc		                clc             	;   Add $40 (64 decimal) to move to next line.
.bd45	69 40		adc #$40	                adc #$40
.bd47	85 08		sta $08		                sta toin+0
.bd49	90 02		bcc $bd4d	                bcc _rts
.bd4b	e6 09		inc $09		                inc toin+1
.bd4d	60		rts		_rts:		rts
.bd4e					_not_block:
.bd4e	a5 06		lda $06		                lda ciblen+0		; consume the remainder of the line
.bd50	85 08		sta $08		                sta toin+0
.bd52	a5 07		lda $07		                lda ciblen+1
.bd54	85 09		sta $09		                sta toin+1
=38					CodeLen	.var *-XtPtr1
=$bd56					Here1 = *	; remember here
>bd2e	26					.byte CodeLen	;patch wh_CodeLength
.bd56	60		rts				rts
>bd57	4d 6f 76 65			Name0:	.text "Move"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=48347					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>bd5b	a4					.byte (("Move"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=47					LinkDisplacement = Nt0-WordListLink
>bd5c	10					.byte WordFlags	;wh_Flags
>bd5d	03					.byte 3	;wh_CodeLength
>bd5e	2f					  .byte LinkDisplacement	; offset to previous nt
=$bd5f					XtPtr1 ::= *
=48347					WordListLink ::= Nt0 ; remember the nt of this word for later
.bd5f					Move:
.bd5f	b5 27		lda $27,x			lda DStack+3,x		; MSB of addr2
.bd61	d5 29		cmp $29,x			cmp DStack+5,x		; MSB of addr1
.bd63	d0 04		bne $bd69			bne _ne
.bd65	b5 26		lda $26,x			lda DStack+2,x		; LSB of addr2
.bd67	d5 28		cmp $28,x			cmp DStack+4,x		; LSB of addr1
.bd69	90 59		bcc $bdc4	_ne:		bcc CMove
.bd6b	d0 10		bne $bd7d			bne CMove_up
.bd6d	8a		txa		ThreeDrop:	txa		; drop three entries from Data Stack
.bd6e	18		clc				clc
.bd6f	69 06		adc #$06			adc #6
.bd71	aa		tax				tax
=19					CodeLen	.var *-XtPtr1
=$bd72					Here1 = *	; remember here
>bd5d	13					.byte CodeLen	;patch wh_CodeLength
.bd72	60		rts				rts
>bd73	43 4d 6f 76 65 3e		Name0:	.text "CMove>"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=48377					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>bd79	c6					.byte (("CMove>"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=30					LinkDisplacement = Nt0-WordListLink
>bd7a	10					.byte WordFlags	;wh_Flags
>bd7b	03					.byte 3	;wh_CodeLength
>bd7c	1e					  .byte LinkDisplacement	; offset to previous nt
=$bd7d					XtPtr1 ::= *
=48377					WordListLink ::= Nt0 ; remember the nt of this word for later
.bd7d					CMove_up:
.bd7d	e0 23		cpx #$23		cpx #(DDim-3)*2+1	; far enough below end of data stack (& not negative)?
.bd7f	b0 37		bcs $bdb8		bcs Throw_Stack_14
.bd81	b5 26		lda $26,x			lda DStack+2,x
.bd83	85 16		sta $16				sta tmp2	; use tmp2 because easier to remember
.bd85	b5 27		lda $27,x			lda DStack+3,x
.bd87	18		clc				clc
.bd88	75 25		adc $25,x			adc DStack+1,x
.bd8a	85 17		sta $17				sta tmp2+1	; point to last page of destination
.bd8c	b5 28		lda $28,x			lda DStack+4,x
.bd8e	85 14		sta $14				sta tmp1	; use tmp1 because easier to remember
.bd90	b5 29		lda $29,x			lda DStack+5,x
.bd92	18		clc				clc
.bd93	75 25		adc $25,x			adc DStack+1,x
.bd95	85 15		sta $15				sta tmp1+1	; point to last page of source
.bd97	f6 25		inc $25,x			inc DStack+1,x	; allows us to use bne with dec DStack+1,x below
.bd99	b4 24		ldy $24,x			ldy DStack+0,x	; length of last page
.bd9b	f0 10		beq $bdad			beq _nopartial
.bd9d					_outerloop:
.bd9d	88		dey				dey
.bd9e	f0 07		beq $bda7			beq _finishpage
.bda0					_innerloop:
.bda0	b1 14		lda ($14),y			lda (tmp1),y
.bda2	91 16		sta ($16),y			sta (tmp2),y
.bda4	88		dey				dey
.bda5	d0 f9		bne $bda0			bne _innerloop
.bda7					_finishpage:
.bda7	a0 00		ldy #$00			ldy #0
.bda9	b1 14		lda ($14),y			lda (tmp1),y	; handle y = 0 separately
.bdab	91 16		sta ($16),y			sta (tmp2),y
.bdad					_nopartial:
.bdad	c6 15		dec $15				dec tmp1+1	; back up to previous pages
.bdaf	c6 17		dec $17				dec tmp2+1
.bdb1	d6 25		dec $25,x			dec DStack+1,x
.bdb3	d0 e8		bne $bd9d			bne _outerloop
.bdb5					_done:
.bdb5	4c 6d bd	jmp $bd6d			jmp ThreeDrop	; clear up the stack and leave
=59					CodeLen	.var *-XtPtr1
=$bdb8					Here1 = *	; remember here
>bd7b	3b					.byte CodeLen	;patch wh_CodeLength
.bdb8	4c 2a c4	jmp $c42a	Throw_Stack_14: jmp Throw_Stack
>bdbb	43 4d 6f 76 65			Name0:	.text "CMove"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=48448					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>bdc0	a5					.byte (("CMove"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=71					LinkDisplacement = Nt0-WordListLink
>bdc1	10					.byte WordFlags	;wh_Flags
>bdc2	03					.byte 3	;wh_CodeLength
>bdc3	47					  .byte LinkDisplacement	; offset to previous nt
=$bdc4					XtPtr1 ::= *
=48448					WordListLink ::= Nt0 ; remember the nt of this word for later
.bdc4					CMove:
.bdc4	e0 23		cpx #$23		cpx #(DDim-3)*2+1	; far enough below end of data stack (& not negative)?
.bdc6	b0 f0		bcs $bdb8		bcs Throw_Stack_14
.bdc8	b5 26		lda $26,x			lda DStack+2,x
.bdca	85 16		sta $16				sta tmp2+0	; use tmp2 because easier to remember
.bdcc	b5 27		lda $27,x			lda DStack+3,x
.bdce	85 17		sta $17				sta tmp2+1
.bdd0	b5 28		lda $28,x			lda DStack+4,x
.bdd2	85 14		sta $14				sta tmp1+0	; use tmp1 because easier to remember
.bdd4	b5 29		lda $29,x			lda DStack+5,x
.bdd6	85 15		sta $15				sta tmp1+1
.bdd8	a0 00		ldy #$00			ldy #0
.bdda	b5 25		lda $25,x			lda DStack+1,x	; number of whole pages to move
.bddc	f0 0f		beq $bded			beq _dopartial
.bdde					_page:
.bdde	b1 14		lda ($14),y			lda (tmp1),y
.bde0	91 16		sta ($16),y			sta (tmp2),y
.bde2	c8		iny				iny
.bde3	d0 f9		bne $bdde			bne _page
.bde5	e6 15		inc $15				inc tmp1+1
.bde7	e6 17		inc $17				inc tmp2+1
.bde9	d6 25		dec $25,x			dec DStack+1,x
.bdeb	d0 f1		bne $bdde			bne _page
.bded					_dopartial:
.bded	b5 24		lda $24,x			lda DStack+0,x	; length of last page
.bdef	f0 09		beq $bdfa			beq _done
.bdf1					_partial:
.bdf1	b1 14		lda ($14),y			lda (tmp1),y
.bdf3	91 16		sta ($16),y			sta (tmp2),y
.bdf5	c8		iny				iny
.bdf6	d6 24		dec $24,x			dec DStack+0,x
.bdf8	d0 f7		bne $bdf1			bne _partial
.bdfa	4c 6d bd	jmp $bd6d	_done:		jmp ThreeDrop	; clear the stack
=57					CodeLen	.var *-XtPtr1
=$bdfd					Here1 = *	; remember here
>bdc2	39					.byte CodeLen	;patch wh_CodeLength
>bdfd	55 4d 2a			Name0:	.text "UM*"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=48512					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>be00	43					.byte (("UM*"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=64					LinkDisplacement = Nt0-WordListLink
>be01	10					.byte WordFlags	;wh_Flags
>be02	03					.byte 3	;wh_CodeLength
>be03	40					  .byte LinkDisplacement	; offset to previous nt
=$be04					XtPtr1 ::= *
=48512					WordListLink ::= Nt0 ; remember the nt of this word for later
.be04					UM_Star:
.be04	e0 25		cpx #$25		cpx #(DDim-2)*2+1	; far enough below end of data stack (& not negative)?
.be06	b0 b0		bcs $bdb8		bcs Throw_Stack_14
.be08	18		clc				clc		; tmp2= divsor-1
.be09	b5 24		lda $24,x			lda DStack+0,x
.be0b	e9 00		sbc #$00			sbc #0
.be0d	85 16		sta $16				sta tmp2+0
.be0f	b5 25		lda $25,x			lda DStack+1,x
.be11	e9 00		sbc #$00			sbc #0
.be13	85 17		sta $17				sta tmp2+1
.be15	90 2e		bcc $be45			bcc _zero	; is divisor zero?
.be17	a9 00		lda #$00			lda #0
.be19	85 14		sta $14				sta tmp1
.be1b	86 18		stx $18				stx tmp3	; tested for exit from outer loop
.be1d	ca		dex				dex
.be1e	ca		dex				dex
.be1f					_outer_loop:
.be1f	a0 08		ldy #$08			ldy #8		; counter inner loop
.be21	56 28		lsr $28,x			lsr DStack+4,x	; think "DStack+2,x" then later "DStack+3,x"
.be23					_inner_loop:
.be23	90 0c		bcc $be31			bcc _no_add
.be25	85 15		sta $15				sta tmp1+1	; save time, don't CLC
.be27	a5 14		lda $14				lda tmp1
.be29	65 16		adc $16				adc tmp2
.be2b	85 14		sta $14				sta tmp1
.be2d	a5 15		lda $15				lda tmp1+1
.be2f	65 17		adc $17				adc tmp2+1
.be31					_no_add:
.be31	6a		ror a				ror
.be32	66 14		ror $14				ror tmp1
.be34	76 28		ror $28,x			ror DStack+4,x	; think "DStack+2,x" then later "DStack+3,x"
.be36	88		dey				dey
.be37	d0 ea		bne $be23			bne _inner_loop ; go back for one more shift?
.be39	e8		inx				inx
.be3a	e4 18		cpx $18				cpx tmp3
.be3c	d0 e1		bne $be1f			bne _outer_loop ; go back for eight more shifts?
.be3e	95 25		sta $25,x			sta DStack+1,x
.be40	a5 14		lda $14				lda tmp1
.be42	95 24		sta $24,x			sta DStack+0,x
.be44	60		rts				rts
.be45	a9 00		lda #$00	_zero:		lda #0
.be47	95 26		sta $26,x			sta DStack+2,x
.be49	95 27		sta $27,x			sta DStack+3,x
.be4b	60		rts				rts
=72					CodeLen	.var *-XtPtr1
=$be4c					Here1 = *	; remember here
>be02	48					.byte CodeLen	;patch wh_CodeLength
>be4c	4d 2a				Name0:	.text "M*"	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=48590					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>be4e	42					.byte (("M*"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=78					LinkDisplacement = Nt0-WordListLink
>be4f	10					.byte WordFlags	;wh_Flags
>be50	03					.byte 3	;wh_CodeLength
>be51	4e					  .byte LinkDisplacement	; offset to previous nt
=$be52					XtPtr1 ::= *
=48590					WordListLink ::= Nt0 ; remember the nt of this word for later
.be52					M_Star:
.be52	e0 25		cpx #$25		cpx #(DDim-2)*2+1	; far enough below end of data stack (& not negative)?
.be54	b0 6b		bcs $bec1		bcs Throw_Stack_15
.be56	b5 25		lda $25,x			lda DStack+1,x	; MSB of n1
.be58	55 27		eor $27,x			eor DStack+3,x	; MSB of n2
.be5a	08		php				php
.be5b	20 fd d6	jsr $d6fd			jsr Abs
.be5e	20 ee df	jsr $dfee			jsr Swap
.be61	20 fd d6	jsr $d6fd			jsr Abs
.be64	20 04 be	jsr $be04			jsr UM_Star		; ( d )
.be67	28		plp				plp			; handle the sign
.be68	10 03		bpl $be6d			bpl +
.be6a	4c 14 d7	jmp $d714			jmp DNegate
.be6d					+
=27					CodeLen	.var *-XtPtr1
=$be6d					Here1 = *	; remember here
>be50	1b					.byte CodeLen	;patch wh_CodeLength
.be6d	60		rts				rts
>be6e	2a				Name0:	.text "*"	;  name of word as a string, ending at wh_NameLastChar
=1					NameLength = *-Name0
=48623					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>be6f	41					.byte (("*"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=0					WordFlags ::= 0	; modifiable copy, remember for later
=33					LinkDisplacement = Nt0-WordListLink
>be70	00					.byte WordFlags	;wh_Flags
>be71	03					.byte 3	;wh_CodeLength
>be72	21					  .byte LinkDisplacement	; offset to previous nt
=$be73					XtPtr1 ::= *
=48623					WordListLink ::= Nt0 ; remember the nt of this word for later
.be73					Star:
.be73	20 04 be	jsr $be04			jsr UM_Star
.be76	e8		inx				inx		; D>S	drop hi cell
.be77	e8		inx				inx
=5					CodeLen	.var *-XtPtr1
=$be78					Here1 = *	; remember here
>be71	05					.byte CodeLen	;patch wh_CodeLength
.be78	60		rts				rts
>be79	55 4d 2f 4d 6f 64		Name0:	.text "UM/Mod"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=48639					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>be7f	86					.byte (("UM/Mod"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=16					LinkDisplacement = Nt0-WordListLink
>be80	10					.byte WordFlags	;wh_Flags
>be81	03					.byte 3	;wh_CodeLength
>be82	10					  .byte LinkDisplacement	; offset to previous nt
=$be83					XtPtr1 ::= *
=48639					WordListLink ::= Nt0 ; remember the nt of this word for later
.be83					UM_Slash_Mod:
.be83	e0 23		cpx #$23		cpx #(DDim-3)*2+1	; far enough below end of data stack (& not negative)?
.be85	b0 3a		bcs $bec1		bcs Throw_Stack_15
.be87	b5 24		lda $24,x			lda DStack+0,x		; catch division by zero
.be89	15 25		ora $25,x			ora DStack+1,x
.be8b	f0 2f		beq $bebc			beq _DivByZero
.be8d	a0 10		ldy #$10			ldy #16			; for 16 bits
.be8f					_loop:
.be8f	36 28		rol $28,x			rol DStack+4,x		;   rotate low cell of dividend one bit left
.be91	36 29		rol $29,x			rol DStack+5,x
.be93	36 26		rol $26,x			rol DStack+2,x		;   rotate high cell of dividend one bit left
.be95	36 27		rol $27,x			rol DStack+3,x
.be97	b0 0a		bcs $bea3			bcs _subtract		;   overflow?
.be99	b5 26		lda $26,x			lda DStack+2,x		;   dividend.hi >= divisor?
.be9b	d5 24		cmp $24,x			cmp DStack+0,x
.be9d	b5 27		lda $27,x			lda DStack+3,x
.be9f	f5 25		sbc $25,x			sbc DStack+1,x
.bea1	90 0d		bcc $beb0			bcc _next
.bea3	b5 26		lda $26,x	_subtract:	lda DStack+2,x		;   dividend.hi -= divisor
.bea5	f5 24		sbc $24,x			sbc DStack+0,x
.bea7	95 26		sta $26,x			sta DStack+2,x
.bea9	b5 27		lda $27,x			lda DStack+3,x
.beab	f5 25		sbc $25,x			sbc DStack+1,x
.bead	95 27		sta $27,x			sta DStack+3,x
.beaf	38		sec				sec			;   it always fits
.beb0	88		dey		_next:		dey			;  next
.beb1	d0 dc		bne $be8f			bne _loop
.beb3	36 28		rol $28,x			rol DStack+4,x		; finish rotating quotient bit in
.beb5	36 29		rol $29,x			rol DStack+5,x
.beb7	e8		inx				inx			; drop divisor
.beb8	e8		inx				inx
.beb9	4c ee df	jmp $dfee			jmp Swap
.bebc	a9 f6		lda #$f6	_DivByZero:	lda #$100+err_DivideBy0
.bebe	4c 63 c4	jmp $c463			jmp ThrowA
=62					CodeLen	.var *-XtPtr1
=$bec1					Here1 = *	; remember here
>be81	3e					.byte CodeLen	;patch wh_CodeLength
.bec1	4c 2a c4	jmp $c42a	Throw_Stack_15: jmp Throw_Stack
>bec4	53 4d 2f 52 65 6d		Name0:	.text "SM/Rem"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=48714					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>beca	a6					.byte (("SM/Rem"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=75					LinkDisplacement = Nt0-WordListLink
>becb	10					.byte WordFlags	;wh_Flags
>becc	03					.byte 3	;wh_CodeLength
>becd	4b					  .byte LinkDisplacement	; offset to previous nt
=$bece					XtPtr1 ::= *
=48714					WordListLink ::= Nt0 ; remember the nt of this word for later
.bece					SM_Slash_Rem:
.bece	e0 23		cpx #$23		cpx #(DDim-3)*2+1	; far enough below end of data stack (& not negative)?
.bed0	b0 ef		bcs $bec1		bcs Throw_Stack_15
.bed2	b5 27		lda $27,x			lda DStack+3,x
.bed4	08		php				php
.bed5	55 25		eor $25,x			eor DStack+1,x
.bed7	08		php				php
.bed8	20 fd d6	jsr $d6fd			jsr Abs
.bedb	e8		inx				inx		; pretend we pushed n1 to R
.bedc	e8		inx				inx
.bedd	20 30 d7	jsr $d730			jsr DAbs
.bee0	ca		dex				dex
.bee1	ca		dex				dex
.bee2	20 83 be	jsr $be83			jsr UM_Slash_Mod	; UM/MOD
.bee5	28		plp				plp
.bee6	10 03		bpl $beeb			bpl +
.bee8	20 e4 d6	jsr $d6e4			jsr Negate
.beeb					+
.beeb	28		plp				plp
.beec	10 07		bpl $bef5			bpl _done
.beee	e8		inx				inx		; pretend we pushed quotient to R
.beef	e8		inx				inx
.bef0	20 e4 d6	jsr $d6e4			jsr Negate
.bef3	ca		dex				dex
.bef4	ca		dex				dex
.bef5					_done:
=39					CodeLen	.var *-XtPtr1
=$bef5					Here1 = *	; remember here
>becc	27					.byte CodeLen	;patch wh_CodeLength
.bef5	60		rts				rts
>bef6	46 4d 2f 4d 6f 64		Name0:	.text "FM/Mod"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=48764					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>befc	86					.byte (("FM/Mod"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=50					LinkDisplacement = Nt0-WordListLink
>befd	10					.byte WordFlags	;wh_Flags
>befe	03					.byte 3	;wh_CodeLength
>beff	32					  .byte LinkDisplacement	; offset to previous nt
=$bf00					XtPtr1 ::= *
=48764					WordListLink ::= Nt0 ; remember the nt of this word for later
.bf00					FM_Slash_Mod:
.bf00	e0 23		cpx #$23		cpx #(DDim-3)*2+1	; far enough below end of data stack (& not negative)?
.bf02	b0 bd		bcs $bec1		bcs Throw_Stack_15
.bf04	b5 25		lda $25,x			lda DStack+1,x	; MSB of n1
.bf06	08		php				php		;  save sign
.bf07	10 0a		bpl $bf13			bpl +
.bf09	20 e4 d6	jsr $d6e4			jsr Negate	; NEGATE
.bf0c	e8		inx				inx
.bf0d	e8		inx				inx
.bf0e	20 14 d7	jsr $d714			jsr DNegate	; DNEGATE
.bf11	ca		dex				dex
.bf12	ca		dex				dex
.bf13					+
.bf13	b5 27		lda $27,x			lda DStack+3,x	; MSB of high word of d
.bf15	10 0d		bpl $bf24			bpl +
.bf17	18		clc				clc
.bf18	b5 24		lda $24,x			lda DStack+0,x	; LSB of n1
.bf1a	75 26		adc $26,x			adc DStack+2,x	; LSB of dh
.bf1c	95 26		sta $26,x			sta DStack+2,x
.bf1e	b5 25		lda $25,x			lda DStack+1,x	; MSB of n1
.bf20	75 27		adc $27,x			adc DStack+3,x	; MSB of dh
.bf22	95 27		sta $27,x			sta DStack+3,x
.bf24					+
.bf24	20 83 be	jsr $be83			jsr UM_Slash_Mod	; ( d n1 -- rem n2 )
.bf27	28		plp				plp
.bf28	10 07		bpl $bf31			bpl +
.bf2a	e8		inx				inx		; pretend that we SWAP
.bf2b	e8		inx				inx
.bf2c	20 e4 d6	jsr $d6e4			jsr Negate
.bf2f	ca		dex				dex
.bf30	ca		dex				dex
.bf31					+
=49					CodeLen	.var *-XtPtr1
=$bf31					Here1 = *	; remember here
>befe	31					.byte CodeLen	;patch wh_CodeLength
.bf31	60		rts				rts
>bf32	2f 4d 6f 64			Name0:	.text "/Mod"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=48822					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>bf36	84					.byte (("/Mod"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=58					LinkDisplacement = Nt0-WordListLink
>bf37	10					.byte WordFlags	;wh_Flags
>bf38	03					.byte 3	;wh_CodeLength
>bf39	3a					  .byte LinkDisplacement	; offset to previous nt
=$bf3a					XtPtr1 ::= *
=48822					WordListLink ::= Nt0 ; remember the nt of this word for later
.bf3a	20 cd df	jsr $dfcd	Slash_Mod:	jsr Dup			; ( n1 n_div n_div )
.bf3d	a0 00		ldy #$00			ldy #0			; sign extend n1
.bf3f	b5 29		lda $29,x			lda DStack+5,x
.bf41	10 01		bpl $bf44			bpl +
.bf43	88		dey				dey
.bf44	94 26		sty $26,x	+		sty DStack+2,x
.bf46	94 27		sty $27,x			sty DStack+3,x		; ( d1 n_div )
.bf48	4c ce be	jmp $bece			jmp SM_Slash_Rem	; SM/REM
=17					CodeLen	.var *-XtPtr1
=$bf4b					Here1 = *	; remember here
>bf38	11					.byte CodeLen	;patch wh_CodeLength
>bf4b	2f				Name0:	.text "/"	;  name of word as a string, ending at wh_NameLastChar
=1					NameLength = *-Name0
=48844					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>bf4c	e1					.byte (("/"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=22					LinkDisplacement = Nt0-WordListLink
>bf4d	10					.byte WordFlags	;wh_Flags
>bf4e	03					.byte 3	;wh_CodeLength
>bf4f	16					  .byte LinkDisplacement	; offset to previous nt
=$bf50					XtPtr1 ::= *
=48844					WordListLink ::= Nt0 ; remember the nt of this word for later
.bf50	20 3a bf	jsr $bf3a	Slash:		jsr Slash_Mod
.bf53	4c c8 d9	jmp $d9c8			jmp Nip		; Nip remainder
=6					CodeLen	.var *-XtPtr1
=$bf56					Here1 = *	; remember here
>bf4e	06					.byte CodeLen	;patch wh_CodeLength
>bf56	4d 6f 64			Name0:	.text "Mod"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=48857					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>bf59	83					.byte (("Mod"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=0					WordFlags ::= 0	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>bf5a	00					.byte WordFlags	;wh_Flags
>bf5b	03					.byte 3	;wh_CodeLength
>bf5c	0d					  .byte LinkDisplacement	; offset to previous nt
=$bf5d					XtPtr1 ::= *
=48857					WordListLink ::= Nt0 ; remember the nt of this word for later
.bf5d	20 3a bf	jsr $bf3a	Mod:		jsr Slash_Mod
.bf60	e8		inx				inx		; Drop quotient
.bf61	e8		inx				inx
=5					CodeLen	.var *-XtPtr1
=$bf62					Here1 = *	; remember here
>bf5b	05					.byte CodeLen	;patch wh_CodeLength
.bf62	60		rts				rts
>bf63	2a 2f 4d 6f 64			Name0:	.text "*/Mod"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=48872					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>bf68	85					.byte (("*/Mod"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=15					LinkDisplacement = Nt0-WordListLink
>bf69	10					.byte WordFlags	;wh_Flags
>bf6a	03					.byte 3	;wh_CodeLength
>bf6b	0f					  .byte LinkDisplacement	; offset to previous nt
=$bf6c					XtPtr1 ::= *
=48872					WordListLink ::= Nt0 ; remember the nt of this word for later
.bf6c					Star_Slash_Mod:
.bf6c	20 20 c4	jsr $c420			jsr underflow_3
.bf6f	20 3d df	jsr $df3d			jsr To_R
.bf72	20 52 be	jsr $be52			jsr M_Star
.bf75	20 5b df	jsr $df5b			jsr R_From
.bf78	4c ce be	jmp $bece			jmp SM_Slash_Rem
=15					CodeLen	.var *-XtPtr1
=$bf7b					Here1 = *	; remember here
>bf6a	0f					.byte CodeLen	;patch wh_CodeLength
>bf7b	2a 2f				Name0:	.text "*/"	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=48893					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>bf7d	e2					.byte (("*/"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=21					LinkDisplacement = Nt0-WordListLink
>bf7e	10					.byte WordFlags	;wh_Flags
>bf7f	03					.byte 3	;wh_CodeLength
>bf80	15					  .byte LinkDisplacement	; offset to previous nt
=$bf81					XtPtr1 ::= *
=48893					WordListLink ::= Nt0 ; remember the nt of this word for later
.bf81					Star_Slash:
.bf81	20 6c bf	jsr $bf6c			jsr Star_Slash_Mod
.bf84	4c c8 d9	jmp $d9c8			jmp Nip			; mod
=6					CodeLen	.var *-XtPtr1
=$bf87					Here1 = *	; remember here
>bf7f	06					.byte CodeLen	;patch wh_CodeLength
>bf87	4d 2a 2f			Name0:	.text "M*/"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=48906					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>bf8a	e3					.byte (("M*/"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>bf8b	10					.byte WordFlags	;wh_Flags
>bf8c	03					.byte 3	;wh_CodeLength
>bf8d	0d					  .byte LinkDisplacement	; offset to previous nt
=$bf8e					XtPtr1 ::= *
=48906					WordListLink ::= Nt0 ; remember the nt of this word for later
.bf8e					m_star_slash:
.bf8e	20 25 c4	jsr $c425	                jsr underflow_4
.bf91	b5 25		lda $25,x			lda DStack+1,x		; calc result sign
.bf93	55 27		eor $27,x			eor DStack+3,x
.bf95	55 29		eor $29,x			eor DStack+5,x
.bf97	08		php				php
.bf98	20 fd d6	jsr $d6fd	                jsr Abs			; Abs
.bf9b	20 3d df	jsr $df3d	                jsr To_R		; >R		( d1 n1 ) ( R: sign abs(n2) )
.bf9e	20 fd d6	jsr $d6fd	                jsr Abs			; Abs
.bfa1	20 3d df	jsr $df3d	                jsr To_R		; >R		( d1 ) ( R: sign abs(n2) abs(n1) )
.bfa4	20 30 d7	jsr $d730	                jsr DAbs		; DAbs		( abs(d1) ) ( R: sign abs(n2) abs(n1) )
.bfa7	20 ee df	jsr $dfee	                jsr Swap		; Swap
.bfaa	20 76 df	jsr $df76	                jsr R_Fetch		; R@
.bfad	20 04 be	jsr $be04	                jsr UM_Star		; UM*
.bfb0	20 ae de	jsr $deae	                jsr Rot			; Rot
.bfb3	20 5b df	jsr $df5b	                jsr R_From		; R>
.bfb6	20 04 be	jsr $be04	                jsr UM_Star		; UM*
.bfb9	20 ae de	jsr $deae	                jsr Rot			; Rot
.bfbc	20 b1 da	jsr $dab1	                jsr UMPlus		; 0 D+
.bfbf	20 76 df	jsr $df76	                jsr R_Fetch		; R@
.bfc2	20 83 be	jsr $be83	                jsr UM_Slash_Mod	; UM/Mod
.bfc5	20 d3 de	jsr $ded3	                jsr Not_Rot		; Rot Rot
.bfc8	20 5b df	jsr $df5b	                jsr R_From		; R>
.bfcb	20 83 be	jsr $be83	                jsr UM_Slash_Mod	; UM/Mod
.bfce	20 c8 d9	jsr $d9c8	                jsr Nip			; Swap Drop
.bfd1	20 ee df	jsr $dfee	                jsr Swap		; Swap
.bfd4	28		plp				plp
.bfd5	10 03		bpl $bfda			bpl _rts		; ... 0< if ...
.bfd7	4c 14 d7	jmp $d714	                jmp DNegate
.bfda	60		rts		_rts:		rts
=77					CodeLen	.var *-XtPtr1
=$bfdb					Here1 = *	; remember here
>bf8c	4d					.byte CodeLen	;patch wh_CodeLength
>bfdb	45 76 61 6c 75 61 74 65		Name0:	.text "Evaluate"	;  name of word as a string, ending at wh_NameLastChar
=8					NameLength = *-Name0
=48995					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>bfe3	a8					.byte (("Evaluate"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=89					LinkDisplacement = Nt0-WordListLink
>bfe4	10					.byte WordFlags	;wh_Flags
>bfe5	03					.byte 3	;wh_CodeLength
>bfe6	59					  .byte LinkDisplacement	; offset to previous nt
=$bfe7					XtPtr1 ::= *
=48995					WordListLink ::= Nt0 ; remember the nt of this word for later
.bfe7					Evaluate:
.bfe7	18		clc				clc			; signal to zero BLK.
.bfe8					load_evaluate:
.bfe8	ad 0d 03	lda $030d			lda BlkV+1	; Save the current value of BLK on the return stack.
.bfeb	48		pha				pha
.bfec	ad 0c 03	lda $030c			lda BlkV+0
.bfef	48		pha				pha
.bff0	b0 08		bcs $bffa			bcs +		; See if we should zero BLK.
.bff2	a9 00		lda #$00			lda #0		; Set BLK to zero.
.bff4	8d 0c 03	sta $030c			sta BlkV+0
.bff7	8d 0d 03	sta $030d			sta BlkV+1
.bffa					+
.bffa	20 11 d4	jsr $d411			jsr Input_To_R	; Save the input state to the Return Stack
.bffd	a9 ff		lda #$ff			lda #$ff	; SOURCE-ID= -1
.bfff	85 02		sta $02				sta insrc+0
.c001	85 03		sta $03				sta insrc+1
.c003	a9 00		lda #$00			lda #0		; >IN= zero
.c005	85 08		sta $08				sta toin+0
.c007	85 09		sta $09				sta toin+1
.c009	20 de c3	jsr $c3de			jsr PopYA	; ciblen= string length (u)
.c00c	85 06		sta $06				sta ciblen+0
.c00e	84 07		sty $07				sty ciblen+1
.c010	20 de c3	jsr $c3de			jsr PopYA	; cib= string addr
.c013	85 04		sta $04				sta cib+0
.c015	84 05		sty $05				sty cib+1
.c017	20 1b c5	jsr $c51b			jsr interpret	; ( -- )
.c01a	20 32 d4	jsr $d432			jsr R_To_Input	; restore input state
.c01d	68		pla				pla		; Restore BLK from the return stack.
.c01e	8d 0c 03	sta $030c			sta BlkV+0
.c021	68		pla				pla
.c022	8d 0d 03	sta $030d			sta BlkV+1
=62					CodeLen	.var *-XtPtr1
=$c025					Here1 = *	; remember here
>bfe5	3e					.byte CodeLen	;patch wh_CodeLength
.c025	60		rts				rts
.c026	4c 2a c4	jmp $c42a	Throw_Stack_11: jmp Throw_Stack
>c029	3e 4e 75 6d 62 65 72		Name0:	.text ">Number"	;  name of word as a string, ending at wh_NameLastChar
=7					NameLength = *-Name0
=49072					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>c030	47					.byte ((">Number"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=77					LinkDisplacement = Nt0-WordListLink
>c031	10					.byte WordFlags	;wh_Flags
>c032	03					.byte 3	;wh_CodeLength
>c033	4d					  .byte LinkDisplacement	; offset to previous nt
=$c034					XtPtr1 ::= *
=49072					WordListLink ::= Nt0 ; remember the nt of this word for later
.c034					To_Number:
.c034	e0 21		cpx #$21		cpx #(DDim-4)*2+1	; far enough below end of data stack (& not negative)?
.c036	b0 ee		bcs $c026		bcs Throw_Stack_11
.c038	b5 24		lda $24,x			lda DStack+0,x		; no chars left?
.c03a	f0 72		beq $c0ae			beq _done
.c03c					_Char_loop:
.c03c	a1 26		lda ($26,x)			lda (DStack+2,x)		; Get next character
.c03e	c9 30		cmp #$30			cmp #'0'		; convert to value (Digit_Question)
.c040	90 6c		bcc $c0ae			bcc _done
.c042	c9 3a		cmp #$3a			cmp #'9'+1
.c044	90 08		bcc $c04e			bcc _digit
.c046	29 df		and #$df			and #$df		;   ASCII uppercase
.c048	c9 41		cmp #$41			cmp #'A'
.c04a	90 62		bcc $c0ae			bcc _done
.c04c	e9 07		sbc #$07			sbc #7 ;'A'-'0'-10	;   to make 'A'=10 below
.c04e	38		sec		_digit:		sec
.c04f	e9 30		sbc #$30			sbc #'0'
.c051	cd 00 03	cmp $0300			cmp base		; must be < base
.c054	b0 58		bcs $c0ae			bcs _done
.c056	48		pha				pha			; Save char value
.c057	20 a0 d5	jsr $d5a0			jsr Two_Over		;   copy ud to work (multiplicand)
.c05a	a9 00		lda #$00			lda #0			;   zero ud (product)
.c05c	95 2c		sta $2c,x			sta DStack+8,x
.c05e	95 2d		sta $2d,x			sta DStack+9,x
.c060	95 2e		sta $2e,x			sta DStack+10,x
.c062	95 2f		sta $2f,x			sta DStack+11,x
.c064	ad 00 03	lda $0300			lda base		;   get multiplier
.c067	d0 23		bne $c08c			bne _Mul_Test
.c069	48		pha		_Mul_Add:	pha			;   save multiplier
.c06a	18		clc				clc			;   ud += work
.c06b	b5 26		lda $26,x			lda DStack+2,x
.c06d	75 2e		adc $2e,x			adc DStack+10,x
.c06f	95 2e		sta $2e,x			sta DStack+10,x
.c071	b5 27		lda $27,x			lda DStack+3,x
.c073	75 2f		adc $2f,x			adc DStack+11,x
.c075	95 2f		sta $2f,x			sta DStack+11,x
.c077	b5 24		lda $24,x			lda DStack+0,x
.c079	75 2c		adc $2c,x			adc DStack+8,x
.c07b	95 2c		sta $2c,x			sta DStack+8,x
.c07d	b5 25		lda $25,x			lda DStack+1,x
.c07f	75 2d		adc $2d,x			adc DStack+9,x
.c081	95 2d		sta $2d,x			sta DStack+9,x
.c083	68		pla				pla			;   restore multiplier
.c084	16 26		asl $26,x	_Mul_Shift:	asl DStack+2,x		;   work <<= 1
.c086	36 27		rol $27,x			rol DStack+3,x
.c088	36 24		rol $24,x			rol DStack+0,x
.c08a	36 25		rol $25,x			rol DStack+1,x
.c08c	4a		lsr a		_Mul_Test:	lsr a			;   shift multiplier
.c08d	b0 da		bcs $c069			bcs _Mul_Add
.c08f	d0 f3		bne $c084			bne _Mul_Shift
.c091	e8		inx				inx			;   2Drop work
.c092	e8		inx				inx
.c093	e8		inx				inx
.c094	e8		inx				inx
.c095	68		pla				pla			; recover value
.c096	18		clc				clc			; add to ud
.c097	75 2a		adc $2a,x			adc DStack+6,x
.c099	95 2a		sta $2a,x			sta DStack+6,x
.c09b	90 0a		bcc $c0a7			bcc +
.c09d	f6 2b		inc $2b,x			inc DStack+7,x
.c09f	d0 06		bne $c0a7			bne +
.c0a1	f6 28		inc $28,x			inc DStack+4,x
.c0a3	d0 02		bne $c0a7			bne +
.c0a5	f6 29		inc $29,x			inc DStack+5,x
.c0a7					+
.c0a7	20 a0 da	jsr $daa0			jsr NOS_One_Plus	; consume the char
.c0aa	d6 24		dec $24,x			dec DStack+0,x
.c0ac	d0 8e		bne $c03c			bne _Char_loop
.c0ae					_done:
=122					CodeLen	.var *-XtPtr1
=$c0ae					Here1 = *	; remember here
>c032	7a					.byte CodeLen	;patch wh_CodeLength
.c0ae	60		rts				rts
>c0af	4e 75 6d 62 65 72		Name0:	.text "Number"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=49205					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>c0b5	46					.byte (("Number"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=80					WordFlags ::= UF+NN	; modifiable copy, remember for later
=133					LinkDisplacement = Nt0-WordListLink
>c0b6	50					.byte WordFlags	;wh_Flags
>c0b7	03					.byte 3	;wh_CodeLength
>c0b8	85					  .byte LinkDisplacement	; offset to previous nt
=$c0b9					XtPtr1 ::= *
=49205					WordListLink ::= Nt0 ; remember the nt of this word for later
.c0b9					Number:
.c0b9	20 1b c4	jsr $c41b			jsr underflow_2
.c0bc	a9 00		lda #$00			lda #0
.c0be	85 1a		sta $1a				sta tmp4+0	; flag for double
.c0c0	85 1b		sta $1b				sta tmp4+1	; flag for minus
.c0c2	ad 00 03	lda $0300			lda base
.c0c5	48		pha				pha
.c0c6	20 f1 dc	jsr $dcf1			jsr Two_dup		; ( addr u addr u )
.c0c9	a1 26		lda ($26,x)			lda (DStack+2,x)	; get 1st char
.c0cb	20 8d c1	jsr $c18d			jsr _MinusCheck		; a minus sign?
.c0ce	a0 0a		ldy #$0a			ldy #10			; decimal?
.c0d0	c9 23		cmp #$23			cmp #'#'
.c0d2	f0 35		beq $c109			beq _base_changed
.c0d4	a0 10		ldy #$10			ldy #16			; hex?
.c0d6	c9 24		cmp #$24			cmp #'$'
.c0d8	f0 2f		beq $c109			beq _base_changed
.c0da	a0 02		ldy #$02			ldy #2			; binary?
.c0dc	c9 25		cmp #$25			cmp #'%'
.c0de	f0 29		beq $c109			beq _base_changed
.c0e0	c9 27		cmp #$27			cmp #$27		; ASCII for "'"
.c0e2	d0 2f		bne $c113			bne _check_dot
.c0e4	b5 24		lda $24,x			lda DStack+0,x	; length=3 ?
.c0e6	c9 03		cmp #$03			cmp #3
.c0e8	d0 1c		bne $c106			bne _not_a_char
.c0ea	b5 26		lda $26,x			lda DStack+2,x	; LSB of address
.c0ec	85 1c		sta $1c				sta tmp5
.c0ee	b5 27		lda $27,x			lda DStack+3,x
.c0f0	85 1d		sta $1d				sta tmp5+1
.c0f2	a0 02		ldy #$02			ldy #2
.c0f4	b1 1c		lda ($1c),y			lda (tmp5),y
.c0f6	c9 27		cmp #$27			cmp #$27	; ASCII for "'"
.c0f8	d0 0c		bne $c106			bne _not_a_char
.c0fa	88		dey				dey		; The char we want is between the single quotes.
.c0fb	b1 1c		lda ($1c),y			lda (tmp5),y
.c0fd	95 26		sta $26,x			sta DStack+2,x
.c0ff	a9 00		lda #$00			lda #0
.c101	95 27		sta $27,x			sta DStack+3,x
.c103	4c 62 c1	jmp $c162			jmp _drop_original_string ; Single flag will drop the TOS for us.
.c106					_not_a_char:
.c106	4c 3f c1	jmp $c13f			jmp _number_error
.c109					_base_changed:
.c109	8c 00 03	sty $0300			sty base	; Switch to the new base
.c10c	20 a0 da	jsr $daa0			jsr NOS_One_Plus ; start one character later
.c10f	d6 24		dec $24,x			dec DStack+0,x	; decrease string length by one
.c111	a1 26		lda ($26,x)			lda (DStack+2,x) ; Load the first char again
.c113					_check_dot:
.c113	20 8d c1	jsr $c18d			jsr _MinusCheck
.c116	b5 26		lda $26,x			lda DStack+2,x	; LSB of address
.c118	85 1c		sta $1c				sta tmp5
.c11a	b5 27		lda $27,x			lda DStack+3,x
.c11c	85 1d		sta $1d				sta tmp5+1
.c11e	b4 24		ldy $24,x			ldy DStack+0,x	; Y now points to the first character after the string,
.c120	88		dey				dey		; but we need the last character
.c121	b1 1c		lda ($1c),y			lda (tmp5),y
.c123	c9 2e		cmp #$2e			cmp #'.'
.c125	d0 04		bne $c12b			bne _main
.c127	c6 1a		dec $1a				dec tmp4	; Flag the fact
.c129	d6 24		dec $24,x			dec DStack+0,x	; reduce string length by one
.c12b					_main:
.c12b	20 f1 dc	jsr $dcf1			jsr Two_Dup
.c12e	a9 00		lda #$00			lda #0
.c130	95 28		sta $28,x			sta DStack+4,x	; clear ud
.c132	95 29		sta $29,x			sta DStack+5,x
.c134	95 2a		sta $2a,x			sta DStack+6,x
.c136	95 2b		sta $2b,x			sta DStack+7,x
.c138	20 34 c0	jsr $c034			jsr To_Number	; ( ud addr u -- ud addr u )
.c13b	b5 24		lda $24,x			lda DStack+0,x
.c13d	f0 1f		beq $c15e			beq _all_converted
.c13f					_number_error:
.c13f	20 6d d5	jsr $d56d			jsr Two_drop	; >NUMBER modified addr u
.c142	20 6d d5	jsr $d56d			jsr Two_drop	; ud   (partially converted number)
.c145	a9 3e		lda #$3e			lda #'>'	; print the unknown
.c147	20 1c de	jsr $de1c			jsr Emit_A	; word using the original addr u we saved at the beginning.
.c14a	20 34 de	jsr $de34			jsr Type
.c14d	a9 3c		lda #$3c			lda #'<'
.c14f	20 1c de	jsr $de1c			jsr Emit_A
.c152	20 28 de	jsr $de28			jsr Space
.c155	68		pla				pla		; restore base
.c156	8d 00 03	sta $0300			sta base
.c159	a9 f3		lda #$f3			lda #$100+err_UndefinedWord
.c15b	4c 63 c4	jmp $c463			jmp ThrowA
.c15e					_all_converted:
.c15e	e8		inx				inx		; Drop the current addr u
.c15f	e8		inx				inx
.c160	e8		inx				inx
.c161	e8		inx				inx
.c162					_drop_original_string:
.c162	20 e8 cf	jsr $cfe8			jsr TwoNip	 ; Drop the original addr u
.c165	a5 1a		lda $1a				lda tmp4	; flag for double
.c167	f0 10		beq $c179			beq _single
.c169	a9 20		lda #$20			lda #%00100000
.c16b	05 0c		ora $0c				ora status
.c16d	85 0c		sta $0c				sta status
.c16f	a5 1b		lda $1b				lda tmp4+1
.c171	f0 15		beq $c188			beq _done	; no minus, all done
.c173	20 14 d7	jsr $d714			jsr DNegate
.c176	4c 88 c1	jmp $c188			jmp _done
.c179					_single:
.c179	e8		inx				inx		; convert ud to u
.c17a	e8		inx				inx
.c17b	a9 df		lda #$df			lda #$ff-%00100000
.c17d	25 0c		and $0c				and status
.c17f	85 0c		sta $0c				sta status
.c181	a5 1b		lda $1b				lda tmp4+1
.c183	f0 03		beq $c188			beq _done	; no minus, all done
.c185	20 e4 d6	jsr $d6e4			jsr Negate
.c188					_done:
.c188	68		pla				pla
.c189	8d 00 03	sta $0300			sta base
=211					CodeLen	.var *-XtPtr1
=$c18c					Here1 = *	; remember here
>c0b7	d3					.byte CodeLen	;patch wh_CodeLength
.c18c	60		rts				rts
.c18d					_MinusCheck:
.c18d	c9 2d		cmp #$2d			cmp #'-'		; a minus sign?
.c18f	d0 09		bne $c19a			bne +
.c191	c6 1b		dec $1b				dec tmp4+1		; set flag
.c193	20 a0 da	jsr $daa0			jsr NOS_One_Plus	; start one character later
.c196	d6 24		dec $24,x			dec DStack+0,x		; decrease string length by one
.c198	a1 26		lda ($26,x)			lda (DStack+2,x)	; get next char
.c19a	60		rts		+		rts
>c19b	48 65 78			Name0:	.text "Hex"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=49438					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>c19e	03					.byte (("Hex"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=233					LinkDisplacement = Nt0-WordListLink
>c19f	10					.byte WordFlags	;wh_Flags
>c1a0	03					.byte 3	;wh_CodeLength
>c1a1	e9					  .byte LinkDisplacement	; offset to previous nt
=$c1a2					XtPtr1 ::= *
=49438					WordListLink ::= Nt0 ; remember the nt of this word for later
.c1a2	a9 10		lda #$10	Hex:		lda #16
.c1a4	d0 0d		bne $c1b3			bne Decimal_a
=4					CodeLen	.var *-XtPtr1
=$c1a6					Here1 = *	; remember here
>c1a0	04					.byte CodeLen	;patch wh_CodeLength
>c1a6	44 65 63 69 6d 61 6c		Name0:	.text "Decimal"	;  name of word as a string, ending at wh_NameLastChar
=7					NameLength = *-Name0
=49453					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>c1ad	87					.byte (("Decimal"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=0					WordFlags ::= 0	; modifiable copy, remember for later
=15					LinkDisplacement = Nt0-WordListLink
>c1ae	00					.byte WordFlags	;wh_Flags
>c1af	03					.byte 3	;wh_CodeLength
>c1b0	0f					  .byte LinkDisplacement	; offset to previous nt
=$c1b1					XtPtr1 ::= *
=49453					WordListLink ::= Nt0 ; remember the nt of this word for later
.c1b1	a9 0a		lda #$0a	Decimal:	lda #10
.c1b3	8d 00 03	sta $0300	Decimal_a:	sta base+0
.c1b6	a9 00		lda #$00			lda #0
.c1b8	8d 01 03	sta $0301			sta base+1		; paranoid
=10					CodeLen	.var *-XtPtr1
=$c1bb					Here1 = *	; remember here
>c1af	0a					.byte CodeLen	;patch wh_CodeLength
.c1bb	60		rts				rts
>c1bc	42 61 73 65			Name0:	.text "Base"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=49472					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>c1c0	a4					.byte (("Base"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=19					LinkDisplacement = Nt0-WordListLink
>c1c1	10					.byte WordFlags	;wh_Flags
>c1c2	03					.byte 3	;wh_CodeLength
>c1c3	13					  .byte LinkDisplacement	; offset to previous nt
=$c1c4					XtPtr1 ::= *
=49472					WordListLink ::= Nt0 ; remember the nt of this word for later
.c1c4	a0 03		ldy #$03			ldy #>base
.c1c6	a9 00		lda #$00			lda #<base
.c1c8	4c b5 c7	jmp $c7b5			jmp PushYA
=7					CodeLen	.var *-XtPtr1
=$c1cb					Here1 = *	; remember here
>c1c2	07					.byte CodeLen	;patch wh_CodeLength
.c1cb	4c 2a c4	jmp $c42a	Throw_Stack_10: jmp Throw_Stack
>c1ce	43 6f 75 6e 74			Name0:	.text "Count"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=49491					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>c1d3	85					.byte (("Count"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=19					LinkDisplacement = Nt0-WordListLink
>c1d4	10					.byte WordFlags	;wh_Flags
>c1d5	03					.byte 3	;wh_CodeLength
>c1d6	13					  .byte LinkDisplacement	; offset to previous nt
=$c1d7					XtPtr1 ::= *
=49491					WordListLink ::= Nt0 ; remember the nt of this word for later
.c1d7					Count:
.c1d7	e0 27		cpx #$27		cpx #(DDim-1)*2+1	; far enough below end of data stack (& not negative)?
.c1d9	b0 f0		bcs $c1cb		bcs Throw_Stack_10
.c1db	a1 24		lda ($24,x)			lda (DStack+0,x)	; A= number of characters
.c1dd	f6 24		inc $24,x			inc DStack+0,x		; move start address up by one
.c1df	d0 02		bne $c1e3			bne +
.c1e1	f6 25		inc $25,x			inc DStack+1,x
.c1e3					+
.c1e3	4c e4 c7	jmp $c7e4			jmp PushZA		; push number of characters, return
=15					CodeLen	.var *-XtPtr1
=$c1e6					Here1 = *	; remember here
>c1d5	0f					.byte CodeLen	;patch wh_CodeLength
>c1e6	3f 50 61 69 72 43 74 6c		Name0:	.text "?PairCtlA"	;  name of word as a string, ending at wh_NameLastChar
>c1ee	41
=9					NameLength = *-Name0
=49519					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>c1ef	29					.byte (("?PairCtlA"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=28					LinkDisplacement = Nt0-WordListLink
>c1f0	10					.byte WordFlags	;wh_Flags
>c1f1	03					.byte 3	;wh_CodeLength
>c1f2	1c					  .byte LinkDisplacement	; offset to previous nt
=$c1f3					XtPtr1 ::= *
=49519					WordListLink ::= Nt0 ; remember the nt of this word for later
.c1f3	d5 24		cmp $24,x	QPairCtlA:	cmp DStack+0,x
.c1f5	f0 05		beq $c1fc			beq _8
.c1f7	a9 ea		lda #$ea			lda #$100+err_ControlMismatch
.c1f9	4c 63 c4	jmp $c463			jmp ThrowA
.c1fc	e8		inx		_8:		inx
.c1fd	e8		inx				inx	; Drop n
.c1fe	60		rts				rts
=12					CodeLen	.var *-XtPtr1
=$c1ff					Here1 = *	; remember here
>c1f1	0c					.byte CodeLen	;patch wh_CodeLength
>0743					DoLeave  .word ?	; head of leave addr patch chain
>0745					DoStkIndex: .byte ?
>0746					DoIndexL: .fill DoStkDim
>074e					DoIndexH: .fill DoStkDim
>0756					DoFufaL:  .fill DoStkDim
>075e					DoFufaH:  .fill DoStkDim
>c1ff	3f 44 6f			Name0:	.text "?Do"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=49538					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>c202	e3					.byte (("?Do"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=28					WordFlags ::= CO+IM+NN	; modifiable copy, remember for later
=19					LinkDisplacement = Nt0-WordListLink
>c203	1c					.byte WordFlags	;wh_Flags
>c204	03					.byte 3	;wh_CodeLength
>c205	13					  .byte LinkDisplacement	; offset to previous nt
=$c206					XtPtr1 ::= *
=49538					WordListLink ::= Nt0 ; remember the nt of this word for later
.c206					Question_Do:
.c206	20 40 c3	jsr $c340			jsr Do_Leave_Init
.c209	a9 1d		lda #$1d			lda #<_runtime
.c20b	a0 c2		ldy #$c2			ldy #>_runtime
.c20d	20 73 dd	jsr $dd73			jsr Jsr_Comma_YA	; compile JSR _runtime
.c210	a9 d0		lda #$d0			lda #$d0		; compile BNE *+5
.c212	a0 03		ldy #$03			ldy #3
.c214	20 50 dd	jsr $dd50			jsr Comma_YA
.c217	20 23 c3	jsr $c323			jsr Leave		; compile JMP leave
.c21a	4c 3a c2	jmp $c23a			jmp Do_8		; finish
=23					CodeLen	.var *-XtPtr1
=$c21d					Here1 = *	; remember here
>c204	17					.byte CodeLen	;patch wh_CodeLength
.c21d					_runtime:
.c21d	20 42 c2	jsr $c242			jsr Do_Runtime	; start normally (we assume TOS!=NOS)
.c220	a5 12		lda $12				lda DoIndex+0	; Are TOS and NOS equal?
.c222	f0 01		beq $c225			beq _2
.c224	60		rts				rts		; return Z=0 to signal continue
.c225	a5 13		lda $13		_2:		lda DoIndex+1
.c227	c9 80		cmp #$80			cmp #$80
.c229	60		rts				rts		; return Z
>c22a	44 6f				Name0:	.text "Do"	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=49580					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>c22c	e2					.byte (("Do"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=28					WordFlags ::= CO+IM+NN	; modifiable copy, remember for later
=42					LinkDisplacement = Nt0-WordListLink
>c22d	1c					.byte WordFlags	;wh_Flags
>c22e	03					.byte 3	;wh_CodeLength
>c22f	2a					  .byte LinkDisplacement	; offset to previous nt
=$c230					XtPtr1 ::= *
=49580					WordListLink ::= Nt0 ; remember the nt of this word for later
.c230					Do:
.c230	20 40 c3	jsr $c340			jsr Do_Leave_Init
.c233	a9 42		lda #$42			lda #<Do_runtime
.c235	a0 c2		ldy #$c2			ldy #>Do_runtime
.c237	20 73 dd	jsr $dd73			jsr Jsr_Comma_YA	; compile JSR _runtime
.c23a	20 62 da	jsr $da62	Do_8:		jsr Here		; remember loop body start addr
.c23d	a9 30		lda #$30			lda #<Do		; identifier
.c23f	4c e4 c7	jmp $c7e4			jmp PushZA
=18					CodeLen	.var *-XtPtr1
=$c242					Here1 = *	; remember here
>c22e	12					.byte CodeLen	;patch wh_CodeLength
.c242					Do_Runtime:
.c242	ce 45 07	dec $0745			dec DoStkIndex		; alloc DO stack entry
.c245	ac 45 07	ldy $0745			ldy DoStkIndex
.c248	30 2d		bmi $c277			bmi _TooDeep
.c24a	a5 12		lda $12				lda DoIndex+0		; save previous DoIndex
.c24c	99 46 07	sta $0746,y			sta DoIndexL,y
.c24f	a5 13		lda $13				lda DoIndex+1
.c251	99 4e 07	sta $074e,y			sta DoIndexH,y
.c254	38		sec				sec			; fudge factor (FUFA)= $8000 - limit
.c255	a9 00		lda #$00			lda #0			;   the number that will trip the overflow flag
.c257	f5 26		sbc $26,x			sbc DStack+2,x
.c259	99 56 07	sta $0756,y			sta DoFuFaL,y
.c25c	a9 80		lda #$80			lda #$80
.c25e	f5 27		sbc $27,x			sbc DStack+3,x
.c260	99 5e 07	sta $075e,y			sta DoFuFaH,y
.c263	18		clc				clc			; index= FUFA plus original index
.c264	b5 24		lda $24,x			lda DStack+0,x
.c266	79 56 07	adc $0756,y			adc DoFuFaL,y
.c269	85 12		sta $12				sta DoIndex+0
.c26b	b5 25		lda $25,x			lda DStack+1,x
.c26d	79 5e 07	adc $075e,y			adc DoFuFaH,y
.c270	85 13		sta $13				sta DoIndex+1
.c272	e8		inx				inx			; Drop orig index
.c273	e8		inx				inx
.c274	e8		inx				inx			; Drop orig limit
.c275	e8		inx				inx
.c276	60		rts				rts			; return
.c277	a9 f9		lda #$f9	_TooDeep:	lda #$100+err_DoLoop_TooDeep
.c279	20 63 c4	jsr $c463			jsr ThrowA
>c27c	4c 6f 6f 70			Name0:	.text "Loop"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=49664					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>c280	04					.byte (("Loop"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=28					WordFlags ::= CO+IM+NN	; modifiable copy, remember for later
=84					LinkDisplacement = Nt0-WordListLink
>c281	1c					.byte WordFlags	;wh_Flags
>c282	03					.byte 3	;wh_CodeLength
>c283	54					  .byte LinkDisplacement	; offset to previous nt
=$c284					XtPtr1 ::= *
=49664					WordListLink ::= Nt0 ; remember the nt of this word for later
.c284					Loop:
.c284	a9 8a		lda #$8a			lda #<_Runtime
.c286	a0 c2		ldy #$c2			ldy #>_Runtime
.c288	d0 1b		bne $c2a5			bne Plus_Loop_5
=6					CodeLen	.var *-XtPtr1
=$c28a					Here1 = *	; remember here
>c282	06					.byte CodeLen	;patch wh_CodeLength
.c28a					_Runtime:
.c28a	e6 12		inc $12				inc DoIndex+0
.c28c	f0 02		beq $c290			beq _Runtime2
.c28e	b8		clv				clv			; return V=0 to signal loop back
.c28f	60		rts				rts
.c290	18		clc		_Runtime2:	clc
.c291	a5 13		lda $13				lda DoIndex+1		; handle carry from lo byte
.c293	69 01		adc #$01			adc #1
.c295	85 13		sta $13				sta DoIndex+1
.c297	60		rts				rts			; return V to signal loop back
>c298	2b 4c 6f 6f 70			Name0:	.text "+Loop"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=49693					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>c29d	05					.byte (("+Loop"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=28					WordFlags ::= CO+IM+NN	; modifiable copy, remember for later
=29					LinkDisplacement = Nt0-WordListLink
>c29e	1c					.byte WordFlags	;wh_Flags
>c29f	03					.byte 3	;wh_CodeLength
>c2a0	1d					  .byte LinkDisplacement	; offset to previous nt
=$c2a1					XtPtr1 ::= *
=49693					WordListLink ::= Nt0 ; remember the nt of this word for later
.c2a1					Plus_Loop:
.c2a1	a9 af		lda #$af			lda #<Plus_Loop_Runtime
.c2a3	a0 c2		ldy #$c2			ldy #>Plus_Loop_Runtime
.c2a5	20 c5 c2	jsr $c2c5	Plus_Loop_5:	jsr Loop_End		; compile JSR _runtime, BVC back
.c2a8	a9 09		lda #$09			lda #<Unloop ;(Unloop-wh_LinkNt-1)
.c2aa	a0 c3		ldy #$c3			ldy #>Unloop ;(Unloop-wh_LinkNt-1)
.c2ac	4c 73 dd	jmp $dd73			jmp Jsr_Comma_YA ;Compile_Comma_NT_YA ; compile Unloop, return
=14					CodeLen	.var *-XtPtr1
=$c2af					Here1 = *	; remember here
>c29f	0e					.byte CodeLen	;patch wh_CodeLength
.c2af					Plus_Loop_Runtime:
.c2af	e0 27		cpx #$27		cpx #(DDim-1)*2+1	; far enough below end of data stack (& not negative)?
.c2b1	b0 0f		bcs $c2c2		bcs Throw_Stack_12
.c2b3	b5 24		lda $24,x			lda DStack+0,x		; DoIndex += step
.c2b5	65 12		adc $12				adc DoIndex+0
.c2b7	85 12		sta $12				sta DoIndex+0
.c2b9	b5 25		lda $25,x			lda DStack+1,x
.c2bb	65 13		adc $13				adc DoIndex+1
.c2bd	85 13		sta $13				sta DoIndex+1
.c2bf	e8		inx				inx			; Drop step
.c2c0	e8		inx				inx
.c2c1	60		rts				rts			; return V=0 to signal loop back
.c2c2	4c 2a c4	jmp $c42a	Throw_Stack_12: jmp Throw_Stack
.c2c5					Loop_End:
.c2c5	20 73 dd	jsr $dd73			jsr Jsr_Comma_YA	; compile JSR runtime
.c2c8	a9 30		lda #$30			lda #<Do		; check id
.c2ca	20 f3 c1	jsr $c1f3	Loop_End_3:	jsr QPairCtlA
.c2cd	a9 50		lda #$50			lda #$50		; compile BVC body
.c2cf	20 f3 b6	jsr $b6f3			jsr Branch_CommaA
.c2d2	ac 43 07	ldy $0743			ldy DoLeave+0		; for each leave addr entry
.c2d5	ad 44 07	lda $0744			lda DoLeave+1
.c2d8	f0 1b		beq $c2f5			beq _p9
.c2da	84 14		sty $14		_p1:		sty tmp1+0		;   save entry pointer
.c2dc	85 15		sta $15				sta tmp1+1
.c2de	a0 01		ldy #$01			ldy #1			;   save link
.c2e0	b1 14		lda ($14),y			lda (tmp1),y
.c2e2	48		pha				pha
.c2e3	88		dey				dey
.c2e4	b1 14		lda ($14),y			lda (tmp1),y
.c2e6	48		pha				pha
.c2e7	a5 00		lda $00				lda cp+0		;   patch addr
.c2e9	91 14		sta ($14),y			sta (tmp1),y
.c2eb	a5 01		lda $01				lda cp+1
.c2ed	c8		iny				iny
.c2ee	91 14		sta ($14),y			sta (tmp1),y
.c2f0	68		pla				pla			;   get saved link
.c2f1	a8		tay				tay
.c2f2	68		pla				pla
.c2f3	d0 e5		bne $c2da			bne _p1
.c2f5					_p9:
.c2f5	20 de c3	jsr $c3de			jsr PopYA		; restore DoLeave
.c2f8	8d 43 07	sta $0743			sta DoLeave+0
.c2fb	8c 44 07	sty $0744			sty DoLeave+1
.c2fe	60		rts				rts
>c2ff	55 6e 6c 6f 6f 70		Name0:	.text "Unloop"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=49797					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>c305	06					.byte (("Unloop"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$04					WordFlags ::= CO	; modifiable copy, remember for later
=104					LinkDisplacement = Nt0-WordListLink
>c306	04					.byte WordFlags	;wh_Flags
>c307	03					.byte 3	;wh_CodeLength
>c308	68					  .byte LinkDisplacement	; offset to previous nt
=$c309					XtPtr1 ::= *
=49797					WordListLink ::= Nt0 ; remember the nt of this word for later
.c309					Unloop:
.c309	ac 45 07	ldy $0745			ldy DoStkIndex
.c30c	b9 46 07	lda $0746,y			lda DoIndexL,y	; restore Index
.c30f	85 12		sta $12				sta DoIndex+0
.c311	b9 4e 07	lda $074e,y			lda DoIndexH,y
.c314	85 13		sta $13				sta DoIndex+1
.c316	ee 45 07	inc $0745			inc DoStkIndex	; drop Do stack entry
=16					CodeLen	.var *-XtPtr1
=$c319					Here1 = *	; remember here
>c307	10					.byte CodeLen	;patch wh_CodeLength
.c319	60		rts				rts
>c31a	4c 65 61 76 65			Name0:	.text "Leave"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=49823					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>c31f	a5					.byte (("Leave"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=28					WordFlags ::= IM+NN+CO	; modifiable copy, remember for later
=26					LinkDisplacement = Nt0-WordListLink
>c320	1c					.byte WordFlags	;wh_Flags
>c321	03					.byte 3	;wh_CodeLength
>c322	1a					  .byte LinkDisplacement	; offset to previous nt
=$c323					XtPtr1 ::= *
=49823					WordListLink ::= Nt0 ; remember the nt of this word for later
.c323					Leave:
.c323	a9 4c		lda #$4c			lda #$4c	; JMP abs
.c325	20 39 dd	jsr $dd39			jsr C_Comma_A
.c328	a5 01		lda $01				lda cp+1	; save cp
.c32a	48		pha				pha
.c32b	a5 00		lda $00				lda cp+0
.c32d	48		pha				pha
.c32e	ad 43 07	lda $0743			lda DoLeave+0	; compile DoLeave link, patched later
.c331	ac 44 07	ldy $0744			ldy DoLeave+1
.c334	20 50 dd	jsr $dd50			jsr Comma_YA
.c337	68		pla				pla		; update DoLeave
.c338	8d 43 07	sta $0743			sta DoLeave+0
.c33b	68		pla				pla
.c33c	8d 44 07	sta $0744			sta DoLeave+1
=28					CodeLen	.var *-XtPtr1
=$c33f					Here1 = *	; remember here
>c321	1c					.byte CodeLen	;patch wh_CodeLength
.c33f	60		rts				rts
.c340					Do_Leave_Init:
.c340	ad 43 07	lda $0743			lda DoLeave+0
.c343	ac 44 07	ldy $0744			ldy DoLeave+1
.c346	20 b5 c7	jsr $c7b5			jsr PushYA	; save old leave head
.c349	a9 00		lda #$00			lda #0		; init
.c34b	8d 44 07	sta $0744			sta DoLeave+1
.c34e	60		rts				rts
>c34f	49				Name0:	.text "I"	;  name of word as a string, ending at wh_NameLastChar
=1					NameLength = *-Name0
=49872					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>c350	21					.byte (("I"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$04					WordFlags ::= CO	; modifiable copy, remember for later
=49					LinkDisplacement = Nt0-WordListLink
>c351	04					.byte WordFlags	;wh_Flags
>c352	03					.byte 3	;wh_CodeLength
>c353	31					  .byte LinkDisplacement	; offset to previous nt
=$c354					XtPtr1 ::= *
=49872					WordListLink ::= Nt0 ; remember the nt of this word for later
.c354	ac 45 07	ldy $0745	I:		ldy DoStkIndex
.c357	ca		dex				dex
.c358	ca		dex				dex
.c359	38		sec				sec		; n= fudged index - fudge factor (FUFA)
.c35a	a5 12		lda $12				lda DoIndex+0
.c35c	f9 56 07	sbc $0756,y			sbc DoFuFaL,y
.c35f	95 24		sta $24,x			sta DStack+0,x
.c361	a5 13		lda $13				lda DoIndex+1
.c363	f9 5e 07	sbc $075e,y			sbc DoFuFaH,y
.c366	95 25		sta $25,x			sta DStack+1,x
=20					CodeLen	.var *-XtPtr1
=$c368					Here1 = *	; remember here
>c352	14					.byte CodeLen	;patch wh_CodeLength
.c368	60		rts				rts
>c369	4a				Name0:	.text "J"	;  name of word as a string, ending at wh_NameLastChar
=1					NameLength = *-Name0
=49898					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>c36a	41					.byte (("J"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$04					WordFlags ::= CO	; modifiable copy, remember for later
=26					LinkDisplacement = Nt0-WordListLink
>c36b	04					.byte WordFlags	;wh_Flags
>c36c	03					.byte 3	;wh_CodeLength
>c36d	1a					  .byte LinkDisplacement	; offset to previous nt
=$c36e					XtPtr1 ::= *
=49898					WordListLink ::= Nt0 ; remember the nt of this word for later
.c36e	ac 45 07	ldy $0745	J:		ldy DoStkIndex
.c371	ca		dex				dex
.c372	ca		dex				dex
.c373	38		sec				sec		; n= 2nd fudged index - 2nd fudge factor (FUFA)
.c374	b9 46 07	lda $0746,y			lda DoIndexL+0,y	; LSB
.c377	f9 57 07	sbc $0757,y			sbc DoFufaL+1,y
.c37a	95 24		sta $24,x			sta DStack+0,x
.c37c	b9 4e 07	lda $074e,y			lda DoIndexH+0,y	; MSB
.c37f	f9 5f 07	sbc $075f,y			sbc DoFufaH+1,y
.c382	95 25		sta $25,x			sta DStack+1,x
=22					CodeLen	.var *-XtPtr1
=$c384					Here1 = *	; remember here
>c36c	16					.byte CodeLen	;patch wh_CodeLength
.c384	60		rts				rts
>c385	41 62 6f 72 74 22		Name0:	.text 'Abort"'	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=49931					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>c38b	46					.byte (('Abort"'[-1]&7)<<5)+NameLength	;wh_HashNameLen
=28					WordFlags ::= CO+IM+NN	; modifiable copy, remember for later
=33					LinkDisplacement = Nt0-WordListLink
>c38c	1c					.byte WordFlags	;wh_Flags
>c38d	03					.byte 3	;wh_CodeLength
>c38e	21					  .byte LinkDisplacement	; offset to previous nt
=$c38f					XtPtr1 ::= *
=49931					WordListLink ::= Nt0 ; remember the nt of this word for later
.c38f					Abort_Quote:
.c38f	20 0a c9	jsr $c90a			jsr S_Quote		; compile the string literal
.c392	a0 c3		ldy #$c3			ldy #>_runtime		; compile JSR runtime, return
.c394	a9 99		lda #$99			lda #<_runtime
.c396	4c 73 dd	jmp $dd73			jmp Jsr_Comma_YA
=10					CodeLen	.var *-XtPtr1
=$c399					Here1 = *	; remember here
>c38d	0a					.byte CodeLen	;patch wh_CodeLength
.c399					_runtime:
.c399	b5 28		lda $28,x			lda DStack+4,x
.c39b	15 29		ora $29,x			ora DStack+5,x
.c39d	d0 03		bne $c3a2			bne _do_abort	; true?
.c39f	4c 6d bd	jmp $bd6d			jmp ThreeDrop	; Drop three entries from the Data Stack
.c3a2					_do_abort:
.c3a2	20 34 de	jsr $de34			jsr Type	; print string
.c3a5	20 4c bb	jsr $bb4c			jsr CR		; We follow Gforth in going to a new line
.c3a8	a9 fe		lda #$fe			lda #$100+err_AbortQuote
.c3aa	4c 63 c4	jmp $c463			jmp ThrowA
>c3ad	41 62 6f 72 74			Name0:	.text "Abort"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=49970					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>c3b2	85					.byte (("Abort"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=39					LinkDisplacement = Nt0-WordListLink
>c3b3	10					.byte WordFlags	;wh_Flags
>c3b4	03					.byte 3	;wh_CodeLength
>c3b5	27					  .byte LinkDisplacement	; offset to previous nt
=$c3b6					XtPtr1 ::= *
=49970					WordListLink ::= Nt0 ; remember the nt of this word for later
.c3b6	a9 ff		lda #$ff	Abort:		lda #$100+err_Abort
.c3b8	4c 63 c4	jmp $c463			jmp ThrowA
=5					CodeLen	.var *-XtPtr1
=$c3bb					Here1 = *	; remember here
>c3b4	05					.byte CodeLen	;patch wh_CodeLength
>c3bb	50 6f 70 41			Name0:	.text "PopA"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=49983					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>c3bf	24					.byte (("PopA"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>c3c0	10					.byte WordFlags	;wh_Flags
>c3c1	03					.byte 3	;wh_CodeLength
>c3c2	0d					  .byte LinkDisplacement	; offset to previous nt
=$c3c3					XtPtr1 ::= *
=49983					WordListLink ::= Nt0 ; remember the nt of this word for later
.c3c3					PopA:
.c3c3	e0 27		cpx #$27		cpx #(DDim-1)*2+1	; far enough below end of data stack (& not negative)?
.c3c5	b0 63		bcs $c42a		bcs Throw_Stack
.c3c7	b5 24		lda $24,x			lda DStack+0,x		; pop TOS to A (1 byte)
.c3c9	e8		inx				inx
.c3ca	e8		inx				inx
=8					CodeLen	.var *-XtPtr1
=$c3cb					Here1 = *	; remember here
>c3c1	08					.byte CodeLen	;patch wh_CodeLength
.c3cb	60		rts		                rts
.c3cc					PopA2:
.c3cc	e0 25		cpx #$25		cpx #(DDim-2)*2+1	; far enough below end of data stack (& not negative)?
.c3ce	b0 5a		bcs $c42a		bcs Throw_Stack
.c3d0	b5 24		lda $24,x			lda DStack+0,x		; pop TOS to A (1 byte)
.c3d2	e8		inx				inx
.c3d3	e8		inx				inx
.c3d4	60		rts		                rts
>c3d5	50 6f 70 59 41			Name0:	.text "PopYA"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=50010					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>c3da	25					.byte (("PopYA"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=27					LinkDisplacement = Nt0-WordListLink
>c3db	10					.byte WordFlags	;wh_Flags
>c3dc	03					.byte 3	;wh_CodeLength
>c3dd	1b					  .byte LinkDisplacement	; offset to previous nt
=$c3de					XtPtr1 ::= *
=50010					WordListLink ::= Nt0 ; remember the nt of this word for later
.c3de					PopYA:
.c3de	e0 27		cpx #$27		cpx #(DDim-1)*2+1	; far enough below end of data stack (& not negative)?
.c3e0	b0 48		bcs $c42a		bcs Throw_Stack
.c3e2	b5 24		lda $24,x			lda DStack+0,x		; pop TOS to YA
.c3e4	b4 25		ldy $25,x			ldy DStack+1,x
.c3e6	e8		inx				inx
.c3e7	e8		inx				inx
=10					CodeLen	.var *-XtPtr1
=$c3e8					Here1 = *	; remember here
>c3dc	0a					.byte CodeLen	;patch wh_CodeLength
.c3e8	60		rts				rts
.c3e9					PopTmp1:
.c3e9	e0 27		cpx #$27		cpx #(DDim-1)*2+1	; far enough below end of data stack (& not negative)?
.c3eb	b0 3d		bcs $c42a		bcs Throw_Stack
.c3ed	b5 24		lda $24,x			lda DStack+0,x	; PopYA
.c3ef	b4 25		ldy $25,x			ldy DStack+1,x
.c3f1	e8		inx				inx
.c3f2	e8		inx				inx
.c3f3	85 14		sta $14				sta tmp1+0
.c3f5	84 15		sty $15				sty tmp1+1
.c3f7	60		rts				rts
>c3f8	75 6e 64 65 72 66 6c 6f		Name0:	.text "underflow_1"	;  name of word as a string, ending at wh_NameLastChar
>c400	77 5f 31
=11					NameLength = *-Name0
=50051					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>c403	2b					.byte (("underflow_1"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=41					LinkDisplacement = Nt0-WordListLink
>c404	10					.byte WordFlags	;wh_Flags
>c405	03					.byte 3	;wh_CodeLength
>c406	29					  .byte LinkDisplacement	; offset to previous nt
=$c407					XtPtr1 ::= *
=50051					WordListLink ::= Nt0 ; remember the nt of this word for later
.c407					underflow_1:
.c407	e0 27		cpx #$27		cpx #(DDim-1)*2+1	; far enough below end of data stack (& not negative)?
.c409	b0 1f		bcs $c42a		bcs Throw_Stack
=4					CodeLen	.var *-XtPtr1
=$c40b					Here1 = *	; remember here
>c405	04					.byte CodeLen	;patch wh_CodeLength
.c40b	60		rts				rts
>c40c	75 6e 64 65 72 66 6c 6f		Name0:	.text "underflow_2"	;  name of word as a string, ending at wh_NameLastChar
>c414	77 5f 32
=11					NameLength = *-Name0
=50071					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>c417	4b					.byte (("underflow_2"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=20					LinkDisplacement = Nt0-WordListLink
>c418	10					.byte WordFlags	;wh_Flags
>c419	03					.byte 3	;wh_CodeLength
>c41a	14					  .byte LinkDisplacement	; offset to previous nt
=$c41b					XtPtr1 ::= *
=50071					WordListLink ::= Nt0 ; remember the nt of this word for later
.c41b					underflow_2:
.c41b	e0 25		cpx #$25		cpx #(DDim-2)*2+1	; far enough below end of data stack (& not negative)?
.c41d	b0 0b		bcs $c42a		bcs Throw_Stack
=4					CodeLen	.var *-XtPtr1
=$c41f					Here1 = *	; remember here
>c419	04					.byte CodeLen	;patch wh_CodeLength
.c41f	60		rts		                rts
.c420					underflow_3:
.c420	e0 23		cpx #$23		cpx #(DDim-3)*2+1	; far enough below end of data stack (& not negative)?
.c422	b0 06		bcs $c42a		bcs Throw_Stack
.c424	60		rts		                rts
.c425					underflow_4:
.c425	e0 21		cpx #$21		cpx #(DDim-4)*2+1	; far enough below end of data stack (& not negative)?
.c427	b0 01		bcs $c42a		bcs Throw_Stack
.c429	60		rts		                rts
.c42a					Throw_Stack:
.c42a	30 04		bmi $c430			bmi _over
.c42c	a9 fc		lda #$fc			lda #$100+err_Stack_Underflow
.c42e	d0 33		bne $c463			bne ThrowA
.c430	a9 fd		lda #$fd	_over:		lda #$100+err_Stack_Overflow
.c432	d0 2f		bne $c463			bne ThrowA
.c434					Throw_FPStack:
.c434	30 04		bmi $c43a			bmi _over
.c436	a9 d3		lda #$d3			lda #$100+err_FPStackUnderflow
.c438	d0 29		bne $c463			bne ThrowA
.c43a	a9 d4		lda #$d4	_over:		lda #$100+err_FPStackOverflow
.c43c	d0 25		bne $c463			bne ThrowA
.c43e					Throw_FpOutOfRange:
.c43e	a9 d5		lda #$d5			lda #$100+err_FpOutOfRange
.c440	d0 21		bne $c463			bne ThrowA
>c442	3f 53 74 61 63 6b		Name0:	.text "?Stack"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=50120					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>c448	66					.byte (("?Stack"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=49					LinkDisplacement = Nt0-WordListLink
>c449	10					.byte WordFlags	;wh_Flags
>c44a	03					.byte 3	;wh_CodeLength
>c44b	31					  .byte LinkDisplacement	; offset to previous nt
=$c44c					XtPtr1 ::= *
=50120					WordListLink ::= Nt0 ; remember the nt of this word for later
.c44c					QStack:
.c44c	e0 29		cpx #$29		cpx #(DDim-0)*2+1	; far enough below end of data stack (& not negative)?
.c44e	b0 da		bcs $c42a		bcs Throw_Stack
.c450	a4 4c		ldy $4c				ldy FIndex		; check floating point stack
.c452	c0 0b		cpy #$0b			cpy #FDim+1
.c454	b0 de		bcs $c434			bcs Throw_FPStack
=10					CodeLen	.var *-XtPtr1
=$c456					Here1 = *	; remember here
>c44a	0a					.byte CodeLen	;patch wh_CodeLength
.c456	60		rts				rts			; all OK
>c457	54 68 72 6f 77			Name0:	.text "Throw"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=50140					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>c45c	e5					.byte (("Throw"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=20					LinkDisplacement = Nt0-WordListLink
>c45d	10					.byte WordFlags	;wh_Flags
>c45e	03					.byte 3	;wh_CodeLength
>c45f	14					  .byte LinkDisplacement	; offset to previous nt
=$c460					XtPtr1 ::= *
=50140					WordListLink ::= Nt0 ; remember the nt of this word for later
.c460	20 c3 c3	jsr $c3c3	Throw:		jsr PopA		; pop n
.c463	20 8e c4	jsr $c48e	ThrowA:		jsr Type_Exception_Text_A ; print the associated error string
.c466	a2 28		ldx #$28			ldx #DDim*2		; reset data stack (in case of underflow)
.c468					Abort_Core:
.c468	20 b8 c8	jsr $c8b8			jsr SLiteral_runtime
.c46b	4c 71 c4	jmp $c471			  jmp +
>c46e	3f 00 20					  .text "?",0," "	; signal an error to the simulator
.c471	20 34 de	jsr $de34	+		jsr Type
.c474	20 5b df	jsr $df5b			jsr R_From		; show return stack TOS
.c477	20 98 81	jsr $8198			jsr TypeSymbol
.c47a	20 76 df	jsr $df76			jsr R_Fetch		; show return stack NOS
.c47d	20 98 81	jsr $8198			jsr TypeSymbol
.c480	20 4c bb	jsr $bb4c			jsr CR
.c483					Abort_Core2:
.c483	a9 08		lda #$08			lda #DoStkDim		; init do stack
.c485	8d 45 07	sta $0745			sta DoStkIndex
.c488	20 d1 c4	jsr $c4d1			jsr Empty_Stack		; empty the Data Stack & FP stack
.c48b	4c e0 c4	jmp $c4e0			jmp Quit		; continue into QUIT.
.c48e					Type_Exception_Text_A:
.c48e	85 16		sta $16				sta tmp2+0	; save error code
.c490	a9 e2		lda #$e2			lda #<Exception_Text_List
.c492	a0 ea		ldy #$ea			ldy #>Exception_Text_List	; for each table entry
.c494	85 18		sta $18				sta tmp3+0
.c496	84 19		sty $19				sty tmp3+1
.c498	a0 00		ldy #$00	_TestEntry:	ldy #0		;   code match?
.c49a	b1 18		lda ($18),y			lda (tmp3),y
.c49c	f0 1a		beq $c4b8			beq _NotFound
.c49e	c5 16		cmp $16				cmp tmp2+0
.c4a0	f0 11		beq $c4b3			beq _Found
.c4a2	c8		iny		-		iny		;   step to end of entry
.c4a3	b1 18		lda ($18),y			lda (tmp3),y
.c4a5	d0 fb		bne $c4a2			bne -
.c4a7	98		tya				tya		;   step to next entry
.c4a8	38		sec				sec
.c4a9	65 18		adc $18				adc tmp3+0
.c4ab	85 18		sta $18				sta tmp3+0
.c4ad	90 e9		bcc $c498			bcc _TestEntry
.c4af	e6 19		inc $19				inc tmp3+1
.c4b1	d0 e5		bne $c498			bne _TestEntry
.c4b3					_Found:
.c4b3	a0 01		ldy #$01			ldy #1
.c4b5	4c 56 de	jmp $de56			jmp Print_ASCIIZ_tmp3_no_lf
.c4b8	a0 ff		ldy #$ff	_NotFound:	ldy #$ff		; print code
.c4ba	a5 16		lda $16				lda tmp2+0
.c4bc	20 b5 c7	jsr $c7b5			jsr PushYA
.c4bf	4c 1c dc	jmp $dc1c			jmp Dot
=98					CodeLen	.var *-XtPtr1
=$c4c2					Here1 = *	; remember here
>c45e	62					.byte CodeLen	;patch wh_CodeLength
>c4c2	45 6d 70 74 79 2d 53 74		Name0:	.text "Empty-Stack"	;  name of word as a string, ending at wh_NameLastChar
>c4ca	61 63 6b
=11					NameLength = *-Name0
=50253					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>c4cd	6b					.byte (("Empty-Stack"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=113					LinkDisplacement = Nt0-WordListLink
>c4ce	10					.byte WordFlags	;wh_Flags
>c4cf	03					.byte 3	;wh_CodeLength
>c4d0	71					  .byte LinkDisplacement	; offset to previous nt
=$c4d1					XtPtr1 ::= *
=50253					WordListLink ::= Nt0 ; remember the nt of this word for later
.c4d1	a2 28		ldx #$28	Empty_Stack:	ldx #DDim*2	; init data stack
.c4d3	a9 0a		lda #$0a			lda #FDim	; init FP stack
.c4d5	85 4c		sta $4c				sta FIndex
=6					CodeLen	.var *-XtPtr1
=$c4d7					Here1 = *	; remember here
>c4cf	06					.byte CodeLen	;patch wh_CodeLength
.c4d7	60		rts				rts
>c4d8	51 75 69 74			Name0:	.text "Quit"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=50268					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>c4dc	84					.byte (("Quit"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=15					LinkDisplacement = Nt0-WordListLink
>c4dd	10					.byte WordFlags	;wh_Flags
>c4de	03					.byte 3	;wh_CodeLength
>c4df	0f					  .byte LinkDisplacement	; offset to previous nt
=$c4e0					XtPtr1 ::= *
=50268					WordListLink ::= Nt0 ; remember the nt of this word for later
.c4e0					Quit:
.c4e0	8a		txa				txa		; Save the DStack index
.c4e1	a2 ff		ldx #$ff			ldx #rsp0	; Set the return stack ptr
.c4e3	9a		txs				txs
.c4e4	aa		tax				tax		; Restore the DStack index.
.c4e5	a9 00		lda #$00			lda #0		; SOURCE-ID= zero (keyboard input)
.c4e7	85 02		sta $02				sta insrc+0
.c4e9	85 03		sta $03				sta insrc+1
.c4eb	20 2e c7	jsr $c72e			jsr Left_Bracket_NoCheck ; switch to interpret state
.c4ee					_get_line:
.c4ee	a9 00		lda #$00			lda #<buffer0	; input buffer, this is paranoid
.c4f0	85 04		sta $04				sta cib+0
.c4f2	a9 02		lda #$02			lda #>buffer0
.c4f4	85 05		sta $05				sta cib+1
.c4f6	20 92 d2	jsr $d292			jsr Refill		; ( -- f )
.c4f9	b5 24		lda $24,x			lda DStack+0,x
.c4fb	d0 05		bne $c502			bne +
.c4fd	a9 6b		lda #$6b			lda #$100+err_Refill	; REFILL returned a FALSE flag, something went wrong
.c4ff	4c 63 c4	jmp $c463			jmp ThrowA
.c502	e8		inx		+		inx			; drop the flag
.c503	e8		inx				inx
.c504	20 1b c5	jsr $c51b			jsr interpret
.c507	a5 0a		lda $0a				lda state
.c509	d0 06		bne $c511			bne _print_compiled
.c50b	a9 ae		lda #$ae			lda #<str_ok
.c50d	a0 ea		ldy #$ea			ldy #>str_ok
.c50f	d0 04		bne $c515			bne _print
.c511	a9 b2		lda #$b2	_print_compiled: lda #<str_compiled	; "compile" string
.c513	a0 ea		ldy #$ea			ldy #>str_compiled
.c515	20 61 de	jsr $de61	_print:		jsr Print_ASCIIZ_YA
.c518	4c ee c4	jmp $c4ee			jmp _get_line
=59					CodeLen	.var *-XtPtr1
=$c51b					Here1 = *	; remember here
>c4de	3b					.byte CodeLen	;patch wh_CodeLength
.c51b					Interpret:
.c51b					_loop:
.c51b	20 4c c4	jsr $c44c			jsr QStack		; check stack bounds
.c51e	20 82 ca	jsr $ca82			jsr parse_name		; ( "string" -- addr u )
.c521	b5 24		lda $24,x	                lda DStack+0,x		; empty line?
.c523	f0 53		beq $c578	                beq _line_done
.c525	20 f1 dc	jsr $dcf1			jsr Two_dup		; ( addr u -- addr u addr u )
.c528	20 67 cc	jsr $cc67			jsr Find_Name		; ( addr u addr u -- addr u nt|0 )
.c52b	b5 25		lda $25,x			lda DStack+1,x		; word found?
.c52d	d0 1b		bne $c54a			bne _got_name_token
.c52f	e8		inx		                inx                     ; ( addr u 0 -- addr u )
.c530	e8		inx		                inx
.c531	20 b9 c0	jsr $c0b9	                jsr Number           ; ( addr u -- u|d )
.c534	a5 0a		lda $0a		                lda state		; interpreting?
.c536	f0 e3		beq $c51b	                beq _loop		;   we're done
.c538	a9 20		lda #$20	                lda #$20		; double cell number?
.c53a	24 0c		bit $0c		                bit status
.c53c	f0 06		beq $c544	                beq _single_number
.c53e	20 86 c7	jsr $c786			jsr Two_literal		; compile a double number
.c541	4c 1b c5	jmp $c51b			jmp _loop
.c544	20 52 c7	jsr $c752	_single_number:	jsr Literal		; compile a single number
.c547	4c 1b c5	jmp $c51b			jmp _loop
.c54a					_got_name_token:
.c54a	20 c8 d9	jsr $d9c8			jsr Nip
.c54d	20 c8 d9	jsr $d9c8			jsr Nip			; ( nt )
.c550	85 14		sta $14				sta tmp1+0		; save a work copy of nt
.c552	84 15		sty $15				sty tmp1+1
.c554	a0 81		ldy #$81			ldy #Wh_Flags		; get word flags, we'll need them shortly
.c556	b1 14		lda ($14),y			lda (tmp1),y		;    using saved nt
.c558	a4 0a		ldy $0a				ldy state		; interpreting or compiling?
.c55a	d0 12		bne $c56e			bne _compile
.c55c	29 04		and #$04			and #CO			; is the word COMPILE-ONLY?
.c55e	f0 05		beq $c565			beq _execute
.c560	a9 f2		lda #$f2			lda #$100+err_CompileOnly ;   complain & quit
.c562	20 63 c4	jsr $c463			jsr ThrowA
.c565	20 a9 cd	jsr $cda9	_execute:	jsr Name_To_Int		; ( nt -- xt )
.c568	20 72 de	jsr $de72			jsr Execute		; EXECUTE the xt that is TOS
.c56b	4c 1b c5	jmp $c51b	                jmp _loop
.c56e					_compile:
.c56e	29 08		and #$08			and #IM			; is the word IMMEDIATE?
.c570	d0 f3		bne $c565			bne _execute		;   IMMEDIATE word, execute now
.c572	20 9d c6	jsr $c69d			jsr Compile_Comma_NT	; Compile the nt into the Dictionary
.c575	4c 1b c5	jmp $c51b			jmp _loop
.c578					_line_done:
.c578	e8		inx				inx			; drop stuff from PARSE_NAME
.c579	e8		inx				inx
.c57a	e8		inx				inx
.c57b	e8		inx				inx
.c57c	60		rts				rts
>c57d	49 6d 6d 65 64 69 61 74		Name0:	.text "Immediate"	;  name of word as a string, ending at wh_NameLastChar
>c585	65
=9					NameLength = *-Name0
=50438					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>c586	a9					.byte (("Immediate"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=170					LinkDisplacement = Nt0-WordListLink
>c587	10					.byte WordFlags	;wh_Flags
>c588	03					.byte 3	;wh_CodeLength
>c589	aa					  .byte LinkDisplacement	; offset to previous nt
=$c58a					XtPtr1 ::= *
=50438					WordListLink ::= Nt0 ; remember the nt of this word for later
.c58a	a9 08		lda #$08	Immediate:	lda #IM
.c58c	48		pha		SetFlag:	pha
.c58d	20 54 ca	jsr $ca54			jsr current_to_dp
.c590	a0 81		ldy #$81			ldy #Wh_Flags
.c592	68		pla				pla
.c593	11 10		ora ($10),y			ora (dp),y
.c595	91 10		sta ($10),y			sta (dp),y
=13					CodeLen	.var *-XtPtr1
=$c597					Here1 = *	; remember here
>c588	0d					.byte CodeLen	;patch wh_CodeLength
.c597	60		rts				rts
>c598	43 6f 6d 70 69 6c 65 2d		Name0:	.text "Compile-only"	;  name of word as a string, ending at wh_NameLastChar
>c5a0	6f 6e 6c 79
=12					NameLength = *-Name0
=50468					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>c5a4	2c					.byte (("Compile-only"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=30					LinkDisplacement = Nt0-WordListLink
>c5a5	10					.byte WordFlags	;wh_Flags
>c5a6	03					.byte 3	;wh_CodeLength
>c5a7	1e					  .byte LinkDisplacement	; offset to previous nt
=$c5a8					XtPtr1 ::= *
=50468					WordListLink ::= Nt0 ; remember the nt of this word for later
.c5a8	a9 04		lda #$04	Compile_Only:	lda #CO
.c5aa	d0 e0		bne $c58c			bne SetFlag
=4					CodeLen	.var *-XtPtr1
=$c5ac					Here1 = *	; remember here
>c5a6	04					.byte CodeLen	;patch wh_CodeLength
>c5ac	6e 65 76 65 72 2d 6e 61		Name0:	.text "never-native"	;  name of word as a string, ending at wh_NameLastChar
>c5b4	74 69 76 65
=12					NameLength = *-Name0
=50488					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>c5b8	ac					.byte (("never-native"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=20					LinkDisplacement = Nt0-WordListLink
>c5b9	10					.byte WordFlags	;wh_Flags
>c5ba	03					.byte 3	;wh_CodeLength
>c5bb	14					  .byte LinkDisplacement	; offset to previous nt
=$c5bc					XtPtr1 ::= *
=50488					WordListLink ::= Nt0 ; remember the nt of this word for later
.c5bc	20 54 ca	jsr $ca54	Never_Native:	jsr current_to_dp
.c5bf	a0 81		ldy #$81			ldy #Wh_Flags
.c5c1	b1 10		lda ($10),y			lda (dp),y
.c5c3	09 10		ora #$10			ora #NN		; set NN flag
.c5c5	29 df		and #$df			and #$ff-AN	; clear AN flag
.c5c7	91 10		sta ($10),y			sta (dp),y
=13					CodeLen	.var *-XtPtr1
=$c5c9					Here1 = *	; remember here
>c5ba	0d					.byte CodeLen	;patch wh_CodeLength
.c5c9	60		rts				rts
>c5ca	61 6c 77 61 79 73 2d 6e		Name0:	.text "always-native"	;  name of word as a string, ending at wh_NameLastChar
>c5d2	61 74 69 76 65
=13					NameLength = *-Name0
=50519					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>c5d7	ad					.byte (("always-native"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=31					LinkDisplacement = Nt0-WordListLink
>c5d8	10					.byte WordFlags	;wh_Flags
>c5d9	03					.byte 3	;wh_CodeLength
>c5da	1f					  .byte LinkDisplacement	; offset to previous nt
=$c5db					XtPtr1 ::= *
=50519					WordListLink ::= Nt0 ; remember the nt of this word for later
.c5db	20 54 ca	jsr $ca54	Always_Native:	jsr current_to_dp
.c5de	a0 81		ldy #$81			ldy #Wh_Flags
.c5e0	b1 10		lda ($10),y			lda (dp),y
.c5e2	09 20		ora #$20			ora #AN		; Make sure AN flag is set
.c5e4	29 ef		and #$ef			and #$ff-NN	; and NN flag is clear.
.c5e6	91 10		sta ($10),y			sta (dp),y
=13					CodeLen	.var *-XtPtr1
=$c5e8					Here1 = *	; remember here
>c5d9	0d					.byte CodeLen	;patch wh_CodeLength
.c5e8	60		rts				rts
>c5e9	61 6c 6c 6f 77 2d 6e 61		Name0:	.text "allow-native"	;  name of word as a string, ending at wh_NameLastChar
>c5f1	74 69 76 65
=12					NameLength = *-Name0
=50549					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>c5f5	ac					.byte (("allow-native"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=30					LinkDisplacement = Nt0-WordListLink
>c5f6	10					.byte WordFlags	;wh_Flags
>c5f7	03					.byte 3	;wh_CodeLength
>c5f8	1e					  .byte LinkDisplacement	; offset to previous nt
=$c5f9					XtPtr1 ::= *
=50549					WordListLink ::= Nt0 ; remember the nt of this word for later
.c5f9	20 54 ca	jsr $ca54	Allow_Native:	jsr current_to_dp
.c5fc	a0 81		ldy #$81			ldy #Wh_Flags	; offset for status byte
.c5fe	b1 10		lda ($10),y			lda (dp),y
.c600	29 cf		and #$cf			and #$ff-NN-AN	; AN and NN flag is clear.
.c602	91 10		sta ($10),y			sta (dp),y
=11					CodeLen	.var *-XtPtr1
=$c604					Here1 = *	; remember here
>c5f7	0b					.byte CodeLen	;patch wh_CodeLength
.c604	60		rts				rts
>c605	6e 63 2d 6c 69 6d 69 74		Name0:	.text "nc-limit"	;  name of word as a string, ending at wh_NameLastChar
=8					NameLength = *-Name0
=50573					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>c60d	88					.byte (("nc-limit"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=24					LinkDisplacement = Nt0-WordListLink
>c60e	10					.byte WordFlags	;wh_Flags
>c60f	03					.byte 3	;wh_CodeLength
>c610	18					  .byte LinkDisplacement	; offset to previous nt
=$c611					XtPtr1 ::= *
=50573					WordListLink ::= Nt0 ; remember the nt of this word for later
.c611	a0 03		ldy #$03			ldy #>nc_limit
.c613	a9 02		lda #$02			lda #<nc_limit
.c615	4c b5 c7	jmp $c7b5			jmp PushYA
=7					CodeLen	.var *-XtPtr1
=$c618					Here1 = *	; remember here
>c60f	07					.byte CodeLen	;patch wh_CodeLength
>c618	73 74 72 69 70 2d 75 6e		Name0:	.text "strip-underflow"	;  name of word as a string, ending at wh_NameLastChar
>c620	64 65 72 66 6c 6f 77
=15					NameLength = *-Name0
=50599					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>c627	ef					.byte (("strip-underflow"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=26					LinkDisplacement = Nt0-WordListLink
>c628	10					.byte WordFlags	;wh_Flags
>c629	03					.byte 3	;wh_CodeLength
>c62a	1a					  .byte LinkDisplacement	; offset to previous nt
=$c62b					XtPtr1 ::= *
=50599					WordListLink ::= Nt0 ; remember the nt of this word for later
.c62b	a0 03		ldy #$03			ldy #>uf_strip
.c62d	a9 04		lda #$04			lda #<uf_strip
.c62f	4c b5 c7	jmp $c7b5			jmp PushYA
=7					CodeLen	.var *-XtPtr1
=$c632					Here1 = *	; remember here
>c629	07					.byte CodeLen	;patch wh_CodeLength
>c632	70 6f 73 74 70 6f 6e 65		Name0:	.text "postpone"	;  name of word as a string, ending at wh_NameLastChar
=8					NameLength = *-Name0
=50618					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>c63a	a8					.byte (("postpone"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=28					WordFlags ::= IM+CO+NN	; modifiable copy, remember for later
=19					LinkDisplacement = Nt0-WordListLink
>c63b	1c					.byte WordFlags	;wh_Flags
>c63c	03					.byte 3	;wh_CodeLength
>c63d	13					  .byte LinkDisplacement	; offset to previous nt
=$c63e					XtPtr1 ::= *
=50618					WordListLink ::= Nt0 ; remember the nt of this word for later
.c63e					Postpone:
.c63e	20 b3 ca	jsr $cab3			jsr parse_name_check	; get name string
.c641	20 95 cc	jsr $cc95			jsr find_name_check	; lookup name
.c644	a0 81		ldy #$81			ldy #Wh_Flags		; IMMEDIATE word?
.c646	b1 14		lda ($14),y			lda (tmp1),y		;    using saved nt
.c648	29 08		and #$08			and #IM
.c64a	f0 03		beq $c64f			beq _not_immediate
.c64c	4c 9d c6	jmp $c69d			jmp Compile_Comma_NT	; compile it as if it was not IMMEDIATE
.c64f					_not_immediate:
.c64f	20 9c c7	jsr $c79c			jsr LDYA_Immed_Comma		; compile LDA #; LDY # with nt of the word
.c652	a0 c6		ldy #$c6			ldy #>Compile_Comma_NT_YA	; compile COMPILE,
.c654	a9 a0		lda #$a0			lda #<Compile_Comma_NT_YA
.c656	4c 73 dd	jmp $dd73			jmp Jsr_Comma_YA
=27					CodeLen	.var *-XtPtr1
=$c659					Here1 = *	; remember here
>c63c	1b					.byte CodeLen	;patch wh_CodeLength
>c659	52 65 63 75 72 73 65		Name0:	.text "Recurse"	;  name of word as a string, ending at wh_NameLastChar
=7					NameLength = *-Name0
=50656					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>c660	a7					.byte (("Recurse"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=28					WordFlags ::= CO+IM+NN	; modifiable copy, remember for later
=38					LinkDisplacement = Nt0-WordListLink
>c661	1c					.byte WordFlags	;wh_Flags
>c662	03					.byte 3	;wh_CodeLength
>c663	26					  .byte LinkDisplacement	; offset to previous nt
=$c664					XtPtr1 ::= *
=50656					WordListLink ::= Nt0 ; remember the nt of this word for later
.c664					Recurse:
.c664	a5 0e		lda $0e				lda WorkWord+0
.c666	a4 0f		ldy $0f				ldy WorkWord+1
.c668	20 b5 c7	jsr $c7b5			jsr PushYA
.c66b	24 0c		bit $0c				bit status		; does WorkWord contain xt or nt?
.c66d	50 10		bvc $c67f			bvc _xt
.c66f	a0 81		ldy #$81			ldy #wh_Flags		; is it Always-Native ?
.c671	b1 0e		lda ($0e),y			lda (WorkWord),y
.c673	29 20		and #$20			and #AN
.c675	f0 05		beq $c67c			beq _NotAn
.c677	a9 e5		lda #$e5			lda #$100+err_InvalidRecursion
.c679	20 63 c4	jsr $c463			jsr ThrowA
.c67c					_NotAN:
.c67c	20 a9 cd	jsr $cda9			jsr Name_To_Int		; convert nt to xt
.c67f					_xt:
.c67f	4c 70 dd	jmp $dd70			jmp Jsr_Comma		; compile JSR xt, return
=30					CodeLen	.var *-XtPtr1
=$c682					Here1 = *	; remember here
>c662	1e					.byte CodeLen	;patch wh_CodeLength
>c682	43 6f 6d 70 69 6c 65 2c		Name0:	.text "Compile,"	;  name of word as a string, ending at wh_NameLastChar
=8					NameLength = *-Name0
=50698					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>c68a	88					.byte (("Compile,"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=42					LinkDisplacement = Nt0-WordListLink
>c68b	10					.byte WordFlags	;wh_Flags
>c68c	03					.byte 3	;wh_CodeLength
>c68d	2a					  .byte LinkDisplacement	; offset to previous nt
=$c68e					XtPtr1 ::= *
=50698					WordListLink ::= Nt0 ; remember the nt of this word for later
.c68e					Compile_Comma:
.c68e	20 cd df	jsr $dfcd			jsr Dup			; ( xt xt )
.c691	20 58 cd	jsr $cd58			jsr Int_To_Name		; ( xt nt )	does a dictionary search, tmp1=nt
.c694	e8		inx				inx			; drop nt
.c695	e8		inx				inx
.c696	a5 15		lda $15				lda tmp1+1
.c698	d0 0a		bne $c6a4			bne Compile_Comma_NT_Tmp1
.c69a	4c 70 dd	jmp $dd70			jmp Jsr_Comma		; compile jsr, return
.c69d					Compile_Comma_NT:
.c69d	20 de c3	jsr $c3de			jsr PopYA
.c6a0					Compile_Comma_NT_YA:
.c6a0	85 14		sta $14				sta tmp1+0		; tmp1= nt
.c6a2	84 15		sty $15				sty tmp1+1
.c6a4					Compile_Comma_NT_Tmp1:
.c6a4	20 b6 cd	jsr $cdb6			jsr NameToIntTmp	; tmp2= xt
.c6a7	a5 16		lda $16				lda tmp2+0
.c6a9	a4 17		ldy $17				ldy tmp2+1
.c6ab	20 b5 c7	jsr $c7b5			jsr PushYA		; ( xt )
.c6ae	a0 82		ldy #$82			ldy #wh_CodeLength
.c6b0	b1 14		lda ($14),y			lda (tmp1),y
.c6b2	20 e4 c7	jsr $c7e4			jsr PushZA		; ( xt u )
.c6b5	a0 81		ldy #$81			ldy #Wh_Flags		; save word flags
.c6b7	b1 14		lda ($14),y			lda (tmp1),y
.c6b9	29 30		and #$30			and #ST
.c6bb	c9 30		cmp #$30			cmp #ST			; inline & strip RTS addr save/restore?
.c6bd	f0 2d		beq $c6ec			beq _strip
.c6bf	c9 10		cmp #$10			cmp #NN			; Never Native word?
.c6c1	f0 12		beq $c6d5			beq _jsr_opt
.c6c3	c9 20		cmp #$20			cmp #AN			; Always Native word?
.c6c5	f0 2f		beq $c6f6			beq _inline
.c6c7	ad 03 03	lda $0303			lda nc_limit+1		; wordsize<=nc_limit?
.c6ca	d0 2a		bne $c6f6			bne _inline
.c6cc	ad 02 03	lda $0302			lda nc_limit+0
.c6cf	d5 24		cmp $24,x			cmp DStack+0,x
.c6d1	f0 02		beq $c6d5			beq _jsr_opt
.c6d3	b0 21		bcs $c6f6			bcs _inline
.c6d5					_jsr_opt:
.c6d5	ad 04 03	lda $0304			lda uf_strip
.c6d8	f0 0d		beq $c6e7			beq _jsr
.c6da	a0 81		ldy #$81			ldy #wh_Flags		; underflow strip & not stack strip?
.c6dc	b1 14		lda ($14),y			lda (tmp1),y
.c6de	29 40		and #$40			and #UF
.c6e0	f0 05		beq $c6e7			beq _jsr
.c6e2	a9 03		lda #$03			lda #3			;   strip the underflow check
.c6e4	20 50 da	jsr $da50			jsr Nos_Plus_A
.c6e7					_jsr:
.c6e7	e8		inx				inx			; Drop len
.c6e8	e8		inx				inx
.c6e9	4c 70 dd	jmp $dd70			jmp Jsr_Comma		; compile jsr, return
.c6ec					_strip:
.c6ec	a9 06		lda #$06			lda #6			;   Adjust xt: skip over the leading RTS addr save
.c6ee	20 50 da	jsr $da50			jsr Nos_Plus_A
.c6f1	a9 f4		lda #$f4			lda #$100-12		;   Adjust u: omit the leading RTS addr save & trailing RTS addr restore
.c6f3	20 85 da	jsr $da85			jsr minus_a
.c6f6					_inline:
.c6f6	ad 04 03	lda $0304			lda uf_strip+0		; user wants underflow stripping?
.c6f9	f0 12		beq $c70d			beq +
.c6fb	a0 81		ldy #$81			ldy #wh_Flags		; this word contains underflow checking?
.c6fd	b1 14		lda ($14),y			lda (tmp1),y
.c6ff	29 40		and #$40			and #UF
.c701	f0 0a		beq $c70d			beq +
.c703	a9 03		lda #$03			lda #3			;   Adjust xt: Start after underflow check
.c705	20 50 da	jsr $da50			jsr Nos_Plus_A
.c708	a9 fd		lda #$fd			lda #$100-3		;   Adjust u: omit underflow check
.c70a	20 85 da	jsr $da85			jsr minus_a
.c70d					+
.c70d	b5 24		lda $24,x			lda DStack+0,x		; compile code bytes
.c70f	f0 0c		beq $c71d			beq _copy_end
.c711	a1 26		lda ($26,x)	_copy_loop:	lda (DStack+2,x)
.c713	20 39 dd	jsr $dd39			jsr C_Comma_A
.c716	20 a0 da	jsr $daa0			jsr NOS_One_Plus
.c719	d6 24		dec $24,x			dec DStack+0,x
.c71b	d0 f4		bne $c711			bne _copy_loop
.c71d					_copy_end:
.c71d	4c 6d d5	jmp $d56d			jmp Two_drop
=146					CodeLen	.var *-XtPtr1
=$c720					Here1 = *	; remember here
>c68c	92					.byte CodeLen	;patch wh_CodeLength
>c720	5b				Name0:	.text "["	;  name of word as a string, ending at wh_NameLastChar
=1					NameLength = *-Name0
=50849					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>c721	61					.byte (("["[-1]&7)<<5)+NameLength	;wh_HashNameLen
=28					WordFlags ::= IM+CO+NN	; modifiable copy, remember for later
=151					LinkDisplacement = Nt0-WordListLink
>c722	1c					.byte WordFlags	;wh_Flags
>c723	03					.byte 3	;wh_CodeLength
>c724	97					  .byte LinkDisplacement	; offset to previous nt
=$c725					XtPtr1 ::= *
=50849					WordListLink ::= Nt0 ; remember the nt of this word for later
.c725	a5 0a		lda $0a		Left_Bracket:	lda state+0		; Already in the interpret state?
.c727	d0 05		bne $c72e			bne Left_Bracket_NoCheck
.c729	a9 69		lda #$69			lda #$100+err_AlreadyInterpreting
.c72b	4c 63 c4	jmp $c463			jmp ThrowA
.c72e					Left_Bracket_NoCheck:
.c72e	a9 00		lda #$00			lda #0
.c730	85 0a		sta $0a		Left_Bracket_3:	sta state+0
.c732	85 0b		sta $0b				sta state+1
=15					CodeLen	.var *-XtPtr1
=$c734					Here1 = *	; remember here
>c723	0f					.byte CodeLen	;patch wh_CodeLength
.c734	60		rts				rts
>c735	5d				Name0:	.text "]"	;  name of word as a string, ending at wh_NameLastChar
=1					NameLength = *-Name0
=50870					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>c736	a1					.byte (("]"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=24					WordFlags ::= IM+NN	; modifiable copy, remember for later
=21					LinkDisplacement = Nt0-WordListLink
>c737	18					.byte WordFlags	;wh_Flags
>c738	03					.byte 3	;wh_CodeLength
>c739	15					  .byte LinkDisplacement	; offset to previous nt
=$c73a					XtPtr1 ::= *
=50870					WordListLink ::= Nt0 ; remember the nt of this word for later
.c73a					Right_Bracket:
.c73a	a5 0a		lda $0a				lda state+0		; Already in the compile state?
.c73c	f0 05		beq $c743			beq +
.c73e	a9 68		lda #$68			lda #$100+err_AlreadyCompiling ;   complain and quit
.c740	4c 63 c4	jmp $c463			jmp ThrowA
.c743					+
.c743	a9 ff		lda #$ff			lda #$FF
.c745	d0 e9		bne $c730			bne Left_Bracket_3
=13					CodeLen	.var *-XtPtr1
=$c747					Here1 = *	; remember here
>c738	0d					.byte CodeLen	;patch wh_CodeLength
>c747	4c 69 74 65 72 61 6c		Name0:	.text "Literal"	;  name of word as a string, ending at wh_NameLastChar
=7					NameLength = *-Name0
=50894					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>c74e	87					.byte (("Literal"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=28					WordFlags ::= IM+CO+NN	; modifiable copy, remember for later
=24					LinkDisplacement = Nt0-WordListLink
>c74f	1c					.byte WordFlags	;wh_Flags
>c750	03					.byte 3	;wh_CodeLength
>c751	18					  .byte LinkDisplacement	; offset to previous nt
=$c752					XtPtr1 ::= *
=50894					WordListLink ::= Nt0 ; remember the nt of this word for later
.c752					Literal:
.c752	20 07 c4	jsr $c407			jsr underflow_1
.c755	20 5b c7	jsr $c75b			jsr LitCompile		; compile load regs, choose a runtime routine
.c758	4c a0 c6	jmp $c6a0			jmp Compile_Comma_NT_YA ; compile JSR runtime
=9					CodeLen	.var *-XtPtr1
=$c75b					Here1 = *	; remember here
>c750	09					.byte CodeLen	;patch wh_CodeLength
.c75b					LitCompile:
.c75b	b5 25		lda $25,x			lda DStack+1,x		; hi byte zero?
.c75d	f0 08		beq $c767			beq _ZByte
.c75f	20 9c c7	jsr $c79c			jsr ldya_immed_comma	; compile "ldy #; lda #" using TOS
.c762	a9 31		lda #$31			lda #<(PushYA-wh_LinkNt-1) ; prepare for Compile_Comma_NT_YA or Jmp_Comma_NT_YA
.c764	a0 c7		ldy #$c7			ldy #>(PushYA-wh_LinkNt-1)
.c766	60		rts				rts
.c767					_ZByte:
.c767	b4 24		ldy $24,x			ldy DStack+0,x		; is it 0 ?
.c769	f0 08		beq $c773			beq _zero
.c76b	20 a3 c7	jsr $c7a3			jsr lda_immed_comma	; compile "lda #" using TOS
.c76e	a9 60		lda #$60			lda #<(PushZA-wh_LinkNt-1) ; prepare for Jsr_Comma_YA or Jmp_Comma_YA
.c770	a0 c7		ldy #$c7			ldy #>(PushZA-wh_LinkNt-1)
.c772	60		rts				rts
.c773	e8		inx		_zero:		inx			; drop
.c774	e8		inx				inx
.c775	a9 6e		lda #$6e			lda #<(Zero-wh_LinkNt-1)	; prepare for Jsr_Comma_YA or Jmp_Comma_YA
.c777	a0 c7		ldy #$c7			ldy #>(Zero-wh_LinkNt-1)
.c779	60		rts				rts
>c77a	32 4c 69 74 65 72 61 6c		Name0:	.text "2Literal"	;  name of word as a string, ending at wh_NameLastChar
=8					NameLength = *-Name0
=50946					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>c782	88					.byte (("2Literal"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=24					WordFlags ::= IM+NN	; modifiable copy, remember for later
=52					LinkDisplacement = Nt0-WordListLink
>c783	18					.byte WordFlags	;wh_Flags
>c784	03					.byte 3	;wh_CodeLength
>c785	34					  .byte LinkDisplacement	; offset to previous nt
=$c786					XtPtr1 ::= *
=50946					WordListLink ::= Nt0 ; remember the nt of this word for later
.c786					Two_literal:
.c786	20 1b c4	jsr $c41b			jsr underflow_2 ; check double number
.c789	20 ee df	jsr $dfee			jsr Swap
.c78c	20 52 c7	jsr $c752			jsr Literal	; do lo cell
.c78f	4c 52 c7	jmp $c752			jmp Literal	; do hi cell
=12					CodeLen	.var *-XtPtr1
=$c792					Here1 = *	; remember here
>c784	0c					.byte CodeLen	;patch wh_CodeLength
>c792	4c 44 59 41 2e 23		Name0:	.text "LDYA.#"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=50968					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>c798	66					.byte (("LDYA.#"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=22					LinkDisplacement = Nt0-WordListLink
>c799	10					.byte WordFlags	;wh_Flags
>c79a	03					.byte 3	;wh_CodeLength
>c79b	16					  .byte LinkDisplacement	; offset to previous nt
=$c79c					XtPtr1 ::= *
=50968					WordListLink ::= Nt0 ; remember the nt of this word for later
.c79c					ldya_immed_comma:
.c79c	a9 a0		lda #$a0			lda #$a0		; ldy #
.c79e	b4 25		ldy $25,x			ldy DStack+1,x
.c7a0	20 50 dd	jsr $dd50			jsr Comma_YA
.c7a3					lda_immed_comma:
.c7a3	a9 a9		lda #$a9			lda #$a9		; lda #
.c7a5	20 39 dd	jsr $dd39			jsr C_Comma_A
.c7a8	4c 36 dd	jmp $dd36			jmp C_Comma
=15					CodeLen	.var *-XtPtr1
=$c7ab					Here1 = *	; remember here
>c79a	0f					.byte CodeLen	;patch wh_CodeLength
>c7ab	50 75 73 68 59 41		Name0:	.text "PushYA"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=50993					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>c7b1	26					.byte (("PushYA"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=0					WordFlags ::= 0	; modifiable copy, remember for later
=25					LinkDisplacement = Nt0-WordListLink
>c7b2	00					.byte WordFlags	;wh_Flags
>c7b3	03					.byte 3	;wh_CodeLength
>c7b4	19					  .byte LinkDisplacement	; offset to previous nt
=$c7b5					XtPtr1 ::= *
=50993					WordListLink ::= Nt0 ; remember the nt of this word for later
.c7b5	ca		dex		PushYA:		dex
.c7b6	ca		dex				dex
.c7b7	95 24		sta $24,x			sta DStack+0,x
.c7b9	94 25		sty $25,x			sty DStack+1,x
=6					CodeLen	.var *-XtPtr1
=$c7bb					Here1 = *	; remember here
>c7b3	06					.byte CodeLen	;patch wh_CodeLength
.c7bb	60		rts				rts
>c7bc	54 72 75 65			Name0:	.text "True"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=51008					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>c7c0	a4					.byte (("True"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=0					WordFlags ::= 0	; modifiable copy, remember for later
=15					LinkDisplacement = Nt0-WordListLink
>c7c1	00					.byte WordFlags	;wh_Flags
>c7c2	03					.byte 3	;wh_CodeLength
>c7c3	0f					  .byte LinkDisplacement	; offset to previous nt
=$c7c4					XtPtr1 ::= *
=51008					WordListLink ::= Nt0 ; remember the nt of this word for later
.c7c4	a9 ff		lda #$ff	True:		lda #$FF
.c7c6	ca		dex		PushAA:		dex
.c7c7	ca		dex				dex
.c7c8	95 24		sta $24,x			sta DStack+0,x
.c7ca	95 25		sta $25,x			sta DStack+1,x
=8					CodeLen	.var *-XtPtr1
=$c7cc					Here1 = *	; remember here
>c7c2	08					.byte CodeLen	;patch wh_CodeLength
.c7cc	60		rts				rts
>c7cd	46 61 6c 73 65			Name0:	.text "False"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=51026					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>c7d2	a5					.byte (("False"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=18					LinkDisplacement = Nt0-WordListLink
>c7d3	10					.byte WordFlags	;wh_Flags
>c7d4	03					.byte 3	;wh_CodeLength
>c7d5	12					  .byte LinkDisplacement	; offset to previous nt
=$c7d6					XtPtr1 ::= *
=51026					WordListLink ::= Nt0 ; remember the nt of this word for later
.c7d6	a9 00		lda #$00	False:		lda #0
.c7d8	f0 ec		beq $c7c6			beq PushAA
=4					CodeLen	.var *-XtPtr1
=$c7da					Here1 = *	; remember here
>c7d4	04					.byte CodeLen	;patch wh_CodeLength
>c7da	50 75 73 68 5a 41		Name0:	.text "PushZA"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=51040					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>c7e0	26					.byte (("PushZA"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=0					WordFlags ::= 0	; modifiable copy, remember for later
=14					LinkDisplacement = Nt0-WordListLink
>c7e1	00					.byte WordFlags	;wh_Flags
>c7e2	03					.byte 3	;wh_CodeLength
>c7e3	0e					  .byte LinkDisplacement	; offset to previous nt
=$c7e4					XtPtr1 ::= *
=51040					WordListLink ::= Nt0 ; remember the nt of this word for later
.c7e4	ca		dex		PushZA:		dex
.c7e5	ca		dex				dex
.c7e6	95 24		sta $24,x			sta DStack+0,x
.c7e8	a9 00		lda #$00			lda #0
.c7ea	95 25		sta $25,x			sta DStack+1,x
=8					CodeLen	.var *-XtPtr1
=$c7ec					Here1 = *	; remember here
>c7e2	08					.byte CodeLen	;patch wh_CodeLength
.c7ec	60		rts				rts
>c7ed	30				Name0:	.text "0"	;  name of word as a string, ending at wh_NameLastChar
=1					NameLength = *-Name0
=51054					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>c7ee	01					.byte (("0"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=14					LinkDisplacement = Nt0-WordListLink
>c7ef	10					.byte WordFlags	;wh_Flags
>c7f0	03					.byte 3	;wh_CodeLength
>c7f1	0e					  .byte LinkDisplacement	; offset to previous nt
=$c7f2					XtPtr1 ::= *
=51054					WordListLink ::= Nt0 ; remember the nt of this word for later
.c7f2	a9 00		lda #$00	Zero:		lda #0
.c7f4	f0 d0		beq $c7c6			beq PushAA
=4					CodeLen	.var *-XtPtr1
=$c7f6					Here1 = *	; remember here
>c7f0	04					.byte CodeLen	;patch wh_CodeLength
>c7f6	31				Name0:	.text "1"	;  name of word as a string, ending at wh_NameLastChar
=1					NameLength = *-Name0
=51063					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>c7f7	21					.byte (("1"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=9					LinkDisplacement = Nt0-WordListLink
>c7f8	10					.byte WordFlags	;wh_Flags
>c7f9	03					.byte 3	;wh_CodeLength
>c7fa	09					  .byte LinkDisplacement	; offset to previous nt
=$c7fb					XtPtr1 ::= *
=51063					WordListLink ::= Nt0 ; remember the nt of this word for later
.c7fb	a9 01		lda #$01	One:		lda #1
.c7fd	d0 e5		bne $c7e4			bne PushZA
=4					CodeLen	.var *-XtPtr1
=$c7ff					Here1 = *	; remember here
>c7f9	04					.byte CodeLen	;patch wh_CodeLength
>c7ff	32				Name0:	.text "2"	;  name of word as a string, ending at wh_NameLastChar
=1					NameLength = *-Name0
=51072					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>c800	41					.byte (("2"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=9					LinkDisplacement = Nt0-WordListLink
>c801	10					.byte WordFlags	;wh_Flags
>c802	03					.byte 3	;wh_CodeLength
>c803	09					  .byte LinkDisplacement	; offset to previous nt
=$c804					XtPtr1 ::= *
=51072					WordListLink ::= Nt0 ; remember the nt of this word for later
.c804	a9 02		lda #$02	Two:		lda #2
.c806	d0 dc		bne $c7e4			bne PushZA
=4					CodeLen	.var *-XtPtr1
=$c808					Here1 = *	; remember here
>c802	04					.byte CodeLen	;patch wh_CodeLength
>c808	42 6c				Name0:	.text "Bl"	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=51082					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>c80a	82					.byte (("Bl"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=10					LinkDisplacement = Nt0-WordListLink
>c80b	10					.byte WordFlags	;wh_Flags
>c80c	03					.byte 3	;wh_CodeLength
>c80d	0a					  .byte LinkDisplacement	; offset to previous nt
=$c80e					XtPtr1 ::= *
=51082					WordListLink ::= Nt0 ; remember the nt of this word for later
.c80e	a9 20		lda #$20	Bl:		lda #AscSP
.c810	d0 d2		bne $c7e4			bne PushZA
=4					CodeLen	.var *-XtPtr1
=$c812					Here1 = *	; remember here
>c80c	04					.byte CodeLen	;patch wh_CodeLength
>c812	3e 49 6e			Name0:	.text ">In"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=51093					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>c815	c3					.byte ((">In"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=11					LinkDisplacement = Nt0-WordListLink
>c816	10					.byte WordFlags	;wh_Flags
>c817	03					.byte 3	;wh_CodeLength
>c818	0b					  .byte LinkDisplacement	; offset to previous nt
=$c819					XtPtr1 ::= *
=51093					WordListLink ::= Nt0 ; remember the nt of this word for later
.c819	a9 08		lda #$08			lda #ToIn
.c81b	4c e4 c7	jmp $c7e4			jmp PushZA	; jmp to be a recognizable constant
=5					CodeLen	.var *-XtPtr1
=$c81e					Here1 = *	; remember here
>c817	05					.byte CodeLen	;patch wh_CodeLength
>c81e	53 74 61 74 65			Name0:	.text "State"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=51107					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>c823	a5					.byte (("State"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=14					LinkDisplacement = Nt0-WordListLink
>c824	10					.byte WordFlags	;wh_Flags
>c825	03					.byte 3	;wh_CodeLength
>c826	0e					  .byte LinkDisplacement	; offset to previous nt
=$c827					XtPtr1 ::= *
=51107					WordListLink ::= Nt0 ; remember the nt of this word for later
.c827	a9 0a		lda #$0a			lda #State
.c829	4c e4 c7	jmp $c7e4			jmp PushZA	; jmp to be a recognizable constant
=5					CodeLen	.var *-XtPtr1
=$c82c					Here1 = *	; remember here
>c825	05					.byte CodeLen	;patch wh_CodeLength
>c82c	64 70				Name0:	.text "dp"	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=51118					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>c82e	02					.byte (("dp"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=11					LinkDisplacement = Nt0-WordListLink
>c82f	10					.byte WordFlags	;wh_Flags
>c830	03					.byte 3	;wh_CodeLength
>c831	0b					  .byte LinkDisplacement	; offset to previous nt
=$c832					XtPtr1 ::= *
=51118					WordListLink ::= Nt0 ; remember the nt of this word for later
.c832	a9 10		lda #$10			lda #dp
.c834	4c e4 c7	jmp $c7e4			jmp PushZA	; jmp to be a recognizable constant
=5					CodeLen	.var *-XtPtr1
=$c837					Here1 = *	; remember here
>c830	05					.byte CodeLen	;patch wh_CodeLength
>c837	54 6d 70 31			Name0:	.text "Tmp1"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=51131					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>c83b	24					.byte (("Tmp1"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>c83c	10					.byte WordFlags	;wh_Flags
>c83d	03					.byte 3	;wh_CodeLength
>c83e	0d					  .byte LinkDisplacement	; offset to previous nt
=$c83f					XtPtr1 ::= *
=51131					WordListLink ::= Nt0 ; remember the nt of this word for later
.c83f	a9 14		lda #$14			lda #tmp1
.c841	4c e4 c7	jmp $c7e4			jmp PushZA	; jmp to be a recognizable constant
=5					CodeLen	.var *-XtPtr1
=$c844					Here1 = *	; remember here
>c83d	05					.byte CodeLen	;patch wh_CodeLength
>c844	54 6d 70 32			Name0:	.text "Tmp2"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=51144					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>c848	44					.byte (("Tmp2"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>c849	10					.byte WordFlags	;wh_Flags
>c84a	03					.byte 3	;wh_CodeLength
>c84b	0d					  .byte LinkDisplacement	; offset to previous nt
=$c84c					XtPtr1 ::= *
=51144					WordListLink ::= Nt0 ; remember the nt of this word for later
.c84c	a9 16		lda #$16			lda #tmp2
.c84e	4c e4 c7	jmp $c7e4			jmp PushZA	; jmp to be a recognizable constant
=5					CodeLen	.var *-XtPtr1
=$c851					Here1 = *	; remember here
>c84a	05					.byte CodeLen	;patch wh_CodeLength
>c851	54 6d 70 33			Name0:	.text "Tmp3"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=51157					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>c855	64					.byte (("Tmp3"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>c856	10					.byte WordFlags	;wh_Flags
>c857	03					.byte 3	;wh_CodeLength
>c858	0d					  .byte LinkDisplacement	; offset to previous nt
=$c859					XtPtr1 ::= *
=51157					WordListLink ::= Nt0 ; remember the nt of this word for later
.c859	a9 18		lda #$18			lda #tmp3
.c85b	4c e4 c7	jmp $c7e4			jmp PushZA	; jmp to be a recognizable constant
=5					CodeLen	.var *-XtPtr1
=$c85e					Here1 = *	; remember here
>c857	05					.byte CodeLen	;patch wh_CodeLength
>c85e	54 6d 70 34			Name0:	.text "Tmp4"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=51170					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>c862	84					.byte (("Tmp4"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>c863	10					.byte WordFlags	;wh_Flags
>c864	03					.byte 3	;wh_CodeLength
>c865	0d					  .byte LinkDisplacement	; offset to previous nt
=$c866					XtPtr1 ::= *
=51170					WordListLink ::= Nt0 ; remember the nt of this word for later
.c866	a9 1a		lda #$1a			lda #tmp4
.c868	4c e4 c7	jmp $c7e4			jmp PushZA	; jmp to be a recognizable constant
=5					CodeLen	.var *-XtPtr1
=$c86b					Here1 = *	; remember here
>c864	05					.byte CodeLen	;patch wh_CodeLength
>c86b	53 4c 69 74 65 72 61 6c		Name0:	.text "SLiteral"	;  name of word as a string, ending at wh_NameLastChar
=8					NameLength = *-Name0
=51187					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>c873	88					.byte (("SLiteral"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=92					WordFlags ::= CO+IM+UF+NN	; modifiable copy, remember for later
=17					LinkDisplacement = Nt0-WordListLink
>c874	5c					.byte WordFlags	;wh_Flags
>c875	03					.byte 3	;wh_CodeLength
>c876	11					  .byte LinkDisplacement	; offset to previous nt
=$c877					XtPtr1 ::= *
=51187					WordListLink ::= Nt0 ; remember the nt of this word for later
.c877					SLiteral:
.c877	20 1b c4	jsr $c41b			jsr underflow_2
.c87a	20 9a c8	jsr $c89a			jsr SLiteral_Start	; compile header
.c87d	4c 8e c8	jmp $c88e			jmp _Move_Test
.c880	a1 28		lda ($28,x)	_Move_Loop:	lda (DStack+4,x)
.c882	20 39 dd	jsr $dd39			jsr C_Comma_A
.c885	f6 28		inc $28,x			inc DStack+4,x
.c887	d0 02		bne $c88b			bne +
.c889	f6 29		inc $29,x			inc DStack+5,x
.c88b					+
.c88b	20 7c da	jsr $da7c			jsr NOS_One_Minus
.c88e	b5 26		lda $26,x	_Move_Test:	lda DStack+2,x
.c890	15 27		ora $27,x			ora DStack+3,x
.c892	d0 ec		bne $c880			bne _Move_Loop
.c894	20 a7 c8	jsr $c8a7			jsr SLiteral_End
.c897	4c 6d d5	jmp $d56d			jmp Two_Drop		; clean up and leave
=35					CodeLen	.var *-XtPtr1
=$c89a					Here1 = *	; remember here
>c875	23					.byte CodeLen	;patch wh_CodeLength
.c89a					SLiteral_Start:
.c89a	a9 b8		lda #$b8			lda #<SLiteral_runtime	; compile JSR SLiteral_Runtime
.c89c	a0 c8		ldy #$c8			ldy #>SLiteral_runtime
.c89e	20 73 dd	jsr $dd73			jsr Jsr_Comma_YA
.c8a1	20 62 da	jsr $da62			jsr Here		; push addr of start of JMP
.c8a4	4c 89 dd	jmp $dd89			jmp Jmp_Comma_YA	; compile JMP around string (dummy addr)
.c8a7					SLiteral_End:
.c8a7	20 95 da	jsr $da95			jsr One_Plus
.c8aa	a5 00		lda $00				lda cp+0		; Update the address of the jump to HERE.
.c8ac	81 24		sta ($24,x)			sta (DStack+0,x)
.c8ae	20 95 da	jsr $da95			jsr One_Plus
.c8b1	a5 01		lda $01				lda cp+1
.c8b3	81 24		sta ($24,x)			sta (DStack+0,x)
.c8b5	e8		inx				inx			; drop herej
.c8b6	e8		inx				inx
.c8b7	60		rts				rts
.c8b8					SLiteral_Runtime:
.c8b8	86 16		stx $16				stx tmp2	; save data stack index
.c8ba	ba		tsx				tsx
.c8bb	bd 01 01	lda $0101,x	SLiteral_Run2:	lda RStack+1,x	; tmp1= RTS addr
.c8be	85 14		sta $14				sta tmp1+0
.c8c0	bd 02 01	lda $0102,x			lda RStack+2,x
.c8c3	85 15		sta $15				sta tmp1+1
.c8c5	a6 16		ldx $16				ldx tmp2	; restore data stack index
.c8c7	ca		dex				dex		; push string addr
.c8c8	ca		dex				dex
.c8c9	18		clc				clc
.c8ca	a5 14		lda $14				lda tmp1+0
.c8cc	69 04		adc #$04			adc #3+1	;   just after the following JMP + correcting for JSR behavior
.c8ce	95 24		sta $24,x			sta DStack+0,x
.c8d0	a5 15		lda $15				lda tmp1+1
.c8d2	69 00		adc #$00			adc #0
.c8d4	95 25		sta $25,x			sta DStack+1,x
.c8d6	ca		dex				dex		; push string length
.c8d7	ca		dex				dex
.c8d8	38		sec				sec
.c8d9	a0 02		ldy #$02			ldy #2		;   = string_end - string_addr
.c8db	b1 14		lda ($14),y			lda (tmp1),y
.c8dd	f5 26		sbc $26,x			sbc DStack+2,x
.c8df	95 24		sta $24,x			sta DStack+0,x
.c8e1	c8		iny				iny
.c8e2	b1 14		lda ($14),y			lda (tmp1),y
.c8e4	f5 27		sbc $27,x			sbc DStack+3,x
.c8e6	95 25		sta $25,x			sta DStack+1,x
.c8e8	60		rts				rts
>c8e9	2e 22				Name0:	.text '."'	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=51307					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>c8eb	42					.byte (('."'[-1]&7)<<5)+NameLength	;wh_HashNameLen
=28					WordFlags ::= CO+IM+NN	; modifiable copy, remember for later
=120					LinkDisplacement = Nt0-WordListLink
>c8ec	1c					.byte WordFlags	;wh_Flags
>c8ed	03					.byte 3	;wh_CodeLength
>c8ee	78					  .byte LinkDisplacement	; offset to previous nt
=$c8ef					XtPtr1 ::= *
=51307					WordListLink ::= Nt0 ; remember the nt of this word for later
.c8ef					Dot_quote:
.c8ef	20 0a c9	jsr $c90a			jsr S_Quote		; compile the string literal
.c8f2	a0 de		ldy #$de			ldy #>Type		; compile: print string
.c8f4	a9 34		lda #$34			lda #<Type
.c8f6	4c 73 dd	jmp $dd73			jmp Jsr_Comma_YA
=10					CodeLen	.var *-XtPtr1
=$c8f9					Here1 = *	; remember here
>c8ed	0a					.byte CodeLen	;patch wh_CodeLength
>c8f9	53 5c 22			Name0:	.text 'S\"'	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=51324					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>c8fc	43					.byte (('S\"'[-1]&7)<<5)+NameLength	;wh_HashNameLen
=24					WordFlags ::= IM+NN	; modifiable copy, remember for later
=17					LinkDisplacement = Nt0-WordListLink
>c8fd	18					.byte WordFlags	;wh_Flags
>c8fe	03					.byte 3	;wh_CodeLength
>c8ff	11					  .byte LinkDisplacement	; offset to previous nt
=$c900					XtPtr1 ::= *
=51324					WordListLink ::= Nt0 ; remember the nt of this word for later
.c900					S_Backslash_Quote:
.c900	a9 ff		lda #$ff			lda #$ff	; Do handle escaped chars.
.c902	d0 08		bne $c90c			bne S_Quote_start
=4					CodeLen	.var *-XtPtr1
=$c904					Here1 = *	; remember here
>c8fe	04					.byte CodeLen	;patch wh_CodeLength
>c904	53 22				Name0:	.text 'S"'	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=51334					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>c906	42					.byte (('S"'[-1]&7)<<5)+NameLength	;wh_HashNameLen
=24					WordFlags ::= IM+NN	; modifiable copy, remember for later
=10					LinkDisplacement = Nt0-WordListLink
>c907	18					.byte WordFlags	;wh_Flags
>c908	03					.byte 3	;wh_CodeLength
>c909	0a					  .byte LinkDisplacement	; offset to previous nt
=$c90a					XtPtr1 ::= *
=51334					WordListLink ::= Nt0 ; remember the nt of this word for later
.c90a					S_Quote:
.c90a	a9 00		lda #$00			lda #0		; Don't handle escaped chars.
.c90c					S_Quote_start:
.c90c	48		pha				pha			; save "handle escaped chars" flag
.c90d	a5 0a		lda $0a				lda state		; compiling?
.c90f	f0 06		beq $c917			beq _15
.c911	20 9a c8	jsr $c89a			jsr SLiteral_Start	; compile SLiteral header
.c914	4c 1a c9	jmp $c91a			jmp _19
.c917	20 62 da	jsr $da62	_15:		jsr Here		; remember start addr
.c91a					_19:
.c91a	68		pla				pla			; init t2 flags
.c91b	20 e4 c7	jsr $c7e4			jsr PushZA
.c91e	20 f2 c7	jsr $c7f2			jsr Zero		; init t3 flags
.c921					_savechars_loop:
.c921	a5 08		lda $08				lda toin+0		; LSB
.c923	c5 06		cmp $06				cmp ciblen+0
.c925	a5 09		lda $09				lda toin+1		; MSB
.c927	e5 07		sbc $07				sbc ciblen+1
.c929	90 10		bcc $c93b			bcc _input_fine		; input buffer empty?
.c92b	20 92 d2	jsr $d292			jsr Refill		; Refill it  ( -- f )
.c92e	b5 24		lda $24,x			lda DStack+0,x		; Check result of refill.
.c930	d0 05		bne $c937			bne +
.c932	a9 6b		lda #$6b			lda #$100+err_refill	; Something when wrong with refill.
.c934	4c 63 c4	jmp $c463			jmp ThrowA
.c937	e8		inx		+		inx			; Drop the refill flag
.c938	e8		inx				inx
.c939	d0 e6		bne $c921			bne _savechars_loop	; jump back up to the empty check, just in
.c93b					_input_fine:
.c93b	18		clc				clc			; tmp1= A= the char at Cib+ToIn
.c93c	a5 04		lda $04				lda cib+0
.c93e	85 14		sta $14				sta tmp1+0
.c940	a5 05		lda $05				lda cib+1
.c942	65 09		adc $09				adc toin+1
.c944	85 15		sta $15				sta tmp1+1
.c946	a4 08		ldy $08				ldy ToIn
.c948	b1 14		lda ($14),y			lda (tmp1),y
.c94a	85 14		sta $14				sta tmp1
.c94c	e6 08		inc $08				inc toin+0		; Move on to the next character.
.c94e	d0 02		bne $c952			bne +
.c950	e6 09		inc $09				inc toin+1
.c952					+
.c952	b4 26		ldy $26,x			ldy DStack+2,x		; handling escaped characters?
.c954	30 03		bmi $c959			bmi +
.c956	4c fc c9	jmp $c9fc			jmp _regular_char
.c959					+
.c959	b4 27		ldy $27,x			ldy DStack+3,x  		; already seen the backslash?
.c95b	30 03		bmi $c960			bmi +
.c95d	4c f2 c9	jmp $c9f2			jmp _not_escaped
.c960					+
.c960	84 15		sty $15				sty tmp1+1
.c962	24 15		bit $15				bit tmp1+1		; in the middle of a \x sequence ?
.c964	70 25		bvs $c98b			bvs _check_esc_chars
.c966	a9 01		lda #$01			lda #1
.c968	24 15		bit $15				bit tmp1+1
.c96a	d0 11		bne $c97d			bne _esc_x_second_digit
.c96c	c8		iny				iny			; Adjust flag for second digit next time.
.c96d	94 27		sty $27,x			sty DStack+3,x
.c96f	a5 14		lda $14				lda tmp1+0		; Get the char again.
.c971	20 1f ca	jsr $ca1f			jsr convert_hex_value	; Convert to hex
.c974	0a		asl a				asl			; This is the upper nybble, so move it up.
.c975	0a		asl a				asl
.c976	0a		asl a				asl
.c977	0a		asl a				asl
.c978	95 24		sta $24,x			sta DStack+0,x		; Save it for later.
.c97a	4c 03 ca	jmp $ca03			jmp _next_character
.c97d					_esc_x_second_digit:
.c97d	a9 00		lda #$00			lda #0			; Clear the escaped character flag
.c97f	95 27		sta $27,x			sta DStack+3,x		;   (because we are handling it right here)
.c981	a5 14		lda $14				lda tmp1+0		; Convert to hex
.c983	20 1f ca	jsr $ca1f			jsr convert_hex_value
.c986	15 24		ora $24,x			ora DStack+0,x		; combine with value in t3
.c988	4c 00 ca	jmp $ca00			jmp _save_character
.c98b					_check_esc_chars:
.c98b	a0 00		ldy #$00			ldy #0
.c98d	94 27		sty $27,x			sty DStack+3,x
.c98f	a8		tay				tay
.c990	a9 07		lda #$07			lda #AscBELL	      ; BEL (ASCII value 7)
.c992	c0 61		cpy #$61			cpy #'a'
.c994	f0 6a		beq $ca00			beq _save_character
.c996	a9 08		lda #$08			lda #AscBS	      ; Backspace (ASCII value 8)
.c998	c0 62		cpy #$62			cpy #'b'
.c99a	f0 64		beq $ca00			beq _save_character
.c99c	a9 1b		lda #$1b			lda #AscESC	      ; ESC (ASCII value 27)
.c99e	c0 65		cpy #$65			cpy #'e'
.c9a0	f0 5e		beq $ca00			beq _save_character
.c9a2	a9 0c		lda #$0c			lda #AscFF	      ; FF (ASCII value 12)
.c9a4	c0 66		cpy #$66			cpy #'f'
.c9a6	f0 58		beq $ca00			beq _save_character
.c9a8	a9 0a		lda #$0a			lda #AscLF	      ; LF (ASCII value 10)
.c9aa	c0 6c		cpy #$6c			cpy #'l'
.c9ac	f0 52		beq $ca00			beq _save_character
.c9ae	c0 6e		cpy #$6e			cpy #'n'
.c9b0	f0 4e		beq $ca00			beq _save_character
.c9b2	c0 6d		cpy #$6d			cpy #'m'
.c9b4	d0 09		bne $c9bf			bne +
.c9b6	a9 0d		lda #$0d			lda #AscCR		; CR/LF pair (ASCII values 13, 10)
.c9b8	20 39 dd	jsr $dd39			jsr C_Comma_A
.c9bb	a9 0a		lda #$0a			lda #AscLF
.c9bd	d0 41		bne $ca00			bne _save_character
.c9bf					+
.c9bf	a9 22		lda #$22			lda #AscDQuote		; Double quote (ASCII value 34)
.c9c1	c0 71		cpy #$71			cpy #'q'
.c9c3	f0 3b		beq $ca00			beq _save_character
.c9c5	c0 22		cpy #$22			cpy #AscDQuote
.c9c7	f0 37		beq $ca00			beq _save_character
.c9c9	a9 0d		lda #$0d			lda #AscCR		; CR (ASCII value 13)
.c9cb	c0 72		cpy #$72			cpy #'r'
.c9cd	f0 31		beq $ca00			beq _save_character
.c9cf	a9 09		lda #$09			lda #AscHT		; Horizontal TAB (ASCII value 9)
.c9d1	c0 74		cpy #$74			cpy #'t'
.c9d3	f0 2b		beq $ca00			beq _save_character
.c9d5	a9 0b		lda #$0b			lda #AscVT		; Vertical TAB (ASCII value 11)
.c9d7	c0 76		cpy #$76			cpy #'v'
.c9d9	f0 25		beq $ca00			beq _save_character
.c9db	a9 00		lda #$00			lda #0			; NULL (ASCII value 0)
.c9dd	c0 7a		cpy #$7a			cpy #'z'
.c9df	f0 1f		beq $ca00			beq _save_character
.c9e1					_check_esc_x:
.c9e1	c0 78		cpy #$78			cpy #'x'
.c9e3	d0 06		bne $c9eb			bne +
.c9e5	a9 be		lda #$be			lda #$BE	; Clear bits 6 and 0
.c9e7	95 27		sta $27,x			sta DStack+3,x
.c9e9	d0 18		bne $ca03			bne _next_character
.c9eb					+
.c9eb	a9 5c		lda #$5c			lda #AscBackslash	; Backslash (ASCII value 92)
.c9ed	c0 5c		cpy #$5c			cpy #AscBackslash
.c9ef	f0 0f		beq $ca00			beq _save_character
.c9f1	98		tya				tya
.c9f2					_not_escaped:
.c9f2	c9 5c		cmp #$5c			cmp #$5C	; The backslash char
.c9f4	d0 06		bne $c9fc			bne _regular_char
.c9f6	a9 ff		lda #$ff			lda #$FF
.c9f8	95 27		sta $27,x			sta DStack+3,x
.c9fa	d0 07		bne $ca03			bne _next_character
.c9fc					_regular_char:
.c9fc	c9 22		cmp #$22			cmp #AscDQuote		; ASCII for "
.c9fe	f0 06		beq $ca06			beq _found_string_end
.ca00					_save_character:
.ca00	20 39 dd	jsr $dd39			jsr C_Comma_A		; compile this character into the dictionary
.ca03					_next_character:
.ca03	4c 21 c9	jmp $c921			jmp _savechars_loop
.ca06					_found_string_end:
.ca06	e8		inx				inx			; Drop t3
.ca07	e8		inx				inx
.ca08	a5 0a		lda $0a				lda state		; What happens next depends on the state (which is bad, but
.ca0a	d0 0e		bne $ca1a			bne _cmpl		; that's the way it works at the moment).
.ca0c	38		sec				sec			; TOS= length of string = Here - start_addr
.ca0d	a5 00		lda $00				lda cp+0
.ca0f	f5 26		sbc $26,x			sbc DStack+2,x
.ca11	95 24		sta $24,x			sta DStack+0,x		;   LSB
.ca13	a5 01		lda $01				lda cp+1
.ca15	f5 27		sbc $27,x			sbc DStack+3,x
.ca17	95 25		sta $25,x			sta DStack+1,x		;   MSB
.ca19	60		rts				rts			; ( startaddr u )
.ca1a					_cmpl:
.ca1a	e8		inx				inx			; Drop t2
.ca1b	e8		inx				inx
.ca1c	4c a7 c8	jmp $c8a7			jmp SLiteral_End	; ( jmpaddr )
=277					CodeLen	.var *-XtPtr1
=$ff					CodeLen	 .var $ff
=$ca1f					Here1 = *	; remember here
>c908	ff					.byte CodeLen	;patch wh_CodeLength
.ca1f					convert_hex_value:
.ca1f	c9 41		cmp #$41			cmp #'A'
.ca21	90 05		bcc $ca28			bcc _digit
.ca23	29 1f		and #$1f	_alpha:		and #$1F		; Make it uppercase.
.ca25	69 08		adc #$08			adc #9-1		; gives value 10 for 'A'
.ca27	60		rts				rts
.ca28					_digit:
.ca28	e9 2f		sbc #$2f			sbc #'0'-1
.ca2a	60		rts				rts
>ca2b	4c 61 74 65 73 74 58 74		Name0:	.text "LatestXt"	;  name of word as a string, ending at wh_NameLastChar
=8					NameLength = *-Name0
=51635					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>ca33	88					.byte (("LatestXt"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=301					LinkDisplacement = Nt0-WordListLink
=$11						  WordFlags ::= WordFlags | FP
>ca34	11					.byte WordFlags	;wh_Flags
>ca35	03					.byte 3	;wh_CodeLength
>ca36	86 c8					  .word WordListLink
=$ca38					XtPtr1 ::= *
=51635					WordListLink ::= Nt0 ; remember the nt of this word for later
.ca38	20 4a ca	jsr $ca4a	LatestXt:	jsr LatestNt	; ( nt )
.ca3b	4c a9 cd	jmp $cda9			jmp Name_To_Int	; ( xt )
=6					CodeLen	.var *-XtPtr1
=$ca3e					Here1 = *	; remember here
>ca35	06					.byte CodeLen	;patch wh_CodeLength
>ca3e	4c 61 74 65 73 74 4e 74		Name0:	.text "LatestNt"	;  name of word as a string, ending at wh_NameLastChar
=8					NameLength = *-Name0
=51654					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>ca46	88					.byte (("LatestNt"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=19					LinkDisplacement = Nt0-WordListLink
>ca47	10					.byte WordFlags	;wh_Flags
>ca48	03					.byte 3	;wh_CodeLength
>ca49	13					  .byte LinkDisplacement	; offset to previous nt
=$ca4a					XtPtr1 ::= *
=51654					WordListLink ::= Nt0 ; remember the nt of this word for later
.ca4a	20 54 ca	jsr $ca54	LatestNt:	jsr current_to_dp
.ca4d	a5 10		lda $10				lda dp+0
.ca4f	a4 11		ldy $11				ldy dp+1
.ca51	4c b5 c7	jmp $c7b5			jmp PushYA
=10					CodeLen	.var *-XtPtr1
=$ca54					Here1 = *	; remember here
>ca48	0a					.byte CodeLen	;patch wh_CodeLength
.ca54					current_to_dp:
.ca54	ad 10 03	lda $0310			lda CurrentV		; A= current wordlist wid
.ca57	0a		asl a				asl			; dp= wordlists[A]
.ca58	a8		tay				tay
.ca59	b9 12 03	lda $0312,y			lda WordlistsV+0,y
.ca5c	85 10		sta $10				sta dp+0
.ca5e	b9 13 03	lda $0313,y			lda WordlistsV+1,y
.ca61	85 11		sta $11				sta dp+1
.ca63	60		rts				rts
.ca64					dp_to_current:
.ca64	ad 10 03	lda $0310			lda CurrentV		; A= current wordlist wid
.ca67	0a		asl a		                asl			; wordlists[A]=dp
.ca68	a8		tay		                tay
.ca69	a5 10		lda $10		                lda dp+0
.ca6b	99 12 03	sta $0312,y			sta WordlistsV+0,y
.ca6e	a5 11		lda $11		                lda dp+1
.ca70	99 13 03	sta $0313,y	                sta WordlistsV+1,y
.ca73	60		rts		                rts
>ca74	50 61 72 73 65 2d 4e 61		Name0:	.text "Parse-Name"	;  name of word as a string, ending at wh_NameLastChar
>ca7c	6d 65
=10					NameLength = *-Name0
=51710					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>ca7e	aa					.byte (("Parse-Name"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=56					LinkDisplacement = Nt0-WordListLink
>ca7f	10					.byte WordFlags	;wh_Flags
>ca80	03					.byte 3	;wh_CodeLength
>ca81	38					  .byte LinkDisplacement	; offset to previous nt
=$ca82					XtPtr1 ::= *
=51710					WordListLink ::= Nt0 ; remember the nt of this word for later
.ca82					Parse_Name:
.ca82	a5 04		lda $04				lda cib+0		; tmp2= cib+(toin & $ff00)
.ca84	85 16		sta $16				sta tmp2+0
.ca86	18		clc				clc
.ca87	a5 05		lda $05				lda cib+1
.ca89	65 09		adc $09				adc toin+1
.ca8b	85 17		sta $17				sta tmp2+1
.ca8d	a4 08		ldy $08				ldy toin+0		; Y= toin & $00ff
.ca8f					_skip_loop:
.ca8f	c4 06		cpy $06				cpy ciblen+0		; more chars left?
.ca91	a5 09		lda $09				lda toin+1
.ca93	e5 07		sbc $07				sbc ciblen+1
.ca95	b0 11		bcs $caa8			bcs _empty_line
.ca97	b1 16		lda ($16),y			lda (tmp2),y		; get cib[toin]
.ca99	c9 21		cmp #$21			cmp #AscSP+1		; is_whitespace
.ca9b	b0 10		bcs $caad			bcs _char_found
.ca9d	c8		iny				iny			; increment toin
.ca9e	84 08		sty $08				sty toin+0
.caa0	d0 ed		bne $ca8f			bne _skip_loop
.caa2	e6 09		inc $09				inc toin+1
.caa4	e6 17		inc $17				inc tmp2+1
.caa6	d0 e7		bne $ca8f			bne _skip_loop
.caa8					_empty_line:
.caa8	ca		dex				dex			; junk address
.caa9	ca		dex				dex
.caaa	4c f2 c7	jmp $c7f2			jmp Zero		; length=0
.caad					_char_found:
.caad	20 0e c8	jsr $c80e			jsr Bl			; push delimiter char
.cab0	4c c9 ca	jmp $cac9			jmp Parse
=49					CodeLen	.var *-XtPtr1
=$cab3					Here1 = *	; remember here
>ca80	31					.byte CodeLen	;patch wh_CodeLength
.cab3					parse_name_check:
.cab3	20 82 ca	jsr $ca82			jsr parse_name		; get character from string
.cab6	b5 24		lda $24,x			lda DStack+0,x		; empty string?
.cab8	f0 01		beq $cabb			beq _empty
.caba	60		rts				rts
.cabb	a9 f3		lda #$f3	_empty:		lda #$100+err_UndefinedWord	; complain & abort
.cabd	4c 63 c4	jmp $c463			jmp ThrowA
>cac0	50 61 72 73 65			Name0:	.text "Parse"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=51781					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>cac5	a5					.byte (("Parse"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=71					LinkDisplacement = Nt0-WordListLink
>cac6	10					.byte WordFlags	;wh_Flags
>cac7	03					.byte 3	;wh_CodeLength
>cac8	47					  .byte LinkDisplacement	; offset to previous nt
=$cac9					XtPtr1 ::= *
=51781					WordListLink ::= Nt0 ; remember the nt of this word for later
.cac9	20 c3 c3	jsr $c3c3	Parse:		jsr PopA		; pop c (check for underflow)
.cacc	85 1c		sta $1c		Parse_A:	sta tmp5		; save delimiter
.cace	ca		dex				dex			; alloc space for addr
.cacf	ca		dex				dex
.cad0	ca		dex				dex			; alloc space for length
.cad1	ca		dex				dex
.cad2	18		clc				clc			; addr= cib+toin
.cad3	a5 08		lda $08				lda toin+0
.cad5	65 04		adc $04				adc cib+0
.cad7	95 26		sta $26,x			sta DStack+2,x
.cad9	a5 09		lda $09				lda toin+1
.cadb	65 05		adc $05				adc cib+1
.cadd	95 27		sta $27,x			sta DStack+3,x
.cadf	a4 08		ldy $08				ldy toin+0		; Y= toin & $00ff
.cae1	84 14		sty $14				sty tmp1+0
.cae3	a5 04		lda $04				lda cib+0		; tmp2= cib + (toin & $ff00)
.cae5	85 16		sta $16				sta tmp2+0
.cae7	18		clc				clc
.cae8	a5 09		lda $09				lda toin+1		; tmp1= toin
.caea	85 15		sta $15				sta tmp1+1
.caec	65 05		adc $05				adc cib+1
.caee	85 17		sta $17				sta tmp2+1
.caf0	a9 00		lda #$00			lda #0		; Initialize the offset we use to adjust EOL or found delimiter
.caf2	85 1d		sta $1d				sta tmp5+1
.caf4					_loop:
.caf4	c4 06		cpy $06				cpy ciblen+0		; end of string?
.caf6	a5 09		lda $09				lda toin+1
.caf8	e5 07		sbc $07				sbc ciblen+1
.cafa	b0 1d		bcs $cb19			bcs _eol
.cafc	a5 1c		lda $1c				lda tmp5+0		; get delimiter
.cafe	c9 20		cmp #$20			cmp #AscSP		; is it whitespace?
.cb00	d0 08		bne $cb0a			bne _not_whitespace
.cb02	b1 16		lda ($16),y			lda (tmp2),y		; get cib[toin]
.cb04	c9 21		cmp #$21			cmp #AscSP+1		; we're looking for all whitespace
.cb06	90 0f		bcc $cb17			bcc _found_delimiter
.cb08	b0 04		bcs $cb0e			bcs _not_delimiter
.cb0a	d1 16		cmp ($16),y	_not_whitespace: cmp (tmp2),y		; compare delimter to cib[toin]
.cb0c	f0 09		beq $cb17			beq _found_delimiter
.cb0e					_not_delimiter:
.cb0e	c8		iny				iny			; next character
.cb0f	d0 e3		bne $caf4			bne _loop
.cb11	e6 09		inc $09				inc toin+1
.cb13	e6 17		inc $17				inc tmp2+1
.cb15	d0 dd		bne $caf4			bne _loop
.cb17					_found_delimiter:
.cb17	e6 1d		inc $1d				inc tmp5+1
.cb19					_eol:
.cb19	38		sec				sec			; length = toin - tmp1
.cb1a	98		tya				tya
.cb1b	e5 14		sbc $14				sbc tmp1+0
.cb1d	95 24		sta $24,x			sta DStack+0,x
.cb1f	a5 09		lda $09				lda toin+1
.cb21	e5 15		sbc $15				sbc tmp1+1
.cb23	95 25		sta $25,x			sta DStack+1,x
.cb25	18		clc				clc			; toin = toin + delimiter_offset
.cb26	98		tya				tya
.cb27	65 1d		adc $1d				adc tmp5+1
.cb29	85 08		sta $08				sta toin+0
.cb2b	90 02		bcc $cb2f			bcc +
.cb2d	e6 09		inc $09				inc toin+1
.cb2f					+
=102					CodeLen	.var *-XtPtr1
=$cb2f					Here1 = *	; remember here
>cac7	66					.byte CodeLen	;patch wh_CodeLength
.cb2f	60		rts				rts
>cb30	45 78 65 63 75 74 65 2d		Name0:	.text "Execute-Parsing"	;  name of word as a string, ending at wh_NameLastChar
>cb38	50 61 72 73 69 6e 67
=15					NameLength = *-Name0
=51903					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>cb3f	ef					.byte (("Execute-Parsing"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=122					LinkDisplacement = Nt0-WordListLink
>cb40	10					.byte WordFlags	;wh_Flags
>cb41	03					.byte 3	;wh_CodeLength
>cb42	7a					  .byte LinkDisplacement	; offset to previous nt
=$cb43					XtPtr1 ::= *
=51903					WordListLink ::= Nt0 ; remember the nt of this word for later
.cb43					Execute_parsing:
.cb43	20 20 c4	jsr $c420			jsr underflow_3
.cb46	20 11 d4	jsr $d411			jsr Input_To_R		; save existing input for later
.cb49	20 d3 de	jsr $ded3			jsr Not_Rot		; -ROT ( xt addr u )
.cb4c	20 de c3	jsr $c3de			jsr PopYA		; TOS is new ciblen
.cb4f	85 06		sta $06				sta ciblen+0
.cb51	84 07		sty $07				sty ciblen+1
.cb53	20 de c3	jsr $c3de			jsr PopYA		; NOS is new cib
.cb56	85 04		sta $04				sta cib+0
.cb58	84 05		sty $05				sty cib+1
.cb5a	a9 00		lda #$00			lda #0
.cb5c	85 08		sta $08				sta toin+0		; Set >IN to zero
.cb5e	85 09		sta $09				sta toin+1
.cb60	20 72 de	jsr $de72			jsr Execute
.cb63	20 32 d4	jsr $d432			jsr R_To_Input		; restore
=35					CodeLen	.var *-XtPtr1
=$cb66					Here1 = *	; remember here
>cb41	23					.byte CodeLen	;patch wh_CodeLength
.cb66	60		rts				rts
>cb67	53 6f 75 72 63 65		Name0:	.text "Source"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=51949					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>cb6d	a6					.byte (("Source"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=46					LinkDisplacement = Nt0-WordListLink
>cb6e	10					.byte WordFlags	;wh_Flags
>cb6f	03					.byte 3	;wh_CodeLength
>cb70	2e					  .byte LinkDisplacement	; offset to previous nt
=$cb71					XtPtr1 ::= *
=51949					WordListLink ::= Nt0 ; remember the nt of this word for later
.cb71					Source:
.cb71	a5 04		lda $04				lda cib+0	; push address
.cb73	a4 05		ldy $05				ldy cib+1
.cb75	20 b5 c7	jsr $c7b5			jsr PushYA
.cb78	a5 06		lda $06				lda ciblen+0	; push size, return
.cb7a	a4 07		ldy $07				ldy ciblen+1
.cb7c	4c b5 c7	jmp $c7b5			jmp PushYA
=14					CodeLen	.var *-XtPtr1
=$cb7f					Here1 = *	; remember here
>cb6f	0e					.byte CodeLen	;patch wh_CodeLength
>cb7f	53 6f 75 72 63 65 2d 49		Name0:	.text "Source-Id"	;  name of word as a string, ending at wh_NameLastChar
>cb87	64
=9					NameLength = *-Name0
=51976					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>cb88	89					.byte (("Source-Id"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=27					LinkDisplacement = Nt0-WordListLink
>cb89	10					.byte WordFlags	;wh_Flags
>cb8a	03					.byte 3	;wh_CodeLength
>cb8b	1b					  .byte LinkDisplacement	; offset to previous nt
=$cb8c					XtPtr1 ::= *
=51976					WordListLink ::= Nt0 ; remember the nt of this word for later
.cb8c	a5 02		lda $02		Source_Id:	lda insrc+0
.cb8e	a4 03		ldy $03				ldy insrc+1
.cb90	4c b5 c7	jmp $c7b5			jmp PushYA
=7					CodeLen	.var *-XtPtr1
=$cb93					Here1 = *	; remember here
>cb8a	07					.byte CodeLen	;patch wh_CodeLength
>cb93	45 78 69 74			Name0:	.text "Exit"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=51991					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>cb97	84					.byte (("Exit"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=36					WordFlags ::= AN+CO	; modifiable copy, remember for later
=15					LinkDisplacement = Nt0-WordListLink
>cb98	24					.byte WordFlags	;wh_Flags
>cb99	03					.byte 3	;wh_CodeLength
>cb9a	0f					  .byte LinkDisplacement	; offset to previous nt
=$cb9b					XtPtr1 ::= *
=51991					WordListLink ::= Nt0 ; remember the nt of this word for later
.cb9b					Exit:
.cb9b	60		rts				rts		; keep before WordEnd so it gets inlined
=1					CodeLen	.var *-XtPtr1
=$cb9c					Here1 = *	; remember here
>cb99	01					.byte CodeLen	;patch wh_CodeLength
>cb9c	3b				Name0:	.text ";"	;  name of word as a string, ending at wh_NameLastChar
=1					NameLength = *-Name0
=51997					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>cb9d	61					.byte ((";"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=28					WordFlags ::= CO+IM+NN	; modifiable copy, remember for later
=6					LinkDisplacement = Nt0-WordListLink
>cb9e	1c					.byte WordFlags	;wh_Flags
>cb9f	03					.byte 3	;wh_CodeLength
>cba0	06					  .byte LinkDisplacement	; offset to previous nt
=$cba1					XtPtr1 ::= *
=51997					WordListLink ::= Nt0 ; remember the nt of this word for later
.cba1					Semicolon:
.cba1	20 25 c7	jsr $c725			jsr Left_Bracket	; switch to interpret state
.cba4	24 0c		bit $0c				bit status		; is this a : word or a :NONAME word?
.cba6	70 0c		bvs $cbb4			bvs _colonword
.cba8	a9 60		lda #$60			lda #$60		; compile an RTS
.cbaa	20 39 dd	jsr $dd39			jsr C_Comma_A
.cbad	a5 0e		lda $0e				lda WorkWord+0		; push xt, return
.cbaf	a4 0f		ldy $0f				ldy WorkWord+1
.cbb1	4c b5 c7	jmp $c7b5			jmp PushYA
.cbb4					_colonword:
.cbb4	10 1a		bpl $cbd0			bpl _new_word	; Bit 7 is clear = new word
.cbb6	a5 0e		lda $0e				lda WorkWord+0		; push our nt
.cbb8	a4 0f		ldy $0f				ldy WorkWord+1
.cbba	20 f5 cd	jsr $cdf5			jsr Name_To_String_YA	; get our name string
.cbbd	a9 bc		lda #$bc			lda #<str_redefined	; string "redefined"
.cbbf	a0 ea		ldy #$ea			ldy #>str_redefined
.cbc1	20 50 de	jsr $de50			jsr Print_ASCIIZ_YA_no_lf
.cbc4	20 34 de	jsr $de34			jsr Type		; print the ofWordEnding word.
.cbc7	20 28 de	jsr $de28			jsr Space
.cbca	a9 7f		lda #$7f			lda #$ff-%10000000
.cbcc	25 0c		and $0c				and status
.cbce	85 0c		sta $0c				sta status
.cbd0					_new_word:
.cbd0	20 1e d1	jsr $d11e			jsr Header_Link		; finish linking into current dictionary
.cbd3	20 db cb	jsr $cbdb			jsr adjust_z		; fix word length
.cbd6	a9 60		lda #$60			lda #$60		; compile an RTS
.cbd8	4c 39 dd	jmp $dd39			jmp C_Comma_A
=58					CodeLen	.var *-XtPtr1
=$cbdb					Here1 = *	; remember here
>cb9f	3a					.byte CodeLen	;patch wh_CodeLength
.cbdb					adjust_z:
.cbdb	a0 81		ldy #$81			ldy #wh_Flags		; tmp1= xt
.cbdd	b1 10		lda ($10),y			lda (dp),y
.cbdf	29 03		and #$03			and #FP+DB
.cbe1	18		clc				clc
.cbe2	69 84		adc #$84			adc #wh_LinkNt+1
.cbe4	65 10		adc $10				adc dp+0
.cbe6	85 14		sta $14				sta tmp1+0
.cbe8	a9 00		lda #$00			lda #0
.cbea	65 11		adc $11				adc dp+1
.cbec	85 15		sta $15				sta tmp1+1
.cbee	38		sec				sec			; length= cp-xt
.cbef	a5 00		lda $00				lda cp+0
.cbf1	e5 14		sbc $14				sbc tmp1+0
.cbf3	a8		tay				tay
.cbf4	a5 01		lda $01				lda cp+1
.cbf6	e5 15		sbc $15				sbc tmp1+1
.cbf8	f0 0c		beq $cc06			beq _short		; length > $ff ?
.cbfa	a0 81		ldy #$81			ldy #Wh_Flags		; make it NN
.cbfc	b1 10		lda ($10),y			lda (dp),y
.cbfe	29 df		and #$df			and #$ff-AN
.cc00	09 10		ora #$10			ora #NN
.cc02	91 10		sta ($10),y			sta (dp),y
.cc04	a0 ff		ldy #$ff			ldy #$ff		; set max length for header
.cc06	98		tya		_short:		tya			; fill in length in header
.cc07	a0 82		ldy #$82			ldy #Wh_CodeLength
.cc09	91 10		sta ($10),y			sta (dp),y
.cc0b	60		rts				rts
>cc0c	3a				Name0:	.text ":"	;  name of word as a string, ending at wh_NameLastChar
=1					NameLength = *-Name0
=52109					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>cc0d	41					.byte ((":"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=112					LinkDisplacement = Nt0-WordListLink
>cc0e	10					.byte WordFlags	;wh_Flags
>cc0f	03					.byte 3	;wh_CodeLength
>cc10	70					  .byte LinkDisplacement	; offset to previous nt
=$cc11					XtPtr1 ::= *
=52109					WordListLink ::= Nt0 ; remember the nt of this word for later
.cc11					Colon:
.cc11	20 3a c7	jsr $c73a			jsr Right_Bracket	; switch to compile state
.cc14	a5 0c		lda $0c				lda status
.cc16	09 40		ora #$40			ora #%01000000	; tell ";" and RECURSE that WorkWord contains nt
.cc18	09 80		ora #$80			ora #%10000000	; Tell Header_Build not to print warning for duplicate name.
.cc1a	85 0c		sta $0c				sta status
.cc1c	4c 29 d1	jmp $d129			jmp Header_Build	; compile word header (but don't link into wordlist)
=14					CodeLen	.var *-XtPtr1
=$cc1f					Here1 = *	; remember here
>cc0f	0e					.byte CodeLen	;patch wh_CodeLength
>cc1f	3a 4e 6f 4e 61 6d 65		Name0:	.text ":NoName"	;  name of word as a string, ending at wh_NameLastChar
=7					NameLength = *-Name0
=52134					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>cc26	a7					.byte ((":NoName"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=25					LinkDisplacement = Nt0-WordListLink
>cc27	10					.byte WordFlags	;wh_Flags
>cc28	03					.byte 3	;wh_CodeLength
>cc29	19					  .byte LinkDisplacement	; offset to previous nt
=$cc2a					XtPtr1 ::= *
=52134					WordListLink ::= Nt0 ; remember the nt of this word for later
.cc2a					Colon_NoName:
.cc2a	20 3a c7	jsr $c73a			jsr Right_Bracket	; switch to compile state
.cc2d	a9 bf		lda #$bf			lda #$ff-%01000000	; tell ";" and RECURSE that WorkWord contains xt
.cc2f	25 0c		and $0c				and status
.cc31	85 0c		sta $0c				sta status
.cc33	a5 00		lda $00				lda cp+0
.cc35	85 0e		sta $0e				sta WorkWord+0
.cc37	a5 01		lda $01				lda cp+1
.cc39	85 0f		sta $0f				sta WorkWord+1
=17					CodeLen	.var *-XtPtr1
=$cc3b					Here1 = *	; remember here
>cc28	11					.byte CodeLen	;patch wh_CodeLength
.cc3b	60		rts				rts
>cc3c	27				Name0:	.text "'"	;  name of word as a string, ending at wh_NameLastChar
=1					NameLength = *-Name0
=52157					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>cc3d	e1					.byte (("'"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=23					LinkDisplacement = Nt0-WordListLink
>cc3e	10					.byte WordFlags	;wh_Flags
>cc3f	03					.byte 3	;wh_CodeLength
>cc40	17					  .byte LinkDisplacement	; offset to previous nt
=$cc41					XtPtr1 ::= *
=52157					WordListLink ::= Nt0 ; remember the nt of this word for later
.cc41	20 47 cc	jsr $cc47	Tick:		jsr Tick_Nt
.cc44	4c a9 cd	jmp $cda9			jmp Name_To_Int	; ( nt -- xt )
=6					CodeLen	.var *-XtPtr1
=$cc47					Here1 = *	; remember here
>cc3f	06					.byte CodeLen	;patch wh_CodeLength
.cc47	20 b3 ca	jsr $cab3	Tick_Nt:	jsr parse_name_check	; ( -- addr u )
.cc4a	4c 95 cc	jmp $cc95			jmp find_name_check	; ( addr u -- nt )
>cc4d	5b 27 5d			Name0:	.text "[']"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=52176					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>cc50	a3					.byte (("[']"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=28					WordFlags ::= CO+IM+NN	; modifiable copy, remember for later
=19					LinkDisplacement = Nt0-WordListLink
>cc51	1c					.byte WordFlags	;wh_Flags
>cc52	03					.byte 3	;wh_CodeLength
>cc53	13					  .byte LinkDisplacement	; offset to previous nt
=$cc54					XtPtr1 ::= *
=52176					WordListLink ::= Nt0 ; remember the nt of this word for later
.cc54	20 41 cc	jsr $cc41	Bracket_Tick:	jsr Tick
.cc57	4c 52 c7	jmp $c752			jmp Literal
=6					CodeLen	.var *-XtPtr1
=$cc5a					Here1 = *	; remember here
>cc52	06					.byte CodeLen	;patch wh_CodeLength
>cc5a	46 69 6e 64 2d 4e 61 6d		Name0:	.text "Find-Name"	;  name of word as a string, ending at wh_NameLastChar
>cc62	65
=9					NameLength = *-Name0
=52195					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>cc63	a9					.byte (("Find-Name"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=19					LinkDisplacement = Nt0-WordListLink
>cc64	10					.byte WordFlags	;wh_Flags
>cc65	03					.byte 3	;wh_CodeLength
>cc66	13					  .byte LinkDisplacement	; offset to previous nt
=$cc67					XtPtr1 ::= *
=52195					WordListLink ::= Nt0 ; remember the nt of this word for later
.cc67					Find_Name:
.cc67	20 a2 cc	jsr $cca2			jsr swl_prepare 	; setup for search
.cc6a	ca		dex				dex
.cc6b	ca		dex				dex			; ( ? )
.cc6c	a9 ff		lda #$ff			lda #$ff		; for each entry in search order
.cc6e	95 25		sta $25,x			sta DStack+1,x
.cc70	f6 25		inc $25,x	_wordlist_next:	inc DStack+1,x		; step to next search order entry
.cc72	b4 25		ldy $25,x			ldy DStack+1,x
.cc74	cc 2a 03	cpy $032a			cpy Num_OrderV		; at end of list?
.cc77	90 06		bcc $cc7f			bcc _nextS
.cc79	d0 15		bne $cc90			bne _fail
.cc7b	a9 03		lda #$03			lda #wid_Root		; also try root wordlist
.cc7d	d0 03		bne $cc82			bne _nextA
.cc7f	b9 2b 03	lda $032b,y	_nextS:		lda Search_OrderV,y	; A= search_order[Y]  get wordlist ID
.cc82	20 cb cc	jsr $cccb	_nextA:		jsr swl_search_wordlist
.cc85	f0 e9		beq $cc70			beq _wordlist_next
.cc87	a5 14		lda $14				lda tmp1+0		; return nt
.cc89	a4 15		ldy $15				ldy tmp1+1
.cc8b	95 24		sta $24,x	_exit:		sta DStack+0,x
.cc8d	94 25		sty $25,x			sty DStack+1,x
.cc8f	60		rts				rts			; ( ? )
.cc90	a9 00		lda #$00	_fail:		lda #0			; return 0
.cc92	a8		tay				tay
.cc93	f0 f6		beq $cc8b			beq _exit
=46					CodeLen	.var *-XtPtr1
=$cc95					Here1 = *	; remember here
>cc65	2e					.byte CodeLen	;patch wh_CodeLength
.cc95					find_name_check:
.cc95	20 67 cc	jsr $cc67			jsr Find_Name
.cc98	b5 25		lda $25,x			lda DStack+1,x		; check that we found a word
.cc9a	f0 01		beq $cc9d			beq _NotFound
.cc9c	60		rts				rts
.cc9d	a9 f3		lda #$f3	_NotFound:	lda #$100+err_UndefinedWord ; complain & quit
.cc9f	4c 63 c4	jmp $c463			jmp ThrowA
.cca2					swl_prepare:
.cca2	20 1b c4	jsr $c41b			jsr underflow_2
.cca5	38		sec				sec			; A= 0 - name start offset
.cca6	b5 24		lda $24,x			lda DStack+0,x
.cca8	e9 80		sbc #$80			sbc #wh_NameLastChar+1
.ccaa	75 26		adc $26,x			adc DStack+2,x		; tmp2= pattern nt
.ccac	85 16		sta $16				sta tmp2+0
.ccae	a9 ff		lda #$ff			lda #$ff
.ccb0	75 27		adc $27,x			adc DStack+3,x
.ccb2	85 17		sta $17				sta tmp2+1
.ccb4	a9 7f		lda #$7f			lda #wh_NameLastChar	; tmp4+0= starting name char index -1
.ccb6	38		sec				sec
.ccb7	f5 24		sbc $24,x			sbc DStack+0,x
.ccb9	85 1a		sta $1a				sta tmp4+0
.ccbb	a0 7f		ldy #$7f			ldy #wh_NameLastChar	; tmp3+0= wh_HashNameLength
.ccbd	b1 16		lda ($16),y			lda (tmp2),y
.ccbf	0a		asl a				asl a
.ccc0	0a		asl a				asl a
.ccc1	0a		asl a				asl a
.ccc2	0a		asl a				asl a
.ccc3	0a		asl a				asl a
.ccc4	15 24		ora $24,x			ora DStack+0,x
.ccc6	85 18		sta $18				sta tmp3+0
.ccc8	4c 6d d5	jmp $d56d			jmp Two_Drop		; Drop addr & u
.cccb					swl_search_wordlist:
.cccb	86 19		stx $19				stx tmp3+1		; save data stack index
.cccd	0a		asl a				asl			; tmp1 = up->wordlists[A]
.ccce	a8		tay				tay
.cccf	be 12 03	ldx $0312,y			ldx WordlistsV+0,y
.ccd2	b9 13 03	lda $0313,y			lda WordlistsV+1,y
.ccd5	d0 15		bne $ccec			bne _word_3		;   not end-of-list?
.ccd7	08		php		_rts:		php
.ccd8	a6 19		ldx $19				ldx tmp3+1		; restore data stack index
.ccda	28		plp				plp
.ccdb	60		rts				rts			; Z= end_of_list
.ccdc					_word_next:
.ccdc	a0 81		ldy #$81			ldy #wh_Flags		; what kind of LinkNt?
.ccde	b1 14		lda ($14),y			lda (tmp1),y
.cce0	a0 83		ldy #$83			ldy #wh_LinkNt
.cce2	29 01		and #$01			and #FP
.cce4	f0 0e		beq $ccf4			beq _LinkShort
.cce6	b1 14		lda ($14),y	_LinkLong:	lda (tmp1),y		; tmp1= tmp1->Wh_LinkNt_word
.cce8	aa		tax				tax
.cce9	c8		iny				iny
.ccea	b1 14		lda ($14),y			lda (tmp1),y
.ccec	85 15		sta $15		_word_3:	sta tmp1+1
.ccee	86 14		stx $14				stx tmp1+0
.ccf0	d0 0d		bne $ccff			bne _Test
.ccf2	f0 e3		beq $ccd7			beq _rts
.ccf4	a5 14		lda $14		_LinkShort:	lda tmp1+0		; tmp1 -= tmp1->wh_LinkNt offset byte
.ccf6	38		sec				sec
.ccf7	f1 14		sbc ($14),y			sbc (tmp1),y
.ccf9	85 14		sta $14				sta tmp1+0
.ccfb	b0 02		bcs $ccff			bcs +
.ccfd	c6 15		dec $15				dec tmp1+1
.ccff					+
.ccff	a0 80		ldy #$80	_Test:		ldy #Wh_HashNameLen	; Are hash & name length the same?
.cd01	b1 14		lda ($14),y			lda (tmp1),y
.cd03	c5 18		cmp $18				cmp tmp3+0
.cd05	d0 d5		bne $ccdc			bne _word_next
.cd07	a4 1a		ldy $1a				ldy tmp4+0		; Y= index of 1st char -1
.cd09	c8		iny		_char_next:	iny			; to next char
.cd0a	30 cb		bmi $ccd7			bmi _rts		; end of string?
.cd0c	b1 16		lda ($16),y			lda (tmp2),y		; char of pattern name
.cd0e	51 14		eor ($14),y			eor (tmp1),y		; char of this word name
.cd10	f0 f7		beq $cd09			beq _char_next		;   exact match?
.cd12	c9 20		cmp #$20			cmp #$20		;   only a case mismatch?
.cd14	d0 c6		bne $ccdc			bne _word_next
.cd16	b1 16		lda ($16),y			lda (tmp2),y		;   verify it is alpha char
.cd18	29 df		and #$df			and #$df
.cd1a	e9 41		sbc #$41			sbc #'A'
.cd1c	c9 1a		cmp #$1a			cmp #'Z'-'A'+1
.cd1e	90 e9		bcc $cd09			bcc _char_next
.cd20	b0 ba		bcs $ccdc			bcs _word_next
>cd22	46 69 6e 64			Name0:	.text "Find"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=52390					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>cd26	84					.byte (("Find"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=195					LinkDisplacement = Nt0-WordListLink
>cd27	10					.byte WordFlags	;wh_Flags
>cd28	03					.byte 3	;wh_CodeLength
>cd29	c3					  .byte LinkDisplacement	; offset to previous nt
=$cd2a					XtPtr1 ::= *
=52390					WordListLink ::= Nt0 ; remember the nt of this word for later
.cd2a					Find:
.cd2a	20 cd df	jsr $dfcd			jsr Dup			; Save caddr in case conversion fails, check underflow
.cd2d	20 d7 c1	jsr $c1d7			jsr Count		; Convert counted string address to modern format
.cd30	20 67 cc	jsr $cc67			jsr Find_Name		; ( caddr nt | 0 ) tmp1=nt
.cd33	b5 25		lda $25,x			lda DStack+1,x		; word found?
.cd35	d0 01		bne $cd38			bne _found_word
.cd37	60		rts				rts			; ( caddr 0 )
.cd38					_found_word:
.cd38	20 c8 d9	jsr $d9c8			jsr Nip			; ( nt )
.cd3b	20 a9 cd	jsr $cda9			jsr Name_To_Int		; ( xt ) tmp1=nt
.cd3e	a0 81		ldy #$81			ldy #Wh_Flags		; immediate?
.cd40	b1 14		lda ($14),y			lda (tmp1),y
.cd42	29 08		and #$08			and #IM
.cd44	d0 03		bne $cd49			bne _immediate
.cd46	4c c4 c7	jmp $c7c4			jmp True		; not immediate, return ( xt -1 )
.cd49	4c fb c7	jmp $c7fb	_immediate:	jmp One			; immediate, return ( xt 1 )
=34					CodeLen	.var *-XtPtr1
=$cd4c					Here1 = *	; remember here
>cd28	22					.byte CodeLen	;patch wh_CodeLength
>cd4c	49 6e 74 3e 4e 61 6d 65		Name0:	.text "Int>Name"	;  name of word as a string, ending at wh_NameLastChar
=8					NameLength = *-Name0
=52436					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>cd54	a8					.byte (("Int>Name"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=46					LinkDisplacement = Nt0-WordListLink
>cd55	10					.byte WordFlags	;wh_Flags
>cd56	03					.byte 3	;wh_CodeLength
>cd57	2e					  .byte LinkDisplacement	; offset to previous nt
=$cd58					XtPtr1 ::= *
=52436					WordListLink ::= Nt0 ; remember the nt of this word for later
.cd58	20 07 c4	jsr $c407	Int_To_Name:	jsr underflow_1
.cd5b	a9 fe		lda #$fe			lda #$100-2		; for each wordlist
.cd5d	85 19		sta $19				sta tmp3+1
.cd5f					_wordlist_next:
.cd5f	a4 19		ldy $19				ldy tmp3+1		; get next wordlist index
.cd61	c8		iny				iny
.cd62	c8		iny				iny
.cd63	84 19		sty $19				sty tmp3+1
.cd65	c0 0c		cpy #$0c			cpy #(Num_OrderV-WordlistsV)/2
.cd67	b0 2b		bcs $cd94			bcs _fail
.cd69	b9 12 03	lda $0312,y			lda WordlistsV+0,y
.cd6c	85 14		sta $14				sta tmp1+0
.cd6e	b9 13 03	lda $0313,y			lda WordlistsV+1,y
.cd71	85 15		sta $15				sta tmp1+1
.cd73	d0 07		bne $cd7c			bne _calc
.cd75	f0 e8		beq $cd5f			beq _wordlist_next
.cd77	20 95 82	jsr $8295	_word_next:	jsr LinkNext		; step to next word
.cd7a	f0 e3		beq $cd5f			beq _wordlist_next
.cd7c	20 b6 cd	jsr $cdb6	_calc:		jsr NameToIntTmp	; tmp2= xt
.cd7f	a5 16		lda $16				lda tmp2+0
.cd81	d5 24		cmp $24,x			cmp DStack+0,x		;  match?
.cd83	d0 f2		bne $cd77			bne _word_next
.cd85	a5 17		lda $17				lda tmp2+1
.cd87	d5 25		cmp $25,x			cmp DStack+1,x
.cd89	d0 ec		bne $cd77			bne _word_next
.cd8b	a5 14		lda $14				lda tmp1+0
.cd8d	95 24		sta $24,x			sta DStack+0,x
.cd8f	a5 15		lda $15				lda tmp1+1
.cd91	95 25		sta $25,x			sta DStack+1,x
.cd93	60		rts				rts			; return P.Z=0
.cd94					_fail:
.cd94	a9 00		lda #$00			lda #0			; return a zero to indicate that we didn't find it.
.cd96	95 24		sta $24,x			sta DStack+0,x
.cd98	95 25		sta $25,x			sta DStack+1,x
.cd9a	85 15		sta $15				sta tmp1+1
.cd9c	60		rts				rts			; return P.Z=1
=69					CodeLen	.var *-XtPtr1
=$cd9d					Here1 = *	; remember here
>cd56	45					.byte CodeLen	;patch wh_CodeLength
>cd9d	4e 61 6d 65 3e 49 6e 74		Name0:	.text "Name>Int"	;  name of word as a string, ending at wh_NameLastChar
=8					NameLength = *-Name0
=52517					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>cda5	88					.byte (("Name>Int"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=81					LinkDisplacement = Nt0-WordListLink
>cda6	10					.byte WordFlags	;wh_Flags
>cda7	03					.byte 3	;wh_CodeLength
>cda8	51					  .byte LinkDisplacement	; offset to previous nt
=$cda9					XtPtr1 ::= *
=52517					WordListLink ::= Nt0 ; remember the nt of this word for later
.cda9	20 e9 c3	jsr $c3e9	Name_To_Int:	jsr PopTmp1
.cdac	20 b6 cd	jsr $cdb6	Name_To_Int_T:	jsr NameToIntTmp
.cdaf	a5 16		lda $16				lda tmp2+0
.cdb1	a4 17		ldy $17				ldy tmp2+1
.cdb3	4c b5 c7	jmp $c7b5			jmp PushYA
=13					CodeLen	.var *-XtPtr1
=$cdb6					Here1 = *	; remember here
>cda7	0d					.byte CodeLen	;patch wh_CodeLength
.cdb6					NameToIntTmp:
.cdb6	a0 81		ldy #$81			ldy #wh_Flags
.cdb8	b1 14		lda ($14),y			lda (tmp1),y
.cdba	29 02		and #$02			and #DB			; has XT ptr?
.cdbc	d0 12		bne $cdd0			bne _HasXtPtr
.cdbe	b1 14		lda ($14),y			lda (tmp1),y		; A= header length
.cdc0	29 03		and #$03			and #DB+FP
.cdc2	18		clc				clc
.cdc3	69 84		adc #$84			adc #wh_LinkNt+1
.cdc5	65 14		adc $14				adc tmp1+0		; TOS=tmp1+A
.cdc7	85 16		sta $16				sta tmp2+0
.cdc9	a9 00		lda #$00			lda #0
.cdcb	65 15		adc $15				adc tmp1+1
.cdcd	85 17		sta $17				sta tmp2+1
.cdcf	60		rts				rts
.cdd0	b1 14		lda ($14),y	_HasXtPtr:	lda (tmp1),y		; get wh_Flags again
.cdd2	a0 84		ldy #$84			ldy #wh_LinkNt+1
.cdd4	29 01		and #$01			and #FP			; has long LinkNt ?
.cdd6	f0 01		beq $cdd9			beq _short
.cdd8	c8		iny				iny			;   skip extra byte
.cdd9	b1 14		lda ($14),y	_short:		lda (tmp1),y		; tmp2= xt pointer
.cddb	85 16		sta $16				sta tmp2+0
.cddd	c8		iny				iny
.cdde	b1 14		lda ($14),y			lda (tmp1),y
.cde0	85 17		sta $17				sta tmp2+1
.cde2	60		rts				rts
>cde3	4e 61 6d 65 3e 53 74 72		Name0:	.text "Name>String"	;  name of word as a string, ending at wh_NameLastChar
>cdeb	69 6e 67
=11					NameLength = *-Name0
=52590					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>cdee	eb					.byte (("Name>String"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=73					LinkDisplacement = Nt0-WordListLink
>cdef	10					.byte WordFlags	;wh_Flags
>cdf0	03					.byte 3	;wh_CodeLength
>cdf1	49					  .byte LinkDisplacement	; offset to previous nt
=$cdf2					XtPtr1 ::= *
=52590					WordListLink ::= Nt0 ; remember the nt of this word for later
.cdf2	20 de c3	jsr $c3de	Name_To_String:	jsr PopYA
.cdf5					Name_To_String_YA:
.cdf5	85 14		sta $14				sta tmp1+0		; tmp1= nt
.cdf7	84 15		sty $15				sty tmp1+1
.cdf9	20 b5 c7	jsr $c7b5			jsr PushYA		; ( nt )
.cdfc	a0 80		ldy #$80			ldy #Wh_HashNameLen	; A= name length
.cdfe	b1 14		lda ($14),y			lda (tmp1),y
.ce00	29 1f		and #$1f			and #wh_NameLengthMask
.ce02	48		pha				pha			; save string length
.ce03	49 ff		eor #$ff			eor #$ff
.ce05	38		sec				sec
.ce06	69 80		adc #$80			adc #Wh_NameLastChar+1	; calc string start offset
.ce08	20 43 da	jsr $da43			jsr Plus_A		; calc string start addr
.ce0b	68		pla				pla			; push string length
.ce0c	4c e4 c7	jmp $c7e4			jmp PushZA
=29					CodeLen	.var *-XtPtr1
=$ce0f					Here1 = *	; remember here
>cdf0	1d					.byte CodeLen	;patch wh_CodeLength
>ce0f	3e 42 6f 64 79			Name0:	.text ">Body"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=52628					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>ce14	25					.byte ((">Body"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=38					LinkDisplacement = Nt0-WordListLink
>ce15	10					.byte WordFlags	;wh_Flags
>ce16	03					.byte 3	;wh_CodeLength
>ce17	26					  .byte LinkDisplacement	; offset to previous nt
=$ce18					XtPtr1 ::= *
=52628					WordListLink ::= Nt0 ; remember the nt of this word for later
.ce18	a9 03		lda #$03	To_Body:	lda #3		; PFA is after the beginning JSR abs
.ce1a	4c 43 da	jmp $da43			jmp Plus_A
=5					CodeLen	.var *-XtPtr1
=$ce1d					Here1 = *	; remember here
>ce16	05					.byte CodeLen	;patch wh_CodeLength
.ce1d	4c 2a c4	jmp $c42a	Throw_Stack_07: jmp Throw_Stack
>ce20	45 72 61 73 65			Name0:	.text "Erase"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=52645					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>ce25	a5					.byte (("Erase"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=17					LinkDisplacement = Nt0-WordListLink
>ce26	10					.byte WordFlags	;wh_Flags
>ce27	03					.byte 3	;wh_CodeLength
>ce28	11					  .byte LinkDisplacement	; offset to previous nt
=$ce29					XtPtr1 ::= *
=52645					WordListLink ::= Nt0 ; remember the nt of this word for later
.ce29					Erase:
.ce29	20 f2 c7	jsr $c7f2			jsr Zero
.ce2c	4c 46 ce	jmp $ce46			jmp Fill
=6					CodeLen	.var *-XtPtr1
=$ce2f					Here1 = *	; remember here
>ce27	06					.byte CodeLen	;patch wh_CodeLength
>ce2f	42 6c 61 6e 6b			Name0:	.text "Blank"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=52660					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>ce34	65					.byte (("Blank"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=15					LinkDisplacement = Nt0-WordListLink
>ce35	10					.byte WordFlags	;wh_Flags
>ce36	03					.byte 3	;wh_CodeLength
>ce37	0f					  .byte LinkDisplacement	; offset to previous nt
=$ce38					XtPtr1 ::= *
=52660					WordListLink ::= Nt0 ; remember the nt of this word for later
.ce38					Blank:
.ce38	20 0e c8	jsr $c80e			jsr Bl
.ce3b	4c 46 ce	jmp $ce46			jmp Fill
=6					CodeLen	.var *-XtPtr1
=$ce3e					Here1 = *	; remember here
>ce36	06					.byte CodeLen	;patch wh_CodeLength
>ce3e	46 69 6c 6c			Name0:	.text "Fill"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=52674					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>ce42	84					.byte (("Fill"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=14					LinkDisplacement = Nt0-WordListLink
>ce43	10					.byte WordFlags	;wh_Flags
>ce44	03					.byte 3	;wh_CodeLength
>ce45	0e					  .byte LinkDisplacement	; offset to previous nt
=$ce46					XtPtr1 ::= *
=52674					WordListLink ::= Nt0 ; remember the nt of this word for later
.ce46					Fill:
.ce46	e0 23		cpx #$23		cpx #(DDim-3)*2+1	; far enough below end of data stack (& not negative)?
.ce48	b0 d3		bcs $ce1d		bcs Throw_Stack_07
.ce4a	b5 28		lda $28,x			lda DStack+4,x		; tmp1= address
.ce4c	85 14		sta $14				sta tmp1+0
.ce4e	b5 29		lda $29,x			lda DStack+5,x
.ce50	85 15		sta $15				sta tmp1+1
.ce52	b5 26		lda $26,x			lda DStack+2,x		; tmp2= counter.lo
.ce54	85 16		sta $16				sta tmp2+0
.ce56	f6 27		inc $27,x			inc DStack+3,x		; so decrement & test for 0 works
.ce58	b5 24		lda $24,x			lda DStack+0,x		; A= fill byte
.ce5a	a0 00		ldy #$00			ldy #0
.ce5c	c4 16		cpy $16		_loop:		cpy tmp2+0		; done?
.ce5e	f0 09		beq $ce69			beq _test2
.ce60	91 14		sta ($14),y	_3:		sta (tmp1),y		; store a byte
.ce62	c8		iny				iny			; to next byte
.ce63	d0 f7		bne $ce5c			bne _loop
.ce65	e6 15		inc $15				inc tmp1+1		; increment addr page
.ce67	d0 f3		bne $ce5c			bne _loop
.ce69	d6 27		dec $27,x	_test2:		dec DStack+3,x		; any more pages?
.ce6b	d0 f3		bne $ce60			bne _3
.ce6d	4c 6d bd	jmp $bd6d			jmp ThreeDrop	; Drop three cells off the Data Stack.
=42					CodeLen	.var *-XtPtr1
=$ce70					Here1 = *	; remember here
>ce44	2a					.byte CodeLen	;patch wh_CodeLength
>ce70	56 61 72 69 61 62 6c 65		Name0:	.text "Variable"	;  name of word as a string, ending at wh_NameLastChar
=8					NameLength = *-Name0
=52728					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>ce78	a8					.byte (("Variable"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=54					LinkDisplacement = Nt0-WordListLink
>ce79	10					.byte WordFlags	;wh_Flags
>ce7a	03					.byte 3	;wh_CodeLength
>ce7b	36					  .byte LinkDisplacement	; offset to previous nt
=$ce7c					XtPtr1 ::= *
=52728					WordListLink ::= Nt0 ; remember the nt of this word for later
.ce7c	20 c8 d1	jsr $d1c8	Variable:	jsr Create		; compile word header & push PFA
.ce7f	a9 00		lda #$00	Z_Comma:	lda #0			; allot & initialize the variable's data
.ce81	a8		tay				tay
.ce82	4c 50 dd	jmp $dd50			jmp Comma_YA
=9					CodeLen	.var *-XtPtr1
=$ce85					Here1 = *	; remember here
>ce7a	09					.byte CodeLen	;patch wh_CodeLength
>ce85	32 56 61 72 69 61 62 6c		Name0:	.text "2Variable"	;  name of word as a string, ending at wh_NameLastChar
>ce8d	65
=9					NameLength = *-Name0
=52750					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>ce8e	a9					.byte (("2Variable"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=22					LinkDisplacement = Nt0-WordListLink
>ce8f	10					.byte WordFlags	;wh_Flags
>ce90	03					.byte 3	;wh_CodeLength
>ce91	16					  .byte LinkDisplacement	; offset to previous nt
=$ce92					XtPtr1 ::= *
=52750					WordListLink ::= Nt0 ; remember the nt of this word for later
.ce92	20 7c ce	jsr $ce7c	Two_variable:	jsr Variable		; compile word header & push PFA & 1st cell of data
.ce95	4c 7f ce	jmp $ce7f			jmp Z_Comma		; alloc & init 2nd cell of data
=6					CodeLen	.var *-XtPtr1
=$ce98					Here1 = *	; remember here
>ce90	06					.byte CodeLen	;patch wh_CodeLength
>ce98	43 6f 6e 73 74 61 6e 74		Name0:	.text "Constant"	;  name of word as a string, ending at wh_NameLastChar
=8					NameLength = *-Name0
=52768					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>cea0	88					.byte (("Constant"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=80					WordFlags ::= UF+NN	; modifiable copy, remember for later
=18					LinkDisplacement = Nt0-WordListLink
>cea1	50					.byte WordFlags	;wh_Flags
>cea2	03					.byte 3	;wh_CodeLength
>cea3	12					  .byte LinkDisplacement	; offset to previous nt
=$cea4					XtPtr1 ::= *
=52768					WordListLink ::= Nt0 ; remember the nt of this word for later
.cea4	20 07 c4	jsr $c407	Constant:	jsr underflow_1
.cea7	20 1b d1	jsr $d11b			jsr Header_Comma	; compile word header
.ceaa	20 5b c7	jsr $c75b			jsr LitCompile		; compile code to load registers, & pick a subroutine
.cead	20 90 dd	jsr $dd90			jsr Jmp_Comma_NT_YA	; compile code to JMP to the subroutine
.ceb0	4c db cb	jmp $cbdb			jmp adjust_z		; fix word length
=15					CodeLen	.var *-XtPtr1
=$ceb3					Here1 = *	; remember here
>cea2	0f					.byte CodeLen	;patch wh_CodeLength
>ceb3	32 43 6f 6e 73 74 61 6e		Name0:	.text "2Constant"	;  name of word as a string, ending at wh_NameLastChar
>cebb	74
=9					NameLength = *-Name0
=52796					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>cebc	89					.byte (("2Constant"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=28					LinkDisplacement = Nt0-WordListLink
>cebd	10					.byte WordFlags	;wh_Flags
>cebe	03					.byte 3	;wh_CodeLength
>cebf	1c					  .byte LinkDisplacement	; offset to previous nt
=$cec0					XtPtr1 ::= *
=52796					WordListLink ::= Nt0 ; remember the nt of this word for later
.cec0					Two_constant:
.cec0	4c e9 ce	jmp $cee9			jmp TwoValue
=3					CodeLen	.var *-XtPtr1
=$cec3					Here1 = *	; remember here
>cebe	03					.byte CodeLen	;patch wh_CodeLength
>cec3	56 61 6c 75 65			Name0:	.text "Value"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=52808					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>cec8	a5					.byte (("Value"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=12					LinkDisplacement = Nt0-WordListLink
>cec9	10					.byte WordFlags	;wh_Flags
>ceca	03					.byte 3	;wh_CodeLength
>cecb	0c					  .byte LinkDisplacement	; offset to previous nt
=$cecc					XtPtr1 ::= *
=52808					WordListLink ::= Nt0 ; remember the nt of this word for later
.cecc	20 07 c4	jsr $c407	Value:		jsr underflow_1
.cecf	20 1b d1	jsr $d11b			jsr Header_Comma	; compile word header
.ced2	20 9c c7	jsr $c79c			jsr ldya_immed_comma	; compile lda # & ldy #
.ced5	a9 b5		lda #$b5			lda #<PushYA		; compile jmp PushYA
.ced7	a0 c7		ldy #$c7			ldy #>PushYA
.ced9	20 89 dd	jsr $dd89			jsr Jmp_Comma_YA
.cedc	4c db cb	jmp $cbdb			jmp adjust_z		; fix word length
=19					CodeLen	.var *-XtPtr1
=$cedf					Here1 = *	; remember here
>ceca	13					.byte CodeLen	;patch wh_CodeLength
>cedf	32 56 61 6c 75 65		Name0:	.text "2Value"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=52837					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>cee5	a6					.byte (("2Value"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=29					LinkDisplacement = Nt0-WordListLink
>cee6	10					.byte WordFlags	;wh_Flags
>cee7	03					.byte 3	;wh_CodeLength
>cee8	1d					  .byte LinkDisplacement	; offset to previous nt
=$cee9					XtPtr1 ::= *
=52837					WordListLink ::= Nt0 ; remember the nt of this word for later
.cee9	20 1b d1	jsr $d11b	TwoValue:	jsr Header_Comma	; compile word header
.ceec	a9 f9		lda #$f9			lda #<TwoValue_Runtime	; compile JSR TValue_Runtime
.ceee	a0 ce		ldy #$ce			ldy #>TwoValue_Runtime
.cef0	20 73 dd	jsr $dd73			jsr Jsr_Comma_YA
.cef3	20 db cb	jsr $cbdb			jsr adjust_z		; fix word length
.cef6	4c 5d dd	jmp $dd5d			jmp Two_Comma		; compile the value, return
=16					CodeLen	.var *-XtPtr1
=$cef9					Here1 = *	; remember here
>cee7	10					.byte CodeLen	;patch wh_CodeLength
.cef9					TwoValue_Runtime:
.cef9	68		pla				pla			; pop RTS addr
.cefa	85 14		sta $14				sta tmp1+0
.cefc	68		pla				pla
.cefd	85 15		sta $15				sta tmp1+1
.ceff	a0 01		ldy #$01			ldy #1			; start at offset 1 (for RTS addr behavior)
.cf01	4c e9 d5	jmp $d5e9			jmp Two_Fetch_Tmp1Y	; fetch the data, return
>cf04	54 6f				Name0:	.text "To"	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=52870					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>cf06	e2					.byte (("To"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=24					WordFlags ::= NN+IM	; modifiable copy, remember for later
=33					LinkDisplacement = Nt0-WordListLink
>cf07	18					.byte WordFlags	;wh_Flags
>cf08	03					.byte 3	;wh_CodeLength
>cf09	21					  .byte LinkDisplacement	; offset to previous nt
=$cf0a					XtPtr1 ::= *
=52870					WordListLink ::= Nt0 ; remember the nt of this word for later
.cf0a					To:
.cf0a	20 41 cc	jsr $cc41			jsr Tick		; We always need the xt of the target word
.cf0d	b5 24		lda $24,x			lda DStack+0,x		; tmp1= xt
.cf0f	b4 25		ldy $25,x			ldy DStack+1,x
.cf11	85 14		sta $14				sta tmp1+0
.cf13	84 15		sty $15				sty tmp1+1
.cf15	a0 00		ldy #$00			ldy #0			; determine what type xt points at
.cf17	b1 14		lda ($14),y			lda (tmp1),y
.cf19	c9 a0		cmp #$a0			cmp #$a0		;   LDY #
.cf1b	d0 38		bne $cf55			bne _Test2
.cf1d	a5 0a		lda $0a				lda state		; check compile state
.cf1f	f0 20		beq $cf41			beq _Value_interpret
.cf21	a9 de		lda #$de			lda #<PopYA		; compile jsr PopYA
.cf23	a0 c3		ldy #$c3			ldy #>PopYA
.cf25	20 73 dd	jsr $dd73			jsr Jsr_Comma_YA
.cf28	a9 8c		lda #$8c			lda #$8C		; compile STY xt+1
.cf2a	20 39 dd	jsr $dd39			jsr C_Comma_A
.cf2d	20 95 da	jsr $da95			jsr One_plus
.cf30	20 cd df	jsr $dfcd			jsr Dup
.cf33	20 4d dd	jsr $dd4d			jsr Comma
.cf36	a9 8d		lda #$8d			lda #$8D		; compile STA xt+3
.cf38	20 39 dd	jsr $dd39			jsr C_Comma_A
.cf3b	20 41 da	jsr $da41			jsr Cell_Plus
.cf3e	4c 4d dd	jmp $dd4d			jmp Comma
.cf41					_Value_interpret:
.cf41	20 1b c4	jsr $c41b			jsr underflow_2		; ( n xt )
.cf44	e8		inx				inx			; Drop xt
.cf45	e8		inx				inx
.cf46	b5 24		lda $24,x			lda DStack+0,x		; LSB
.cf48	a0 03		ldy #$03			ldy #3			;   modify LDA # data
.cf4a	91 14		sta ($14),y			sta (tmp1),y
.cf4c	b5 25		lda $25,x			lda DStack+1,x		; MSB
.cf4e	a0 01		ldy #$01			ldy #1			;   modify LDY # data
.cf50	91 14		sta ($14),y			sta (tmp1),y
.cf52	e8		inx				inx			; Drop n
.cf53	e8		inx				inx
.cf54	60		rts				rts
.cf55	c9 20		cmp #$20	_Test2:		cmp #$20		;   JSR abs ?
.cf57	d0 48		bne $cfa1			bne _Err
.cf59	a9 03		lda #$03			lda #3			; advance xt over the JSR abs to the data
.cf5b	20 43 da	jsr $da43			jsr Plus_A
.cf5e	a0 01		ldy #$01			ldy #1			; get JSR abs addr lo byte
.cf60	b1 14		lda ($14),y			lda (tmp1),y
.cf62	c9 f9		cmp #$f9			cmp #<TwoValue_Runtime
.cf64	d0 11		bne $cf77			bne _Test3
.cf66	a5 0a		lda $0a				lda state		; check compile state
.cf68	f0 0a		beq $cf74			beq _2Value_runtime
.cf6a	20 9c c7	jsr $c79c			jsr ldya_immed_comma	; compile LDY #; LDA #  of xt+3
.cf6d	a9 b8		lda #$b8			lda #<Two_Store_YA
.cf6f	a0 d5		ldy #$d5			ldy #>Two_Store_YA
.cf71	4c 73 dd	jmp $dd73			jmp Jsr_Comma_YA	; compile JSR Two_Store_YA; return
.cf74	4c b5 d5	jmp $d5b5	_2Value_runtime: jmp Two_Store
.cf77					_Test3:
.cf77	c9 5e		cmp #$5e			cmp #<FValue_runtime
.cf79	d0 11		bne $cf8c			bne _Test4
.cf7b	a5 0a		lda $0a				lda state		; check compile state
.cf7d	f0 0a		beq $cf89			beq _FValue_interpret
.cf7f	20 9c c7	jsr $c79c			jsr ldya_immed_comma	; compile LDY #; LDA #  of xt+3
.cf82	a9 7f		lda #$7f			lda #<FStore_YA
.cf84	a0 86		ldy #$86			ldy #>FStore_YA
.cf86	4c 73 dd	jmp $dd73			jmp Jsr_Comma_YA	; compile JSR FStore_YA; return
.cf89	4c 7c 86	jmp $867c	_FValue_interpret: jmp FStore
.cf8c					_Test4:
.cf8c	c9 d7		cmp #$d7			cmp #<EValue_runtime
.cf8e	d0 11		bne $cfa1			bne _Err
.cf90	a5 0a		lda $0a				lda state		; check compile state
.cf92	f0 0a		beq $cf9e			beq _EValue_interpret
.cf94	20 9c c7	jsr $c79c			jsr ldya_immed_comma	; compile LDY #; LDA #  of xt+3
.cf97	a9 0e		lda #$0e			lda #<EStore_YA
.cf99	a0 9c		ldy #$9c			ldy #>EStore_YA
.cf9b	4c 73 dd	jmp $dd73			jmp Jsr_Comma_YA	; compile JSR EStore_YA; return
.cf9e	4c 0b 9c	jmp $9c0b	_EValue_interpret: jmp EStore
.cfa1	a9 e0		lda #$e0	_Err:		lda #$100+err_InvalidName ; unrecognized type.
.cfa3	20 63 c4	jsr $c463			jsr ThrowA
=156					CodeLen	.var *-XtPtr1
=$cfa6					Here1 = *	; remember here
>cf08	9c					.byte CodeLen	;patch wh_CodeLength
>cfa6	44 4d 61 78			Name0:	.text "DMax"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=53034					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>cfaa	04					.byte (("DMax"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=164					LinkDisplacement = Nt0-WordListLink
>cfab	10					.byte WordFlags	;wh_Flags
>cfac	03					.byte 3	;wh_CodeLength
>cfad	a4					  .byte LinkDisplacement	; offset to previous nt
=$cfae					XtPtr1 ::= *
=53034					WordListLink ::= Nt0 ; remember the nt of this word for later
.cfae	a9 80		lda #$80	DMax:		lda #$80
.cfb0	d0 0d		bne $cfbf			bne DMin3
=4					CodeLen	.var *-XtPtr1
=$cfb2					Here1 = *	; remember here
>cfac	04					.byte CodeLen	;patch wh_CodeLength
.cfb2	4c 2a c4	jmp $c42a	Throw_Stack_23: jmp Throw_Stack
>cfb5	44 4d 69 6e			Name0:	.text "DMin"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=53049					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>cfb9	c4					.byte (("DMin"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=15					LinkDisplacement = Nt0-WordListLink
>cfba	10					.byte WordFlags	;wh_Flags
>cfbb	03					.byte 3	;wh_CodeLength
>cfbc	0f					  .byte LinkDisplacement	; offset to previous nt
=$cfbd					XtPtr1 ::= *
=53049					WordListLink ::= Nt0 ; remember the nt of this word for later
.cfbd	a9 00		lda #$00	DMin:		lda #0
.cfbf	85 16		sta $16		DMin3:		sta tmp2	; save sign correction
.cfc1	e0 21		cpx #$21		cpx #(DDim-4)*2+1	; far enough below end of data stack (& not negative)?
.cfc3	b0 ed		bcs $cfb2		bcs Throw_Stack_23
.cfc5	b5 26		lda $26,x			lda DStack+2,x	; compare
.cfc7	d5 2a		cmp $2a,x			cmp DStack+6,x
.cfc9	b5 27		lda $27,x			lda DStack+3,x
.cfcb	f5 2b		sbc $2b,x			sbc DStack+7,x
.cfcd	b5 24		lda $24,x			lda DStack+0,x
.cfcf	f5 28		sbc $28,x			sbc DStack+4,x
.cfd1	b5 25		lda $25,x			lda DStack+1,x
.cfd3	f5 29		sbc $29,x			sbc DStack+5,x
.cfd5	50 02		bvc $cfd9			bvc +
.cfd7	49 80		eor #$80			eor #$80	; fix sign
.cfd9	45 16		eor $16		+		eor tmp2
.cfdb	30 0f		bmi $cfec			bmi TwoNip_nouf	; if negative, NOS is larger and needs to be kept
.cfdd	4c 6d d5	jmp $d56d			jmp Two_Drop
=35					CodeLen	.var *-XtPtr1
=$cfe0					Here1 = *	; remember here
>cfbb	23					.byte CodeLen	;patch wh_CodeLength
>cfe0	32 4e 69 70			Name0:	.text "2Nip"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=53092					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>cfe4	04					.byte (("2Nip"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=43					LinkDisplacement = Nt0-WordListLink
>cfe5	10					.byte WordFlags	;wh_Flags
>cfe6	03					.byte 3	;wh_CodeLength
>cfe7	2b					  .byte LinkDisplacement	; offset to previous nt
=$cfe8					XtPtr1 ::= *
=53092					WordListLink ::= Nt0 ; remember the nt of this word for later
.cfe8					TwoNip:
.cfe8	e0 21		cpx #$21		cpx #(DDim-4)*2+1	; far enough below end of data stack (& not negative)?
.cfea	b0 62		bcs $d04e		bcs Throw_Stack_25
.cfec	b5 24		lda $24,x	TwoNip_NoUf:	lda DStack+0,x	; copy dTOS to dNOS
.cfee	95 28		sta $28,x			sta DStack+4,x
.cff0	b5 25		lda $25,x			lda DStack+1,x
.cff2	95 29		sta $29,x			sta DStack+5,x
.cff4	b5 26		lda $26,x			lda DStack+2,x
.cff6	95 2a		sta $2a,x			sta DStack+6,x
.cff8	b5 27		lda $27,x			lda DStack+3,x
.cffa	95 2b		sta $2b,x			sta DStack+7,x
.cffc	4c 6d d5	jmp $d56d			jmp Two_Drop
=23					CodeLen	.var *-XtPtr1
=$cfff					Here1 = *	; remember here
>cfe6	17					.byte CodeLen	;patch wh_CodeLength
>cfff	53 3e 44			Name0:	.text "S>D"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=53122					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>d002	83					.byte (("S>D"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=30					LinkDisplacement = Nt0-WordListLink
>d003	10					.byte WordFlags	;wh_Flags
>d004	03					.byte 3	;wh_CodeLength
>d005	1e					  .byte LinkDisplacement	; offset to previous nt
=$d006					XtPtr1 ::= *
=53122					WordListLink ::= Nt0 ; remember the nt of this word for later
.d006					S_To_D:
.d006	e0 27		cpx #$27		cpx #(DDim-1)*2+1	; far enough below end of data stack (& not negative)?
.d008	b0 44		bcs $d04e		bcs Throw_Stack_25
.d00a	a0 00		ldy #$00			ldy #0			; assume positive
.d00c	b5 25		lda $25,x			lda DStack+1,x		; test n
.d00e	10 01		bpl $d011			bpl +
.d010	88		dey				dey			; make negative
.d011					+
.d011	ca		dex				dex			; push new hi cell
.d012	ca		dex				dex
.d013	94 24		sty $24,x			sty DStack+0,x
.d015	94 25		sty $25,x			sty DStack+1,x
=17					CodeLen	.var *-XtPtr1
=$d017					Here1 = *	; remember here
>d004	11					.byte CodeLen	;patch wh_CodeLength
.d017	60		rts				rts
>d018	44 3e 53			Name0:	.text "D>S"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=53147					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>d01b	63					.byte (("D>S"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=25					LinkDisplacement = Nt0-WordListLink
>d01c	10					.byte WordFlags	;wh_Flags
>d01d	03					.byte 3	;wh_CodeLength
>d01e	19					  .byte LinkDisplacement	; offset to previous nt
=$d01f					XtPtr1 ::= *
=53147					WordListLink ::= Nt0 ; remember the nt of this word for later
.d01f					D_To_S:
.d01f	e0 25		cpx #$25		cpx #(DDim-2)*2+1	; far enough below end of data stack (& not negative)?
.d021	b0 2b		bcs $d04e		bcs Throw_Stack_25
.d023	e8		inx				inx		; Drop hi cell
.d024	e8		inx				inx
=6					CodeLen	.var *-XtPtr1
=$d025					Here1 = *	; remember here
>d01d	06					.byte CodeLen	;patch wh_CodeLength
.d025	60		rts				rts
>d026	44 2d				Name0:	.text "D-"	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=53160					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>d028	a2					.byte (("D-"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>d029	10					.byte WordFlags	;wh_Flags
>d02a	03					.byte 3	;wh_CodeLength
>d02b	0d					  .byte LinkDisplacement	; offset to previous nt
=$d02c					XtPtr1 ::= *
=53160					WordListLink ::= Nt0 ; remember the nt of this word for later
.d02c					D_Minus:
.d02c	e0 21		cpx #$21		cpx #(DDim-4)*2+1	; far enough below end of data stack (& not negative)?
.d02e	b0 1e		bcs $d04e		bcs Throw_Stack_25
.d030	38		sec				sec
.d031	b5 2a		lda $2a,x			lda DStack+6,x	; LSB of lower word
.d033	f5 26		sbc $26,x			sbc DStack+2,x
.d035	95 2a		sta $2a,x			sta DStack+6,x
.d037	b5 2b		lda $2b,x			lda DStack+7,x	; MSB of lower word
.d039	f5 27		sbc $27,x			sbc DStack+3,x
.d03b	95 2b		sta $2b,x			sta DStack+7,x
.d03d	b5 28		lda $28,x			lda DStack+4,x	; LSB of upper word
.d03f	f5 24		sbc $24,x			sbc DStack+0,x
.d041	95 28		sta $28,x			sta DStack+4,x
.d043	b5 29		lda $29,x			lda DStack+5,x	; MSB of upper word
.d045	f5 25		sbc $25,x			sbc DStack+1,x
.d047	95 29		sta $29,x			sta DStack+5,x
.d049	e8		inx				inx
.d04a	e8		inx				inx
.d04b	e8		inx				inx
.d04c	e8		inx				inx
=33					CodeLen	.var *-XtPtr1
=$d04d					Here1 = *	; remember here
>d02a	21					.byte CodeLen	;patch wh_CodeLength
.d04d	60		rts				rts
.d04e	4c 2a c4	jmp $c42a	Throw_Stack_25: jmp Throw_Stack
>d051	44 2b				Name0:	.text "D+"	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=53203					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>d053	62					.byte (("D+"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=43					LinkDisplacement = Nt0-WordListLink
>d054	10					.byte WordFlags	;wh_Flags
>d055	03					.byte 3	;wh_CodeLength
>d056	2b					  .byte LinkDisplacement	; offset to previous nt
=$d057					XtPtr1 ::= *
=53203					WordListLink ::= Nt0 ; remember the nt of this word for later
.d057					D_Plus:
.d057	e0 21		cpx #$21		cpx #(DDim-4)*2+1	; far enough below end of data stack (& not negative)?
.d059	b0 f3		bcs $d04e		bcs Throw_Stack_25
.d05b	b5 26		lda $26,x			lda DStack+2,x	; LSB of lower word
.d05d	75 2a		adc $2a,x			adc DStack+6,x
.d05f	95 2a		sta $2a,x			sta DStack+6,x
.d061	b5 27		lda $27,x			lda DStack+3,x	; MSB of lower word
.d063	75 2b		adc $2b,x			adc DStack+7,x
.d065	95 2b		sta $2b,x			sta DStack+7,x
.d067	b5 24		lda $24,x			lda DStack+0,x	; LSB of upper word
.d069	75 28		adc $28,x			adc DStack+4,x
.d06b	95 28		sta $28,x			sta DStack+4,x
.d06d	b5 25		lda $25,x			lda DStack+1,x	; MSB of upper word
.d06f	75 29		adc $29,x			adc DStack+5,x
.d071	95 29		sta $29,x			sta DStack+5,x
.d073	e8		inx				inx
.d074	e8		inx				inx
.d075	e8		inx				inx
.d076	e8		inx				inx
=32					CodeLen	.var *-XtPtr1
=$d077					Here1 = *	; remember here
>d055	20					.byte CodeLen	;patch wh_CodeLength
.d077	60		rts				rts
>d078	44 31 2b			Name0:	.text "D1+"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=53243					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>d07b	63					.byte (("D1+"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=40					LinkDisplacement = Nt0-WordListLink
>d07c	10					.byte WordFlags	;wh_Flags
>d07d	03					.byte 3	;wh_CodeLength
>d07e	28					  .byte LinkDisplacement	; offset to previous nt
=$d07f					XtPtr1 ::= *
=53243					WordListLink ::= Nt0 ; remember the nt of this word for later
.d07f					D1Plus:
.d07f	e0 21		cpx #$21		cpx #(DDim-4)*2+1	; far enough below end of data stack (& not negative)?
.d081	b0 cb		bcs $d04e		bcs Throw_Stack_25
.d083	f6 26		inc $26,x			inc DStack+2,x
.d085	d0 0a		bne $d091			bne +
.d087	f6 27		inc $27,x			inc DStack+3,x
.d089	d0 06		bne $d091			bne +
.d08b	f6 24		inc $24,x			inc DStack+0,x
.d08d	d0 02		bne $d091			bne +
.d08f	f6 25		inc $25,x			inc DStack+1,x
.d091					+
=18					CodeLen	.var *-XtPtr1
=$d091					Here1 = *	; remember here
>d07d	12					.byte CodeLen	;patch wh_CodeLength
.d091	60		rts				rts
>d092	44 31 2d			Name0:	.text "D1-"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=53269					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>d095	a3					.byte (("D1-"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=26					LinkDisplacement = Nt0-WordListLink
>d096	10					.byte WordFlags	;wh_Flags
>d097	03					.byte 3	;wh_CodeLength
>d098	1a					  .byte LinkDisplacement	; offset to previous nt
=$d099					XtPtr1 ::= *
=53269					WordListLink ::= Nt0 ; remember the nt of this word for later
.d099					D1Minus:
.d099	e0 21		cpx #$21		cpx #(DDim-4)*2+1	; far enough below end of data stack (& not negative)?
.d09b	b0 b1		bcs $d04e		bcs Throw_Stack_25
.d09d	b5 26		lda $26,x			lda DStack+2,x
.d09f	d0 0e		bne $d0af			bne _1
.d0a1	b5 27		lda $27,x			lda DStack+3,x
.d0a3	d0 08		bne $d0ad			bne _2
.d0a5	b5 24		lda $24,x			lda DStack+0,x
.d0a7	d0 02		bne $d0ab			bne _3
.d0a9	d6 25		dec $25,x			dec DStack+1,x
.d0ab	d6 24		dec $24,x	_3:		dec DStack+0,x
.d0ad	d6 27		dec $27,x	_2:		dec DStack+3,x
.d0af	d6 26		dec $26,x	_1:		dec DStack+2,x
=24					CodeLen	.var *-XtPtr1
=$d0b1					Here1 = *	; remember here
>d097	18					.byte CodeLen	;patch wh_CodeLength
.d0b1	60		rts				rts
.d0b2	20 e4 c7	jsr $c7e4	Allot_ZA:	jsr PushZA
.d0b5	4c c1 d0	jmp $d0c1			jmp Allot
>d0b8	41 6c 6c 6f 74			Name0:	.text "Allot"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=53309					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>d0bd	85					.byte (("Allot"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=40					LinkDisplacement = Nt0-WordListLink
>d0be	10					.byte WordFlags	;wh_Flags
>d0bf	03					.byte 3	;wh_CodeLength
>d0c0	28					  .byte LinkDisplacement	; offset to previous nt
=$d0c1					XtPtr1 ::= *
=53309					WordListLink ::= Nt0 ; remember the nt of this word for later
.d0c1					Allot:
.d0c1	e0 27		cpx #$27		cpx #(DDim-1)*2+1	; far enough below end of data stack (& not negative)?
.d0c3	b0 89		bcs $d04e		bcs Throw_Stack_25
.d0c5	18		clc				clc			; adjust cp
.d0c6	b5 24		lda $24,x			lda DStack+0,x
.d0c8	65 00		adc $00				adc cp+0
.d0ca	85 00		sta $00				sta cp+0
.d0cc	a8		tay				tay			;   save lo byte
.d0cd	b5 25		lda $25,x			lda DStack+1,x
.d0cf	85 14		sta $14				sta tmp1
.d0d1	65 01		adc $01				adc cp+1
.d0d3	85 01		sta $01				sta cp+1
.d0d5	24 14		bit $14				bit tmp1
.d0d7	30 15		bmi $d0ee			bmi _release
.d0d9	b0 06		bcs $d0e1			bcs _pos_err		; carry from the add is bad
=32600					_last = cp_end-2*PadOffset
.d0db	c0 58		cpy #$58			cpy #<_last		; cp < cp_end ?
.d0dd	e9 7f		sbc #$7f			sbc #>_last
.d0df	90 2c		bcc $d10d			bcc _done		; we're fine.
.d0e1					_pos_err:
.d0e1	a9 58		lda #$58			lda #<_last
.d0e3	85 00		sta $00				sta cp+0
.d0e5	a9 7f		lda #$7f			lda #>_last
.d0e7	85 01		sta $01				sta cp+1
.d0e9	a9 c5		lda #$c5			lda #$100+err_Allocate
.d0eb	4c 63 c4	jmp $c463			jmp ThrowA
.d0ee					_release:
.d0ee	90 06		bcc $d0f6			bcc _neg_err		; borrow indicates we've gone below 0
.d0f0	c0 66		cpy #$66			cpy #<cp0
.d0f2	e9 0b		sbc #$0b			sbc #>cp0
.d0f4	b0 17		bcs $d10d			bcs _done
.d0f6					_neg_err:
.d0f6	a9 66		lda #$66			lda #<cp0		; Set CP to CP0
.d0f8	85 00		sta $00				sta cp+0
.d0fa	a9 0b		lda #$0b			lda #>cp0
.d0fc	85 01		sta $01				sta cp+1
.d0fe	a9 87		lda #$87			lda #<forth_dictionary_start	; set WordLists[Forth] to the first
.d100	8d 12 03	sta $0312			sta WordlistsV+0		; word in ROM
.d103	a9 df		lda #$df			lda #>forth_dictionary_start
.d105	8d 13 03	sta $0313			sta WordlistsV+1
.d108	a9 c4		lda #$c4			lda #$100+err_Free		; abort with an error
.d10a	4c 63 c4	jmp $c463			jmp ThrowA
.d10d					_done:
.d10d	e8		inx				inx			; Drop n
.d10e	e8		inx				inx
=78					CodeLen	.var *-XtPtr1
=$d10f					Here1 = *	; remember here
>d0bf	4e					.byte CodeLen	;patch wh_CodeLength
.d10f	60		rts				rts
>d110	48 65 61 64 65 72 2c		Name0:	.text "Header,"	;  name of word as a string, ending at wh_NameLastChar
=7					NameLength = *-Name0
=53399					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>d117	87					.byte (("Header,"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=90					LinkDisplacement = Nt0-WordListLink
>d118	10					.byte WordFlags	;wh_Flags
>d119	03					.byte 3	;wh_CodeLength
>d11a	5a					  .byte LinkDisplacement	; offset to previous nt
=$d11b					XtPtr1 ::= *
=53399					WordListLink ::= Nt0 ; remember the nt of this word for later
.d11b					Header_Comma:
.d11b	20 29 d1	jsr $d129			jsr Header_Build
.d11e					Header_Link:
.d11e	a5 0e		lda $0e				lda WorkWord+0		; dp= WorkWord
.d120	85 10		sta $10				sta dp+0
.d122	a5 0f		lda $0f				lda WorkWord+1
.d124	85 11		sta $11				sta dp+1
.d126	4c 64 ca	jmp $ca64			jmp dp_to_current	; Update the CURRENT wordlist with the new DP.
.d129					Header_Build:
.d129	20 b3 ca	jsr $cab3			jsr parse_name_check	; get name string, throw error if empty string
.d12c	20 f1 dc	jsr $dcf1			jsr Two_dup		; ( addr u addr u )
.d12f	20 a3 b0	jsr $b0a3			jsr Get_Current
.d132	20 bd b1	jsr $b1bd			jsr Search_WordList	; ( addr u xt f ) or ( addr u 0 )
.d135	e8		inx				inx			; pop flag.
.d136	e8		inx				inx
.d137	b5 22		lda $22,x			lda DStack-2,x		; not found?
.d139	f0 21		beq $d15c			beq _new_name		; We haven't seen this one before.
.d13b	e8		inx				inx			; Drop xt
.d13c	e8		inx				inx
.d13d	24 0c		bit $0c				bit status		; Check bit 7
.d13f	10 08		bpl $d149			bpl _redefined_name	; Bit 7 is zero, so print the message.
.d141	a9 80		lda #$80			lda #$80		; Set bit 7 to indicate dup
.d143	05 0c		ora $0c				ora status
.d145	85 0c		sta $0c				sta status
.d147	d0 19		bne $d162			bne _process_name
.d149					_redefined_name:
.d149	a9 bc		lda #$bc			lda #<str_redefined
.d14b	a0 ea		ldy #$ea			ldy #>str_redefined
.d14d	20 50 de	jsr $de50			jsr Print_ASCIIZ_YA_no_lf
.d150	20 f1 dc	jsr $dcf1			jsr Two_dup		 ; ( addr u addr u )
.d153	20 34 de	jsr $de34			jsr Type
.d156	20 28 de	jsr $de28			jsr Space
.d159	4c 62 d1	jmp $d162			jmp _process_name
.d15c					_new_name:
.d15c	a9 7f		lda #$7f			lda #$7F		; Clear bit 0 of status to indicate new word.
.d15e	25 0c		and $0c				and status
.d160	85 0c		sta $0c				sta status
.d162					_process_name:
.d162	20 f1 dc	jsr $dcf1			jsr Two_dup		; compile name string ending at wh_NameLastChar
.d165	20 62 da	jsr $da62			jsr Here
.d168	20 ee df	jsr $dfee			jsr Swap
.d16b	20 c4 bd	jsr $bdc4			jsr CMove
.d16e	b5 24		lda $24,x			lda DStack+0,x		;   save length
.d170	20 b2 d0	jsr $d0b2			jsr Allot_ZA
.d173	38		sec				sec
.d174	a5 00		lda $00				lda cp+0		; WorkWord= nt
.d176	e9 80		sbc #$80			sbc #wh_NameLastChar+1
.d178	85 0e		sta $0e				sta WorkWord+0
.d17a	a5 01		lda $01				lda cp+1
.d17c	e9 00		sbc #$00			sbc #0
.d17e	85 0f		sta $0f				sta WorkWord+1
.d180	a0 7f		ldy #$7f			ldy #wh_NameLastChar
.d182	b1 0e		lda ($0e),y			lda (WorkWord),y
.d184	0a		asl a				asl a
.d185	0a		asl a				asl a
.d186	0a		asl a				asl a
.d187	0a		asl a				asl a
.d188	0a		asl a				asl a
.d189	15 24		ora $24,x			ora DStack+0,x
.d18b	95 24		sta $24,x			sta DStack+0,x
.d18d	20 36 dd	jsr $dd36			jsr C_Comma		; compile wh_HashNameLen
.d190	e8		inx				inx			; drop name string addr
.d191	e8		inx				inx
.d192	a9 10		lda #$10			lda #NN			; compile wh_Flags
.d194	20 39 dd	jsr $dd39			jsr C_Comma_A
.d197	a9 03		lda #$03			lda #3			; compile wh_CodeLength (temporary value, see adjust_z)
.d199	20 39 dd	jsr $dd39			jsr C_Comma_A
.d19c	20 54 ca	jsr $ca54			jsr current_to_dp	; Get the CURRENT dictionary pointer.
.d19f	38		sec				sec
.d1a0	a5 0e		lda $0e				lda WorkWord+0
.d1a2	e5 10		sbc $10				sbc dp+0
.d1a4	a8		tay				tay
.d1a5	a5 0f		lda $0f				lda WorkWord+1
.d1a7	e5 11		sbc $11				sbc dp+1
.d1a9	f0 0f		beq $d1ba			beq _LinkShort
.d1ab	a0 81		ldy #$81			ldy #wh_Flags		; set FP flag
.d1ad	b1 0e		lda ($0e),y			lda (WorkWord),y
.d1af	09 01		ora #$01			ora #FP
.d1b1	91 0e		sta ($0e),y			sta (WorkWord),y
.d1b3	a5 10		lda $10				lda dp+0		; compile wh_LinkNt ptr word
.d1b5	a4 11		ldy $11				ldy dp+1
.d1b7	4c 50 dd	jmp $dd50			jmp Comma_YA
.d1ba	98		tya		_LinkShort:	tya			; compile wh_LinkNt offset byte
.d1bb	4c 39 dd	jmp $dd39			jmp C_Comma_A
=163					CodeLen	.var *-XtPtr1
=$d1be					Here1 = *	; remember here
>d119	a3					.byte CodeLen	;patch wh_CodeLength
>d1be	43 72 65 61 74 65		Name0:	.text "Create"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=53572					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>d1c4	a6					.byte (("Create"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=173					LinkDisplacement = Nt0-WordListLink
>d1c5	10					.byte WordFlags	;wh_Flags
>d1c6	03					.byte 3	;wh_CodeLength
>d1c7	ad					  .byte LinkDisplacement	; offset to previous nt
=$d1c8					XtPtr1 ::= *
=53572					WordListLink ::= Nt0 ; remember the nt of this word for later
.d1c8					Create:
.d1c8	20 1b d1	jsr $d11b			jsr Header_Comma	; compile word header
.d1cb	a9 d5		lda #$d5			lda #<DoVar		; compile JSR DoVar
.d1cd	a0 d1		ldy #$d1			ldy #>DoVar
.d1cf	20 73 dd	jsr $dd73			jsr Jsr_Comma_YA
.d1d2	4c db cb	jmp $cbdb			jmp adjust_z
=13					CodeLen	.var *-XtPtr1
=$d1d5					Here1 = *	; remember here
>d1c6	0d					.byte CodeLen	;patch wh_CodeLength
.d1d5					DoVar:
.d1d5	68		pla				pla		; Pull the return address off the machine's stack
.d1d6	18		clc				clc		;   +1 because of the way the JSR works
.d1d7	69 01		adc #$01			adc #1
.d1d9	ca		dex				dex		; push on data stack
.d1da	ca		dex				dex
.d1db	95 24		sta $24,x			sta DStack+0,x
.d1dd	68		pla				pla
.d1de	69 00		adc #$00			adc #0
.d1e0	95 25		sta $25,x			sta DStack+1,x
.d1e2	60		rts				rts		; takes us to the original caller of the
>d1e3	44 6f 65 73 3e			Name0:	.text "Does>"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=53608					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>d1e8	c5					.byte (("Does>"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=28					WordFlags ::= CO+IM+NN	; modifiable copy, remember for later
=36					LinkDisplacement = Nt0-WordListLink
>d1e9	1c					.byte WordFlags	;wh_Flags
>d1ea	03					.byte 3	;wh_CodeLength
>d1eb	24					  .byte LinkDisplacement	; offset to previous nt
=$d1ec					XtPtr1 ::= *
=53608					WordListLink ::= Nt0 ; remember the nt of this word for later
.d1ec					Does:
.d1ec	a0 d2		ldy #$d2			ldy #>_runtime		; compile JSR _runtime
.d1ee	a9 06		lda #$06			lda #<_runtime
.d1f0	20 73 dd	jsr $dd73			jsr Jsr_Comma_YA
.d1f3	a9 68		lda #$68			lda #$68		; compile PLA  to pop RTS addr (PFA-1) to AY
.d1f5	a0 a8		ldy #$a8			ldy #$a8		;    & TAY
.d1f7	20 50 dd	jsr $dd50			jsr Comma_YA
.d1fa	a9 68		lda #$68			lda #$68		; compile PLA
.d1fc	20 39 dd	jsr $dd39			jsr C_Comma_A
.d1ff	a0 d2		ldy #$d2			ldy #>_DoDoes		; compile JSR _DoDoes
.d201	a9 23		lda #$23			lda #<_DoDoes
.d203	4c 73 dd	jmp $dd73			jmp Jsr_Comma_YA
=26					CodeLen	.var *-XtPtr1
=$d206					Here1 = *	; remember here
>d1ea	1a					.byte CodeLen	;patch wh_CodeLength
.d206					_runtime:
.d206	20 54 ca	jsr $ca54			jsr current_to_dp	; Grab the DP from the CURRENT wordlist.
.d209	a5 10		lda $10				lda dp+0		; tmp1= dp
.d20b	a4 11		ldy $11				ldy dp+1
.d20d	85 14		sta $14				sta tmp1+0
.d20f	84 15		sty $15				sty tmp1+1
.d211	20 b6 cd	jsr $cdb6			jsr NameToIntTmp	; tmp2= xt
.d214	18		clc				clc
.d215	68		pla				pla		; RTS addr LSB
.d216	69 01		adc #$01			adc #1		;   +1 for JSR bahavior
.d218	a0 01		ldy #$01			ldy #1
.d21a	91 16		sta ($16),y			sta (tmp2),y
.d21c	68		pla				pla		; RTS addr MSB
.d21d	69 00		adc #$00			adc #0
.d21f	c8		iny				iny
.d220	91 16		sta ($16),y			sta (tmp2),y
.d222	60		rts				rts
.d223					_DoDoes:
.d223	c8		iny				iny		; +1 for JSR behavior
.d224	d0 03		bne $d229			bne +
.d226	18		clc				clc
.d227	69 01		adc #$01			adc #1
.d229					+
.d229	4c df df	jmp $dfdf			jmp PushAY
>d22c	43 70 45 6e 64			Name0:	.text "CpEnd"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=53681					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>d231	85					.byte (("CpEnd"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=73					LinkDisplacement = Nt0-WordListLink
>d232	10					.byte WordFlags	;wh_Flags
>d233	03					.byte 3	;wh_CodeLength
>d234	49					  .byte LinkDisplacement	; offset to previous nt
=$d235					XtPtr1 ::= *
=53681					WordListLink ::= Nt0 ; remember the nt of this word for later
.d235	a9 00		lda #$00			lda #<cp_end
.d237	a0 80		ldy #$80			ldy #>cp_end
.d239	4c b5 c7	jmp $c7b5			jmp PushYA
>d23c	55 6e 75 73 65 64		Name0:	.text "Unused"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=53698					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>d242	86					.byte (("Unused"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=17					LinkDisplacement = Nt0-WordListLink
>d243	10					.byte WordFlags	;wh_Flags
>d244	03					.byte 3	;wh_CodeLength
>d245	11					  .byte LinkDisplacement	; offset to previous nt
=$d246					XtPtr1 ::= *
=53698					WordListLink ::= Nt0 ; remember the nt of this word for later
.d246					Unused:
=32600					_last = cp_end-2*padoffset
.d246	38		sec				sec
.d247	a9 58		lda #$58			lda #<_last
.d249	e5 00		sbc $00				sbc cp+0
.d24b	a8		tay				tay
.d24c	a9 7f		lda #$7f			lda #>_last
.d24e	e5 01		sbc $01				sbc cp+1
.d250	4c df df	jmp $dfdf			jmp PushAY
=13					CodeLen	.var *-XtPtr1
=$d253					Here1 = *	; remember here
>d244	0d					.byte CodeLen	;patch wh_CodeLength
>d253	44 65 70 74 68			Name0:	.text "Depth"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=53720					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>d258	05					.byte (("Depth"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=22					LinkDisplacement = Nt0-WordListLink
>d259	10					.byte WordFlags	;wh_Flags
>d25a	03					.byte 3	;wh_CodeLength
>d25b	16					  .byte LinkDisplacement	; offset to previous nt
=$d25c					XtPtr1 ::= *
=53720					WordListLink ::= Nt0 ; remember the nt of this word for later
.d25c					Depth:
.d25c	a9 28		lda #$28			lda #DDim*2	; A= DDim*2 - X
.d25e	86 1a		stx $1a				stx tmp4
.d260	38		sec				sec
.d261	e5 1a		sbc $1a				sbc tmp4
.d263	4a		lsr a				lsr		; divide by two because each cell is two bytes
.d264	4c e4 c7	jmp $c7e4			jmp PushZA
=11					CodeLen	.var *-XtPtr1
=$d267					Here1 = *	; remember here
>d25a	0b					.byte CodeLen	;patch wh_CodeLength
>d267	4b 65 79			Name0:	.text "Key"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=53738					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>d26a	23					.byte (("Key"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=18					LinkDisplacement = Nt0-WordListLink
>d26b	10					.byte WordFlags	;wh_Flags
>d26c	03					.byte 3	;wh_CodeLength
>d26d	12					  .byte LinkDisplacement	; offset to previous nt
=$d26e					XtPtr1 ::= *
=53738					WordListLink ::= Nt0 ; remember the nt of this word for later
.d26e	20 74 d2	jsr $d274	Key:		jsr key_a		; returns char in A
.d271	4c e4 c7	jmp $c7e4			jmp PushZA
=6					CodeLen	.var *-XtPtr1
=$d274					Here1 = *	; remember here
>d26c	06					.byte CodeLen	;patch wh_CodeLength
.d274					Key_A:
.d274	6c 08 03	jmp ($0308)			jmp (input)		; JSR/RTS
>d277	4b 65 79 3f			Name0:	.text "Key?"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=53755					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>d27b	e4					.byte (("Key?"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=17					LinkDisplacement = Nt0-WordListLink
>d27c	10					.byte WordFlags	;wh_Flags
>d27d	03					.byte 3	;wh_CodeLength
>d27e	11					  .byte LinkDisplacement	; offset to previous nt
=$d27f					XtPtr1 ::= *
=53755					WordListLink ::= Nt0 ; remember the nt of this word for later
.d27f	20 85 d2	jsr $d285	KeyQ:		jsr KeyQ_A
.d282	4c e4 c7	jmp $c7e4			jmp PushZA
.d285	6c 0a 03	jmp ($030a)	KeyQ_A:		jmp (HaveKey)
>d288	52 65 66 69 6c 6c		Name0:	.text "Refill"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=53774					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>d28e	86					.byte (("Refill"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=19					LinkDisplacement = Nt0-WordListLink
>d28f	10					.byte WordFlags	;wh_Flags
>d290	03					.byte 3	;wh_CodeLength
>d291	13					  .byte LinkDisplacement	; offset to previous nt
=$d292					XtPtr1 ::= *
=53774					WordListLink ::= Nt0 ; remember the nt of this word for later
.d292					Refill:
.d292	a9 00		lda #$00			lda #0			; show empty in case of error
.d294	85 06		sta $06				sta ciblen+0
.d296	85 07		sta $07				sta ciblen+1
.d298	a5 02		lda $02				lda insrc		; cheat: We only check LSB
.d29a	d0 24		bne $d2c0			bne _src_not_kbd
.d29c	a5 04		lda $04				lda cib+0		; address of CIB is NOS
.d29e	a4 05		ldy $05				ldy cib+1
.d2a0	20 b5 c7	jsr $c7b5			jsr PushYA
.d2a3	a9 ff		lda #$ff			lda #bsize		; max number of chars is TOS
.d2a5	20 e4 c7	jsr $c7e4			jsr PushZA		;  cheat: We only accept max 255
.d2a8	20 d9 d2	jsr $d2d9			jsr Accept		; ( addr n1 -- n2)
.d2ab	b5 24		lda $24,x			lda DStack+0,x
.d2ad	85 06		sta $06				sta ciblen+0
.d2af	b5 25		lda $25,x			lda DStack+1,x
.d2b1	85 07		sta $07				sta ciblen+1		; though we only accept 255 chars
.d2b3	a9 00		lda #$00			lda #0
.d2b5	85 08		sta $08				sta toin+0
.d2b7	85 09		sta $09				sta toin+1
.d2b9	a9 ff		lda #$ff			lda #$FF		; overwrite with TRUE flag
.d2bb	95 24		sta $24,x			sta DStack+0,x
.d2bd	95 25		sta $25,x			sta DStack+1,x
.d2bf	60		rts				rts
.d2c0					_src_not_kbd:
.d2c0	c9 ff		cmp #$ff			cmp #$ff
.d2c2	d0 03		bne $d2c7			bne _src_not_string
.d2c4	4c d6 c7	jmp $c7d6			jmp False
.d2c7					_src_not_string:
.d2c7	a9 eb		lda #$eb			lda #$100+err_Unsupported
.d2c9	20 63 c4	jsr $c463			jsr ThrowA
=58					CodeLen	.var *-XtPtr1
=$d2cc					Here1 = *	; remember here
>d290	3a					.byte CodeLen	;patch wh_CodeLength
.d2cc	4c 2a c4	jmp $c42a	Throw_Stack_06: jmp Throw_Stack
>d2cf	41 63 63 65 70 74		Name0:	.text "Accept"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=53845					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>d2d5	86					.byte (("Accept"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=71					LinkDisplacement = Nt0-WordListLink
>d2d6	10					.byte WordFlags	;wh_Flags
>d2d7	03					.byte 3	;wh_CodeLength
>d2d8	47					  .byte LinkDisplacement	; offset to previous nt
=$d2d9					XtPtr1 ::= *
=53845					WordListLink ::= Nt0 ; remember the nt of this word for later
.d2d9					Accept:
.d2d9	e0 25		cpx #$25		cpx #(DDim-2)*2+1	; far enough below end of data stack (& not negative)?
.d2db	b0 ef		bcs $d2cc		bcs Throw_Stack_06
.d2dd	b5 24		lda $24,x			lda DStack+0,x		; Abort if we were asked to receive 0 chars
.d2df	15 25		ora $25,x			ora DStack+1,x
.d2e1	d0 09		bne $d2ec			bne _not_zero
.d2e3	e8		inx				inx			; drop n
.d2e4	e8		inx				inx
.d2e5	95 24		sta $24,x			sta DStack+0,x		; replace addr with 0
.d2e7	95 25		sta $25,x			sta DStack+1,x
.d2e9	4c c1 d3	jmp $d3c1			jmp accept_done
.d2ec					_not_zero:
.d2ec	b5 24		lda $24,x			lda DStack+0,x	; number of chars to get in tmp2 ...
.d2ee	85 16		sta $16				sta tmp2
.d2f0	a9 00		lda #$00			lda #0
.d2f2	85 17		sta $17				sta tmp2+1	; ... but we only accept max 255 chars
.d2f4	b5 26		lda $26,x			lda DStack+2,x	; address of buffer is NOS, to tmp1
.d2f6	85 14		sta $14				sta tmp1
.d2f8	b5 27		lda $27,x			lda DStack+3,x
.d2fa	85 15		sta $15				sta tmp1+1
.d2fc	e8		inx				inx
.d2fd	e8		inx				inx
.d2fe	a0 00		ldy #$00			ldy #0
.d300	a5 0c		lda $0c				lda status
.d302	29 f7		and #$f7			and #$f7
.d304	18		clc				clc
.d305	69 01		adc #$01			adc #1
.d307	09 08		ora #$08			ora #$08
.d309	85 0c		sta $0c				sta status
.d30b					accept_loop:
.d30b	20 74 d2	jsr $d274			jsr key_a
.d30e	c9 0a		cmp #$0a			cmp #AscLF
.d310	f0 20		beq $d332			beq _eol
.d312	c9 0d		cmp #$0d			cmp #AscCR
.d314	f0 1c		beq $d332			beq _eol
.d316	c9 08		cmp #$08			cmp #AscBS
.d318	f0 24		beq $d33e			beq _backspace
.d31a	c9 7f		cmp #$7f			cmp #AscDEL	; (CTRL-h)
.d31c	f0 20		beq $d33e			beq _backspace
.d31e	c9 10		cmp #$10			cmp #AscCP
.d320	f0 37		beq $d359			beq _ctrl_p
.d322	c9 0e		cmp #$0e			cmp #AscCN
.d324	f0 46		beq $d36c			beq _ctrl_n
.d326	91 14		sta ($14),y			sta (tmp1),y
.d328	c8		iny				iny
.d329	20 1c de	jsr $de1c			jsr Emit_A
.d32c	c4 16		cpy $16				cpy tmp2	; reached character limit?
.d32e	d0 db		bne $d30b			bne accept_loop	      ; fall through if buffer limit reached
.d330	f0 03		beq $d335			beq _buffer_full
.d332					_eol:
.d332	20 28 de	jsr $de28			jsr Space	; print final space
.d335					_buffer_full:
.d335	94 24		sty $24,x			sty DStack+0,x	; Y contains number of chars accepted already
.d337	a9 00		lda #$00			lda #0
.d339	95 25		sta $25,x			sta DStack+1,x		; we only accept 256 chars
.d33b	4c c1 d3	jmp $d3c1			jmp accept_done
.d33e					_backspace:
.d33e	c0 00		cpy #$00			cpy #0		; buffer empty?
.d340	d0 06		bne $d348			bne +
.d342	a9 07		lda #$07			lda #AscBELL	; complain and don't delete beyond the start of line
.d344	20 1c de	jsr $de1c			jsr Emit_A
.d347	c8		iny				iny
.d348					+
.d348	88		dey				dey
.d349	a9 08		lda #$08			lda #AscBS	; move back one
.d34b	20 1c de	jsr $de1c			jsr Emit_A
.d34e	20 28 de	jsr $de28			jsr Space	; print a space (rubout)
.d351	a9 08		lda #$08			lda #AscBS	; move back over space
.d353	20 1c de	jsr $de1c			jsr Emit_A
.d356	4c 0b d3	jmp $d30b			jmp accept_loop
.d359					_ctrl_p:
.d359	a5 0c		lda $0c				lda status
.d35b	29 07		and #$07			and #7
.d35d	d0 08		bne $d367			bne _ctrl_p_dec
.d35f	a5 0c		lda $0c				lda status
.d361	09 07		ora #$07			ora #7
.d363	85 0c		sta $0c				sta status
.d365	d0 14		bne $d37b			bne _recall_history
.d367					_ctrl_p_dec:
.d367	c6 0c		dec $0c				dec status
.d369	4c 7b d3	jmp $d37b			jmp _recall_history
.d36c					_ctrl_n:
.d36c	a9 08		lda #$08			lda #$8
.d36e	24 0c		bit $0c				bit status
.d370	d0 09		bne $d37b			bne _recall_history
.d372	a5 0c		lda $0c				lda status
.d374	29 f7		and #$f7			and #$f7
.d376	18		clc				clc
.d377	69 01		adc #$01			adc #1
.d379	85 0c		sta $0c				sta status
.d37b					_recall_history:
.d37b	a9 f7		lda #$f7			lda #$ff-%00001000
.d37d	25 0c		and $0c				and status
.d37f	85 0c		sta $0c				sta status
.d381	20 dc d3	jsr $d3dc			jsr accept_total_recall
.d384	a9 0d		lda #$0d			lda #AscCR
.d386	20 1c de	jsr $de1c			jsr Emit_A
.d389					input_clear:
.d389	c0 00		cpy #$00			cpy #0
.d38b	f0 07		beq $d394			beq input_cleared
.d38d	20 28 de	jsr $de28			jsr Space
.d390	88		dey				dey
.d391	4c 89 d3	jmp $d389			jmp input_clear
.d394					input_cleared:
.d394	a9 0d		lda #$0d			lda #AscCR
.d396	20 1c de	jsr $de1c			jsr Emit_A
.d399	b1 18		lda ($18),y			lda (tmp3),y
.d39b	85 0d		sta $0d				sta status+1
.d39d	e6 18		inc $18				inc tmp3
.d39f	d0 02		bne $d3a3			bne +		; Increment the upper byte on carry.
.d3a1	e6 19		inc $19				inc tmp3+1
.d3a3					+
.d3a3	a9 0d		lda #$0d			lda #AscCR
.d3a5	20 1c de	jsr $de1c			jsr Emit_A
.d3a8					_history_loop:
.d3a8	c4 0d		cpy $0d				cpy status+1
.d3aa	d0 03		bne $d3af			bne +
.d3ac	4c 0b d3	jmp $d30b			jmp accept_loop	      ; Needs a long jump
.d3af					+
.d3af	c4 16		cpy $16				cpy tmp2
.d3b1	f0 0a		beq $d3bd			beq _hist_filled_buffer
.d3b3	b1 18		lda ($18),y			lda (tmp3),y
.d3b5	91 14		sta ($14),y			sta (tmp1),y
.d3b7	20 1c de	jsr $de1c			jsr Emit_A
.d3ba	c8		iny				iny
.d3bb	d0 eb		bne $d3a8			bne _history_loop
.d3bd					_hist_filled_buffer:
.d3bd	88		dey				dey
.d3be	4c 0b d3	jmp $d30b			jmp accept_loop
.d3c1					accept_done:
.d3c1	20 dc d3	jsr $d3dc			jsr accept_total_recall
.d3c4	85 0d		sta $0d				sta status+1
.d3c6	a0 00		ldy #$00			ldy #0
.d3c8	91 18		sta ($18),y			sta (tmp3),y
.d3ca	e6 18		inc $18				inc tmp3
.d3cc	d0 02		bne $d3d0			bne +		; Increment the upper byte on carry.
.d3ce	e6 19		inc $19				inc tmp3+1
.d3d0					+
.d3d0					_save_history_loop:
.d3d0	c4 0d		cpy $0d				cpy status+1
.d3d2	f0 07		beq $d3db			beq _save_history_done
.d3d4	b1 14		lda ($14),y			lda (tmp1),y
.d3d6	91 18		sta ($18),y			sta (tmp3),y
.d3d8	c8		iny				iny
.d3d9	d0 f5		bne $d3d0			bne _save_history_loop
.d3db					_save_history_done:
=258					CodeLen	.var *-XtPtr1
=$ff					CodeLen	 .var $ff
=$d3db					Here1 = *	; remember here
>d2d7	ff					.byte CodeLen	;patch wh_CodeLength
.d3db	60		rts				rts
.d3dc					accept_total_recall:
.d3dc	a9 66		lda #$66			lda #<hist_buff
.d3de	85 18		sta $18				sta tmp3
.d3e0	a9 07		lda #$07			lda #>hist_buff
.d3e2	85 19		sta $19				sta tmp3+1
.d3e4	a5 0c		lda $0c				lda status
.d3e6	6a		ror a				ror
.d3e7	29 03		and #$03			and #3
.d3e9	18		clc				clc
.d3ea	65 19		adc $19				adc tmp3+1
.d3ec	85 19		sta $19				sta tmp3+1
.d3ee	a5 0c		lda $0c				lda status
.d3f0	6a		ror a				ror		; Rotate through carry into msb.
.d3f1	6a		ror a				ror
.d3f2	29 80		and #$80			and #$80
.d3f4	18		clc				clc
.d3f5	65 18		adc $18				adc tmp3
.d3f7	85 18		sta $18				sta tmp3
.d3f9	90 02		bcc $d3fd			bcc +		; Increment the upper byte on carry.
.d3fb	e6 19		inc $19				inc tmp3+1
.d3fd					+
.d3fd	98		tya				tya
.d3fe	c9 80		cmp #$80			cmp #$80
.d400	90 02		bcc $d404			bcc +
.d402	a9 7f		lda #$7f			lda #$7F
.d404					+
.d404	60		rts				rts
>d405	49 6e 70 75 74 3e 52		Name0:	.text "Input>R"	;  name of word as a string, ending at wh_NameLastChar
=7					NameLength = *-Name0
=54156					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>d40c	47					.byte (("Input>R"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$30					WordFlags ::= NN|ST	; modifiable copy, remember for later
=311					LinkDisplacement = Nt0-WordListLink
=$31						  WordFlags ::= WordFlags | FP
>d40d	31					.byte WordFlags	;wh_Flags
>d40e	03					.byte 3	;wh_CodeLength
>d40f	55 d2					  .word WordListLink
=$d411					XtPtr1 ::= *
=54156					WordListLink ::= Nt0 ; remember the nt of this word for later
.d411					Input_To_R:
.d411	68		pla				pla			; move it out of the way
.d412	85 14		sta $14				sta tmp1+0
.d414	68		pla				pla
.d415	85 15		sta $15				sta tmp1+1
.d417	a0 07		ldy #$07			ldy #7
.d419	b9 02 00	lda $0002,y	_loop:		lda InSrc,y	; insrc+7 is toin+1
.d41c	48		pha				pha
.d41d	88		dey				dey
.d41e	10 f9		bpl $d419			bpl _loop
.d420	a5 15		lda $15				lda tmp1+1		; Restore address for return jump
.d422	48		pha				pha
.d423	a5 14		lda $14				lda tmp1+0
.d425	48		pha				pha
=21					CodeLen	.var *-XtPtr1
=$d426					Here1 = *	; remember here
>d40e	15					.byte CodeLen	;patch wh_CodeLength
.d426	60		rts				rts
>d427	52 3e 49 6e 70 75 74		Name0:	.text "R>Input"	;  name of word as a string, ending at wh_NameLastChar
=7					NameLength = *-Name0
=54190					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>d42e	87					.byte (("R>Input"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$30					WordFlags ::= ST	; modifiable copy, remember for later
=34					LinkDisplacement = Nt0-WordListLink
>d42f	30					.byte WordFlags	;wh_Flags
>d430	03					.byte 3	;wh_CodeLength
>d431	22					  .byte LinkDisplacement	; offset to previous nt
=$d432					XtPtr1 ::= *
=54190					WordListLink ::= Nt0 ; remember the nt of this word for later
.d432					R_To_Input:
.d432	68		pla				pla		 ; move RTS addr out of the way
.d433	85 14		sta $14				sta tmp1+0
.d435	68		pla				pla
.d436	85 15		sta $15				sta tmp1+1
.d438	a0 00		ldy #$00			ldy #0
.d43a	68		pla		_loop:		pla
.d43b	99 02 00	sta $0002,y			sta InSrc,y ; also cib ciblen toin
.d43e	c8		iny				iny
.d43f	c0 08		cpy #$08			cpy #8
.d441	d0 f7		bne $d43a			bne _loop
.d443	a5 15		lda $15				lda tmp1+1	; Restore RTS address
.d445	48		pha				pha
.d446	a5 14		lda $14				lda tmp1+0
.d448	48		pha				pha
=23					CodeLen	.var *-XtPtr1
=$d449					Here1 = *	; remember here
>d430	17					.byte CodeLen	;patch wh_CodeLength
.d449	60		rts				rts
>d44a	49 4b 65 79			Name0:	.text "IKey"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=54222					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>d44e	24					.byte (("IKey"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=32					LinkDisplacement = Nt0-WordListLink
>d44f	10					.byte WordFlags	;wh_Flags
>d450	03					.byte 3	;wh_CodeLength
>d451	20					  .byte LinkDisplacement	; offset to previous nt
=$d452					XtPtr1 ::= *
=54222					WordListLink ::= Nt0 ; remember the nt of this word for later
.d452					IKey:
.d452	20 f2 c7	jsr $c7f2	_again:		jsr Zero
.d455	20 f2 c7	jsr $c7f2			jsr Zero	; ( ud )
.d458	20 62 da	jsr $da62			jsr Here
.d45b	20 cd df	jsr $dfcd			jsr Dup		; get text
.d45e	a9 10		lda #$10			lda #16
.d460	20 e4 c7	jsr $c7e4			jsr PushZA
.d463	20 d9 d2	jsr $d2d9			jsr Accept	; ( ud addr len )
.d466	a1 26		lda ($26,x)			lda (DStack+2,x) ; negative?
.d468	c9 2d		cmp #$2d			cmp #'-'
.d46a	08		php				php		;  save sign
.d46b	d0 06		bne $d473			bne +
.d46d	20 a0 da	jsr $daa0			jsr NOS_One_Plus ;   eat the '-'
.d470	20 6f da	jsr $da6f			jsr One_Minus
.d473					+
.d473	20 34 c0	jsr $c034			jsr To_Number ; ( ud addr u -- ud addr u )  Continue convert a string to an integer
.d476	e8		inx				inx		; Drop len
.d477	e8		inx				inx
.d478	e8		inx				inx		; Drop addr
.d479	e8		inx				inx
.d47a	e8		inx				inx		; UD>S
.d47b	e8		inx				inx
.d47c	b5 1e		lda $1e,x			lda DStack-6,x	; string all consumed?
.d47e	f0 11		beq $d491			beq _ok
.d480	e8		inx		_err:		inx		; Drop u
.d481	e8		inx				inx
.d482	28		plp				plp		; RDrop saved sign
.d483	20 28 de	jsr $de28			jsr Space	; prompt again
.d486	a9 3f		lda #$3f			lda #'?'
.d488	20 1c de	jsr $de1c			jsr Emit_A
.d48b	20 28 de	jsr $de28			jsr Space
.d48e	4c 52 d4	jmp $d452			jmp _again	; try it again
.d491	28		plp		_ok:		plp		; apply sign
.d492	d0 03		bne $d497			bne +
.d494	20 e4 d6	jsr $d6e4			jsr Negate
.d497					+
.d497	60		rts				rts
=70					CodeLen	.var *-XtPtr1
=$d498					Here1 = *	; remember here
>d450	46					.byte CodeLen	;patch wh_CodeLength
>d498	42 6f 75 6e 64 73		Name0:	.text "Bounds"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=54302					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>d49e	66					.byte (("Bounds"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=80					LinkDisplacement = Nt0-WordListLink
>d49f	10					.byte WordFlags	;wh_Flags
>d4a0	03					.byte 3	;wh_CodeLength
>d4a1	50					  .byte LinkDisplacement	; offset to previous nt
=$d4a2					XtPtr1 ::= *
=54302					WordListLink ::= Nt0 ; remember the nt of this word for later
.d4a2					Bounds:
.d4a2	e0 25		cpx #$25		cpx #(DDim-2)*2+1	; far enough below end of data stack (& not negative)?
.d4a4	b0 14		bcs $d4ba		bcs Throw_Stack_22
.d4a6	18		clc				clc
.d4a7	b5 26		lda $26,x			lda DStack+2,x		; LSB addr
.d4a9	a8		tay				tay
.d4aa	75 24		adc $24,x			adc DStack+0,x		; LSB u
.d4ac	95 26		sta $26,x			sta DStack+2,x		; LSB addr+u
.d4ae	94 24		sty $24,x			sty DStack+0,x
.d4b0	b5 27		lda $27,x			lda DStack+3,x		; MSB addr
.d4b2	a8		tay				tay
.d4b3	75 25		adc $25,x			adc DStack+1,x		; MSB u
.d4b5	95 27		sta $27,x			sta DStack+3,x		; MSB addr+u
.d4b7	94 25		sty $25,x			sty DStack+1,x
=23					CodeLen	.var *-XtPtr1
=$d4b9					Here1 = *	; remember here
>d4a0	17					.byte CodeLen	;patch wh_CodeLength
.d4b9	60		rts				rts
.d4ba	4c 2a c4	jmp $c42a	Throw_Stack_22: jmp Throw_Stack
>d4bd	53 70 61 63 65 73		Name0:	.text "Spaces"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=54339					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>d4c3	66					.byte (("Spaces"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=37					LinkDisplacement = Nt0-WordListLink
>d4c4	10					.byte WordFlags	;wh_Flags
>d4c5	03					.byte 3	;wh_CodeLength
>d4c6	25					  .byte LinkDisplacement	; offset to previous nt
=$d4c7					XtPtr1 ::= *
=54339					WordListLink ::= Nt0 ; remember the nt of this word for later
.d4c7					Spaces:
.d4c7	e0 27		cpx #$27		cpx #(DDim-1)*2+1	; far enough below end of data stack (& not negative)?
.d4c9	b0 ef		bcs $d4ba		bcs Throw_Stack_22
.d4cb	4c d1 d4	jmp $d4d1			jmp _test
.d4ce					_loop:
.d4ce	20 28 de	jsr $de28			jsr Space		; print a space
.d4d1	d6 24		dec $24,x	_test:		dec DStack+0,x		; decrement & test
.d4d3	10 f9		bpl $d4ce			bpl _loop
.d4d5	e8		inx				inx			; Drop
.d4d6	e8		inx				inx
=16					CodeLen	.var *-XtPtr1
=$d4d7					Here1 = *	; remember here
>d4c5	10					.byte CodeLen	;patch wh_CodeLength
.d4d7	60		rts				rts
>d4d8	2d 54 72 61 69 6c 69 6e		Name0:	.text "-Trailing"	;  name of word as a string, ending at wh_NameLastChar
>d4e0	67
=9					NameLength = *-Name0
=54369					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>d4e1	e9					.byte (("-Trailing"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=30					LinkDisplacement = Nt0-WordListLink
>d4e2	10					.byte WordFlags	;wh_Flags
>d4e3	03					.byte 3	;wh_CodeLength
>d4e4	1e					  .byte LinkDisplacement	; offset to previous nt
=$d4e5					XtPtr1 ::= *
=54369					WordListLink ::= Nt0 ; remember the nt of this word for later
.d4e5					Minus_trailing:
.d4e5	e0 25		cpx #$25		cpx #(DDim-2)*2+1	; far enough below end of data stack (& not negative)?
.d4e7	b0 78		bcs $d561		bcs Throw_Stack_20
.d4e9	b5 26		lda $26,x			lda DStack+2,x		; tmp1= addr + (u1 & $ff00)
.d4eb	85 14		sta $14				sta tmp1+0
.d4ed	b5 27		lda $27,x			lda DStack+3,x
.d4ef	18		clc				clc
.d4f0	75 25		adc $25,x			adc DStack+1,x
.d4f2	85 15		sta $15				sta tmp1+1
.d4f4	b4 24		ldy $24,x			ldy DStack+0,x
.d4f6	88		dey		_loop:		dey			; back 1 char
.d4f7	c0 ff		cpy #$ff			cpy #$ff
.d4f9	d0 06		bne $d501			bne +
.d4fb	c6 15		dec $15				dec tmp1+1		;   back 1 page
.d4fd	d6 25		dec $25,x			dec DStack+1,x
.d4ff	30 06		bmi $d507			bmi _done
.d501					+
.d501	b1 14		lda ($14),y			lda (tmp1),y		; if blank, keep going
.d503	c9 20		cmp #$20			cmp #AscSP
.d505	f0 ef		beq $d4f6			beq _loop
.d507	c8		iny		_done:		iny			; forward 1 char
.d508	d0 02		bne $d50c			bne +
.d50a	f6 25		inc $25,x			inc DStack+1,x
.d50c	94 24		sty $24,x	+		sty DStack+0,x
=41					CodeLen	.var *-XtPtr1
=$d50e					Here1 = *	; remember here
>d4e3	29					.byte CodeLen	;patch wh_CodeLength
.d50e	60		rts				rts
>d50f	2d 4c 65 61 64 69 6e 67		Name0:	.text "-Leading"	;  name of word as a string, ending at wh_NameLastChar
=8					NameLength = *-Name0
=54423					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>d517	e8					.byte (("-Leading"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=54					LinkDisplacement = Nt0-WordListLink
>d518	10					.byte WordFlags	;wh_Flags
>d519	03					.byte 3	;wh_CodeLength
>d51a	36					  .byte LinkDisplacement	; offset to previous nt
=$d51b					XtPtr1 ::= *
=54423					WordListLink ::= Nt0 ; remember the nt of this word for later
.d51b					Minus_leading:
.d51b	e0 25		cpx #$25		cpx #(DDim-2)*2+1	; far enough below end of data stack (& not negative)?
.d51d	b0 42		bcs $d561		bcs Throw_Stack_20
.d51f					_loop:
.d51f	b5 24		lda $24,x			lda DStack+0,x		; chars left?
.d521	15 25		ora $25,x			ora DStack+1,x
.d523	f0 0f		beq $d534			beq _done
.d525	a1 26		lda ($26,x)			lda (DStack+2,x)	; get first character
.d527	c9 21		cmp #$21			cmp #AscSP+1		;   is_whitespace
.d529	b0 09		bcs $d534			bcs _done
.d52b	20 a0 da	jsr $daa0			jsr NOS_One_Plus
.d52e	20 73 da	jsr $da73			jsr One_Minus_NoUF
.d531	4c 1f d5	jmp $d51f			jmp _loop
.d534					_done:
=25					CodeLen	.var *-XtPtr1
=$d534					Here1 = *	; remember here
>d519	19					.byte CodeLen	;patch wh_CodeLength
.d534	60		rts				rts
>d535	2f 53 74 72 69 6e 67		Name0:	.text "/String"	;  name of word as a string, ending at wh_NameLastChar
=7					NameLength = *-Name0
=54460					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>d53c	e7					.byte (("/String"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=37					LinkDisplacement = Nt0-WordListLink
>d53d	10					.byte WordFlags	;wh_Flags
>d53e	03					.byte 3	;wh_CodeLength
>d53f	25					  .byte LinkDisplacement	; offset to previous nt
=$d540					XtPtr1 ::= *
=54460					WordListLink ::= Nt0 ; remember the nt of this word for later
.d540					Slash_String:
.d540	e0 23		cpx #$23		cpx #(DDim-3)*2+1	; far enough below end of data stack (& not negative)?
.d542	b0 1d		bcs $d561		bcs Throw_Stack_20
.d544	18		clc				clc		; addr += n
.d545	b5 24		lda $24,x			lda DStack+0,x
.d547	75 28		adc $28,x			adc DStack+4,x
.d549	95 28		sta $28,x			sta DStack+4,x
.d54b	b5 25		lda $25,x			lda DStack+1,x
.d54d	75 29		adc $29,x			adc DStack+5,x
.d54f	95 29		sta $29,x			sta DStack+5,x
.d551	38		sec				sec		; u -= n
.d552	b5 26		lda $26,x			lda DStack+2,x
.d554	f5 24		sbc $24,x			sbc DStack+0,x
.d556	95 26		sta $26,x			sta DStack+2,x
.d558	b5 27		lda $27,x			lda DStack+3,x
.d55a	f5 25		sbc $25,x			sbc DStack+1,x
.d55c	95 27		sta $27,x			sta DStack+3,x
.d55e	e8		inx				inx		; Drop n
.d55f	e8		inx				inx
=32					CodeLen	.var *-XtPtr1
=$d560					Here1 = *	; remember here
>d53e	20					.byte CodeLen	;patch wh_CodeLength
.d560	60		rts				rts
.d561	4c 2a c4	jmp $c42a	Throw_Stack_20: jmp Throw_Stack
>d564	32 44 72 6f 70			Name0:	.text "2Drop"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=54505					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>d569	05					.byte (("2Drop"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=45					LinkDisplacement = Nt0-WordListLink
>d56a	10					.byte WordFlags	;wh_Flags
>d56b	03					.byte 3	;wh_CodeLength
>d56c	2d					  .byte LinkDisplacement	; offset to previous nt
=$d56d					XtPtr1 ::= *
=54505					WordListLink ::= Nt0 ; remember the nt of this word for later
.d56d					Two_drop:
.d56d	e0 25		cpx #$25		cpx #(DDim-2)*2+1	; far enough below end of data stack (& not negative)?
.d56f	b0 f0		bcs $d561		bcs Throw_Stack_20
.d571	e8		inx				inx
.d572	e8		inx				inx
.d573	e8		inx				inx
.d574	e8		inx				inx
=8					CodeLen	.var *-XtPtr1
=$d575					Here1 = *	; remember here
>d56b	08					.byte CodeLen	;patch wh_CodeLength
.d575	60		rts				rts
>d576	32 53 77 61 70			Name0:	.text "2Swap"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=54523					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>d57b	05					.byte (("2Swap"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=18					LinkDisplacement = Nt0-WordListLink
>d57c	10					.byte WordFlags	;wh_Flags
>d57d	03					.byte 3	;wh_CodeLength
>d57e	12					  .byte LinkDisplacement	; offset to previous nt
=$d57f					XtPtr1 ::= *
=54523					WordListLink ::= Nt0 ; remember the nt of this word for later
.d57f					Two_Swap:
.d57f	e0 21		cpx #$21		cpx #(DDim-4)*2+1	; far enough below end of data stack (& not negative)?
.d581	b0 de		bcs $d561		bcs Throw_Stack_20
.d583	86 14		stx $14				stx tmp1
.d585	ca		dex				dex
.d586	ca		dex				dex
.d587	ca		dex				dex
.d588	ca		dex				dex
.d589	e8		inx		_loop:		inx
.d58a	b5 27		lda $27,x			lda DStack+3,x	; 3 <-> 7
.d58c	b4 2b		ldy $2b,x			ldy DStack+7,x
.d58e	95 2b		sta $2b,x			sta DStack+7,x
.d590	94 27		sty $27,x			sty DStack+3,x
.d592	e4 14		cpx $14				cpx tmp1
.d594	90 f3		bcc $d589			bcc _loop
=23					CodeLen	.var *-XtPtr1
=$d596					Here1 = *	; remember here
>d57d	17					.byte CodeLen	;patch wh_CodeLength
.d596	60		rts				rts
>d597	32 4f 76 65 72			Name0:	.text "2Over"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=54556					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>d59c	45					.byte (("2Over"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=33					LinkDisplacement = Nt0-WordListLink
>d59d	10					.byte WordFlags	;wh_Flags
>d59e	03					.byte 3	;wh_CodeLength
>d59f	21					  .byte LinkDisplacement	; offset to previous nt
=$d5a0					XtPtr1 ::= *
=54556					WordListLink ::= Nt0 ; remember the nt of this word for later
.d5a0					Two_over:
.d5a0	e0 21		cpx #$21		cpx #(DDim-4)*2+1	; far enough below end of data stack (& not negative)?
.d5a2	b0 bd		bcs $d561		bcs Throw_Stack_20
.d5a4	a0 04		ldy #$04			ldy #4
.d5a6	ca		dex		_loop:		dex
.d5a7	b5 2c		lda $2c,x			lda DStack+8,x
.d5a9	95 24		sta $24,x			sta DStack+0,x
.d5ab	88		dey				dey
.d5ac	d0 f8		bne $d5a6			bne _loop
=14					CodeLen	.var *-XtPtr1
=$d5ae					Here1 = *	; remember here
>d59e	0e					.byte CodeLen	;patch wh_CodeLength
.d5ae	60		rts				rts
>d5af	32 21				Name0:	.text "2!"	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=54577					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>d5b1	22					.byte (("2!"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=21					LinkDisplacement = Nt0-WordListLink
>d5b2	10					.byte WordFlags	;wh_Flags
>d5b3	03					.byte 3	;wh_CodeLength
>d5b4	15					  .byte LinkDisplacement	; offset to previous nt
=$d5b5					XtPtr1 ::= *
=54577					WordListLink ::= Nt0 ; remember the nt of this word for later
.d5b5	20 de c3	jsr $c3de	Two_Store:	jsr PopYA
.d5b8	85 14		sta $14		Two_Store_YA:	sta tmp1+0	; save addr
.d5ba	84 15		sty $15				sty tmp1+1
.d5bc	e0 25		cpx #$25		cpx #(DDim-2)*2+1	; far enough below end of data stack (& not negative)?
.d5be	b0 a1		bcs $d561		bcs Throw_Stack_20
.d5c0	b5 24		lda $24,x			lda DStack+0,x	; copy MSB
.d5c2	a0 00		ldy #$00			ldy #0
.d5c4	91 14		sta ($14),y			sta (tmp1),y
.d5c6	b5 25		lda $25,x			lda DStack+1,x	; copy next
.d5c8	c8		iny				iny
.d5c9	91 14		sta ($14),y			sta (tmp1),y
.d5cb	b5 26		lda $26,x			lda DStack+2,x	; copy next
.d5cd	c8		iny				iny
.d5ce	91 14		sta ($14),y			sta (tmp1),y
.d5d0	b5 27		lda $27,x			lda DStack+3,x	; copy MSB
.d5d2	c8		iny				iny
.d5d3	91 14		sta ($14),y			sta (tmp1),y
.d5d5	e8		inx				inx		; 2Drop
.d5d6	e8		inx				inx
.d5d7	e8		inx				inx
.d5d8	e8		inx				inx
=36					CodeLen	.var *-XtPtr1
=$d5d9					Here1 = *	; remember here
>d5b3	24					.byte CodeLen	;patch wh_CodeLength
.d5d9	60		rts				rts
>d5da	32 40				Name0:	.text "2@"	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=54620					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>d5dc	02					.byte (("2@"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=0					WordFlags ::= 0	; modifiable copy, remember for later
=43					LinkDisplacement = Nt0-WordListLink
>d5dd	00					.byte WordFlags	;wh_Flags
>d5de	03					.byte 3	;wh_CodeLength
>d5df	2b					  .byte LinkDisplacement	; offset to previous nt
=$d5e0					XtPtr1 ::= *
=54620					WordListLink ::= Nt0 ; remember the nt of this word for later
.d5e0	20 de c3	jsr $c3de	Two_fetch:	jsr PopYA
.d5e3	85 14		sta $14		Two_Fetch_YA:	sta tmp1+0	; save addr
.d5e5	84 15		sty $15				sty tmp1+1
.d5e7	a0 00		ldy #$00			ldy #0
.d5e9					Two_Fetch_Tmp1Y:
.d5e9	ca		dex				dex
.d5ea	ca		dex				dex
.d5eb	ca		dex				dex
.d5ec	ca		dex				dex
.d5ed	b1 14		lda ($14),y			lda (tmp1),y	; copy LSB
.d5ef	95 24		sta $24,x			sta DStack+0,x
.d5f1	c8		iny				iny		; copy next
.d5f2	b1 14		lda ($14),y			lda (tmp1),y
.d5f4	95 25		sta $25,x			sta DStack+1,x
.d5f6	c8		iny				iny		; copy next
.d5f7	b1 14		lda ($14),y			lda (tmp1),y
.d5f9	95 26		sta $26,x			sta DStack+2,x
.d5fb	c8		iny				iny		; copy next
.d5fc	b1 14		lda ($14),y			lda (tmp1),y
.d5fe	95 27		sta $27,x			sta DStack+3,x
=32					CodeLen	.var *-XtPtr1
=$d600					Here1 = *	; remember here
>d5de	20					.byte CodeLen	;patch wh_CodeLength
.d600	60		rts				rts
>d601	44 40				Name0:	.text "D@"	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=54659					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>d603	02					.byte (("D@"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=39					LinkDisplacement = Nt0-WordListLink
>d604	10					.byte WordFlags	;wh_Flags
>d605	03					.byte 3	;wh_CodeLength
>d606	27					  .byte LinkDisplacement	; offset to previous nt
=$d607					XtPtr1 ::= *
=54659					WordListLink ::= Nt0 ; remember the nt of this word for later
.d607	20 de c3	jsr $c3de	DFetch:		jsr PopYA
.d60a	85 14		sta $14		DFetchYA:	sta tmp1+0	; save addr
.d60c	84 15		sty $15				sty tmp1+1
.d60e	ca		dex				dex
.d60f	ca		dex				dex
.d610	ca		dex				dex
.d611	ca		dex				dex
.d612	a0 00		ldy #$00			ldy #0
.d614	b1 14		lda ($14),y			lda (tmp1),y
.d616	95 26		sta $26,x			sta DStack+2,x
.d618	c8		iny				iny
.d619	b1 14		lda ($14),y			lda (tmp1),y
.d61b	95 27		sta $27,x			sta DStack+3,x
.d61d	c8		iny				iny
.d61e	b1 14		lda ($14),y			lda (tmp1),y
.d620	95 24		sta $24,x			sta DStack+0,x
.d622	c8		iny				iny
.d623	b1 14		lda ($14),y			lda (tmp1),y
.d625	95 25		sta $25,x			sta DStack+1,x
=32					CodeLen	.var *-XtPtr1
=$d627					Here1 = *	; remember here
>d605	20					.byte CodeLen	;patch wh_CodeLength
.d627	60		rts				rts
>d628	44 21				Name0:	.text "D!"	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=54698					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>d62a	22					.byte (("D!"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=39					LinkDisplacement = Nt0-WordListLink
>d62b	10					.byte WordFlags	;wh_Flags
>d62c	03					.byte 3	;wh_CodeLength
>d62d	27					  .byte LinkDisplacement	; offset to previous nt
=$d62e					XtPtr1 ::= *
=54698					WordListLink ::= Nt0 ; remember the nt of this word for later
.d62e	20 de c3	jsr $c3de	DStore:		jsr PopYA
.d631	85 14		sta $14		DStoreYA:	sta tmp1+0	; save addr
.d633	84 15		sty $15				sty tmp1+1
.d635	b5 26		lda $26,x			lda DStack+2,x	; LSB
.d637	a0 00		ldy #$00			ldy #0
.d639	91 14		sta ($14),y			sta (tmp1),y
.d63b	b5 27		lda $27,x			lda DStack+3,x
.d63d	c8		iny				iny
.d63e	91 14		sta ($14),y			sta (tmp1),y
.d640	b5 24		lda $24,x			lda DStack+0,x
.d642	c8		iny				iny
.d643	91 14		sta ($14),y			sta (tmp1),y
.d645	b5 25		lda $25,x			lda DStack+1,x	; MSB
.d647	c8		iny				iny
.d648	91 14		sta ($14),y			sta (tmp1),y
.d64a	4c 6d d5	jmp $d56d			jmp Two_Drop	; also check underflow, return
=31					CodeLen	.var *-XtPtr1
=$d64d					Here1 = *	; remember here
>d62c	1f					.byte CodeLen	;patch wh_CodeLength
>d64d	32 52 40			Name0:	.text "2R@"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=54736					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>d650	03					.byte (("2R@"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=20					WordFlags ::= CO+NN	; modifiable copy, remember for later
=38					LinkDisplacement = Nt0-WordListLink
>d651	14					.byte WordFlags	;wh_Flags
>d652	03					.byte 3	;wh_CodeLength
>d653	26					  .byte LinkDisplacement	; offset to previous nt
=$d654					XtPtr1 ::= *
=54736					WordListLink ::= Nt0 ; remember the nt of this word for later
.d654					Two_r_fetch:
.d654	8a		txa				txa		; Y= return stack index
.d655	ba		tsx				tsx
.d656	86 14		stx $14				stx tmp1
.d658	a4 14		ldy $14				ldy tmp1
.d65a	aa		tax				tax
.d65b	ca		dex				dex		; make room on the Data Stack
.d65c	ca		dex				dex
.d65d	ca		dex				dex
.d65e	ca		dex				dex
.d65f	b9 03 01	lda $0103,y			lda RStack+3,y	; LSB of top entry
.d662	95 24		sta $24,x			sta DStack+0,x
.d664	b9 04 01	lda $0104,y			lda RStack+4,y	; MSB of top entry
.d667	95 25		sta $25,x			sta DStack+1,x
.d669	b9 05 01	lda $0105,y			lda RStack+5,y	; LSB of bottom entry
.d66c	95 26		sta $26,x			sta DStack+2,x
.d66e	b9 06 01	lda $0106,y			lda RStack+6,y	; MSB of bottom entry
.d671	95 27		sta $27,x			sta DStack+3,x
=31					CodeLen	.var *-XtPtr1
=$d673					Here1 = *	; remember here
>d652	1f					.byte CodeLen	;patch wh_CodeLength
.d673	60		rts				rts
>d674	32 52 3e			Name0:	.text "2R>"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=54775					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>d677	c3					.byte (("2R>"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=52					WordFlags ::= CO+ST	; modifiable copy, remember for later
=39					LinkDisplacement = Nt0-WordListLink
>d678	34					.byte WordFlags	;wh_Flags
>d679	03					.byte 3	;wh_CodeLength
>d67a	27					  .byte LinkDisplacement	; offset to previous nt
=$d67b					XtPtr1 ::= *
=54775					WordListLink ::= Nt0 ; remember the nt of this word for later
.d67b					Two_r_from:
.d67b	68		pla				pla			; save the return address
.d67c	85 14		sta $14				sta tmp1+0
.d67e	68		pla				pla
.d67f	85 15		sta $15				sta tmp1+1
.d681	ca		dex				dex			; make room on stack
.d682	ca		dex				dex
.d683	ca		dex				dex
.d684	ca		dex				dex
.d685	68		pla				pla			; LSB
.d686	95 24		sta $24,x			sta DStack+0,x
.d688	68		pla				pla			; MSB
.d689	95 25		sta $25,x			sta DStack+1,x
.d68b	68		pla				pla			; LSB
.d68c	95 26		sta $26,x			sta DStack+2,x
.d68e	68		pla				pla			; MSB
.d68f	95 27		sta $27,x			sta DStack+3,x
.d691	a5 15		lda $15				lda tmp1+1		; restore return address
.d693	48		pha				pha
.d694	a5 14		lda $14				lda tmp1+0
.d696	48		pha				pha
=28					CodeLen	.var *-XtPtr1
=$d697					Here1 = *	; remember here
>d679	1c					.byte CodeLen	;patch wh_CodeLength
.d697	60		rts				rts
>d698	32 3e 52			Name0:	.text "2>R"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=54811					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>d69b	43					.byte (("2>R"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=116					WordFlags ::= CO+UF+ST	; modifiable copy, remember for later
=36					LinkDisplacement = Nt0-WordListLink
>d69c	74					.byte WordFlags	;wh_Flags
>d69d	03					.byte 3	;wh_CodeLength
>d69e	24					  .byte LinkDisplacement	; offset to previous nt
=$d69f					XtPtr1 ::= *
=54811					WordListLink ::= Nt0 ; remember the nt of this word for later
.d69f					Two_to_r:
.d69f	68		pla				pla		; save the return address
.d6a0	85 14		sta $14				sta tmp1+0
.d6a2	68		pla				pla
.d6a3	85 15		sta $15				sta tmp1+1
.d6a5	20 1b c4	jsr $c41b			jsr underflow_2
.d6a8	b5 27		lda $27,x			lda DStack+3,x	; MSB
.d6aa	48		pha				pha
.d6ab	b5 26		lda $26,x			lda DStack+2,x	; LSB
.d6ad	48		pha				pha
.d6ae	b5 25		lda $25,x			lda DStack+1,x	; MSB
.d6b0	48		pha				pha
.d6b1	b5 24		lda $24,x			lda DStack+0,x	; LSB
.d6b3	48		pha				pha
.d6b4	e8		inx				inx
.d6b5	e8		inx				inx
.d6b6	e8		inx				inx
.d6b7	e8		inx				inx
.d6b8	a5 15		lda $15				lda tmp1+1	; restore return address
.d6ba	48		pha				pha
.d6bb	a5 14		lda $14				lda tmp1+0
.d6bd	48		pha				pha
=31					CodeLen	.var *-XtPtr1
=$d6be					Here1 = *	; remember here
>d69d	1f					.byte CodeLen	;patch wh_CodeLength
.d6be	60		rts				rts
>d6bf	49 6e 76 65 72 74		Name0:	.text "Invert"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=54853					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>d6c5	86					.byte (("Invert"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$40					WordFlags ::= UF	; modifiable copy, remember for later
=42					LinkDisplacement = Nt0-WordListLink
>d6c6	40					.byte WordFlags	;wh_Flags
>d6c7	03					.byte 3	;wh_CodeLength
>d6c8	2a					  .byte LinkDisplacement	; offset to previous nt
=$d6c9					XtPtr1 ::= *
=54853					WordListLink ::= Nt0 ; remember the nt of this word for later
.d6c9					Invert:
.d6c9	e0 27		cpx #$27		cpx #(DDim-1)*2+1	; far enough below end of data stack (& not negative)?
.d6cb	b0 39		bcs $d706		bcs Throw_Stack_17
.d6cd	a9 ff		lda #$ff			lda #$FF
.d6cf	55 24		eor $24,x			eor DStack+0,x	; LSB
.d6d1	95 24		sta $24,x			sta DStack+0,x
.d6d3	a9 ff		lda #$ff			lda #$FF
.d6d5	55 25		eor $25,x			eor DStack+1,x	; MSB
.d6d7	95 25		sta $25,x			sta DStack+1,x
=16					CodeLen	.var *-XtPtr1
=$d6d9					Here1 = *	; remember here
>d6c7	10					.byte CodeLen	;patch wh_CodeLength
.d6d9	60		rts				rts
>d6da	4e 65 67 61 74 65		Name0:	.text "Negate"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=54880					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>d6e0	a6					.byte (("Negate"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=27					LinkDisplacement = Nt0-WordListLink
>d6e1	10					.byte WordFlags	;wh_Flags
>d6e2	03					.byte 3	;wh_CodeLength
>d6e3	1b					  .byte LinkDisplacement	; offset to previous nt
=$d6e4					XtPtr1 ::= *
=54880					WordListLink ::= Nt0 ; remember the nt of this word for later
.d6e4					Negate:
.d6e4	e0 27		cpx #$27		cpx #(DDim-1)*2+1	; far enough below end of data stack (& not negative)?
.d6e6	b0 1e		bcs $d706		bcs Throw_Stack_17
.d6e8	38		sec		Negate3:	sec
.d6e9	a9 00		lda #$00	Negate4:	lda #0
.d6eb	f5 24		sbc $24,x			sbc DStack+0,x	; LSB
.d6ed	95 24		sta $24,x			sta DStack+0,x
.d6ef	a9 00		lda #$00			lda #0
.d6f1	f5 25		sbc $25,x			sbc DStack+1,x	; MSB
.d6f3	95 25		sta $25,x			sta DStack+1,x
=17					CodeLen	.var *-XtPtr1
=$d6f5					Here1 = *	; remember here
>d6e2	11					.byte CodeLen	;patch wh_CodeLength
.d6f5	60		rts				rts
>d6f6	41 62 73			Name0:	.text "Abs"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=54905					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>d6f9	63					.byte (("Abs"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=25					LinkDisplacement = Nt0-WordListLink
>d6fa	10					.byte WordFlags	;wh_Flags
>d6fb	03					.byte 3	;wh_CodeLength
>d6fc	19					  .byte LinkDisplacement	; offset to previous nt
=$d6fd					XtPtr1 ::= *
=54905					WordListLink ::= Nt0 ; remember the nt of this word for later
.d6fd					Abs:
.d6fd	e0 27		cpx #$27		cpx #(DDim-1)*2+1	; far enough below end of data stack (& not negative)?
.d6ff	b0 05		bcs $d706		bcs Throw_Stack_17
.d701	b5 25		lda $25,x			lda DStack+1,x	; n negative?
.d703	30 e3		bmi $d6e8			bmi Negate3
=8					CodeLen	.var *-XtPtr1
=$d705					Here1 = *	; remember here
>d6fb	08					.byte CodeLen	;patch wh_CodeLength
.d705	60		rts				rts
.d706	4c 2a c4	jmp $c42a	Throw_Stack_17: jmp Throw_Stack
>d709	44 4e 65 67 61 74 65		Name0:	.text "DNegate"	;  name of word as a string, ending at wh_NameLastChar
=7					NameLength = *-Name0
=54928					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>d710	a7					.byte (("DNegate"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=23					LinkDisplacement = Nt0-WordListLink
>d711	10					.byte WordFlags	;wh_Flags
>d712	03					.byte 3	;wh_CodeLength
>d713	17					  .byte LinkDisplacement	; offset to previous nt
=$d714					XtPtr1 ::= *
=54928					WordListLink ::= Nt0 ; remember the nt of this word for later
.d714					DNegate:
.d714	e0 25		cpx #$25		cpx #(DDim-2)*2+1	; far enough below end of data stack (& not negative)?
.d716	b0 ee		bcs $d706		bcs Throw_Stack_17
.d718	38		sec		DNegate3:	sec
.d719	a9 00		lda #$00			lda #0
.d71b	f5 26		sbc $26,x			sbc DStack+2,x	; LSB of low cell
.d71d	95 26		sta $26,x			sta DStack+2,x
.d71f	a9 00		lda #$00			lda #0
.d721	f5 27		sbc $27,x			sbc DStack+3,x	; MSB of low cell
.d723	95 27		sta $27,x			sta DStack+3,x
.d725	4c e9 d6	jmp $d6e9			jmp Negate4
=20					CodeLen	.var *-XtPtr1
=$d728					Here1 = *	; remember here
>d712	14					.byte CodeLen	;patch wh_CodeLength
>d728	44 41 62 73			Name0:	.text "DAbs"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=54956					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>d72c	64					.byte (("DAbs"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=28					LinkDisplacement = Nt0-WordListLink
>d72d	10					.byte WordFlags	;wh_Flags
>d72e	03					.byte 3	;wh_CodeLength
>d72f	1c					  .byte LinkDisplacement	; offset to previous nt
=$d730					XtPtr1 ::= *
=54956					WordListLink ::= Nt0 ; remember the nt of this word for later
.d730					DAbs:
.d730	e0 25		cpx #$25		cpx #(DDim-2)*2+1	; far enough below end of data stack (& not negative)?
.d732	b0 d2		bcs $d706		bcs Throw_Stack_17
.d734	b5 25		lda $25,x			lda DStack+1,x	; d negative?
.d736	30 e0		bmi $d718			bmi DNegate3
=8					CodeLen	.var *-XtPtr1
=$d738					Here1 = *	; remember here
>d72e	08					.byte CodeLen	;patch wh_CodeLength
.d738	60		rts				rts
>d739	44 3c 3e			Name0:	.text "D<>"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=54972					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>d73c	c3					.byte (("D<>"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=16					LinkDisplacement = Nt0-WordListLink
>d73d	10					.byte WordFlags	;wh_Flags
>d73e	03					.byte 3	;wh_CodeLength
>d73f	10					  .byte LinkDisplacement	; offset to previous nt
=$d740					XtPtr1 ::= *
=54972					WordListLink ::= Nt0 ; remember the nt of this word for later
.d740	20 4c d7	jsr $d74c	DNEq:		jsr DEqual
.d743	4c 37 d9	jmp $d937			jmp ZEqA
=6					CodeLen	.var *-XtPtr1
=$d746					Here1 = *	; remember here
>d73e	06					.byte CodeLen	;patch wh_CodeLength
>d746	44 3d				Name0:	.text "D="	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=54984					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>d748	a2					.byte (("D="[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=12					LinkDisplacement = Nt0-WordListLink
>d749	10					.byte WordFlags	;wh_Flags
>d74a	03					.byte 3	;wh_CodeLength
>d74b	0c					  .byte LinkDisplacement	; offset to previous nt
=$d74c					XtPtr1 ::= *
=54984					WordListLink ::= Nt0 ; remember the nt of this word for later
.d74c	b5 2a		lda $2a,x	DEqual:		lda DStack+6,x
.d74e	d5 26		cmp $26,x			cmp DStack+2,x
.d750	d0 4c		bne $d79e			bne False3
.d752	b5 2b		lda $2b,x			lda DStack+7,x
.d754	d5 27		cmp $27,x			cmp DStack+3,x
.d756	d0 46		bne $d79e			bne False3
.d758	b5 24		lda $24,x			lda DStack+0,x
.d75a	d5 28		cmp $28,x			cmp DStack+4,x
.d75c	d0 40		bne $d79e			bne False3
.d75e	b5 25		lda $25,x			lda DStack+1,x
.d760	d5 29		cmp $29,x			cmp DStack+5,x
.d762	d0 3a		bne $d79e			bne False3
.d764	f0 5c		beq $d7c2			beq True3
=26					CodeLen	.var *-XtPtr1
=$d766					Here1 = *	; remember here
>d74a	1a					.byte CodeLen	;patch wh_CodeLength
>d766	44 55 3e			Name0:	.text "DU>"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=55017					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>d769	c3					.byte (("DU>"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=33					LinkDisplacement = Nt0-WordListLink
>d76a	10					.byte WordFlags	;wh_Flags
>d76b	03					.byte 3	;wh_CodeLength
>d76c	21					  .byte LinkDisplacement	; offset to previous nt
=$d76d					XtPtr1 ::= *
=55017					WordListLink ::= Nt0 ; remember the nt of this word for later
.d76d	20 03 d8	jsr $d803	DUGt:		jsr DGtSub
.d770	90 50		bcc $d7c2			bcc True3
.d772	b0 2a		bcs $d79e			bcs False3
=7					CodeLen	.var *-XtPtr1
=$d774					Here1 = *	; remember here
>d76b	07					.byte CodeLen	;patch wh_CodeLength
>d774	44 55 3c 3d			Name0:	.text "DU<="	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=55032					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>d778	a4					.byte (("DU<="[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=15					LinkDisplacement = Nt0-WordListLink
>d779	10					.byte WordFlags	;wh_Flags
>d77a	03					.byte 3	;wh_CodeLength
>d77b	0f					  .byte LinkDisplacement	; offset to previous nt
=$d77c					XtPtr1 ::= *
=55032					WordListLink ::= Nt0 ; remember the nt of this word for later
.d77c	20 03 d8	jsr $d803	DULe:		jsr DGtSub
.d77f	b0 41		bcs $d7c2			bcs True3
.d781	90 1b		bcc $d79e			bcc False3
=7					CodeLen	.var *-XtPtr1
=$d783					Here1 = *	; remember here
>d77a	07					.byte CodeLen	;patch wh_CodeLength
>d783	44 55 3e 3d			Name0:	.text "DU>="	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=55047					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>d787	a4					.byte (("DU>="[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=15					LinkDisplacement = Nt0-WordListLink
>d788	10					.byte WordFlags	;wh_Flags
>d789	03					.byte 3	;wh_CodeLength
>d78a	0f					  .byte LinkDisplacement	; offset to previous nt
=$d78b					XtPtr1 ::= *
=55047					WordListLink ::= Nt0 ; remember the nt of this word for later
.d78b	20 d3 d7	jsr $d7d3	DUGe:		jsr DLessSub
.d78e	b0 32		bcs $d7c2			bcs True3
.d790	90 0c		bcc $d79e			bcc False3
=7					CodeLen	.var *-XtPtr1
=$d792					Here1 = *	; remember here
>d789	07					.byte CodeLen	;patch wh_CodeLength
>d792	44 55 3c			Name0:	.text "DU<"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=55061					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>d795	83					.byte (("DU<"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=14					LinkDisplacement = Nt0-WordListLink
>d796	10					.byte WordFlags	;wh_Flags
>d797	03					.byte 3	;wh_CodeLength
>d798	0e					  .byte LinkDisplacement	; offset to previous nt
=$d799					XtPtr1 ::= *
=55061					WordListLink ::= Nt0 ; remember the nt of this word for later
.d799	20 d3 d7	jsr $d7d3	DULess:		jsr DLessSub
.d79c	90 24		bcc $d7c2			bcc True3
.d79e	a9 00		lda #$00	False3:		lda #0
.d7a0	f0 22		beq $d7c4			beq DReturn3
=9					CodeLen	.var *-XtPtr1
=$d7a2					Here1 = *	; remember here
>d797	09					.byte CodeLen	;patch wh_CodeLength
.d7a2	4c 2a c4	jmp $c42a	Throw_Stack_09: jmp Throw_Stack
>d7a5	44 3e 3d			Name0:	.text "D>="	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=55080					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>d7a8	a3					.byte (("D>="[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=19					LinkDisplacement = Nt0-WordListLink
>d7a9	10					.byte WordFlags	;wh_Flags
>d7aa	03					.byte 3	;wh_CodeLength
>d7ab	13					  .byte LinkDisplacement	; offset to previous nt
=$d7ac					XtPtr1 ::= *
=55080					WordListLink ::= Nt0 ; remember the nt of this word for later
.d7ac	20 d3 d7	jsr $d7d3	DGEq:		jsr DLessSub
.d7af	70 0f		bvs $d7c0			bvs DLess3
.d7b1	10 0f		bpl $d7c2	DGEq3:		bpl True3
.d7b3	30 e9		bmi $d79e			bmi False3
=9					CodeLen	.var *-XtPtr1
=$d7b5					Here1 = *	; remember here
>d7aa	09					.byte CodeLen	;patch wh_CodeLength
>d7b5	44 3c				Name0:	.text "D<"	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=55095					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>d7b7	82					.byte (("D<"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=15					LinkDisplacement = Nt0-WordListLink
>d7b8	10					.byte WordFlags	;wh_Flags
>d7b9	03					.byte 3	;wh_CodeLength
>d7ba	0f					  .byte LinkDisplacement	; offset to previous nt
=$d7bb					XtPtr1 ::= *
=55095					WordListLink ::= Nt0 ; remember the nt of this word for later
.d7bb	20 d3 d7	jsr $d7d3	DLess:		jsr DLessSub
.d7be	70 f1		bvs $d7b1			bvs DGEq3
.d7c0	10 dc		bpl $d79e	DLess3:		bpl False3
.d7c2	a9 ff		lda #$ff	True3:		lda #$ff
.d7c4					DReturn3:
.d7c4	e0 21		cpx #$21		cpx #(DDim-4)*2+1	; far enough below end of data stack (& not negative)?
.d7c6	b0 da		bcs $d7a2		bcs Throw_Stack_09
.d7c8	95 2a		sta $2a,x			sta DStack+6,x
.d7ca	95 2b		sta $2b,x			sta DStack+7,x
.d7cc	e8		inx				inx			; preserve A, don't use ThreeDrop
.d7cd	e8		inx				inx
.d7ce	e8		inx				inx
.d7cf	e8		inx				inx
.d7d0	e8		inx				inx
.d7d1	e8		inx				inx
.d7d2	60		rts				rts
=24					CodeLen	.var *-XtPtr1
=$d7d3					Here1 = *	; remember here
>d7b9	18					.byte CodeLen	;patch wh_CodeLength
.d7d3	b5 2a		lda $2a,x	DLessSub:	lda DStack+6,x
.d7d5	d5 26		cmp $26,x			cmp DStack+2,x
.d7d7	b5 2b		lda $2b,x			lda DStack+7,x
.d7d9	f5 27		sbc $27,x			sbc DStack+3,x
.d7db	b5 28		lda $28,x			lda DStack+4,x
.d7dd	f5 24		sbc $24,x			sbc DStack+0,x
.d7df	b5 29		lda $29,x			lda DStack+5,x
.d7e1	f5 25		sbc $25,x			sbc DStack+1,x
.d7e3	60		rts				rts
>d7e4	44 3c 3d			Name0:	.text "D<="	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=55143					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>d7e7	a3					.byte (("D<="[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=48					LinkDisplacement = Nt0-WordListLink
>d7e8	10					.byte WordFlags	;wh_Flags
>d7e9	03					.byte 3	;wh_CodeLength
>d7ea	30					  .byte LinkDisplacement	; offset to previous nt
=$d7eb					XtPtr1 ::= *
=55143					WordListLink ::= Nt0 ; remember the nt of this word for later
.d7eb	20 03 d8	jsr $d803	DLe:		jsr DGtSub
.d7ee	70 0f		bvs $d7ff			bvs DGt3
.d7f0	10 d0		bpl $d7c2	DLe3:		bpl True3
.d7f2	30 aa		bmi $d79e			bmi False3
=9					CodeLen	.var *-XtPtr1
=$d7f4					Here1 = *	; remember here
>d7e9	09					.byte CodeLen	;patch wh_CodeLength
>d7f4	44 3e				Name0:	.text "D>"	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=55158					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>d7f6	c2					.byte (("D>"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=15					LinkDisplacement = Nt0-WordListLink
>d7f7	10					.byte WordFlags	;wh_Flags
>d7f8	03					.byte 3	;wh_CodeLength
>d7f9	0f					  .byte LinkDisplacement	; offset to previous nt
=$d7fa					XtPtr1 ::= *
=55158					WordListLink ::= Nt0 ; remember the nt of this word for later
.d7fa	20 03 d8	jsr $d803	DGt:		jsr DGtSub
.d7fd	70 f1		bvs $d7f0			bvs DLe3
.d7ff	30 c1		bmi $d7c2	DGt3:		bmi True3
.d801	10 9b		bpl $d79e			bpl False3
=9					CodeLen	.var *-XtPtr1
=$d803					Here1 = *	; remember here
>d7f8	09					.byte CodeLen	;patch wh_CodeLength
.d803	b5 26		lda $26,x	DGtSub:		lda DStack+2,x
.d805	d5 2a		cmp $2a,x			cmp DStack+6,x
.d807	b5 27		lda $27,x			lda DStack+3,x
.d809	f5 2b		sbc $2b,x			sbc DStack+7,x
.d80b	b5 24		lda $24,x			lda DStack+0,x
.d80d	f5 28		sbc $28,x			sbc DStack+4,x
.d80f	b5 25		lda $25,x			lda DStack+1,x
.d811	f5 29		sbc $29,x			sbc DStack+5,x
.d813	60		rts				rts
>d814	44 30 3c 3d			Name0:	.text "D0<="	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=55192					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>d818	a4					.byte (("D0<="[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=34					LinkDisplacement = Nt0-WordListLink
>d819	10					.byte WordFlags	;wh_Flags
>d81a	03					.byte 3	;wh_CodeLength
>d81b	22					  .byte LinkDisplacement	; offset to previous nt
=$d81c					XtPtr1 ::= *
=55192					WordListLink ::= Nt0 ; remember the nt of this word for later
.d81c	b5 25		lda $25,x	D0Le:		lda DStack+1,x	; test sign
.d81e	30 65		bmi $d885			bmi True1
.d820	10 24		bpl $d846			bpl D0Equal
=6					CodeLen	.var *-XtPtr1
=$d822					Here1 = *	; remember here
>d81a	06					.byte CodeLen	;patch wh_CodeLength
>d822	44 30 3e			Name0:	.text "D0>"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=55205					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>d825	c3					.byte (("D0>"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>d826	10					.byte WordFlags	;wh_Flags
>d827	03					.byte 3	;wh_CodeLength
>d828	0d					  .byte LinkDisplacement	; offset to previous nt
=$d829					XtPtr1 ::= *
=55205					WordListLink ::= Nt0 ; remember the nt of this word for later
.d829	b5 25		lda $25,x	D0Gt:		lda DStack+1,x	; test sign
.d82b	10 0b		bpl $d838			bpl D0Ne
.d82d	4c a4 d8	jmp $d8a4			jmp False1
>d830	44 30 3c 3e			Name0:	.text "D0<>"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=55220					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>d834	c4					.byte (("D0<>"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=15					LinkDisplacement = Nt0-WordListLink
>d835	10					.byte WordFlags	;wh_Flags
>d836	03					.byte 3	;wh_CodeLength
>d837	0f					  .byte LinkDisplacement	; offset to previous nt
=$d838					XtPtr1 ::= *
=55220					WordListLink ::= Nt0 ; remember the nt of this word for later
.d838	20 4d d8	jsr $d84d	D0Ne:		jsr D0EqSub
.d83b	d0 48		bne $d885			bne True1
.d83d	f0 65		beq $d8a4			beq False1
=7					CodeLen	.var *-XtPtr1
=$d83f					Here1 = *	; remember here
>d836	07					.byte CodeLen	;patch wh_CodeLength
>d83f	44 30 3d			Name0:	.text "D0="	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=55234					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>d842	a3					.byte (("D0="[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=14					LinkDisplacement = Nt0-WordListLink
>d843	10					.byte WordFlags	;wh_Flags
>d844	03					.byte 3	;wh_CodeLength
>d845	0e					  .byte LinkDisplacement	; offset to previous nt
=$d846					XtPtr1 ::= *
=55234					WordListLink ::= Nt0 ; remember the nt of this word for later
.d846	20 4d d8	jsr $d84d	D0Equal:	jsr D0EqSub
.d849	d0 59		bne $d8a4			bne False1
.d84b	f0 38		beq $d885			beq True1
=7					CodeLen	.var *-XtPtr1
=$d84d					Here1 = *	; remember here
>d844	07					.byte CodeLen	;patch wh_CodeLength
.d84d	b5 26		lda $26,x	D0EqSub:	lda DStack+2,x
.d84f	15 27		ora $27,x			ora DStack+3,x
.d851	15 24		ora $24,x			ora DStack+0,x
.d853	15 25		ora $25,x			ora DStack+1,x
.d855	60		rts				rts
>d856	44 30 3c			Name0:	.text "D0<"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=55257					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>d859	83					.byte (("D0<"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=23					LinkDisplacement = Nt0-WordListLink
>d85a	10					.byte WordFlags	;wh_Flags
>d85b	03					.byte 3	;wh_CodeLength
>d85c	17					  .byte LinkDisplacement	; offset to previous nt
=$d85d					XtPtr1 ::= *
=55257					WordListLink ::= Nt0 ; remember the nt of this word for later
.d85d	b5 25		lda $25,x	D0Less:		lda DStack+1,x	; test sign
.d85f	30 24		bmi $d885			bmi True1
.d861	10 41		bpl $d8a4			bpl False1
=6					CodeLen	.var *-XtPtr1
=$d863					Here1 = *	; remember here
>d85b	06					.byte CodeLen	;patch wh_CodeLength
>d863	44 30 3e 3d			Name0:	.text "D0>="	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=55271					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>d867	a4					.byte (("D0>="[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=14					LinkDisplacement = Nt0-WordListLink
>d868	10					.byte WordFlags	;wh_Flags
>d869	03					.byte 3	;wh_CodeLength
>d86a	0e					  .byte LinkDisplacement	; offset to previous nt
=$d86b					XtPtr1 ::= *
=55271					WordListLink ::= Nt0 ; remember the nt of this word for later
.d86b	b5 25		lda $25,x	D0Ge:		lda DStack+1,x	; test sign
.d86d	10 16		bpl $d885			bpl True1
.d86f	30 33		bmi $d8a4			bmi False1
=6					CodeLen	.var *-XtPtr1
=$d871					Here1 = *	; remember here
>d869	06					.byte CodeLen	;patch wh_CodeLength
.d871	4c 2a c4	jmp $c42a	Throw_Stack_08: jmp Throw_Stack
>d874	3d				Name0:	.text "="	;  name of word as a string, ending at wh_NameLastChar
=1					NameLength = *-Name0
=55285					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>d875	a1					.byte (("="[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=14					LinkDisplacement = Nt0-WordListLink
>d876	10					.byte WordFlags	;wh_Flags
>d877	03					.byte 3	;wh_CodeLength
>d878	0e					  .byte LinkDisplacement	; offset to previous nt
=$d879					XtPtr1 ::= *
=55285					WordListLink ::= Nt0 ; remember the nt of this word for later
.d879	b5 24		lda $24,x	Equal:		lda DStack+0,x		; LSB
.d87b	d5 26		cmp $26,x			cmp DStack+2,x
.d87d	d0 25		bne $d8a4			bne False1
.d87f	b5 25		lda $25,x			lda DStack+1,x		; MSB
.d881	d5 27		cmp $27,x			cmp DStack+3,x
.d883	d0 1f		bne $d8a4			bne False1
.d885	a9 ff		lda #$ff	True1:		lda #$ff	; return TRUE
.d887					Return1:
.d887	e0 25		cpx #$25		cpx #(DDim-2)*2+1	; far enough below end of data stack (& not negative)?
.d889	b0 e6		bcs $d871		bcs Throw_Stack_08
.d88b	e8		inx				inx		; Drop
.d88c	e8		inx				inx
.d88d	95 24		sta $24,x			sta DStack+0,x	; store f
.d88f	95 25		sta $25,x			sta DStack+1,x
.d891	60		rts				rts
=25					CodeLen	.var *-XtPtr1
=$d892					Here1 = *	; remember here
>d877	19					.byte CodeLen	;patch wh_CodeLength
>d892	3c 3e				Name0:	.text "<>"	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=55316					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>d894	c2					.byte (("<>"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=31					LinkDisplacement = Nt0-WordListLink
>d895	10					.byte WordFlags	;wh_Flags
>d896	03					.byte 3	;wh_CodeLength
>d897	1f					  .byte LinkDisplacement	; offset to previous nt
=$d898					XtPtr1 ::= *
=55316					WordListLink ::= Nt0 ; remember the nt of this word for later
.d898	b5 24		lda $24,x	Not_Equals:	lda DStack+0,x		; LSB
.d89a	d5 26		cmp $26,x			cmp DStack+2,x
.d89c	d0 e7		bne $d885			bne True1
.d89e	b5 25		lda $25,x			lda DStack+1,x		; MSB
.d8a0	d5 27		cmp $27,x			cmp DStack+3,x
.d8a2	d0 e1		bne $d885			bne True1
.d8a4	a9 00		lda #$00	False1:		lda #0		; return FALSE
.d8a6	f0 df		beq $d887			beq Return1
=16					CodeLen	.var *-XtPtr1
=$d8a8					Here1 = *	; remember here
>d896	10					.byte CodeLen	;patch wh_CodeLength
>d8a8	3c				Name0:	.text "<"	;  name of word as a string, ending at wh_NameLastChar
=1					NameLength = *-Name0
=55337					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>d8a9	81					.byte (("<"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=21					LinkDisplacement = Nt0-WordListLink
>d8aa	10					.byte WordFlags	;wh_Flags
>d8ab	03					.byte 3	;wh_CodeLength
>d8ac	15					  .byte LinkDisplacement	; offset to previous nt
=$d8ad					XtPtr1 ::= *
=55337					WordListLink ::= Nt0 ; remember the nt of this word for later
.d8ad	b5 26		lda $26,x	Less_Than:	lda DStack+2,x	; compare
.d8af	d5 24		cmp $24,x			cmp DStack+0,x
.d8b1	b5 27		lda $27,x			lda DStack+3,x
.d8b3	f5 25		sbc $25,x			sbc DStack+1,x
.d8b5	50 02		bvc $d8b9			bvc _c
.d8b7	49 80		eor #$80			eor #$80	; fix sign
.d8b9	10 e9		bpl $d8a4	_c:		bpl False1
.d8bb	30 c8		bmi $d885			bmi True1
=16					CodeLen	.var *-XtPtr1
=$d8bd					Here1 = *	; remember here
>d8ab	10					.byte CodeLen	;patch wh_CodeLength
>d8bd	3e 3d				Name0:	.text ">="	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=55359					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>d8bf	a2					.byte ((">="[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=22					LinkDisplacement = Nt0-WordListLink
>d8c0	10					.byte WordFlags	;wh_Flags
>d8c1	03					.byte 3	;wh_CodeLength
>d8c2	16					  .byte LinkDisplacement	; offset to previous nt
=$d8c3					XtPtr1 ::= *
=55359					WordListLink ::= Nt0 ; remember the nt of this word for later
.d8c3	20 ad d8	jsr $d8ad	Ge:		jsr Less_Than
.d8c6	4c 37 d9	jmp $d937			jmp ZEqA
=6					CodeLen	.var *-XtPtr1
=$d8c9					Here1 = *	; remember here
>d8c1	06					.byte CodeLen	;patch wh_CodeLength
>d8c9	55 3c				Name0:	.text "U<"	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=55371					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>d8cb	82					.byte (("U<"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=12					LinkDisplacement = Nt0-WordListLink
>d8cc	10					.byte WordFlags	;wh_Flags
>d8cd	03					.byte 3	;wh_CodeLength
>d8ce	0c					  .byte LinkDisplacement	; offset to previous nt
=$d8cf					XtPtr1 ::= *
=55371					WordListLink ::= Nt0 ; remember the nt of this word for later
.d8cf	b5 26		lda $26,x	U_Less_Than:	lda DStack+2,x
.d8d1	d5 24		cmp $24,x			cmp DStack+0,x
.d8d3	b5 27		lda $27,x			lda DStack+3,x
.d8d5	f5 25		sbc $25,x			sbc DStack+1,x
.d8d7	b0 cb		bcs $d8a4			bcs False1
.d8d9	90 aa		bcc $d885			bcc True1
=12					CodeLen	.var *-XtPtr1
=$d8db					Here1 = *	; remember here
>d8cd	0c					.byte CodeLen	;patch wh_CodeLength
>d8db	55 3e				Name0:	.text "U>"	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=55389					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>d8dd	c2					.byte (("U>"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=18					LinkDisplacement = Nt0-WordListLink
>d8de	10					.byte WordFlags	;wh_Flags
>d8df	03					.byte 3	;wh_CodeLength
>d8e0	12					  .byte LinkDisplacement	; offset to previous nt
=$d8e1					XtPtr1 ::= *
=55389					WordListLink ::= Nt0 ; remember the nt of this word for later
.d8e1	b5 24		lda $24,x	U_Greater_Than:	lda DStack+0,x
.d8e3	d5 26		cmp $26,x			cmp DStack+2,x
.d8e5	b5 25		lda $25,x			lda DStack+1,x
.d8e7	f5 27		sbc $27,x			sbc DStack+3,x
.d8e9	b0 b9		bcs $d8a4			bcs False1
.d8eb	90 98		bcc $d885			bcc True1
=12					CodeLen	.var *-XtPtr1
=$d8ed					Here1 = *	; remember here
>d8df	0c					.byte CodeLen	;patch wh_CodeLength
>d8ed	3e				Name0:	.text ">"	;  name of word as a string, ending at wh_NameLastChar
=1					NameLength = *-Name0
=55406					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>d8ee	c1					.byte ((">"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=17					LinkDisplacement = Nt0-WordListLink
>d8ef	10					.byte WordFlags	;wh_Flags
>d8f0	03					.byte 3	;wh_CodeLength
>d8f1	11					  .byte LinkDisplacement	; offset to previous nt
=$d8f2					XtPtr1 ::= *
=55406					WordListLink ::= Nt0 ; remember the nt of this word for later
.d8f2	b5 24		lda $24,x	Greater_Than:	lda DStack+0,x	; compare
.d8f4	d5 26		cmp $26,x			cmp DStack+2,x
.d8f6	b5 25		lda $25,x			lda DStack+1,x
.d8f8	f5 27		sbc $27,x			sbc DStack+3,x
.d8fa	50 02		bvc $d8fe			bvc _c
.d8fc	49 80		eor #$80			eor #$80	; fix sign
.d8fe	10 a4		bpl $d8a4	_c:		bpl False1
.d900	4c 85 d8	jmp $d885			jmp True1
=17					CodeLen	.var *-XtPtr1
=$d903					Here1 = *	; remember here
>d8f0	11					.byte CodeLen	;patch wh_CodeLength
>d903	3c 3d				Name0:	.text "<="	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=55429					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>d905	a2					.byte (("<="[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=23					LinkDisplacement = Nt0-WordListLink
>d906	10					.byte WordFlags	;wh_Flags
>d907	03					.byte 3	;wh_CodeLength
>d908	17					  .byte LinkDisplacement	; offset to previous nt
=$d909					XtPtr1 ::= *
=55429					WordListLink ::= Nt0 ; remember the nt of this word for later
.d909	20 f2 d8	jsr $d8f2	Le:		jsr Greater_Than
.d90c	4c 37 d9	jmp $d937			jmp ZEqA
=6					CodeLen	.var *-XtPtr1
=$d90f					Here1 = *	; remember here
>d907	06					.byte CodeLen	;patch wh_CodeLength
>d90f	55 3e 3d			Name0:	.text "U>="	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=55442					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>d912	a3					.byte (("U>="[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>d913	10					.byte WordFlags	;wh_Flags
>d914	03					.byte 3	;wh_CodeLength
>d915	0d					  .byte LinkDisplacement	; offset to previous nt
=$d916					XtPtr1 ::= *
=55442					WordListLink ::= Nt0 ; remember the nt of this word for later
.d916	20 cf d8	jsr $d8cf	UGe:		jsr U_Less_Than
.d919	4c 37 d9	jmp $d937			jmp ZEqA
=6					CodeLen	.var *-XtPtr1
=$d91c					Here1 = *	; remember here
>d914	06					.byte CodeLen	;patch wh_CodeLength
>d91c	55 3c 3d			Name0:	.text "U<="	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=55455					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>d91f	a3					.byte (("U<="[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>d920	10					.byte WordFlags	;wh_Flags
>d921	03					.byte 3	;wh_CodeLength
>d922	0d					  .byte LinkDisplacement	; offset to previous nt
=$d923					XtPtr1 ::= *
=55455					WordListLink ::= Nt0 ; remember the nt of this word for later
.d923	20 e1 d8	jsr $d8e1	ULe:		jsr U_Greater_Than
.d926	4c 37 d9	jmp $d937			jmp ZEqA
=6					CodeLen	.var *-XtPtr1
=$d929					Here1 = *	; remember here
>d921	06					.byte CodeLen	;patch wh_CodeLength
>d929	30 3d				Name0:	.text "0="	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=55467					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>d92b	a2					.byte (("0="[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=12					LinkDisplacement = Nt0-WordListLink
>d92c	10					.byte WordFlags	;wh_Flags
>d92d	03					.byte 3	;wh_CodeLength
>d92e	0c					  .byte LinkDisplacement	; offset to previous nt
=$d92f					XtPtr1 ::= *
=55467					WordListLink ::= Nt0 ; remember the nt of this word for later
.d92f	b5 25		lda $25,x	Zero_Equal:	lda DStack+1,x
.d931	15 24		ora $24,x	ZEq3:		ora DStack+0,x
.d933	d0 2b		bne $d960			bne False0
.d935	f0 14		beq $d94b			beq True0
=8					CodeLen	.var *-XtPtr1
=$d937					Here1 = *	; remember here
>d92d	08					.byte CodeLen	;patch wh_CodeLength
.d937					ZEqA:
.d937	49 ff		eor #$ff			eor #$ff
.d939	95 24		sta $24,x			sta DStack+0,x
.d93b	95 25		sta $25,x			sta DStack+1,x
.d93d	60		rts				rts
>d93e	30 3c 3e			Name0:	.text "0<>"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=55489					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>d941	c3					.byte (("0<>"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=22					LinkDisplacement = Nt0-WordListLink
>d942	10					.byte WordFlags	;wh_Flags
>d943	03					.byte 3	;wh_CodeLength
>d944	16					  .byte LinkDisplacement	; offset to previous nt
=$d945					XtPtr1 ::= *
=55489					WordListLink ::= Nt0 ; remember the nt of this word for later
.d945	b5 25		lda $25,x	Zero_Unequal:	lda DStack+1,x
.d947	15 24		ora $24,x	ZNe3:		ora DStack+0,x
.d949	f0 15		beq $d960			beq False0
.d94b	a9 ff		lda #$ff	True0:		lda #$ff	; return TRUE
.d94d	95 24		sta $24,x	Return0:	sta DStack+0,x
.d94f	95 25		sta $25,x			sta DStack+1,x
.d951	e0 27		cpx #$27		cpx #(DDim-1)*2+1	; far enough below end of data stack (& not negative)?
.d953	b0 35		bcs $d98a		bcs Throw_Stack_05
.d955	60		rts				rts
=17					CodeLen	.var *-XtPtr1
=$d956					Here1 = *	; remember here
>d943	11					.byte CodeLen	;patch wh_CodeLength
>d956	30 3e				Name0:	.text "0>"	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=55512					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>d958	c2					.byte (("0>"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=23					LinkDisplacement = Nt0-WordListLink
>d959	10					.byte WordFlags	;wh_Flags
>d95a	03					.byte 3	;wh_CodeLength
>d95b	17					  .byte LinkDisplacement	; offset to previous nt
=$d95c					XtPtr1 ::= *
=55512					WordListLink ::= Nt0 ; remember the nt of this word for later
.d95c	b5 25		lda $25,x	Zero_Greater:	lda DStack+1,x	; MSB
.d95e	10 e7		bpl $d947			bpl ZNe3	; >= 0 ?
.d960	a9 00		lda #$00	False0:		lda #0		; return FALSE
.d962	f0 e9		beq $d94d			beq Return0
=8					CodeLen	.var *-XtPtr1
=$d964					Here1 = *	; remember here
>d95a	08					.byte CodeLen	;patch wh_CodeLength
>d964	30 3c 3d			Name0:	.text "0<="	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=55527					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>d967	a3					.byte (("0<="[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=15					LinkDisplacement = Nt0-WordListLink
>d968	10					.byte WordFlags	;wh_Flags
>d969	03					.byte 3	;wh_CodeLength
>d96a	0f					  .byte LinkDisplacement	; offset to previous nt
=$d96b					XtPtr1 ::= *
=55527					WordListLink ::= Nt0 ; remember the nt of this word for later
.d96b	b5 25		lda $25,x	ZLe:		lda DStack+1,x	; < 0 ?
.d96d	30 dc		bmi $d94b			bmi True0
.d96f	10 c0		bpl $d931			bpl ZEq3
=6					CodeLen	.var *-XtPtr1
=$d971					Here1 = *	; remember here
>d969	06					.byte CodeLen	;patch wh_CodeLength
>d971	30 3e 3d			Name0:	.text "0>="	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=55540					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>d974	a3					.byte (("0>="[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>d975	10					.byte WordFlags	;wh_Flags
>d976	03					.byte 3	;wh_CodeLength
>d977	0d					  .byte LinkDisplacement	; offset to previous nt
=$d978					XtPtr1 ::= *
=55540					WordListLink ::= Nt0 ; remember the nt of this word for later
.d978	b5 25		lda $25,x	ZGe:		lda DStack+1,x
.d97a	10 cf		bpl $d94b			bpl True0
.d97c	30 e2		bmi $d960			bmi False0
=6					CodeLen	.var *-XtPtr1
=$d97e					Here1 = *	; remember here
>d976	06					.byte CodeLen	;patch wh_CodeLength
>d97e	30 3c				Name0:	.text "0<"	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=55552					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>d980	82					.byte (("0<"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=12					LinkDisplacement = Nt0-WordListLink
>d981	10					.byte WordFlags	;wh_Flags
>d982	03					.byte 3	;wh_CodeLength
>d983	0c					  .byte LinkDisplacement	; offset to previous nt
=$d984					XtPtr1 ::= *
=55552					WordListLink ::= Nt0 ; remember the nt of this word for later
.d984	b5 25		lda $25,x	Zero_Less:	lda DStack+1,x	; MSB
.d986	10 d8		bpl $d960			bpl False0
.d988	30 c1		bmi $d94b			bmi True0
=6					CodeLen	.var *-XtPtr1
=$d98a					Here1 = *	; remember here
>d982	06					.byte CodeLen	;patch wh_CodeLength
.d98a	4c 2a c4	jmp $c42a	Throw_Stack_05: jmp Throw_Stack
>d98d	4d 69 6e			Name0:	.text "Min"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=55568					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>d990	c3					.byte (("Min"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=16					LinkDisplacement = Nt0-WordListLink
>d991	10					.byte WordFlags	;wh_Flags
>d992	03					.byte 3	;wh_CodeLength
>d993	10					  .byte LinkDisplacement	; offset to previous nt
=$d994					XtPtr1 ::= *
=55568					WordListLink ::= Nt0 ; remember the nt of this word for later
.d994					Min:
.d994	e0 25		cpx #$25		cpx #(DDim-2)*2+1	; far enough below end of data stack (& not negative)?
.d996	b0 f2		bcs $d98a		bcs Throw_Stack_05
.d998	b5 24		lda $24,x			lda DStack+0,x	; compare n1 & n2; sets V & N but not Z
.d99a	d5 26		cmp $26,x			cmp DStack+2,x
.d99c	b5 25		lda $25,x			lda DStack+1,x
.d99e	f5 27		sbc $27,x			sbc DStack+3,x
.d9a0	70 1a		bvs $d9bc			bvs Max_3	; if overflow, the sign is backwards
.d9a2	30 28		bmi $d9cc	Min_3:		bmi Nip_NoUf	; if negative, NOS is larger and needs to be dumped
.d9a4	e8		inx				inx		; Drop n2
.d9a5	e8		inx				inx
=18					CodeLen	.var *-XtPtr1
=$d9a6					Here1 = *	; remember here
>d992	12					.byte CodeLen	;patch wh_CodeLength
.d9a6	60		rts				rts
>d9a7	4d 61 78			Name0:	.text "Max"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=55594					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>d9aa	03					.byte (("Max"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=26					LinkDisplacement = Nt0-WordListLink
>d9ab	10					.byte WordFlags	;wh_Flags
>d9ac	03					.byte 3	;wh_CodeLength
>d9ad	1a					  .byte LinkDisplacement	; offset to previous nt
=$d9ae					XtPtr1 ::= *
=55594					WordListLink ::= Nt0 ; remember the nt of this word for later
.d9ae					Max:
.d9ae	e0 25		cpx #$25		cpx #(DDim-2)*2+1	; far enough below end of data stack (& not negative)?
.d9b0	b0 d8		bcs $d98a		bcs Throw_Stack_05
.d9b2	b5 24		lda $24,x			lda DStack+0,x	; Compare n1 & n2; sets V & N but not Z
.d9b4	d5 26		cmp $26,x			cmp DStack+2,x
.d9b6	b5 25		lda $25,x			lda DStack+1,x
.d9b8	f5 27		sbc $27,x			sbc DStack+3,x
.d9ba	70 e6		bvs $d9a2			bvs Min_3	; if overflow, the sign is backwards
.d9bc	10 0e		bpl $d9cc	Max_3:		bpl Nip_NoUf	; if negative, NOS is larger and needs to be kept
.d9be	e8		inx				inx		; Drop n2
.d9bf	e8		inx				inx
=18					CodeLen	.var *-XtPtr1
=$d9c0					Here1 = *	; remember here
>d9ac	12					.byte CodeLen	;patch wh_CodeLength
.d9c0	60		rts				rts
>d9c1	4e 69 70			Name0:	.text "Nip"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=55620					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>d9c4	03					.byte (("Nip"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=26					LinkDisplacement = Nt0-WordListLink
>d9c5	10					.byte WordFlags	;wh_Flags
>d9c6	03					.byte 3	;wh_CodeLength
>d9c7	1a					  .byte LinkDisplacement	; offset to previous nt
=$d9c8					XtPtr1 ::= *
=55620					WordListLink ::= Nt0 ; remember the nt of this word for later
.d9c8					Nip:
.d9c8	e0 25		cpx #$25		cpx #(DDim-2)*2+1	; far enough below end of data stack (& not negative)?
.d9ca	b0 be		bcs $d98a		bcs Throw_Stack_05
.d9cc	b5 24		lda $24,x	Nip_NoUf:	lda DStack+0,x	; PopYA
.d9ce	b4 25		ldy $25,x			ldy DStack+1,x
.d9d0	e8		inx				inx
.d9d1	e8		inx				inx
.d9d2	95 24		sta $24,x			sta DStack+0,x	; store over n1
.d9d4	94 25		sty $25,x			sty DStack+1,x
=14					CodeLen	.var *-XtPtr1
=$d9d6					Here1 = *	; remember here
>d9c6	0e					.byte CodeLen	;patch wh_CodeLength
.d9d6	60		rts				rts
>d9d7	50 69 63 6b			Name0:	.text "Pick"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=55643					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>d9db	64					.byte (("Pick"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=0					WordFlags ::= 0	; modifiable copy, remember for later
=23					LinkDisplacement = Nt0-WordListLink
>d9dc	00					.byte WordFlags	;wh_Flags
>d9dd	03					.byte 3	;wh_CodeLength
>d9de	17					  .byte LinkDisplacement	; offset to previous nt
=$d9df					XtPtr1 ::= *
=55643					WordListLink ::= Nt0 ; remember the nt of this word for later
.d9df					Pick:
.d9df	16 24		asl $24,x			asl DStack+0,x	; we assume u < 128 (stack is small)
.d9e1	8a		txa				txa
.d9e2	75 24		adc $24,x			adc DStack+0,x
.d9e4	a8		tay				tay
.d9e5	b9 26 00	lda $0026,y			lda DStack+2,y
.d9e8	95 24		sta $24,x			sta DStack+0,x
.d9ea	b9 27 00	lda $0027,y			lda DStack+3,y
.d9ed	95 25		sta $25,x			sta DStack+1,x
=16					CodeLen	.var *-XtPtr1
=$d9ef					Here1 = *	; remember here
>d9dd	10					.byte CodeLen	;patch wh_CodeLength
.d9ef	60		rts				rts
>d9f0	43 68 61 72			Name0:	.text "Char"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=55668					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>d9f4	44					.byte (("Char"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=25					LinkDisplacement = Nt0-WordListLink
>d9f5	10					.byte WordFlags	;wh_Flags
>d9f6	03					.byte 3	;wh_CodeLength
>d9f7	19					  .byte LinkDisplacement	; offset to previous nt
=$d9f8					XtPtr1 ::= *
=55668					WordListLink ::= Nt0 ; remember the nt of this word for later
.d9f8					Char:
.d9f8	20 b3 ca	jsr $cab3			jsr parse_name_check
.d9fb	e8		inx				inx		; Drop number of characters, leave addr
.d9fc	e8		inx				inx
.d9fd	4c 9f dd	jmp $dd9f			jmp C_Fetch	; get character ( C@ )
=8					CodeLen	.var *-XtPtr1
=$da00					Here1 = *	; remember here
>d9f6	08					.byte CodeLen	;patch wh_CodeLength
>da00	5b 43 68 61 72 5d		Name0:	.text "[Char]"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=55686					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>da06	a6					.byte (("[Char]"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=28					WordFlags ::= CO+IM+NN	; modifiable copy, remember for later
=18					LinkDisplacement = Nt0-WordListLink
>da07	1c					.byte WordFlags	;wh_Flags
>da08	03					.byte 3	;wh_CodeLength
>da09	12					  .byte LinkDisplacement	; offset to previous nt
=$da0a					XtPtr1 ::= *
=55686					WordListLink ::= Nt0 ; remember the nt of this word for later
.da0a	20 f8 d9	jsr $d9f8	Bracket_Char:	jsr Char
.da0d	4c 52 c7	jmp $c752			jmp Literal
=6					CodeLen	.var *-XtPtr1
=$da10					Here1 = *	; remember here
>da08	06					.byte CodeLen	;patch wh_CodeLength
>da10	43 68 61 72 2b			Name0:	.text "Char+"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=55701					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>da15	65					.byte (("Char+"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=15					LinkDisplacement = Nt0-WordListLink
>da16	10					.byte WordFlags	;wh_Flags
>da17	03					.byte 3	;wh_CodeLength
>da18	0f					  .byte LinkDisplacement	; offset to previous nt
=$da19					XtPtr1 ::= *
=55701					WordListLink ::= Nt0 ; remember the nt of this word for later
.da19	4c 95 da	jmp $da95	Char_Plus:	jmp One_Plus
=3					CodeLen	.var *-XtPtr1
=$da1c					Here1 = *	; remember here
>da17	03					.byte CodeLen	;patch wh_CodeLength
>da1c	43 68 61 72 73			Name0:	.text "Chars"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=55713					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>da21	65					.byte (("Chars"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$20					WordFlags ::= AN	; modifiable copy, remember for later
=12					LinkDisplacement = Nt0-WordListLink
>da22	20					.byte WordFlags	;wh_Flags
>da23	03					.byte 3	;wh_CodeLength
>da24	0c					  .byte LinkDisplacement	; offset to previous nt
=$da25					XtPtr1 ::= *
=55713					WordListLink ::= Nt0 ; remember the nt of this word for later
.da25					Chars:
=0					CodeLen	.var *-XtPtr1
=$da25					Here1 = *	; remember here
>da23	00					.byte CodeLen	;patch wh_CodeLength
.da25	60		rts				rts
>da26	43 65 6c 6c 73			Name0:	.text "Cells"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=55723					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>da2b	65					.byte (("Cells"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=10					LinkDisplacement = Nt0-WordListLink
>da2c	10					.byte WordFlags	;wh_Flags
>da2d	03					.byte 3	;wh_CodeLength
>da2e	0a					  .byte LinkDisplacement	; offset to previous nt
=$da2f					XtPtr1 ::= *
=55723					WordListLink ::= Nt0 ; remember the nt of this word for later
.da2f					Cells:
.da2f	e0 27		cpx #$27		cpx #(DDim-1)*2+1	; far enough below end of data stack (& not negative)?
.da31	b0 74		bcs $daa7		bcs Throw_Stack_19
.da33	16 24		asl $24,x			asl DStack+0,x		; 2*
.da35	36 25		rol $25,x			rol DStack+1,x
=8					CodeLen	.var *-XtPtr1
=$da37					Here1 = *	; remember here
>da2d	08					.byte CodeLen	;patch wh_CodeLength
.da37	60		rts				rts
>da38	43 65 6c 6c 2b			Name0:	.text "Cell+"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=55741					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>da3d	65					.byte (("Cell+"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$40					WordFlags ::= UF	; modifiable copy, remember for later
=18					LinkDisplacement = Nt0-WordListLink
>da3e	40					.byte WordFlags	;wh_Flags
>da3f	03					.byte 3	;wh_CodeLength
>da40	12					  .byte LinkDisplacement	; offset to previous nt
=$da41					XtPtr1 ::= *
=55741					WordListLink ::= Nt0 ; remember the nt of this word for later
.da41	a9 02		lda #$02	Cell_Plus:	lda #2		; our cells are 2 bytes
.da43					Plus_A:
.da43	e0 27		cpx #$27		cpx #(DDim-1)*2+1	; far enough below end of data stack (& not negative)?
.da45	b0 60		bcs $daa7		bcs Throw_Stack_19
.da47	75 24		adc $24,x			adc DStack+0,x
.da49	95 24		sta $24,x			sta DStack+0,x
.da4b	90 02		bcc $da4f			bcc +
.da4d	f6 25		inc $25,x			inc DStack+1,x
.da4f					+
=14					CodeLen	.var *-XtPtr1
=$da4f					Here1 = *	; remember here
>da3f	0e					.byte CodeLen	;patch wh_CodeLength
.da4f	60		rts				rts
.da50					Nos_Plus_A:
.da50	18		clc				clc
.da51	75 26		adc $26,x			adc DStack+2,x
.da53	95 26		sta $26,x			sta DStack+2,x
.da55	90 02		bcc $da59			bcc +
.da57	f6 27		inc $27,x			inc DStack+3,x
.da59	60		rts		+		rts
>da5a	48 65 72 65			Name0:	.text "Here"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=55774					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>da5e	a4					.byte (("Here"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=33					LinkDisplacement = Nt0-WordListLink
>da5f	10					.byte WordFlags	;wh_Flags
>da60	03					.byte 3	;wh_CodeLength
>da61	21					  .byte LinkDisplacement	; offset to previous nt
=$da62					XtPtr1 ::= *
=55774					WordListLink ::= Nt0 ; remember the nt of this word for later
.da62	a5 00		lda $00		Here:		lda cp+0
.da64	a4 01		ldy $01				ldy cp+1
.da66	4c b5 c7	jmp $c7b5			jmp PushYA
=7					CodeLen	.var *-XtPtr1
=$da69					Here1 = *	; remember here
>da60	07					.byte CodeLen	;patch wh_CodeLength
>da69	31 2d				Name0:	.text "1-"	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=55787					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>da6b	a2					.byte (("1-"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>da6c	10					.byte WordFlags	;wh_Flags
>da6d	03					.byte 3	;wh_CodeLength
>da6e	0d					  .byte LinkDisplacement	; offset to previous nt
=$da6f					XtPtr1 ::= *
=55787					WordListLink ::= Nt0 ; remember the nt of this word for later
.da6f					One_Minus:
.da6f	e0 27		cpx #$27		cpx #(DDim-1)*2+1	; far enough below end of data stack (& not negative)?
.da71	b0 34		bcs $daa7		bcs Throw_Stack_19
.da73					One_Minus_NoUf:
.da73	b5 24		lda $24,x			lda DStack+0,x
.da75	d0 02		bne $da79			bne +
.da77	d6 25		dec $25,x			dec DStack+1,x
.da79	d6 24		dec $24,x	+		dec DStack+0,x
=12					CodeLen	.var *-XtPtr1
=$da7b					Here1 = *	; remember here
>da6d	0c					.byte CodeLen	;patch wh_CodeLength
.da7b	60		rts				rts
.da7c					NOS_One_Minus:
.da7c	b5 26		lda $26,x			lda DStack+2,x
.da7e	d0 02		bne $da82			bne +
.da80	d6 27		dec $27,x			dec DStack+3,x
.da82	d6 26		dec $26,x	+		dec DStack+2,x
.da84	60		rts				rts
.da85					Minus_A:
.da85	18		clc				clc
.da86	75 24		adc $24,x			adc DStack+0,x
.da88	95 24		sta $24,x			sta DStack+0,x
.da8a	b0 02		bcs $da8e			bcs +
.da8c	d6 25		dec $25,x			dec DStack+1,x
.da8e	60		rts		+		rts
>da8f	31 2b				Name0:	.text "1+"	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=55825					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>da91	62					.byte (("1+"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=38					LinkDisplacement = Nt0-WordListLink
>da92	10					.byte WordFlags	;wh_Flags
>da93	03					.byte 3	;wh_CodeLength
>da94	26					  .byte LinkDisplacement	; offset to previous nt
=$da95					XtPtr1 ::= *
=55825					WordListLink ::= Nt0 ; remember the nt of this word for later
.da95					One_Plus:
.da95	e0 27		cpx #$27		cpx #(DDim-1)*2+1	; far enough below end of data stack (& not negative)?
.da97	b0 0e		bcs $daa7		bcs Throw_Stack_19
.da99	f6 24		inc $24,x			inc DStack+0,x
.da9b	d0 02		bne $da9f			bne +
.da9d	f6 25		inc $25,x			inc DStack+1,x
.da9f					+
=10					CodeLen	.var *-XtPtr1
=$da9f					Here1 = *	; remember here
>da93	0a					.byte CodeLen	;patch wh_CodeLength
.da9f	60		rts				rts
.daa0					NOS_One_Plus:
.daa0	f6 26		inc $26,x			inc DStack+2,x
.daa2	d0 02		bne $daa6			bne +
.daa4	f6 27		inc $27,x			inc DStack+3,x
.daa6	60		rts		+		rts
.daa7	4c 2a c4	jmp $c42a	Throw_Stack_19: jmp Throw_Stack
>daaa	55 4d 2b			Name0:	.text "UM+"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=55853					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>daad	63					.byte (("UM+"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=0					WordFlags ::= 0	; modifiable copy, remember for later
=28					LinkDisplacement = Nt0-WordListLink
>daae	00					.byte WordFlags	;wh_Flags
>daaf	03					.byte 3	;wh_CodeLength
>dab0	1c					  .byte LinkDisplacement	; offset to previous nt
=$dab1					XtPtr1 ::= *
=55853					WordListLink ::= Nt0 ; remember the nt of this word for later
.dab1	20 de c3	jsr $c3de	UMPlus:		jsr PopYA
.dab4	18		clc				clc		; add n to d1.lo
.dab5	75 26		adc $26,x			adc DStack+2,x
.dab7	95 26		sta $26,x			sta DStack+2,x
.dab9	98		tya				tya
.daba	75 27		adc $27,x			adc DStack+3,x
.dabc	95 27		sta $27,x			sta DStack+3,x
.dabe	90 06		bcc $dac6			bcc +		; propagate carry thru d1.hi
.dac0	f6 24		inc $24,x			inc DStack+0,x
.dac2	d0 02		bne $dac6			bne +
.dac4	f6 25		inc $25,x			inc DStack+1,x
.dac6					+
=21					CodeLen	.var *-XtPtr1
=$dac6					Here1 = *	; remember here
>daaf	15					.byte CodeLen	;patch wh_CodeLength
.dac6	60		rts				rts
>dac7	4d 2b				Name0:	.text "M+"	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=55881					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>dac9	62					.byte (("M+"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=28					LinkDisplacement = Nt0-WordListLink
>daca	10					.byte WordFlags	;wh_Flags
>dacb	03					.byte 3	;wh_CodeLength
>dacc	1c					  .byte LinkDisplacement	; offset to previous nt
=$dacd					XtPtr1 ::= *
=55881					WordListLink ::= Nt0 ; remember the nt of this word for later
.dacd	20 b1 da	jsr $dab1	MPlus:		jsr UMPlus
.dad0	98		tya				tya		; if n negative
.dad1	30 a0		bmi $da73			bmi One_Minus_NoUf ;   decrement d1.hi
=6					CodeLen	.var *-XtPtr1
=$dad3					Here1 = *	; remember here
>dacb	06					.byte CodeLen	;patch wh_CodeLength
.dad3	60		rts				rts
>dad4	44 32 2a			Name0:	.text "D2*"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=55895					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>dad7	43					.byte (("D2*"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=14					LinkDisplacement = Nt0-WordListLink
>dad8	10					.byte WordFlags	;wh_Flags
>dad9	03					.byte 3	;wh_CodeLength
>dada	0e					  .byte LinkDisplacement	; offset to previous nt
=$dadb					XtPtr1 ::= *
=55895					WordListLink ::= Nt0 ; remember the nt of this word for later
.dadb					D2Star:
.dadb	e0 25		cpx #$25		cpx #(DDim-2)*2+1	; far enough below end of data stack (& not negative)?
.dadd	b0 c8		bcs $daa7		bcs Throw_Stack_19
.dadf	16 26		asl $26,x			asl DStack+2,x
.dae1	36 27		rol $27,x			rol DStack+3,x
.dae3	36 24		rol $24,x			rol DStack+0,x
.dae5	36 25		rol $25,x			rol DStack+1,x
=12					CodeLen	.var *-XtPtr1
=$dae7					Here1 = *	; remember here
>dad9	0c					.byte CodeLen	;patch wh_CodeLength
.dae7	60		rts				rts
>dae8	44 32 2f			Name0:	.text "D2/"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=55915					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>daeb	e3					.byte (("D2/"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=20					LinkDisplacement = Nt0-WordListLink
>daec	10					.byte WordFlags	;wh_Flags
>daed	03					.byte 3	;wh_CodeLength
>daee	14					  .byte LinkDisplacement	; offset to previous nt
=$daef					XtPtr1 ::= *
=55915					WordListLink ::= Nt0 ; remember the nt of this word for later
.daef					D2Slash:
.daef	e0 25		cpx #$25		cpx #(DDim-2)*2+1	; far enough below end of data stack (& not negative)?
.daf1	b0 b4		bcs $daa7		bcs Throw_Stack_19
.daf3	b5 25		lda $25,x			lda DStack+1,x		; setup for sign-extended shift right
.daf5	0a		asl a				asl a
.daf6	76 25		ror $25,x	D2SlashU:	ror DStack+1,x
.daf8	76 24		ror $24,x			ror DStack+0,x
.dafa	76 27		ror $27,x			ror DStack+3,x
.dafc	76 26		ror $26,x			ror DStack+2,x
=15					CodeLen	.var *-XtPtr1
=$dafe					Here1 = *	; remember here
>daed	0f					.byte CodeLen	;patch wh_CodeLength
.dafe	60		rts				rts
>daff	55 44 32 2f			Name0:	.text "UD2/"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=55939					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>db03	e4					.byte (("UD2/"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=24					LinkDisplacement = Nt0-WordListLink
>db04	10					.byte WordFlags	;wh_Flags
>db05	03					.byte 3	;wh_CodeLength
>db06	18					  .byte LinkDisplacement	; offset to previous nt
=$db07					XtPtr1 ::= *
=55939					WordListLink ::= Nt0 ; remember the nt of this word for later
.db07					DU2Slash:
.db07	e0 25		cpx #$25		cpx #(DDim-2)*2+1	; far enough below end of data stack (& not negative)?
.db09	b0 9c		bcs $daa7		bcs Throw_Stack_19
.db0b	18		clc				clc
.db0c	90 e8		bcc $daf6			bcc D2SlashU
=7					CodeLen	.var *-XtPtr1
=$db0e					Here1 = *	; remember here
>db05	07					.byte CodeLen	;patch wh_CodeLength
>db0e	32 2a				Name0:	.text "2*"	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=55952					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>db10	42					.byte (("2*"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>db11	10					.byte WordFlags	;wh_Flags
>db12	03					.byte 3	;wh_CodeLength
>db13	0d					  .byte LinkDisplacement	; offset to previous nt
=$db14					XtPtr1 ::= *
=55952					WordListLink ::= Nt0 ; remember the nt of this word for later
.db14					Two_Star:
.db14	e0 27		cpx #$27		cpx #(DDim-1)*2+1	; far enough below end of data stack (& not negative)?
.db16	b0 8f		bcs $daa7		bcs Throw_Stack_19
.db18	16 24		asl $24,x			asl DStack+0,x
.db1a	36 25		rol $25,x			rol DStack+1,x
=8					CodeLen	.var *-XtPtr1
=$db1c					Here1 = *	; remember here
>db12	08					.byte CodeLen	;patch wh_CodeLength
.db1c	60		rts				rts
>db1d	32 2f				Name0:	.text "2/"	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=55967					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>db1f	e2					.byte (("2/"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=15					LinkDisplacement = Nt0-WordListLink
>db20	10					.byte WordFlags	;wh_Flags
>db21	03					.byte 3	;wh_CodeLength
>db22	0f					  .byte LinkDisplacement	; offset to previous nt
=$db23					XtPtr1 ::= *
=55967					WordListLink ::= Nt0 ; remember the nt of this word for later
.db23					Two_Slash:
.db23	e0 27		cpx #$27		cpx #(DDim-1)*2+1	; far enough below end of data stack (& not negative)?
.db25	b0 80		bcs $daa7		bcs Throw_Stack_19
.db27	b5 25		lda $25,x			lda DStack+1,x		; load sign into carry, for signed shift
.db29	0a		asl a				asl
.db2a	76 25		ror $25,x			ror DStack+1,x
.db2c	76 24		ror $24,x			ror DStack+0,x
=11					CodeLen	.var *-XtPtr1
=$db2e					Here1 = *	; remember here
>db21	0b					.byte CodeLen	;patch wh_CodeLength
.db2e	60		rts				rts
>db2f	55 32 2f			Name0:	.text "U2/"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=55986					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>db32	e3					.byte (("U2/"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$40					WordFlags ::= UF	; modifiable copy, remember for later
=19					LinkDisplacement = Nt0-WordListLink
>db33	40					.byte WordFlags	;wh_Flags
>db34	03					.byte 3	;wh_CodeLength
>db35	13					  .byte LinkDisplacement	; offset to previous nt
=$db36					XtPtr1 ::= *
=55986					WordListLink ::= Nt0 ; remember the nt of this word for later
.db36					UTwo_Slash:
.db36	e0 27		cpx #$27		cpx #(DDim-1)*2+1	; far enough below end of data stack (& not negative)?
.db38	b0 75		bcs $dbaf		bcs Throw_Stack_18
.db3a	56 25		lsr $25,x			lsr DStack+1,x
.db3c	76 24		ror $24,x			ror DStack+0,x
=8					CodeLen	.var *-XtPtr1
=$db3e					Here1 = *	; remember here
>db34	08					.byte CodeLen	;patch wh_CodeLength
.db3e	60		rts				rts
>db3f	44 52 53 68 69 66 74		Name0:	.text "DRShift"	;  name of word as a string, ending at wh_NameLastChar
=7					NameLength = *-Name0
=56006					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>db46	87					.byte (("DRShift"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=0					WordFlags ::= 0	; modifiable copy, remember for later
=20					LinkDisplacement = Nt0-WordListLink
>db47	00					.byte WordFlags	;wh_Flags
>db48	03					.byte 3	;wh_CodeLength
>db49	14					  .byte LinkDisplacement	; offset to previous nt
=$db4a					XtPtr1 ::= *
=56006					WordListLink ::= Nt0 ; remember the nt of this word for later
.db4a	20 c3 c3	jsr $c3c3	DRShift:	jsr PopA	; pop u
.db4d	a8		tay		DRShiftA:	tay
.db4e	f0 0e		beq $db5e			beq _9
.db50	b5 25		lda $25,x			lda DStack+1,x
.db52	4a		lsr a		_2:		lsr a
.db53	76 24		ror $24,x			ror DStack+0,x
.db55	76 27		ror $27,x			ror DStack+3,x
.db57	76 26		ror $26,x			ror DStack+2,x
.db59	88		dey				dey
.db5a	d0 f6		bne $db52			bne _2
.db5c	95 25		sta $25,x			sta DStack+1,x
.db5e					_9:
=20					CodeLen	.var *-XtPtr1
=$db5e					Here1 = *	; remember here
>db48	14					.byte CodeLen	;patch wh_CodeLength
.db5e	60		rts				rts
>db5f	52 53 68 69 66 74		Name0:	.text "RShift"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=56037					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>db65	86					.byte (("RShift"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=0					WordFlags ::= 0	; modifiable copy, remember for later
=31					LinkDisplacement = Nt0-WordListLink
>db66	00					.byte WordFlags	;wh_Flags
>db67	03					.byte 3	;wh_CodeLength
>db68	1f					  .byte LinkDisplacement	; offset to previous nt
=$db69					XtPtr1 ::= *
=56037					WordListLink ::= Nt0 ; remember the nt of this word for later
.db69	20 cc c3	jsr $c3cc	RShift:		jsr PopA2	; pop u, check for 2 params
.db6c	a8		tay		RShift_A:	tay		; get shift count
.db6d	f0 0a		beq $db79			beq _done
.db6f	b5 25		lda $25,x			lda DStack+1,x
.db71	4a		lsr a		_loop:		lsr a
.db72	76 24		ror $24,x			ror DStack+0,x
.db74	88		dey				dey
.db75	d0 fa		bne $db71			bne _loop
.db77	95 25		sta $25,x			sta DStack+1,x
.db79					_done:
=16					CodeLen	.var *-XtPtr1
=$db79					Here1 = *	; remember here
>db67	10					.byte CodeLen	;patch wh_CodeLength
.db79	60		rts				rts
>db7a	4c 53 68 69 66 74		Name0:	.text "LShift"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=56064					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>db80	86					.byte (("LShift"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=0					WordFlags ::= 0	; modifiable copy, remember for later
=27					LinkDisplacement = Nt0-WordListLink
>db81	00					.byte WordFlags	;wh_Flags
>db82	03					.byte 3	;wh_CodeLength
>db83	1b					  .byte LinkDisplacement	; offset to previous nt
=$db84					XtPtr1 ::= *
=56064					WordListLink ::= Nt0 ; remember the nt of this word for later
.db84	20 cc c3	jsr $c3cc	LShift:		jsr PopA2	; pop u, check for 2 params
.db87	a8		tay		LShift_A:	tay		; get shift count
.db88	f0 0a		beq $db94			beq _done
.db8a	b5 25		lda $25,x			lda DStack+1,x
.db8c	16 24		asl $24,x	_loop:		asl DStack+0,x
.db8e	2a		rol a				rol a
.db8f	88		dey				dey
.db90	d0 fa		bne $db8c			bne _loop
.db92	95 25		sta $25,x			sta DStack+1,x
.db94					_done:
=16					CodeLen	.var *-XtPtr1
=$db94					Here1 = *	; remember here
>db82	10					.byte CodeLen	;patch wh_CodeLength
.db94	60		rts				rts
>db95	41 6e 64			Name0:	.text "And"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=56088					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>db98	83					.byte (("And"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=24					LinkDisplacement = Nt0-WordListLink
>db99	10					.byte WordFlags	;wh_Flags
>db9a	03					.byte 3	;wh_CodeLength
>db9b	18					  .byte LinkDisplacement	; offset to previous nt
=$db9c					XtPtr1 ::= *
=56088					WordListLink ::= Nt0 ; remember the nt of this word for later
.db9c					And2:
.db9c	e0 25		cpx #$25		cpx #(DDim-2)*2+1	; far enough below end of data stack (& not negative)?
.db9e	b0 0f		bcs $dbaf		bcs Throw_Stack_18
.dba0	b5 24		lda $24,x			lda DStack+0,x
.dba2	35 26		and $26,x			and DStack+2,x
.dba4	95 26		sta $26,x			sta DStack+2,x
.dba6	b5 25		lda $25,x			lda DStack+1,x
.dba8	35 27		and $27,x			and DStack+3,x
.dbaa	95 27		sta $27,x			sta DStack+3,x
.dbac	e8		inx				inx		; Drop n2
.dbad	e8		inx				inx
=18					CodeLen	.var *-XtPtr1
=$dbae					Here1 = *	; remember here
>db9a	12					.byte CodeLen	;patch wh_CodeLength
.dbae	60		rts				rts
.dbaf	4c 2a c4	jmp $c42a	Throw_Stack_18: jmp Throw_Stack
>dbb2	4f 72				Name0:	.text "Or"	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=56116					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>dbb4	42					.byte (("Or"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=28					LinkDisplacement = Nt0-WordListLink
>dbb5	10					.byte WordFlags	;wh_Flags
>dbb6	03					.byte 3	;wh_CodeLength
>dbb7	1c					  .byte LinkDisplacement	; offset to previous nt
=$dbb8					XtPtr1 ::= *
=56116					WordListLink ::= Nt0 ; remember the nt of this word for later
.dbb8					Or:
.dbb8	e0 25		cpx #$25		cpx #(DDim-2)*2+1	; far enough below end of data stack (& not negative)?
.dbba	b0 f3		bcs $dbaf		bcs Throw_Stack_18
.dbbc	b5 24		lda $24,x			lda DStack+0,x
.dbbe	15 26		ora $26,x			ora DStack+2,x
.dbc0	95 26		sta $26,x			sta DStack+2,x
.dbc2	b5 25		lda $25,x			lda DStack+1,x
.dbc4	15 27		ora $27,x			ora DStack+3,x
.dbc6	95 27		sta $27,x			sta DStack+3,x
.dbc8	e8		inx				inx		; Drop n2
.dbc9	e8		inx				inx
=18					CodeLen	.var *-XtPtr1
=$dbca					Here1 = *	; remember here
>dbb6	12					.byte CodeLen	;patch wh_CodeLength
.dbca	60		rts				rts
>dbcb	58 6f 72			Name0:	.text "Xor"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=56142					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>dbce	43					.byte (("Xor"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=26					LinkDisplacement = Nt0-WordListLink
>dbcf	10					.byte WordFlags	;wh_Flags
>dbd0	03					.byte 3	;wh_CodeLength
>dbd1	1a					  .byte LinkDisplacement	; offset to previous nt
=$dbd2					XtPtr1 ::= *
=56142					WordListLink ::= Nt0 ; remember the nt of this word for later
.dbd2					Xor:
.dbd2	e0 25		cpx #$25		cpx #(DDim-2)*2+1	; far enough below end of data stack (& not negative)?
.dbd4	b0 d9		bcs $dbaf		bcs Throw_Stack_18
.dbd6	b5 24		lda $24,x			lda DStack+0,x
.dbd8	55 26		eor $26,x			eor DStack+2,x
.dbda	95 26		sta $26,x			sta DStack+2,x
.dbdc	b5 25		lda $25,x			lda DStack+1,x
.dbde	55 27		eor $27,x			eor DStack+3,x
.dbe0	95 27		sta $27,x			sta DStack+3,x
.dbe2	e8		inx				inx		; Drop n2
.dbe3	e8		inx				inx
=18					CodeLen	.var *-XtPtr1
=$dbe4					Here1 = *	; remember here
>dbd0	12					.byte CodeLen	;patch wh_CodeLength
.dbe4	60		rts				rts
>dbe5	2b				Name0:	.text "+"	;  name of word as a string, ending at wh_NameLastChar
=1					NameLength = *-Name0
=56166					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>dbe6	61					.byte (("+"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=24					LinkDisplacement = Nt0-WordListLink
>dbe7	10					.byte WordFlags	;wh_Flags
>dbe8	03					.byte 3	;wh_CodeLength
>dbe9	18					  .byte LinkDisplacement	; offset to previous nt
=$dbea					XtPtr1 ::= *
=56166					WordListLink ::= Nt0 ; remember the nt of this word for later
.dbea					Plus:
.dbea	e0 25		cpx #$25		cpx #(DDim-2)*2+1	; far enough below end of data stack (& not negative)?
.dbec	b0 c1		bcs $dbaf		bcs Throw_Stack_18
.dbee	18		clc				clc
.dbef	b5 24		lda $24,x			lda DStack+0,x		; LSB
.dbf1	75 26		adc $26,x			adc DStack+2,x
.dbf3	95 26		sta $26,x			sta DStack+2,x
.dbf5	b5 25		lda $25,x			lda DStack+1,x		; MSB. No CLC, conserve carry bit
.dbf7	75 27		adc $27,x			adc DStack+3,x
.dbf9	95 27		sta $27,x			sta DStack+3,x
.dbfb	e8		inx				inx
.dbfc	e8		inx				inx
=19					CodeLen	.var *-XtPtr1
=$dbfd					Here1 = *	; remember here
>dbe8	13					.byte CodeLen	;patch wh_CodeLength
.dbfd	60		rts				rts
>dbfe	2d				Name0:	.text "-"	;  name of word as a string, ending at wh_NameLastChar
=1					NameLength = *-Name0
=56191					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>dbff	a1					.byte (("-"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=25					LinkDisplacement = Nt0-WordListLink
>dc00	10					.byte WordFlags	;wh_Flags
>dc01	03					.byte 3	;wh_CodeLength
>dc02	19					  .byte LinkDisplacement	; offset to previous nt
=$dc03					XtPtr1 ::= *
=56191					WordListLink ::= Nt0 ; remember the nt of this word for later
.dc03					Minus:
.dc03	e0 25		cpx #$25		cpx #(DDim-2)*2+1	; far enough below end of data stack (& not negative)?
.dc05	b0 a8		bcs $dbaf		bcs Throw_Stack_18
.dc07	38		sec				sec
.dc08	b5 26		lda $26,x			lda DStack+2,x	; LSB
.dc0a	f5 24		sbc $24,x			sbc DStack+0,x
.dc0c	95 26		sta $26,x			sta DStack+2,x
.dc0e	b5 27		lda $27,x			lda DStack+3,x	; MSB
.dc10	f5 25		sbc $25,x			sbc DStack+1,x
.dc12	95 27		sta $27,x			sta DStack+3,x
.dc14	e8		inx				inx		; Drop n2
.dc15	e8		inx				inx
=19					CodeLen	.var *-XtPtr1
=$dc16					Here1 = *	; remember here
>dc01	13					.byte CodeLen	;patch wh_CodeLength
.dc16	60		rts				rts
>dc17	2e				Name0:	.text "."	;  name of word as a string, ending at wh_NameLastChar
=1					NameLength = *-Name0
=56216					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>dc18	c1					.byte (("."[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=25					LinkDisplacement = Nt0-WordListLink
>dc19	10					.byte WordFlags	;wh_Flags
>dc1a	03					.byte 3	;wh_CodeLength
>dc1b	19					  .byte LinkDisplacement	; offset to previous nt
=$dc1c					XtPtr1 ::= *
=56216					WordListLink ::= Nt0 ; remember the nt of this word for later
.dc1c	b5 25		lda $25,x	Dot:		lda DStack+1,x		; ( n )	save sign
.dc1e	08		php				php
.dc1f	20 fd d6	jsr $d6fd			jsr Abs			; ( u )
.dc22	20 f2 c7	jsr $c7f2			jsr Zero		; ( ud )	u>d  cvt u to ud
.dc25	4c 34 dc	jmp $dc34			jmp fmt_d3
=12					CodeLen	.var *-XtPtr1
=$dc28					Here1 = *	; remember here
>dc1a	0c					.byte CodeLen	;patch wh_CodeLength
>dc28	44 2e				Name0:	.text "D."	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=56234					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>dc2a	c2					.byte (("D."[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=18					LinkDisplacement = Nt0-WordListLink
>dc2b	10					.byte WordFlags	;wh_Flags
>dc2c	03					.byte 3	;wh_CodeLength
>dc2d	12					  .byte LinkDisplacement	; offset to previous nt
=$dc2e					XtPtr1 ::= *
=56234					WordListLink ::= Nt0 ; remember the nt of this word for later
.dc2e	b5 25		lda $25,x	D_Dot:		lda DStack+1,x		; save sign
.dc30	08		php				php
.dc31	20 30 d7	jsr $d730			jsr DAbs
.dc34	20 c0 bb	jsr $bbc0	fmt_d3:		jsr Less_Number_Sign	; ( ud )	start formatting
.dc37	20 2f bc	jsr $bc2f			jsr Number_sign_s	; ( ud )	do all digits
.dc3a	28		plp				plp			; ( ud )	do sign
.dc3b	20 49 bc	jsr $bc49			jsr Sign_P		; ( ud )
.dc3e	20 cc bb	jsr $bbcc			jsr Number_sign_greater	; ( addr u )	end formatting
.dc41	20 34 de	jsr $de34			jsr Type
.dc44	4c 28 de	jmp $de28			jmp Space
=25					CodeLen	.var *-XtPtr1
=$dc47					Here1 = *	; remember here
>dc2c	19					.byte CodeLen	;patch wh_CodeLength
>dc47	55 2e				Name0:	.text "U."	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=56265					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>dc49	c2					.byte (("U."[-1]&7)<<5)+NameLength	;wh_HashNameLen
=80					WordFlags ::= UF+NN	; modifiable copy, remember for later
=31					LinkDisplacement = Nt0-WordListLink
>dc4a	50					.byte WordFlags	;wh_Flags
>dc4b	03					.byte 3	;wh_CodeLength
>dc4c	1f					  .byte LinkDisplacement	; offset to previous nt
=$dc4d					XtPtr1 ::= *
=56265					WordListLink ::= Nt0 ; remember the nt of this word for later
.dc4d	20 07 c4	jsr $c407	U_Dot:		jsr underflow_1
.dc50	20 66 dc	jsr $dc66			jsr print_u
.dc53	4c 28 de	jmp $de28			jmp Space
=9					CodeLen	.var *-XtPtr1
=$dc56					Here1 = *	; remember here
>dc4b	09					.byte CodeLen	;patch wh_CodeLength
>dc56	55 44 2e			Name0:	.text "UD."	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=56281					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>dc59	c3					.byte (("UD."[-1]&7)<<5)+NameLength	;wh_HashNameLen
=80					WordFlags ::= UF+NN	; modifiable copy, remember for later
=16					LinkDisplacement = Nt0-WordListLink
>dc5a	50					.byte WordFlags	;wh_Flags
>dc5b	03					.byte 3	;wh_CodeLength
>dc5c	10					  .byte LinkDisplacement	; offset to previous nt
=$dc5d					XtPtr1 ::= *
=56281					WordListLink ::= Nt0 ; remember the nt of this word for later
.dc5d	20 1b c4	jsr $c41b	UD_Dot:		jsr underflow_2 ; double number
.dc60	20 69 dc	jsr $dc69			jsr print_ud
.dc63	4c 28 de	jmp $de28			jmp Space
=9					CodeLen	.var *-XtPtr1
=$dc66					Here1 = *	; remember here
>dc5b	09					.byte CodeLen	;patch wh_CodeLength
.dc66					print_u:
.dc66	20 f2 c7	jsr $c7f2			jsr Zero			; convert to ud
.dc69					print_ud:
.dc69	20 c0 bb	jsr $bbc0			jsr Less_Number_Sign		; <#	start formatting
.dc6c	20 2f bc	jsr $bc2f			jsr Number_sign_s		; #S	do all digits
.dc6f	20 cc bb	jsr $bbcc			jsr Number_sign_greater		; #>	end formatting
.dc72	4c 34 de	jmp $de34			jmp Type
>dc75	55 2e 52			Name0:	.text "U.R"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=56312					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>dc78	43					.byte (("U.R"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=31					LinkDisplacement = Nt0-WordListLink
>dc79	10					.byte WordFlags	;wh_Flags
>dc7a	03					.byte 3	;wh_CodeLength
>dc7b	1f					  .byte LinkDisplacement	; offset to previous nt
=$dc7c					XtPtr1 ::= *
=56312					WordListLink ::= Nt0 ; remember the nt of this word for later
.dc7c	20 c3 c3	jsr $c3c3	U_Dot_R:	jsr PopA		; save field width
.dc7f	48		pha		U_Dot_R_A:	pha
.dc80	20 f2 c7	jsr $c7f2			jsr Zero		; u>d  cvt u to ud
.dc83	4c 92 dc	jmp $dc92			jmp fmt_udr3
=10					CodeLen	.var *-XtPtr1
=$dc86					Here1 = *	; remember here
>dc7a	0a					.byte CodeLen	;patch wh_CodeLength
>dc86	55 44 2e 52			Name0:	.text "UD.R"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=56330					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>dc8a	44					.byte (("UD.R"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=18					LinkDisplacement = Nt0-WordListLink
>dc8b	10					.byte WordFlags	;wh_Flags
>dc8c	03					.byte 3	;wh_CodeLength
>dc8d	12					  .byte LinkDisplacement	; offset to previous nt
=$dc8e					XtPtr1 ::= *
=56330					WordListLink ::= Nt0 ; remember the nt of this word for later
.dc8e	20 c3 c3	jsr $c3c3	UD_Dot_R:	jsr PopA			; save field width
.dc91	48		pha		UD_Dot_R_A:	pha
.dc92	20 c0 bb	jsr $bbc0	fmt_udr3:	jsr Less_Number_Sign		; start formatted
.dc95	20 2f bc	jsr $bc2f			jsr Number_sign_s		; do all digits
.dc98	20 cc bb	jsr $bbcc	fmt_r:		jsr Number_sign_greater		; finish formatted
.dc9b	68		pla				pla				; recover field width
.dc9c	38		sec				sec				; do leading spaces
.dc9d	f5 24		sbc $24,x			sbc DStack+0,x
.dc9f	90 06		bcc $dca7			bcc +
.dca1	20 e4 c7	jsr $c7e4			jsr PushZA
.dca4	20 c7 d4	jsr $d4c7			jsr Spaces
.dca7	4c 34 de	jmp $de34	+		jmp Type			; type formatted
=28					CodeLen	.var *-XtPtr1
=$dcaa					Here1 = *	; remember here
>dc8c	1c					.byte CodeLen	;patch wh_CodeLength
>dcaa	2e 52				Name0:	.text ".R"	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=56364					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>dcac	42					.byte ((".R"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=34					LinkDisplacement = Nt0-WordListLink
>dcad	10					.byte WordFlags	;wh_Flags
>dcae	03					.byte 3	;wh_CodeLength
>dcaf	22					  .byte LinkDisplacement	; offset to previous nt
=$dcb0					XtPtr1 ::= *
=56364					WordListLink ::= Nt0 ; remember the nt of this word for later
.dcb0	20 c3 c3	jsr $c3c3	Dot_R:		jsr PopA		; save field width
.dcb3	48		pha		Dot_R_A:	pha
.dcb4	b5 25		lda $25,x			lda DStack+1,x		; save sign
.dcb6	08		php				php
.dcb7	20 fd d6	jsr $d6fd			jsr Abs
.dcba	20 f2 c7	jsr $c7f2			jsr Zero		; u>d  cvt u to ud
.dcbd	4c d1 dc	jmp $dcd1			jmp fmt_dr3
=16					CodeLen	.var *-XtPtr1
=$dcc0					Here1 = *	; remember here
>dcae	10					.byte CodeLen	;patch wh_CodeLength
>dcc0	44 2e 52			Name0:	.text "D.R"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=56387					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>dcc3	43					.byte (("D.R"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=23					LinkDisplacement = Nt0-WordListLink
>dcc4	10					.byte WordFlags	;wh_Flags
>dcc5	03					.byte 3	;wh_CodeLength
>dcc6	17					  .byte LinkDisplacement	; offset to previous nt
=$dcc7					XtPtr1 ::= *
=56387					WordListLink ::= Nt0 ; remember the nt of this word for later
.dcc7	20 c3 c3	jsr $c3c3	D_Dot_R:	jsr PopA		; save field width
.dcca	48		pha		D_Dot_R_A:	pha
.dccb	b5 25		lda $25,x			lda DStack+1,x		; save sign
.dccd	08		php				php
.dcce	20 30 d7	jsr $d730			jsr DAbs
.dcd1	20 c0 bb	jsr $bbc0	fmt_dr3:	jsr Less_Number_Sign	; start formatted output
.dcd4	20 2f bc	jsr $bc2f			jsr Number_sign_s	; do all digits
.dcd7	28		plp				plp			; do the sign
.dcd8	20 49 bc	jsr $bc49			jsr Sign_P
.dcdb	4c 98 dc	jmp $dc98			jmp fmt_r
=23					CodeLen	.var *-XtPtr1
=$dcde					Here1 = *	; remember here
>dcc5	17					.byte CodeLen	;patch wh_CodeLength
>dcde	3f				Name0:	.text "?"	;  name of word as a string, ending at wh_NameLastChar
=1					NameLength = *-Name0
=56415					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>dcdf	e1					.byte (("?"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=28					LinkDisplacement = Nt0-WordListLink
>dce0	10					.byte WordFlags	;wh_Flags
>dce1	03					.byte 3	;wh_CodeLength
>dce2	1c					  .byte LinkDisplacement	; offset to previous nt
=$dce3					XtPtr1 ::= *
=56415					WordListLink ::= Nt0 ; remember the nt of this word for later
.dce3					Question:
.dce3	20 f5 de	jsr $def5			jsr Fetch
.dce6	4c 1c dc	jmp $dc1c			jmp Dot
=6					CodeLen	.var *-XtPtr1
=$dce9					Here1 = *	; remember here
>dce1	06					.byte CodeLen	;patch wh_CodeLength
>dce9	32 44 75 70			Name0:	.text "2Dup"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=56429					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>dced	04					.byte (("2Dup"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=14					LinkDisplacement = Nt0-WordListLink
>dcee	10					.byte WordFlags	;wh_Flags
>dcef	03					.byte 3	;wh_CodeLength
>dcf0	0e					  .byte LinkDisplacement	; offset to previous nt
=$dcf1					XtPtr1 ::= *
=56429					WordListLink ::= Nt0 ; remember the nt of this word for later
.dcf1					Two_Dup:
.dcf1	e0 25		cpx #$25		cpx #(DDim-2)*2+1	; far enough below end of data stack (& not negative)?
.dcf3	b0 15		bcs $dd0a		bcs Throw_Stack_13
.dcf5	ca		dex				dex
.dcf6	ca		dex				dex
.dcf7	ca		dex				dex
.dcf8	ca		dex				dex
.dcf9	b5 28		lda $28,x			lda DStack+4,x	; TOS
.dcfb	95 24		sta $24,x			sta DStack+0,x
.dcfd	b5 29		lda $29,x			lda DStack+5,x
.dcff	95 25		sta $25,x			sta DStack+1,x
.dd01	b5 2a		lda $2a,x			lda DStack+6,x	; NOS
.dd03	95 26		sta $26,x			sta DStack+2,x
.dd05	b5 2b		lda $2b,x			lda DStack+7,x
.dd07	95 27		sta $27,x			sta DStack+3,x
=24					CodeLen	.var *-XtPtr1
=$dd09					Here1 = *	; remember here
>dcef	18					.byte CodeLen	;patch wh_CodeLength
.dd09	60		rts				rts
.dd0a	4c 2a c4	jmp $c42a	Throw_Stack_13: jmp Throw_Stack
>dd0d	54 75 63 6b			Name0:	.text "Tuck"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=56465					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>dd11	64					.byte (("Tuck"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=36					LinkDisplacement = Nt0-WordListLink
>dd12	10					.byte WordFlags	;wh_Flags
>dd13	03					.byte 3	;wh_CodeLength
>dd14	24					  .byte LinkDisplacement	; offset to previous nt
=$dd15					XtPtr1 ::= *
=56465					WordListLink ::= Nt0 ; remember the nt of this word for later
.dd15					Tuck:
.dd15	e0 25		cpx #$25		cpx #(DDim-2)*2+1	; far enough below end of data stack (& not negative)?
.dd17	b0 f1		bcs $dd0a		bcs Throw_Stack_13
.dd19	ca		dex				dex
.dd1a	ca		dex				dex
.dd1b	b4 28		ldy $28,x			ldy DStack+4,x	; LSB
.dd1d	b5 26		lda $26,x			lda DStack+2,x
.dd1f	95 28		sta $28,x			sta DStack+4,x
.dd21	94 26		sty $26,x			sty DStack+2,x
.dd23	95 24		sta $24,x			sta DStack+0,x
.dd25	b4 29		ldy $29,x			ldy DStack+5,x	; MSB
.dd27	b5 27		lda $27,x			lda DStack+3,x
.dd29	95 29		sta $29,x			sta DStack+5,x
.dd2b	94 27		sty $27,x			sty DStack+3,x
.dd2d	95 25		sta $25,x			sta DStack+1,x
=26					CodeLen	.var *-XtPtr1
=$dd2f					Here1 = *	; remember here
>dd13	1a					.byte CodeLen	;patch wh_CodeLength
.dd2f	60		rts				rts
>dd30	43 2c				Name0:	.text "C,"	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=56498					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>dd32	82					.byte (("C,"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=33					LinkDisplacement = Nt0-WordListLink
>dd33	10					.byte WordFlags	;wh_Flags
>dd34	03					.byte 3	;wh_CodeLength
>dd35	21					  .byte LinkDisplacement	; offset to previous nt
=$dd36					XtPtr1 ::= *
=56498					WordListLink ::= Nt0 ; remember the nt of this word for later
.dd36	20 c3 c3	jsr $c3c3	C_Comma:	jsr PopA	; pop c, with underflow check
.dd39					C_Comma_A:
.dd39	94 23		sty $23,x			sty DStack-1,x	; save Y
.dd3b	a0 00		ldy #$00			ldy #0		; store A
.dd3d	91 00		sta ($00),y			sta (cp),y
.dd3f	e6 00		inc $00				inc cp+0	; increment cp
.dd41	d0 02		bne $dd45			bne +
.dd43	e6 01		inc $01				inc cp+1
.dd45					+
.dd45	b4 23		ldy $23,x			ldy DStack-1,x	; restore Y
=17					CodeLen	.var *-XtPtr1
=$dd47					Here1 = *	; remember here
>dd34	11					.byte CodeLen	;patch wh_CodeLength
.dd47	60		rts				rts
>dd48	2c				Name0:	.text ","	;  name of word as a string, ending at wh_NameLastChar
=1					NameLength = *-Name0
=56521					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>dd49	81					.byte ((","[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=23					LinkDisplacement = Nt0-WordListLink
>dd4a	10					.byte WordFlags	;wh_Flags
>dd4b	03					.byte 3	;wh_CodeLength
>dd4c	17					  .byte LinkDisplacement	; offset to previous nt
=$dd4d					XtPtr1 ::= *
=56521					WordListLink ::= Nt0 ; remember the nt of this word for later
.dd4d	20 de c3	jsr $c3de	Comma:		jsr PopYA	; pop n, with underflow check
.dd50					Comma_YA:
.dd50	20 39 dd	jsr $dd39			jsr C_Comma_A	; compile LSB
.dd53	98		tya				tya		; compile MSB
.dd54	4c 39 dd	jmp $dd39			jmp C_Comma_A
=10					CodeLen	.var *-XtPtr1
=$dd57					Here1 = *	; remember here
>dd4b	0a					.byte CodeLen	;patch wh_CodeLength
>dd57	32 2c				Name0:	.text "2,"	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=56537					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>dd59	82					.byte (("2,"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=16					LinkDisplacement = Nt0-WordListLink
>dd5a	10					.byte WordFlags	;wh_Flags
>dd5b	03					.byte 3	;wh_CodeLength
>dd5c	10					  .byte LinkDisplacement	; offset to previous nt
=$dd5d					XtPtr1 ::= *
=56537					WordListLink ::= Nt0 ; remember the nt of this word for later
.dd5d	20 4d dd	jsr $dd4d	Two_Comma:	jsr Comma
.dd60	4c 4d dd	jmp $dd4d			jmp Comma
=6					CodeLen	.var *-XtPtr1
=$dd63					Here1 = *	; remember here
>dd5b	06					.byte CodeLen	;patch wh_CodeLength
.dd63	a9 e8		lda #$e8	Drop_Comma:	lda #$e8	;inx
.dd65	a8		tay				tay
.dd66	d0 e8		bne $dd50			bne Comma_YA
>dd68	4a 73 72 2c			Name0:	.text "Jsr,"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=56556					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>dd6c	84					.byte (("Jsr,"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=19					LinkDisplacement = Nt0-WordListLink
>dd6d	10					.byte WordFlags	;wh_Flags
>dd6e	03					.byte 3	;wh_CodeLength
>dd6f	13					  .byte LinkDisplacement	; offset to previous nt
=$dd70					XtPtr1 ::= *
=56556					WordListLink ::= Nt0 ; remember the nt of this word for later
.dd70	20 de c3	jsr $c3de	Jsr_Comma:	jsr PopYA	; pop addr (optimize can skip)
.dd73	20 b5 c7	jsr $c7b5	Jsr_Comma_YA:	jsr PushYA	; push addr
.dd76	a9 20		lda #$20			lda #$20	; JSR abs opcode
.dd78	20 39 dd	jsr $dd39	Jsr_Comma_3:	jsr C_Comma_A
.dd7b	4c 4d dd	jmp $dd4d			jmp Comma	; compile addr
=14					CodeLen	.var *-XtPtr1
=$dd7e					Here1 = *	; remember here
>dd6e	0e					.byte CodeLen	;patch wh_CodeLength
>dd7e	4a 6d 70 2c			Name0:	.text "Jmp,"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=56578					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>dd82	84					.byte (("Jmp,"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=22					LinkDisplacement = Nt0-WordListLink
>dd83	10					.byte WordFlags	;wh_Flags
>dd84	03					.byte 3	;wh_CodeLength
>dd85	16					  .byte LinkDisplacement	; offset to previous nt
=$dd86					XtPtr1 ::= *
=56578					WordListLink ::= Nt0 ; remember the nt of this word for later
.dd86	20 de c3	jsr $c3de	Jmp_Comma:	jsr PopYA	; pop addr (optimize can skip)
.dd89	20 b5 c7	jsr $c7b5	Jmp_Comma_YA:	jsr PushYA	; push addr
.dd8c	a9 4c		lda #$4c			lda #$4c	; JMP abs opcode
.dd8e	d0 e8		bne $dd78			bne Jsr_Comma_3
.dd90					Jmp_Comma_NT_YA:
.dd90	20 b5 c7	jsr $c7b5			jsr PushYA
.dd93	20 a9 cd	jsr $cda9			jsr Name_To_Int	; convert nt to xt
.dd96	4c 86 dd	jmp $dd86			jmp Jmp_Comma
=19					CodeLen	.var *-XtPtr1
=$dd99					Here1 = *	; remember here
>dd84	13					.byte CodeLen	;patch wh_CodeLength
>dd99	43 40				Name0:	.text "C@"	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=56603					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>dd9b	02					.byte (("C@"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=25					LinkDisplacement = Nt0-WordListLink
>dd9c	10					.byte WordFlags	;wh_Flags
>dd9d	03					.byte 3	;wh_CodeLength
>dd9e	19					  .byte LinkDisplacement	; offset to previous nt
=$dd9f					XtPtr1 ::= *
=56603					WordListLink ::= Nt0 ; remember the nt of this word for later
.dd9f					C_Fetch:
.dd9f	e0 27		cpx #$27		cpx #(DDim-1)*2+1	; far enough below end of data stack (& not negative)?
.dda1	b0 1c		bcs $ddbf		bcs Throw_Stack_16
.dda3	a1 24		lda ($24,x)			lda (DStack+0,x)
.dda5	95 24		sta $24,x			sta DStack+0,x
.dda7	a9 00		lda #$00			lda #0
.dda9	95 25		sta $25,x			sta DStack+1,x	; zero MSB
=12					CodeLen	.var *-XtPtr1
=$ddab					Here1 = *	; remember here
>dd9d	0c					.byte CodeLen	;patch wh_CodeLength
.ddab	60		rts				rts
>ddac	43 21				Name0:	.text "C!"	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=56622					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>ddae	22					.byte (("C!"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=19					LinkDisplacement = Nt0-WordListLink
>ddaf	10					.byte WordFlags	;wh_Flags
>ddb0	03					.byte 3	;wh_CodeLength
>ddb1	13					  .byte LinkDisplacement	; offset to previous nt
=$ddb2					XtPtr1 ::= *
=56622					WordListLink ::= Nt0 ; remember the nt of this word for later
.ddb2					C_Store:
.ddb2	e0 25		cpx #$25		cpx #(DDim-2)*2+1	; far enough below end of data stack (& not negative)?
.ddb4	b0 09		bcs $ddbf		bcs Throw_Stack_16
.ddb6	b5 26		lda $26,x			lda DStack+2,x
.ddb8	81 24		sta ($24,x)			sta (DStack+0,x)
.ddba	e8		inx				inx
.ddbb	e8		inx				inx
.ddbc	e8		inx				inx
.ddbd	e8		inx				inx
=12					CodeLen	.var *-XtPtr1
=$ddbe					Here1 = *	; remember here
>ddb0	0c					.byte CodeLen	;patch wh_CodeLength
.ddbe	60		rts				rts
.ddbf	4c 2a c4	jmp $c42a	Throw_Stack_16: jmp Throw_Stack
>ddc2	31 2b 21			Name0:	.text "1+!"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=56645					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>ddc5	23					.byte (("1+!"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=0					WordFlags ::= 0	; modifiable copy, remember for later
=23					LinkDisplacement = Nt0-WordListLink
>ddc6	00					.byte WordFlags	;wh_Flags
>ddc7	03					.byte 3	;wh_CodeLength
>ddc8	17					  .byte LinkDisplacement	; offset to previous nt
=$ddc9					XtPtr1 ::= *
=56645					WordListLink ::= Nt0 ; remember the nt of this word for later
.ddc9	a9 01		lda #$01	OnePlusStore:	lda #1
.ddcb	e0 27		cpx #$27		cpx #(DDim-1)*2+1	; far enough below end of data stack (& not negative)?
.ddcd	b0 f0		bcs $ddbf		bcs Throw_Stack_16
.ddcf	18		clc				clc
.ddd0	61 24		adc ($24,x)			adc (DStack+0,x)	; increment lo byte
.ddd2	81 24		sta ($24,x)			sta (DStack+0,x)
.ddd4	90 0c		bcc $dde2			bcc _7			; if carry
.ddd6	f6 24		inc $24,x			inc DStack+0,x		;   point at hi byte
.ddd8	d0 02		bne $dddc			bne +
.ddda	f6 25		inc $25,x			inc DStack+1,x
.dddc					+
.dddc	a1 24		lda ($24,x)			lda (DStack+0,x)	;   increment hi byte
.ddde	69 00		adc #$00			adc #0
.dde0	81 24		sta ($24,x)			sta (Dstack+0,x)
.dde2					_7:
.dde2	e8		inx				inx			; Drop addr
.dde3	e8		inx				inx
=27					CodeLen	.var *-XtPtr1
=$dde4					Here1 = *	; remember here
>ddc7	1b					.byte CodeLen	;patch wh_CodeLength
.dde4	60		rts				rts
>dde5	2b 21				Name0:	.text "+!"	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=56679					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>dde7	22					.byte (("+!"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=34					LinkDisplacement = Nt0-WordListLink
>dde8	10					.byte WordFlags	;wh_Flags
>dde9	03					.byte 3	;wh_CodeLength
>ddea	22					  .byte LinkDisplacement	; offset to previous nt
=$ddeb					XtPtr1 ::= *
=56679					WordListLink ::= Nt0 ; remember the nt of this word for later
.ddeb					Plus_store:
.ddeb	e0 25		cpx #$25		cpx #(DDim-2)*2+1	; far enough below end of data stack (& not negative)?
.dded	b0 d0		bcs $ddbf		bcs Throw_Stack_16
.ddef	18		clc				clc
.ddf0	b5 26		lda $26,x			lda DStack+2,x
.ddf2	61 24		adc ($24,x)			adc (DStack+0,x)
.ddf4	81 24		sta ($24,x)			sta (DStack+0,x)
.ddf6	f6 24		inc $24,x			inc DStack+0,x
.ddf8	d0 02		bne $ddfc			bne +
.ddfa	f6 25		inc $25,x			inc DStack+1,x
.ddfc					+
.ddfc	b5 27		lda $27,x			lda DStack+3,x
.ddfe	61 24		adc ($24,x)			adc (DStack+0,x)
.de00	81 24		sta ($24,x)			sta (DStack+0,x)
.de02	4c 6d d5	jmp $d56d			jmp Two_Drop
=26					CodeLen	.var *-XtPtr1
=$de05					Here1 = *	; remember here
>dde9	1a					.byte CodeLen	;patch wh_CodeLength
>de05	42 65 6c 6c			Name0:	.text "Bell"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=56713					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>de09	84					.byte (("Bell"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=34					LinkDisplacement = Nt0-WordListLink
>de0a	10					.byte WordFlags	;wh_Flags
>de0b	03					.byte 3	;wh_CodeLength
>de0c	22					  .byte LinkDisplacement	; offset to previous nt
=$de0d					XtPtr1 ::= *
=56713					WordListLink ::= Nt0 ; remember the nt of this word for later
.de0d	a9 07		lda #$07	Bell:		lda #7		; ASCII value for BELL
.de0f	d0 0b		bne $de1c			bne Emit_A
=4					CodeLen	.var *-XtPtr1
=$de11					Here1 = *	; remember here
>de0b	04					.byte CodeLen	;patch wh_CodeLength
>de11	45 6d 69 74			Name0:	.text "Emit"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=56725					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>de15	84					.byte (("Emit"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=12					LinkDisplacement = Nt0-WordListLink
>de16	10					.byte WordFlags	;wh_Flags
>de17	03					.byte 3	;wh_CodeLength
>de18	0c					  .byte LinkDisplacement	; offset to previous nt
=$de19					XtPtr1 ::= *
=56725					WordListLink ::= Nt0 ; remember the nt of this word for later
.de19	20 c3 c3	jsr $c3c3	Emit:		jsr PopA		; pop char, with underflow check
.de1c					Emit_A:
.de1c	6c 06 03	jmp ($0306)			jmp (output)		; JSR/RTS
=6					CodeLen	.var *-XtPtr1
=$de1f					Here1 = *	; remember here
>de17	06					.byte CodeLen	;patch wh_CodeLength
>de1f	53 70 61 63 65			Name0:	.text "Space"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=56740					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>de24	a5					.byte (("Space"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=15					LinkDisplacement = Nt0-WordListLink
>de25	10					.byte WordFlags	;wh_Flags
>de26	03					.byte 3	;wh_CodeLength
>de27	0f					  .byte LinkDisplacement	; offset to previous nt
=$de28					XtPtr1 ::= *
=56740					WordListLink ::= Nt0 ; remember the nt of this word for later
.de28	a9 20		lda #$20	Space:		lda #AscSP
.de2a	d0 f0		bne $de1c			bne Emit_A
=4					CodeLen	.var *-XtPtr1
=$de2c					Here1 = *	; remember here
>de26	04					.byte CodeLen	;patch wh_CodeLength
>de2c	54 79 70 65			Name0:	.text "Type"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=56752					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>de30	a4					.byte (("Type"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=80					WordFlags ::= UF+NN	; modifiable copy, remember for later
=12					LinkDisplacement = Nt0-WordListLink
>de31	50					.byte WordFlags	;wh_Flags
>de32	03					.byte 3	;wh_CodeLength
>de33	0c					  .byte LinkDisplacement	; offset to previous nt
=$de34					XtPtr1 ::= *
=56752					WordListLink ::= Nt0 ; remember the nt of this word for later
.de34					Type:
.de34	e0 25		cpx #$25		cpx #(DDim-2)*2+1	; far enough below end of data stack (& not negative)?
.de36	b0 6c		bcs $dea4		bcs Throw_Stack_03
.de38	4c 45 de	jmp $de45			jmp _test
.de3b					_loop:
.de3b	d6 24		dec $24,x			dec DStack+0,x		; finish length decrement
.de3d	a1 26		lda ($26,x)			lda (DStack+2,x)	; Send the current character
.de3f	20 1c de	jsr $de1c			jsr Emit_A
.de42	20 a0 da	jsr $daa0			jsr NOS_One_Plus	; increment address
.de45	b5 24		lda $24,x	_test:		lda DStack+0,x		; decrement length & test for <0
.de47	d0 f2		bne $de3b			bne _loop
.de49	d6 25		dec $25,x			dec DStack+1,x
.de4b	10 ee		bpl $de3b			bpl _loop
.de4d	4c 6d d5	jmp $d56d			jmp Two_drop
=28					CodeLen	.var *-XtPtr1
=$de50					Here1 = *	; remember here
>de32	1c					.byte CodeLen	;patch wh_CodeLength
.de50					Print_ASCIIZ_YA_no_lf:
.de50	85 18		sta $18				sta tmp3+0		; save string address
.de52	84 19		sty $19				sty tmp3+1
.de54	a0 00		ldy #$00			ldy #0
.de56					Print_ASCIIZ_tmp3_no_lf:
.de56	b1 18		lda ($18),y			lda (tmp3),y
.de58	f0 06		beq $de60			beq _done		; end of string?
.de5a	20 1c de	jsr $de1c			jsr emit_a
.de5d	c8		iny				iny
.de5e	d0 f6		bne $de56			bne Print_ASCIIZ_tmp3_no_lf
.de60					_done:
.de60	60		rts				rts
.de61					Print_ASCIIZ_YA:
.de61	20 50 de	jsr $de50			jsr Print_ASCIIZ_YA_no_lf
.de64	4c 4c bb	jmp $bb4c	                jmp CR
>de67	45 78 65 63 75 74 65		Name0:	.text "Execute"	;  name of word as a string, ending at wh_NameLastChar
=7					NameLength = *-Name0
=56814					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>de6e	a7					.byte (("Execute"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=62					LinkDisplacement = Nt0-WordListLink
>de6f	10					.byte WordFlags	;wh_Flags
>de70	03					.byte 3	;wh_CodeLength
>de71	3e					  .byte LinkDisplacement	; offset to previous nt
=$de72					XtPtr1 ::= *
=56814					WordListLink ::= Nt0 ; remember the nt of this word for later
.de72					Execute:
.de72	e0 27		cpx #$27		cpx #(DDim-1)*2+1	; far enough below end of data stack (& not negative)?
.de74	b0 2e		bcs $dea4		bcs Throw_Stack_03
.de76	b5 25		lda $25,x			lda DStack+1,x	; addr for RTI
.de78	48		pha				pha
.de79	b5 24		lda $24,x			lda DStack+0,x
.de7b	48		pha				pha
.de7c	e8		inx				inx		; drop addr
.de7d	e8		inx				inx
.de7e	08		php				php		; flags for RTI
.de7f	40		rti				rti
=14					CodeLen	.var *-XtPtr1
=$de80					Here1 = *	; remember here
>de70	0e					.byte CodeLen	;patch wh_CodeLength
>de80	32 52 6f 74			Name0:	.text "2Rot"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=56836					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>de84	84					.byte (("2Rot"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=22					LinkDisplacement = Nt0-WordListLink
>de85	10					.byte WordFlags	;wh_Flags
>de86	03					.byte 3	;wh_CodeLength
>de87	16					  .byte LinkDisplacement	; offset to previous nt
=$de88					XtPtr1 ::= *
=56836					WordListLink ::= Nt0 ; remember the nt of this word for later
.de88					TwoRot:
.de88	e0 1d		cpx #$1d		cpx #(DDim-6)*2+1	; far enough below end of data stack (& not negative)?
.de8a	b0 18		bcs $dea4		bcs Throw_Stack_03
.de8c	86 14		stx $14				stx tmp1+0
.de8e	e8		inx				inx		; do 4 times
.de8f	e8		inx				inx
.de90	e8		inx				inx
.de91	e8		inx				inx
.de92	ca		dex		-		dex
.de93	b4 2c		ldy $2c,x			ldy DStack+8,x	; do a byte
.de95	b5 28		lda $28,x			lda DStack+4,x
.de97	95 2c		sta $2c,x			sta DStack+8,x
.de99	b5 24		lda $24,x			lda DStack+0,x
.de9b	95 28		sta $28,x			sta DStack+4,x
.de9d	94 24		sty $24,x			sty DStack+0,x
.de9f	e4 14		cpx $14				cpx tmp1+0
.dea1	d0 ef		bne $de92			bne -
=27					CodeLen	.var *-XtPtr1
=$dea3					Here1 = *	; remember here
>de86	1b					.byte CodeLen	;patch wh_CodeLength
.dea3	60		rts				rts
.dea4	4c 2a c4	jmp $c42a	Throw_Stack_03: jmp Throw_Stack
>dea7	52 6f 74			Name0:	.text "Rot"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=56874					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>deaa	83					.byte (("Rot"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=38					LinkDisplacement = Nt0-WordListLink
>deab	10					.byte WordFlags	;wh_Flags
>deac	03					.byte 3	;wh_CodeLength
>dead	26					  .byte LinkDisplacement	; offset to previous nt
=$deae					XtPtr1 ::= *
=56874					WordListLink ::= Nt0 ; remember the nt of this word for later
.deae					Rot:
.deae	e0 23		cpx #$23		cpx #(DDim-3)*2+1	; far enough below end of data stack (& not negative)?
.deb0	b0 f2		bcs $dea4		bcs Throw_Stack_03
.deb2	b4 29		ldy $29,x			ldy DStack+5,x	; do MSB
.deb4	b5 27		lda $27,x			lda DStack+3,x
.deb6	95 29		sta $29,x			sta DStack+5,x
.deb8	b5 25		lda $25,x			lda DStack+1,x
.deba	95 27		sta $27,x			sta DStack+3,x
.debc	94 25		sty $25,x			sty DStack+1,x
.debe	b4 28		ldy $28,x			ldy DStack+4,x	; do LSB
.dec0	b5 26		lda $26,x			lda DStack+2,x
.dec2	95 28		sta $28,x			sta DStack+4,x
.dec4	b5 24		lda $24,x			lda DStack+0,x
.dec6	95 26		sta $26,x			sta DStack+2,x
.dec8	94 24		sty $24,x			sty DStack+0,x
=28					CodeLen	.var *-XtPtr1
=$deca					Here1 = *	; remember here
>deac	1c					.byte CodeLen	;patch wh_CodeLength
.deca	60		rts				rts
>decb	2d 52 6f 74			Name0:	.text "-Rot"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=56911					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>decf	84					.byte (("-Rot"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=37					LinkDisplacement = Nt0-WordListLink
>ded0	10					.byte WordFlags	;wh_Flags
>ded1	03					.byte 3	;wh_CodeLength
>ded2	25					  .byte LinkDisplacement	; offset to previous nt
=$ded3					XtPtr1 ::= *
=56911					WordListLink ::= Nt0 ; remember the nt of this word for later
.ded3					Not_Rot:
.ded3	e0 23		cpx #$23		cpx #(DDim-3)*2+1	; far enough below end of data stack (& not negative)?
.ded5	b0 cd		bcs $dea4		bcs Throw_Stack_03
.ded7	b4 25		ldy $25,x			ldy DStack+1,x	; do MSB
.ded9	b5 27		lda $27,x			lda DStack+3,x
.dedb	95 25		sta $25,x			sta DStack+1,x
.dedd	b5 29		lda $29,x			lda DStack+5,x
.dedf	95 27		sta $27,x			sta DStack+3,x
.dee1	94 29		sty $29,x			sty DStack+5,x
.dee3	b4 24		ldy $24,x			ldy DStack+0,x	; do LSB
.dee5	b5 26		lda $26,x			lda DStack+2,x
.dee7	95 24		sta $24,x			sta DStack+0,x
.dee9	b5 28		lda $28,x			lda DStack+4,x
.deeb	95 26		sta $26,x			sta DStack+2,x
.deed	94 28		sty $28,x			sty DStack+4,x
=28					CodeLen	.var *-XtPtr1
=$deef					Here1 = *	; remember here
>ded1	1c					.byte CodeLen	;patch wh_CodeLength
.deef	60		rts				rts
>def0	40				Name0:	.text "@"	;  name of word as a string, ending at wh_NameLastChar
=1					NameLength = *-Name0
=56945					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>def1	01					.byte (("@"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=34					LinkDisplacement = Nt0-WordListLink
>def2	10					.byte WordFlags	;wh_Flags
>def3	03					.byte 3	;wh_CodeLength
>def4	22					  .byte LinkDisplacement	; offset to previous nt
=$def5					XtPtr1 ::= *
=56945					WordListLink ::= Nt0 ; remember the nt of this word for later
.def5					Fetch:
.def5	e0 27		cpx #$27		cpx #(DDim-1)*2+1	; far enough below end of data stack (& not negative)?
.def7	b0 ab		bcs $dea4		bcs Throw_Stack_03
.def9	a1 24		lda ($24,x)			lda (DStack+0,x)		; LSB
.defb	a8		tay				tay
.defc	f6 24		inc $24,x			inc DStack+0,x
.defe	d0 02		bne $df02			bne +
.df00	f6 25		inc $25,x			inc DStack+1,x
.df02					+
.df02	a1 24		lda ($24,x)			lda (DStack+0,x)		; MSB
.df04	95 25		sta $25,x			sta DStack+1,x
.df06	94 24		sty $24,x			sty DStack+0,x
=19					CodeLen	.var *-XtPtr1
=$df08					Here1 = *	; remember here
>def3	13					.byte CodeLen	;patch wh_CodeLength
.df08	60		rts				rts
>df09	21				Name0:	.text "!"	;  name of word as a string, ending at wh_NameLastChar
=1					NameLength = *-Name0
=56970					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>df0a	21					.byte (("!"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=25					LinkDisplacement = Nt0-WordListLink
>df0b	10					.byte WordFlags	;wh_Flags
>df0c	03					.byte 3	;wh_CodeLength
>df0d	19					  .byte LinkDisplacement	; offset to previous nt
=$df0e					XtPtr1 ::= *
=56970					WordListLink ::= Nt0 ; remember the nt of this word for later
.df0e					Store:
.df0e	e0 25		cpx #$25		cpx #(DDim-2)*2+1	; far enough below end of data stack (& not negative)?
.df10	b0 92		bcs $dea4		bcs Throw_Stack_03
.df12	b5 26		lda $26,x			lda DStack+2,x	; LSB
.df14	81 24		sta ($24,x)			sta (DStack+0,x)
.df16	f6 24		inc $24,x			inc DStack+0,x
.df18	d0 02		bne $df1c			bne +
.df1a	f6 25		inc $25,x			inc DStack+1,x
.df1c					+
.df1c	b5 27		lda $27,x			lda DStack+3,x	; MSB
.df1e	81 24		sta ($24,x)			sta (DStack+0,x)
.df20	e8		inx				inx		; 2Drop
.df21	e8		inx				inx
.df22	e8		inx				inx
.df23	e8		inx				inx
=22					CodeLen	.var *-XtPtr1
=$df24					Here1 = *	; remember here
>df0c	16					.byte CodeLen	;patch wh_CodeLength
.df24	60		rts				rts
>df25	30 21				Name0:	.text "0!"	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=56999					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>df27	22					.byte (("0!"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=0					WordFlags ::= 0	; modifiable copy, remember for later
=29					LinkDisplacement = Nt0-WordListLink
>df28	00					.byte WordFlags	;wh_Flags
>df29	03					.byte 3	;wh_CodeLength
>df2a	1d					  .byte LinkDisplacement	; offset to previous nt
=$df2b					XtPtr1 ::= *
=56999					WordListLink ::= Nt0 ; remember the nt of this word for later
.df2b	20 e9 c3	jsr $c3e9	ZStore:		jsr PopTmp1	; pop addr, check underflow
.df2e	a9 00		lda #$00			lda #0
.df30	a8		tay				tay		; clear LSB
.df31	91 14		sta ($14),y			sta (tmp1),y
.df33	c8		iny				iny		; clear MSB
.df34	91 14		sta ($14),y			sta (tmp1),y
=11					CodeLen	.var *-XtPtr1
=$df36					Here1 = *	; remember here
>df29	0b					.byte CodeLen	;patch wh_CodeLength
.df36	60		rts				rts
>df37	3e 52				Name0:	.text ">R"	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=57017					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>df39	42					.byte ((">R"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=52					WordFlags ::= CO+ST	; modifiable copy, remember for later
=18					LinkDisplacement = Nt0-WordListLink
>df3a	34					.byte WordFlags	;wh_Flags
>df3b	03					.byte 3	;wh_CodeLength
>df3c	12					  .byte LinkDisplacement	; offset to previous nt
=$df3d					XtPtr1 ::= *
=57017					WordListLink ::= Nt0 ; remember the nt of this word for later
.df3d					To_R:
.df3d	68		pla				pla		; move the RTS address out of the way
.df3e	85 1c		sta $1c				sta tmp5+0
.df40	68		pla				pla
.df41	85 1d		sta $1d				sta tmp5+1
.df43	20 07 c4	jsr $c407			jsr underflow_1
.df46	b5 25		lda $25,x			lda DStack+1,x	; MSB
.df48	48		pha				pha
.df49	b5 24		lda $24,x			lda DStack+0,x	; LSB
.df4b	48		pha				pha
.df4c	e8		inx				inx
.df4d	e8		inx				inx
.df4e	a5 1d		lda $1d				lda tmp5+1	; move the RTS address back in
.df50	48		pha				pha
.df51	a5 1c		lda $1c				lda tmp5+0
.df53	48		pha				pha
=23					CodeLen	.var *-XtPtr1
=$df54					Here1 = *	; remember here
>df3b	17					.byte CodeLen	;patch wh_CodeLength
.df54	60		rts				rts
>df55	52 3e				Name0:	.text "R>"	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=57047					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>df57	c2					.byte (("R>"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=52					WordFlags ::= CO+ST	; modifiable copy, remember for later
=30					LinkDisplacement = Nt0-WordListLink
>df58	34					.byte WordFlags	;wh_Flags
>df59	03					.byte 3	;wh_CodeLength
>df5a	1e					  .byte LinkDisplacement	; offset to previous nt
=$df5b					XtPtr1 ::= *
=57047					WordListLink ::= Nt0 ; remember the nt of this word for later
.df5b					R_From:
.df5b	68		pla				pla		; Move the RTS addr out of the way
.df5c	85 1c		sta $1c				sta tmp5+0
.df5e	68		pla				pla
.df5f	85 1d		sta $1d				sta tmp5+1
.df61	ca		dex				dex
.df62	ca		dex				dex
.df63	68		pla				pla		; LSB
.df64	95 24		sta $24,x			sta DStack+0,x
.df66	68		pla				pla		; MSB
.df67	95 25		sta $25,x			sta DStack+1,x
.df69	a5 1d		lda $1d				lda tmp5+1	; Restore the RTS addr
.df6b	48		pha				pha
.df6c	a5 1c		lda $1c				lda tmp5+0
.df6e	48		pha				pha
=20					CodeLen	.var *-XtPtr1
=$df6f					Here1 = *	; remember here
>df59	14					.byte CodeLen	;patch wh_CodeLength
.df6f	60		rts				rts
>df70	52 40				Name0:	.text "R@"	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=57074					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>df72	02					.byte (("R@"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=20					WordFlags ::= NN+CO	; modifiable copy, remember for later
=27					LinkDisplacement = Nt0-WordListLink
>df73	14					.byte WordFlags	;wh_Flags
>df74	03					.byte 3	;wh_CodeLength
>df75	1b					  .byte LinkDisplacement	; offset to previous nt
=$df76					XtPtr1 ::= *
=57074					WordListLink ::= Nt0 ; remember the nt of this word for later
.df76					R_Fetch:
.df76	86 14		stx $14				stx tmp1	; save data stack index
.df78	ba		tsx				tsx		; X= return stack index
.df79	bd 03 01	lda $0103,x			lda RStack+3,x
.df7c	bc 04 01	ldy $0104,x			ldy RStack+4,x
.df7f	a6 14		ldx $14				ldx tmp1	; restore data stack index
.df81	4c b5 c7	jmp $c7b5			jmp PushYA
=14					CodeLen	.var *-XtPtr1
=$df84					Here1 = *	; remember here
>df74	0e					.byte CodeLen	;patch wh_CodeLength
>df84	52 44 72 6f 70			Name0:	.text "RDrop"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=57097					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>df89	05					.byte (("RDrop"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=52					WordFlags ::= CO+ST	; modifiable copy, remember for later
=23					LinkDisplacement = Nt0-WordListLink
>df8a	34					.byte WordFlags	;wh_Flags
>df8b	03					.byte 3	;wh_CodeLength
>df8c	17					  .byte LinkDisplacement	; offset to previous nt
=$df8d					XtPtr1 ::= *
=57097					WordListLink ::= Nt0 ; remember the nt of this word for later
.df8d					RDrop:
.df8d	68		pla				pla		; Move the RTS addr out of the way
.df8e	85 1c		sta $1c				sta tmp5+0
.df90	68		pla				pla
.df91	85 1d		sta $1d				sta tmp5+1
.df93	68		pla				pla		; LSB
.df94	68		pla				pla		; MSB
.df95	a5 1d		lda $1d				lda tmp5+1	; Restore the RTS addr
.df97	48		pha				pha
.df98	a5 1c		lda $1c				lda tmp5+0
.df9a	48		pha				pha
=14					CodeLen	.var *-XtPtr1
=$df9b					Here1 = *	; remember here
>df8b	0e					.byte CodeLen	;patch wh_CodeLength
.df9b	60		rts				rts
>df9c	4f 76 65 72			Name0:	.text "Over"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=57120					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>dfa0	44					.byte (("Over"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=23					LinkDisplacement = Nt0-WordListLink
>dfa1	10					.byte WordFlags	;wh_Flags
>dfa2	03					.byte 3	;wh_CodeLength
>dfa3	17					  .byte LinkDisplacement	; offset to previous nt
=$dfa4					XtPtr1 ::= *
=57120					WordListLink ::= Nt0 ; remember the nt of this word for later
.dfa4					Over:
.dfa4	e0 25		cpx #$25		cpx #(DDim-2)*2+1	; far enough below end of data stack (& not negative)?
.dfa6	b0 34		bcs $dfdc		bcs Throw_Stack_04
.dfa8	b5 26		lda $26,x			lda DStack+2,x	; LSB
.dfaa	b4 27		ldy $27,x			ldy DStack+3,x	; MSB
.dfac	ca		dex				dex		; PushYA
.dfad	ca		dex				dex
.dfae	95 24		sta $24,x			sta DStack+0,x
.dfb0	94 25		sty $25,x			sty DStack+1,x
=14					CodeLen	.var *-XtPtr1
=$dfb2					Here1 = *	; remember here
>dfa2	0e					.byte CodeLen	;patch wh_CodeLength
.dfb2	60		rts				rts
>dfb3	3f 44 75 70			Name0:	.text "?Dup"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=57143					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>dfb7	04					.byte (("?Dup"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=23					LinkDisplacement = Nt0-WordListLink
>dfb8	10					.byte WordFlags	;wh_Flags
>dfb9	03					.byte 3	;wh_CodeLength
>dfba	17					  .byte LinkDisplacement	; offset to previous nt
=$dfbb					XtPtr1 ::= *
=57143					WordListLink ::= Nt0 ; remember the nt of this word for later
.dfbb					Question_Dup:
.dfbb	e0 27		cpx #$27		cpx #(DDim-1)*2+1	; far enough below end of data stack (& not negative)?
.dfbd	b0 1d		bcs $dfdc		bcs Throw_Stack_04
.dfbf	b5 24		lda $24,x			lda DStack+0,x	; Check if TOS is zero
.dfc1	15 25		ora $25,x			ora DStack+1,x
.dfc3	d0 0c		bne $dfd1			bne Dup_NoUf
=10					CodeLen	.var *-XtPtr1
=$dfc5					Here1 = *	; remember here
>dfb9	0a					.byte CodeLen	;patch wh_CodeLength
.dfc5	60		rts				rts
>dfc6	44 75 70			Name0:	.text "Dup"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=57161					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>dfc9	03					.byte (("Dup"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=18					LinkDisplacement = Nt0-WordListLink
>dfca	10					.byte WordFlags	;wh_Flags
>dfcb	03					.byte 3	;wh_CodeLength
>dfcc	12					  .byte LinkDisplacement	; offset to previous nt
=$dfcd					XtPtr1 ::= *
=57161					WordListLink ::= Nt0 ; remember the nt of this word for later
.dfcd					Dup:
.dfcd	e0 27		cpx #$27		cpx #(DDim-1)*2+1	; far enough below end of data stack (& not negative)?
.dfcf	b0 0b		bcs $dfdc		bcs Throw_Stack_04
.dfd1	b5 24		lda $24,x	Dup_NoUf:	lda DStack+0,x	; LSB
.dfd3	b4 25		ldy $25,x			ldy DStack+1,x	; MSB
.dfd5	ca		dex				dex
.dfd6	ca		dex				dex
.dfd7	95 24		sta $24,x			sta DStack+0,x
.dfd9	94 25		sty $25,x			sty DStack+1,x
=14					CodeLen	.var *-XtPtr1
=$dfdb					Here1 = *	; remember here
>dfcb	0e					.byte CodeLen	;patch wh_CodeLength
.dfdb	60		rts				rts
.dfdc	4c 2a c4	jmp $c42a	Throw_Stack_04: jmp Throw_Stack
.dfdf					PushAY:
.dfdf	ca		dex				dex
.dfe0	ca		dex				dex
.dfe1	94 24		sty $24,x			sty DStack+0,x
.dfe3	95 25		sta $25,x			sta DStack+1,x
.dfe5	60		rts				rts
>dfe6	53 77 61 70			Name0:	.text "Swap"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=57194					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>dfea	04					.byte (("Swap"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=33					LinkDisplacement = Nt0-WordListLink
>dfeb	10					.byte WordFlags	;wh_Flags
>dfec	03					.byte 3	;wh_CodeLength
>dfed	21					  .byte LinkDisplacement	; offset to previous nt
=$dfee					XtPtr1 ::= *
=57194					WordListLink ::= Nt0 ; remember the nt of this word for later
.dfee					Swap:
.dfee	e0 25		cpx #$25		cpx #(DDim-2)*2+1	; far enough below end of data stack (& not negative)?
.dff0	b0 ea		bcs $dfdc		bcs Throw_Stack_04
.dff2	b5 24		lda $24,x			lda DStack+0,x	; do LSB
.dff4	b4 26		ldy $26,x			ldy DStack+2,x
.dff6	95 26		sta $26,x			sta DStack+2,x
.dff8	94 24		sty $24,x			sty DStack+0,x
.dffa	b5 25		lda $25,x			lda DStack+1,x	; do MSB
.dffc	b4 27		ldy $27,x			ldy DStack+3,x
.dffe	95 27		sta $27,x			sta DStack+3,x
.e000	94 25		sty $25,x			sty DStack+1,x
=20					CodeLen	.var *-XtPtr1
=$e002					Here1 = *	; remember here
>dfec	14					.byte CodeLen	;patch wh_CodeLength
.e002	60		rts				rts
>e003	44 72 6f 70			Name0:	.text "Drop"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=57223					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e007	04					.byte (("Drop"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=29					LinkDisplacement = Nt0-WordListLink
>e008	10					.byte WordFlags	;wh_Flags
>e009	03					.byte 3	;wh_CodeLength
>e00a	1d					  .byte LinkDisplacement	; offset to previous nt
=$e00b					XtPtr1 ::= *
=57223					WordListLink ::= Nt0 ; remember the nt of this word for later
.e00b					Drop:
.e00b	e0 27		cpx #$27		cpx #(DDim-1)*2+1	; far enough below end of data stack (& not negative)?
.e00d	b0 cd		bcs $dfdc		bcs Throw_Stack_04
.e00f	e8		inx				inx
.e010	e8		inx				inx
=6					CodeLen	.var *-XtPtr1
=$e011					Here1 = *	; remember here
>e009	06					.byte CodeLen	;patch wh_CodeLength
.e011	60		rts				rts
=57223					forth_dictionary_start = WordListLink ; END of FORTH-WORDLIST
=0					WordListLink .var 0
>e012	57 6f 72 64 73			Name0:	.text "Words"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=57239					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e017	65					.byte (("Words"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=57239					LinkDisplacement = Nt0-WordListLink
=$11						  WordFlags ::= WordFlags | FP
=$13						  WordFlags ::= WordFlags | DB
>e018	13					.byte WordFlags	;wh_Flags
>e019	08					.byte 8	;wh_CodeLength
>e01a	00 00					  .word WordListLink
>e01c	9f ba					  .word Words		; pointer to xt
=0					XtPtr1 ::= 0
=57239					WordListLink ::= Nt0 ; remember the nt of this word for later
>e01e	46 6f 72 74 68 2d 57 6f		Name0:	.text "Forth-Wordlist"	;  name of word as a string, ending at wh_NameLastChar
>e026	72 64 6c 69 73 74
=14					NameLength = *-Name0
=57260					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e02c	8e					.byte (("Forth-Wordlist"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=21					LinkDisplacement = Nt0-WordListLink
=$12						  WordFlags ::= WordFlags | DB
>e02d	12					.byte WordFlags	;wh_Flags
>e02e	08					.byte 8	;wh_CodeLength
>e02f	15					  .byte LinkDisplacement	; offset to previous nt
>e030	02 b0					  .word Forth_WordList		; pointer to xt
=0					XtPtr1 ::= 0
=57260					WordListLink ::= Nt0 ; remember the nt of this word for later
>e032	46 6f 72 74 68			Name0:	.text "Forth"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=57271					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e037	05					.byte (("Forth"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=11					LinkDisplacement = Nt0-WordListLink
=$12						  WordFlags ::= WordFlags | DB
>e038	12					.byte WordFlags	;wh_Flags
>e039	08					.byte 8	;wh_CodeLength
>e03a	0b					  .byte LinkDisplacement	; offset to previous nt
>e03b	06 b1					  .word Forth		; pointer to xt
=0					XtPtr1 ::= 0
=57271					WordListLink ::= Nt0 ; remember the nt of this word for later
>e03d	53 65 74 2d 4f 72 64 65		Name0:	.text "Set-Order"	;  name of word as a string, ending at wh_NameLastChar
>e045	72
=9					NameLength = *-Name0
=57286					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e046	49					.byte (("Set-Order"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=15					LinkDisplacement = Nt0-WordListLink
=$12						  WordFlags ::= WordFlags | DB
>e047	12					.byte WordFlags	;wh_Flags
>e048	08					.byte 8	;wh_CodeLength
>e049	0f					  .byte LinkDisplacement	; offset to previous nt
>e04a	6f b1					  .word Set_Order		; pointer to xt
=0					XtPtr1 ::= 0
=57286					WordListLink ::= Nt0 ; remember the nt of this word for later
=57286					root_dictionary_start = WordListLink ; END of ROOT-WORDLIST
=0					WordListLink .var 0
>e04c	61 64 63			Name0:	.text "adc"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=57295					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e04f	63					.byte (("adc"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=57295					LinkDisplacement = Nt0-WordListLink
=$11						  WordFlags ::= WordFlags | FP
>e050	11					.byte WordFlags	;wh_Flags
>e051	03					.byte 3	;wh_CodeLength
>e052	00 00					  .word WordListLink
=$e054					XtPtr1 ::= *
=57295					WordListLink ::= Nt0 ; remember the nt of this word for later
.e054	20 07 e8	jsr $e807		jsr asm_2
=3					CodeLen	.var *-XtPtr1
=$e057					Here1 = *	; remember here
>e051	03					.byte CodeLen	;patch wh_CodeLength
>e057	6d					.byte $6d
>e058	61 64 63 2e 23			Name0:	.text "adc.#"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=57309					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e05d	65					.byte (("adc.#"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=14					LinkDisplacement = Nt0-WordListLink
>e05e	10					.byte WordFlags	;wh_Flags
>e05f	03					.byte 3	;wh_CodeLength
>e060	0e					  .byte LinkDisplacement	; offset to previous nt
=$e061					XtPtr1 ::= *
=57309					WordListLink ::= Nt0 ; remember the nt of this word for later
.e061	20 f5 e7	jsr $e7f5		jsr asm_1
=3					CodeLen	.var *-XtPtr1
=$e064					Here1 = *	; remember here
>e05f	03					.byte CodeLen	;patch wh_CodeLength
>e064	69					.byte $69
>e065	61 64 63 2e 78			Name0:	.text "adc.x"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=57322					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e06a	05					.byte (("adc.x"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>e06b	10					.byte WordFlags	;wh_Flags
>e06c	03					.byte 3	;wh_CodeLength
>e06d	0d					  .byte LinkDisplacement	; offset to previous nt
=$e06e					XtPtr1 ::= *
=57322					WordListLink ::= Nt0 ; remember the nt of this word for later
.e06e	20 07 e8	jsr $e807		jsr asm_2
=3					CodeLen	.var *-XtPtr1
=$e071					Here1 = *	; remember here
>e06c	03					.byte CodeLen	;patch wh_CodeLength
>e071	7d					.byte $7d
>e072	61 64 63 2e 79			Name0:	.text "adc.y"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=57335					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e077	25					.byte (("adc.y"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>e078	10					.byte WordFlags	;wh_Flags
>e079	03					.byte 3	;wh_CodeLength
>e07a	0d					  .byte LinkDisplacement	; offset to previous nt
=$e07b					XtPtr1 ::= *
=57335					WordListLink ::= Nt0 ; remember the nt of this word for later
.e07b	20 07 e8	jsr $e807		jsr asm_2
=3					CodeLen	.var *-XtPtr1
=$e07e					Here1 = *	; remember here
>e079	03					.byte CodeLen	;patch wh_CodeLength
>e07e	79					.byte $79
>e07f	61 64 63 2e 7a			Name0:	.text "adc.z"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=57348					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e084	45					.byte (("adc.z"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>e085	10					.byte WordFlags	;wh_Flags
>e086	03					.byte 3	;wh_CodeLength
>e087	0d					  .byte LinkDisplacement	; offset to previous nt
=$e088					XtPtr1 ::= *
=57348					WordListLink ::= Nt0 ; remember the nt of this word for later
.e088	20 f5 e7	jsr $e7f5		jsr asm_1
=3					CodeLen	.var *-XtPtr1
=$e08b					Here1 = *	; remember here
>e086	03					.byte CodeLen	;patch wh_CodeLength
>e08b	65					.byte $65
>e08c	61 64 63 2e 7a 69 79		Name0:	.text "adc.ziy"	;  name of word as a string, ending at wh_NameLastChar
=7					NameLength = *-Name0
=57363					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e093	27					.byte (("adc.ziy"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=15					LinkDisplacement = Nt0-WordListLink
>e094	10					.byte WordFlags	;wh_Flags
>e095	03					.byte 3	;wh_CodeLength
>e096	0f					  .byte LinkDisplacement	; offset to previous nt
=$e097					XtPtr1 ::= *
=57363					WordListLink ::= Nt0 ; remember the nt of this word for later
.e097	20 f5 e7	jsr $e7f5		jsr asm_1
=3					CodeLen	.var *-XtPtr1
=$e09a					Here1 = *	; remember here
>e095	03					.byte CodeLen	;patch wh_CodeLength
>e09a	71					.byte $71
>e09b	61 64 63 2e 7a 78		Name0:	.text "adc.zx"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=57377					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e0a1	06					.byte (("adc.zx"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=14					LinkDisplacement = Nt0-WordListLink
>e0a2	10					.byte WordFlags	;wh_Flags
>e0a3	03					.byte 3	;wh_CodeLength
>e0a4	0e					  .byte LinkDisplacement	; offset to previous nt
=$e0a5					XtPtr1 ::= *
=57377					WordListLink ::= Nt0 ; remember the nt of this word for later
.e0a5	20 f5 e7	jsr $e7f5		jsr asm_1
=3					CodeLen	.var *-XtPtr1
=$e0a8					Here1 = *	; remember here
>e0a3	03					.byte CodeLen	;patch wh_CodeLength
>e0a8	75					.byte $75
>e0a9	61 64 63 2e 7a 78 69		Name0:	.text "adc.zxi"	;  name of word as a string, ending at wh_NameLastChar
=7					NameLength = *-Name0
=57392					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e0b0	27					.byte (("adc.zxi"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=15					LinkDisplacement = Nt0-WordListLink
>e0b1	10					.byte WordFlags	;wh_Flags
>e0b2	03					.byte 3	;wh_CodeLength
>e0b3	0f					  .byte LinkDisplacement	; offset to previous nt
=$e0b4					XtPtr1 ::= *
=57392					WordListLink ::= Nt0 ; remember the nt of this word for later
.e0b4	20 f5 e7	jsr $e7f5		jsr asm_1
=3					CodeLen	.var *-XtPtr1
=$e0b7					Here1 = *	; remember here
>e0b2	03					.byte CodeLen	;patch wh_CodeLength
>e0b7	61					.byte $61
>e0b8	61 6e 64 2e			Name0:	.text "and."	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=57404					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e0bc	c4					.byte (("and."[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=12					LinkDisplacement = Nt0-WordListLink
>e0bd	10					.byte WordFlags	;wh_Flags
>e0be	03					.byte 3	;wh_CodeLength
>e0bf	0c					  .byte LinkDisplacement	; offset to previous nt
=$e0c0					XtPtr1 ::= *
=57404					WordListLink ::= Nt0 ; remember the nt of this word for later
.e0c0	20 07 e8	jsr $e807		jsr asm_2
=3					CodeLen	.var *-XtPtr1
=$e0c3					Here1 = *	; remember here
>e0be	03					.byte CodeLen	;patch wh_CodeLength
>e0c3	2d					.byte $2d
>e0c4	61 6e 64 2e 23			Name0:	.text "and.#"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=57417					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e0c9	65					.byte (("and.#"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>e0ca	10					.byte WordFlags	;wh_Flags
>e0cb	03					.byte 3	;wh_CodeLength
>e0cc	0d					  .byte LinkDisplacement	; offset to previous nt
=$e0cd					XtPtr1 ::= *
=57417					WordListLink ::= Nt0 ; remember the nt of this word for later
.e0cd	20 f5 e7	jsr $e7f5		jsr asm_1
=3					CodeLen	.var *-XtPtr1
=$e0d0					Here1 = *	; remember here
>e0cb	03					.byte CodeLen	;patch wh_CodeLength
>e0d0	29					.byte $29
>e0d1	61 6e 64 2e 78			Name0:	.text "and.x"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=57430					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e0d6	05					.byte (("and.x"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>e0d7	10					.byte WordFlags	;wh_Flags
>e0d8	03					.byte 3	;wh_CodeLength
>e0d9	0d					  .byte LinkDisplacement	; offset to previous nt
=$e0da					XtPtr1 ::= *
=57430					WordListLink ::= Nt0 ; remember the nt of this word for later
.e0da	20 07 e8	jsr $e807		jsr asm_2
=3					CodeLen	.var *-XtPtr1
=$e0dd					Here1 = *	; remember here
>e0d8	03					.byte CodeLen	;patch wh_CodeLength
>e0dd	3d					.byte $3d
>e0de	61 6e 64 2e 79			Name0:	.text "and.y"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=57443					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e0e3	25					.byte (("and.y"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>e0e4	10					.byte WordFlags	;wh_Flags
>e0e5	03					.byte 3	;wh_CodeLength
>e0e6	0d					  .byte LinkDisplacement	; offset to previous nt
=$e0e7					XtPtr1 ::= *
=57443					WordListLink ::= Nt0 ; remember the nt of this word for later
.e0e7	20 07 e8	jsr $e807		jsr asm_2
=3					CodeLen	.var *-XtPtr1
=$e0ea					Here1 = *	; remember here
>e0e5	03					.byte CodeLen	;patch wh_CodeLength
>e0ea	39					.byte $39
>e0eb	61 6e 64 2e 7a			Name0:	.text "and.z"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=57456					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e0f0	45					.byte (("and.z"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>e0f1	10					.byte WordFlags	;wh_Flags
>e0f2	03					.byte 3	;wh_CodeLength
>e0f3	0d					  .byte LinkDisplacement	; offset to previous nt
=$e0f4					XtPtr1 ::= *
=57456					WordListLink ::= Nt0 ; remember the nt of this word for later
.e0f4	20 f5 e7	jsr $e7f5		jsr asm_1
=3					CodeLen	.var *-XtPtr1
=$e0f7					Here1 = *	; remember here
>e0f2	03					.byte CodeLen	;patch wh_CodeLength
>e0f7	25					.byte $25
>e0f8	61 6e 64 2e 7a 69 79		Name0:	.text "and.ziy"	;  name of word as a string, ending at wh_NameLastChar
=7					NameLength = *-Name0
=57471					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e0ff	27					.byte (("and.ziy"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=15					LinkDisplacement = Nt0-WordListLink
>e100	10					.byte WordFlags	;wh_Flags
>e101	03					.byte 3	;wh_CodeLength
>e102	0f					  .byte LinkDisplacement	; offset to previous nt
=$e103					XtPtr1 ::= *
=57471					WordListLink ::= Nt0 ; remember the nt of this word for later
.e103	20 f5 e7	jsr $e7f5		jsr asm_1
=3					CodeLen	.var *-XtPtr1
=$e106					Here1 = *	; remember here
>e101	03					.byte CodeLen	;patch wh_CodeLength
>e106	31					.byte $31
>e107	61 6e 64 2e 7a 78		Name0:	.text "and.zx"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=57485					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e10d	06					.byte (("and.zx"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=14					LinkDisplacement = Nt0-WordListLink
>e10e	10					.byte WordFlags	;wh_Flags
>e10f	03					.byte 3	;wh_CodeLength
>e110	0e					  .byte LinkDisplacement	; offset to previous nt
=$e111					XtPtr1 ::= *
=57485					WordListLink ::= Nt0 ; remember the nt of this word for later
.e111	20 f5 e7	jsr $e7f5		jsr asm_1
=3					CodeLen	.var *-XtPtr1
=$e114					Here1 = *	; remember here
>e10f	03					.byte CodeLen	;patch wh_CodeLength
>e114	35					.byte $35
>e115	61 6e 64 2e 7a 78 69		Name0:	.text "and.zxi"	;  name of word as a string, ending at wh_NameLastChar
=7					NameLength = *-Name0
=57500					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e11c	27					.byte (("and.zxi"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=15					LinkDisplacement = Nt0-WordListLink
>e11d	10					.byte WordFlags	;wh_Flags
>e11e	03					.byte 3	;wh_CodeLength
>e11f	0f					  .byte LinkDisplacement	; offset to previous nt
=$e120					XtPtr1 ::= *
=57500					WordListLink ::= Nt0 ; remember the nt of this word for later
.e120	20 f5 e7	jsr $e7f5		jsr asm_1
=3					CodeLen	.var *-XtPtr1
=$e123					Here1 = *	; remember here
>e11e	03					.byte CodeLen	;patch wh_CodeLength
>e123	21					.byte $21
>e124	61 73 6c			Name0:	.text "asl"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=57511					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e127	83					.byte (("asl"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=11					LinkDisplacement = Nt0-WordListLink
>e128	10					.byte WordFlags	;wh_Flags
>e129	03					.byte 3	;wh_CodeLength
>e12a	0b					  .byte LinkDisplacement	; offset to previous nt
=$e12b					XtPtr1 ::= *
=57511					WordListLink ::= Nt0 ; remember the nt of this word for later
.e12b	20 07 e8	jsr $e807		jsr asm_2
=3					CodeLen	.var *-XtPtr1
=$e12e					Here1 = *	; remember here
>e129	03					.byte CodeLen	;patch wh_CodeLength
>e12e	0e					.byte $0e
>e12f	61 73 6c 2e 61			Name0:	.text "asl.a"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=57524					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e134	25					.byte (("asl.a"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>e135	10					.byte WordFlags	;wh_Flags
>e136	03					.byte 3	;wh_CodeLength
>e137	0d					  .byte LinkDisplacement	; offset to previous nt
=$e138					XtPtr1 ::= *
=57524					WordListLink ::= Nt0 ; remember the nt of this word for later
.e138	20 10 e8	jsr $e810		jsr asm_0
=3					CodeLen	.var *-XtPtr1
=$e13b					Here1 = *	; remember here
>e136	03					.byte CodeLen	;patch wh_CodeLength
>e13b	0a					.byte $0a
>e13c	61 73 6c 2e 78			Name0:	.text "asl.x"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=57537					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e141	05					.byte (("asl.x"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>e142	10					.byte WordFlags	;wh_Flags
>e143	03					.byte 3	;wh_CodeLength
>e144	0d					  .byte LinkDisplacement	; offset to previous nt
=$e145					XtPtr1 ::= *
=57537					WordListLink ::= Nt0 ; remember the nt of this word for later
.e145	20 07 e8	jsr $e807		jsr asm_2
=3					CodeLen	.var *-XtPtr1
=$e148					Here1 = *	; remember here
>e143	03					.byte CodeLen	;patch wh_CodeLength
>e148	1e					.byte $1e
>e149	61 73 6c 2e 7a			Name0:	.text "asl.z"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=57550					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e14e	45					.byte (("asl.z"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>e14f	10					.byte WordFlags	;wh_Flags
>e150	03					.byte 3	;wh_CodeLength
>e151	0d					  .byte LinkDisplacement	; offset to previous nt
=$e152					XtPtr1 ::= *
=57550					WordListLink ::= Nt0 ; remember the nt of this word for later
.e152	20 f5 e7	jsr $e7f5		jsr asm_1
=3					CodeLen	.var *-XtPtr1
=$e155					Here1 = *	; remember here
>e150	03					.byte CodeLen	;patch wh_CodeLength
>e155	06					.byte $06
>e156	61 73 6c 2e 7a 78		Name0:	.text "asl.zx"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=57564					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e15c	06					.byte (("asl.zx"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=14					LinkDisplacement = Nt0-WordListLink
>e15d	10					.byte WordFlags	;wh_Flags
>e15e	03					.byte 3	;wh_CodeLength
>e15f	0e					  .byte LinkDisplacement	; offset to previous nt
=$e160					XtPtr1 ::= *
=57564					WordListLink ::= Nt0 ; remember the nt of this word for later
.e160	20 f5 e7	jsr $e7f5		jsr asm_1
=3					CodeLen	.var *-XtPtr1
=$e163					Here1 = *	; remember here
>e15e	03					.byte CodeLen	;patch wh_CodeLength
>e163	16					.byte $16
>e164	62 63 63			Name0:	.text "bcc"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=57575					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e167	63					.byte (("bcc"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=11					LinkDisplacement = Nt0-WordListLink
>e168	10					.byte WordFlags	;wh_Flags
>e169	03					.byte 3	;wh_CodeLength
>e16a	0b					  .byte LinkDisplacement	; offset to previous nt
=$e16b					XtPtr1 ::= *
=57575					WordListLink ::= Nt0 ; remember the nt of this word for later
.e16b	20 d5 e7	jsr $e7d5		jsr asm_r
=3					CodeLen	.var *-XtPtr1
=$e16e					Here1 = *	; remember here
>e169	03					.byte CodeLen	;patch wh_CodeLength
>e16e	90					.byte $90
>e16f	62 63 73			Name0:	.text "bcs"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=57586					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e172	63					.byte (("bcs"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=11					LinkDisplacement = Nt0-WordListLink
>e173	10					.byte WordFlags	;wh_Flags
>e174	03					.byte 3	;wh_CodeLength
>e175	0b					  .byte LinkDisplacement	; offset to previous nt
=$e176					XtPtr1 ::= *
=57586					WordListLink ::= Nt0 ; remember the nt of this word for later
.e176	20 d5 e7	jsr $e7d5		jsr asm_r
=3					CodeLen	.var *-XtPtr1
=$e179					Here1 = *	; remember here
>e174	03					.byte CodeLen	;patch wh_CodeLength
>e179	b0					.byte $b0
>e17a	62 65 71			Name0:	.text "beq"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=57597					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e17d	23					.byte (("beq"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=11					LinkDisplacement = Nt0-WordListLink
>e17e	10					.byte WordFlags	;wh_Flags
>e17f	03					.byte 3	;wh_CodeLength
>e180	0b					  .byte LinkDisplacement	; offset to previous nt
=$e181					XtPtr1 ::= *
=57597					WordListLink ::= Nt0 ; remember the nt of this word for later
.e181	20 d5 e7	jsr $e7d5		jsr asm_r
=3					CodeLen	.var *-XtPtr1
=$e184					Here1 = *	; remember here
>e17f	03					.byte CodeLen	;patch wh_CodeLength
>e184	f0					.byte $f0
>e185	62 69 74			Name0:	.text "bit"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=57608					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e188	83					.byte (("bit"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=11					LinkDisplacement = Nt0-WordListLink
>e189	10					.byte WordFlags	;wh_Flags
>e18a	03					.byte 3	;wh_CodeLength
>e18b	0b					  .byte LinkDisplacement	; offset to previous nt
=$e18c					XtPtr1 ::= *
=57608					WordListLink ::= Nt0 ; remember the nt of this word for later
.e18c	20 07 e8	jsr $e807		jsr asm_2
=3					CodeLen	.var *-XtPtr1
=$e18f					Here1 = *	; remember here
>e18a	03					.byte CodeLen	;patch wh_CodeLength
>e18f	2c					.byte $2c
>e190	62 69 74 2e 7a			Name0:	.text "bit.z"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=57621					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e195	45					.byte (("bit.z"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>e196	10					.byte WordFlags	;wh_Flags
>e197	03					.byte 3	;wh_CodeLength
>e198	0d					  .byte LinkDisplacement	; offset to previous nt
=$e199					XtPtr1 ::= *
=57621					WordListLink ::= Nt0 ; remember the nt of this word for later
.e199	20 f5 e7	jsr $e7f5		jsr asm_1
=3					CodeLen	.var *-XtPtr1
=$e19c					Here1 = *	; remember here
>e197	03					.byte CodeLen	;patch wh_CodeLength
>e19c	24					.byte $24
>e19d	62 6d 69			Name0:	.text "bmi"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=57632					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e1a0	23					.byte (("bmi"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=11					LinkDisplacement = Nt0-WordListLink
>e1a1	10					.byte WordFlags	;wh_Flags
>e1a2	03					.byte 3	;wh_CodeLength
>e1a3	0b					  .byte LinkDisplacement	; offset to previous nt
=$e1a4					XtPtr1 ::= *
=57632					WordListLink ::= Nt0 ; remember the nt of this word for later
.e1a4	20 d5 e7	jsr $e7d5		jsr asm_r
=3					CodeLen	.var *-XtPtr1
=$e1a7					Here1 = *	; remember here
>e1a2	03					.byte CodeLen	;patch wh_CodeLength
>e1a7	30					.byte $30
>e1a8	62 6e 65			Name0:	.text "bne"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=57643					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e1ab	a3					.byte (("bne"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=11					LinkDisplacement = Nt0-WordListLink
>e1ac	10					.byte WordFlags	;wh_Flags
>e1ad	03					.byte 3	;wh_CodeLength
>e1ae	0b					  .byte LinkDisplacement	; offset to previous nt
=$e1af					XtPtr1 ::= *
=57643					WordListLink ::= Nt0 ; remember the nt of this word for later
.e1af	20 d5 e7	jsr $e7d5		jsr asm_r
=3					CodeLen	.var *-XtPtr1
=$e1b2					Here1 = *	; remember here
>e1ad	03					.byte CodeLen	;patch wh_CodeLength
>e1b2	d0					.byte $d0
>e1b3	62 70 6c			Name0:	.text "bpl"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=57654					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e1b6	83					.byte (("bpl"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=11					LinkDisplacement = Nt0-WordListLink
>e1b7	10					.byte WordFlags	;wh_Flags
>e1b8	03					.byte 3	;wh_CodeLength
>e1b9	0b					  .byte LinkDisplacement	; offset to previous nt
=$e1ba					XtPtr1 ::= *
=57654					WordListLink ::= Nt0 ; remember the nt of this word for later
.e1ba	20 d5 e7	jsr $e7d5		jsr asm_r
=3					CodeLen	.var *-XtPtr1
=$e1bd					Here1 = *	; remember here
>e1b8	03					.byte CodeLen	;patch wh_CodeLength
>e1bd	10					.byte $10
>e1be	62 72 6b			Name0:	.text "brk"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=57665					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e1c1	63					.byte (("brk"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=11					LinkDisplacement = Nt0-WordListLink
>e1c2	10					.byte WordFlags	;wh_Flags
>e1c3	03					.byte 3	;wh_CodeLength
>e1c4	0b					  .byte LinkDisplacement	; offset to previous nt
=$e1c5					XtPtr1 ::= *
=57665					WordListLink ::= Nt0 ; remember the nt of this word for later
.e1c5	20 f5 e7	jsr $e7f5		jsr asm_1
=3					CodeLen	.var *-XtPtr1
=$e1c8					Here1 = *	; remember here
>e1c3	03					.byte CodeLen	;patch wh_CodeLength
>e1c8	00					.byte $00
>e1c9	62 76 63			Name0:	.text "bvc"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=57676					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e1cc	63					.byte (("bvc"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=11					LinkDisplacement = Nt0-WordListLink
>e1cd	10					.byte WordFlags	;wh_Flags
>e1ce	03					.byte 3	;wh_CodeLength
>e1cf	0b					  .byte LinkDisplacement	; offset to previous nt
=$e1d0					XtPtr1 ::= *
=57676					WordListLink ::= Nt0 ; remember the nt of this word for later
.e1d0	20 d5 e7	jsr $e7d5		jsr asm_r
=3					CodeLen	.var *-XtPtr1
=$e1d3					Here1 = *	; remember here
>e1ce	03					.byte CodeLen	;patch wh_CodeLength
>e1d3	50					.byte $50
>e1d4	62 76 73			Name0:	.text "bvs"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=57687					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e1d7	63					.byte (("bvs"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=11					LinkDisplacement = Nt0-WordListLink
>e1d8	10					.byte WordFlags	;wh_Flags
>e1d9	03					.byte 3	;wh_CodeLength
>e1da	0b					  .byte LinkDisplacement	; offset to previous nt
=$e1db					XtPtr1 ::= *
=57687					WordListLink ::= Nt0 ; remember the nt of this word for later
.e1db	20 d5 e7	jsr $e7d5		jsr asm_r
=3					CodeLen	.var *-XtPtr1
=$e1de					Here1 = *	; remember here
>e1d9	03					.byte CodeLen	;patch wh_CodeLength
>e1de	70					.byte $70
>e1df	63 6c 63			Name0:	.text "clc"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=57698					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e1e2	63					.byte (("clc"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=11					LinkDisplacement = Nt0-WordListLink
>e1e3	10					.byte WordFlags	;wh_Flags
>e1e4	03					.byte 3	;wh_CodeLength
>e1e5	0b					  .byte LinkDisplacement	; offset to previous nt
=$e1e6					XtPtr1 ::= *
=57698					WordListLink ::= Nt0 ; remember the nt of this word for later
.e1e6	20 10 e8	jsr $e810		jsr asm_0
=3					CodeLen	.var *-XtPtr1
=$e1e9					Here1 = *	; remember here
>e1e4	03					.byte CodeLen	;patch wh_CodeLength
>e1e9	18					.byte $18
>e1ea	63 6c 64			Name0:	.text "cld"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=57709					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e1ed	83					.byte (("cld"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=11					LinkDisplacement = Nt0-WordListLink
>e1ee	10					.byte WordFlags	;wh_Flags
>e1ef	03					.byte 3	;wh_CodeLength
>e1f0	0b					  .byte LinkDisplacement	; offset to previous nt
=$e1f1					XtPtr1 ::= *
=57709					WordListLink ::= Nt0 ; remember the nt of this word for later
.e1f1	20 10 e8	jsr $e810		jsr asm_0
=3					CodeLen	.var *-XtPtr1
=$e1f4					Here1 = *	; remember here
>e1ef	03					.byte CodeLen	;patch wh_CodeLength
>e1f4	d8					.byte $d8
>e1f5	63 6c 69			Name0:	.text "cli"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=57720					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e1f8	23					.byte (("cli"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=11					LinkDisplacement = Nt0-WordListLink
>e1f9	10					.byte WordFlags	;wh_Flags
>e1fa	03					.byte 3	;wh_CodeLength
>e1fb	0b					  .byte LinkDisplacement	; offset to previous nt
=$e1fc					XtPtr1 ::= *
=57720					WordListLink ::= Nt0 ; remember the nt of this word for later
.e1fc	20 10 e8	jsr $e810		jsr asm_0
=3					CodeLen	.var *-XtPtr1
=$e1ff					Here1 = *	; remember here
>e1fa	03					.byte CodeLen	;patch wh_CodeLength
>e1ff	58					.byte $58
>e200	63 6c 76			Name0:	.text "clv"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=57731					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e203	c3					.byte (("clv"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=11					LinkDisplacement = Nt0-WordListLink
>e204	10					.byte WordFlags	;wh_Flags
>e205	03					.byte 3	;wh_CodeLength
>e206	0b					  .byte LinkDisplacement	; offset to previous nt
=$e207					XtPtr1 ::= *
=57731					WordListLink ::= Nt0 ; remember the nt of this word for later
.e207	20 10 e8	jsr $e810		jsr asm_0
=3					CodeLen	.var *-XtPtr1
=$e20a					Here1 = *	; remember here
>e205	03					.byte CodeLen	;patch wh_CodeLength
>e20a	b8					.byte $b8
>e20b	63 6d 70			Name0:	.text "cmp"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=57742					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e20e	03					.byte (("cmp"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=11					LinkDisplacement = Nt0-WordListLink
>e20f	10					.byte WordFlags	;wh_Flags
>e210	03					.byte 3	;wh_CodeLength
>e211	0b					  .byte LinkDisplacement	; offset to previous nt
=$e212					XtPtr1 ::= *
=57742					WordListLink ::= Nt0 ; remember the nt of this word for later
.e212	20 07 e8	jsr $e807		jsr asm_2
=3					CodeLen	.var *-XtPtr1
=$e215					Here1 = *	; remember here
>e210	03					.byte CodeLen	;patch wh_CodeLength
>e215	cd					.byte $cd
>e216	63 6d 70 2e 23			Name0:	.text "cmp.#"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=57755					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e21b	65					.byte (("cmp.#"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>e21c	10					.byte WordFlags	;wh_Flags
>e21d	03					.byte 3	;wh_CodeLength
>e21e	0d					  .byte LinkDisplacement	; offset to previous nt
=$e21f					XtPtr1 ::= *
=57755					WordListLink ::= Nt0 ; remember the nt of this word for later
.e21f	20 f5 e7	jsr $e7f5		jsr asm_1
=3					CodeLen	.var *-XtPtr1
=$e222					Here1 = *	; remember here
>e21d	03					.byte CodeLen	;patch wh_CodeLength
>e222	c9					.byte $c9
>e223	63 6d 70 2e 78			Name0:	.text "cmp.x"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=57768					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e228	05					.byte (("cmp.x"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>e229	10					.byte WordFlags	;wh_Flags
>e22a	03					.byte 3	;wh_CodeLength
>e22b	0d					  .byte LinkDisplacement	; offset to previous nt
=$e22c					XtPtr1 ::= *
=57768					WordListLink ::= Nt0 ; remember the nt of this word for later
.e22c	20 07 e8	jsr $e807		jsr asm_2
=3					CodeLen	.var *-XtPtr1
=$e22f					Here1 = *	; remember here
>e22a	03					.byte CodeLen	;patch wh_CodeLength
>e22f	dd					.byte $dd
>e230	63 6d 70 2e 79			Name0:	.text "cmp.y"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=57781					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e235	25					.byte (("cmp.y"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>e236	10					.byte WordFlags	;wh_Flags
>e237	03					.byte 3	;wh_CodeLength
>e238	0d					  .byte LinkDisplacement	; offset to previous nt
=$e239					XtPtr1 ::= *
=57781					WordListLink ::= Nt0 ; remember the nt of this word for later
.e239	20 07 e8	jsr $e807		jsr asm_2
=3					CodeLen	.var *-XtPtr1
=$e23c					Here1 = *	; remember here
>e237	03					.byte CodeLen	;patch wh_CodeLength
>e23c	d9					.byte $d9
>e23d	63 6d 70 2e 7a			Name0:	.text "cmp.z"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=57794					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e242	45					.byte (("cmp.z"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>e243	10					.byte WordFlags	;wh_Flags
>e244	03					.byte 3	;wh_CodeLength
>e245	0d					  .byte LinkDisplacement	; offset to previous nt
=$e246					XtPtr1 ::= *
=57794					WordListLink ::= Nt0 ; remember the nt of this word for later
.e246	20 f5 e7	jsr $e7f5		jsr asm_1
=3					CodeLen	.var *-XtPtr1
=$e249					Here1 = *	; remember here
>e244	03					.byte CodeLen	;patch wh_CodeLength
>e249	c5					.byte $c5
>e24a	63 6d 70 2e 7a 69 79		Name0:	.text "cmp.ziy"	;  name of word as a string, ending at wh_NameLastChar
=7					NameLength = *-Name0
=57809					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e251	27					.byte (("cmp.ziy"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=15					LinkDisplacement = Nt0-WordListLink
>e252	10					.byte WordFlags	;wh_Flags
>e253	03					.byte 3	;wh_CodeLength
>e254	0f					  .byte LinkDisplacement	; offset to previous nt
=$e255					XtPtr1 ::= *
=57809					WordListLink ::= Nt0 ; remember the nt of this word for later
.e255	20 f5 e7	jsr $e7f5		jsr asm_1
=3					CodeLen	.var *-XtPtr1
=$e258					Here1 = *	; remember here
>e253	03					.byte CodeLen	;patch wh_CodeLength
>e258	d1					.byte $d1
>e259	63 6d 70 2e 7a 78		Name0:	.text "cmp.zx"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=57823					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e25f	06					.byte (("cmp.zx"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=14					LinkDisplacement = Nt0-WordListLink
>e260	10					.byte WordFlags	;wh_Flags
>e261	03					.byte 3	;wh_CodeLength
>e262	0e					  .byte LinkDisplacement	; offset to previous nt
=$e263					XtPtr1 ::= *
=57823					WordListLink ::= Nt0 ; remember the nt of this word for later
.e263	20 f5 e7	jsr $e7f5		jsr asm_1
=3					CodeLen	.var *-XtPtr1
=$e266					Here1 = *	; remember here
>e261	03					.byte CodeLen	;patch wh_CodeLength
>e266	d5					.byte $d5
>e267	63 6d 70 2e 7a 78 69		Name0:	.text "cmp.zxi"	;  name of word as a string, ending at wh_NameLastChar
=7					NameLength = *-Name0
=57838					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e26e	27					.byte (("cmp.zxi"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=15					LinkDisplacement = Nt0-WordListLink
>e26f	10					.byte WordFlags	;wh_Flags
>e270	03					.byte 3	;wh_CodeLength
>e271	0f					  .byte LinkDisplacement	; offset to previous nt
=$e272					XtPtr1 ::= *
=57838					WordListLink ::= Nt0 ; remember the nt of this word for later
.e272	20 f5 e7	jsr $e7f5		jsr asm_1
=3					CodeLen	.var *-XtPtr1
=$e275					Here1 = *	; remember here
>e270	03					.byte CodeLen	;patch wh_CodeLength
>e275	c1					.byte $c1
>e276	63 70 78			Name0:	.text "cpx"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=57849					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e279	03					.byte (("cpx"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=11					LinkDisplacement = Nt0-WordListLink
>e27a	10					.byte WordFlags	;wh_Flags
>e27b	03					.byte 3	;wh_CodeLength
>e27c	0b					  .byte LinkDisplacement	; offset to previous nt
=$e27d					XtPtr1 ::= *
=57849					WordListLink ::= Nt0 ; remember the nt of this word for later
.e27d	20 07 e8	jsr $e807		jsr asm_2
=3					CodeLen	.var *-XtPtr1
=$e280					Here1 = *	; remember here
>e27b	03					.byte CodeLen	;patch wh_CodeLength
>e280	ec					.byte $ec
>e281	63 70 78 2e 23			Name0:	.text "cpx.#"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=57862					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e286	65					.byte (("cpx.#"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>e287	10					.byte WordFlags	;wh_Flags
>e288	03					.byte 3	;wh_CodeLength
>e289	0d					  .byte LinkDisplacement	; offset to previous nt
=$e28a					XtPtr1 ::= *
=57862					WordListLink ::= Nt0 ; remember the nt of this word for later
.e28a	20 f5 e7	jsr $e7f5		jsr asm_1
=3					CodeLen	.var *-XtPtr1
=$e28d					Here1 = *	; remember here
>e288	03					.byte CodeLen	;patch wh_CodeLength
>e28d	e0					.byte $e0
>e28e	63 70 78 2e 7a			Name0:	.text "cpx.z"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=57875					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e293	45					.byte (("cpx.z"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>e294	10					.byte WordFlags	;wh_Flags
>e295	03					.byte 3	;wh_CodeLength
>e296	0d					  .byte LinkDisplacement	; offset to previous nt
=$e297					XtPtr1 ::= *
=57875					WordListLink ::= Nt0 ; remember the nt of this word for later
.e297	20 f5 e7	jsr $e7f5		jsr asm_1
=3					CodeLen	.var *-XtPtr1
=$e29a					Here1 = *	; remember here
>e295	03					.byte CodeLen	;patch wh_CodeLength
>e29a	e4					.byte $e4
>e29b	63 70 79			Name0:	.text "cpy"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=57886					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e29e	23					.byte (("cpy"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=11					LinkDisplacement = Nt0-WordListLink
>e29f	10					.byte WordFlags	;wh_Flags
>e2a0	03					.byte 3	;wh_CodeLength
>e2a1	0b					  .byte LinkDisplacement	; offset to previous nt
=$e2a2					XtPtr1 ::= *
=57886					WordListLink ::= Nt0 ; remember the nt of this word for later
.e2a2	20 07 e8	jsr $e807		jsr asm_2
=3					CodeLen	.var *-XtPtr1
=$e2a5					Here1 = *	; remember here
>e2a0	03					.byte CodeLen	;patch wh_CodeLength
>e2a5	cc					.byte $cc
>e2a6	63 70 79 2e 23			Name0:	.text "cpy.#"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=57899					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e2ab	65					.byte (("cpy.#"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>e2ac	10					.byte WordFlags	;wh_Flags
>e2ad	03					.byte 3	;wh_CodeLength
>e2ae	0d					  .byte LinkDisplacement	; offset to previous nt
=$e2af					XtPtr1 ::= *
=57899					WordListLink ::= Nt0 ; remember the nt of this word for later
.e2af	20 f5 e7	jsr $e7f5		jsr asm_1
=3					CodeLen	.var *-XtPtr1
=$e2b2					Here1 = *	; remember here
>e2ad	03					.byte CodeLen	;patch wh_CodeLength
>e2b2	c0					.byte $c0
>e2b3	63 70 79 2e 7a			Name0:	.text "cpy.z"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=57912					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e2b8	45					.byte (("cpy.z"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>e2b9	10					.byte WordFlags	;wh_Flags
>e2ba	03					.byte 3	;wh_CodeLength
>e2bb	0d					  .byte LinkDisplacement	; offset to previous nt
=$e2bc					XtPtr1 ::= *
=57912					WordListLink ::= Nt0 ; remember the nt of this word for later
.e2bc	20 f5 e7	jsr $e7f5		jsr asm_1
=3					CodeLen	.var *-XtPtr1
=$e2bf					Here1 = *	; remember here
>e2ba	03					.byte CodeLen	;patch wh_CodeLength
>e2bf	c4					.byte $c4
>e2c0	64 65 63			Name0:	.text "dec"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=57923					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e2c3	63					.byte (("dec"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=11					LinkDisplacement = Nt0-WordListLink
>e2c4	10					.byte WordFlags	;wh_Flags
>e2c5	03					.byte 3	;wh_CodeLength
>e2c6	0b					  .byte LinkDisplacement	; offset to previous nt
=$e2c7					XtPtr1 ::= *
=57923					WordListLink ::= Nt0 ; remember the nt of this word for later
.e2c7	20 07 e8	jsr $e807		jsr asm_2
=3					CodeLen	.var *-XtPtr1
=$e2ca					Here1 = *	; remember here
>e2c5	03					.byte CodeLen	;patch wh_CodeLength
>e2ca	ce					.byte $ce
>e2cb	64 65 63 2e 61			Name0:	.text "dec.a"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=57936					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e2d0	25					.byte (("dec.a"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>e2d1	10					.byte WordFlags	;wh_Flags
>e2d2	03					.byte 3	;wh_CodeLength
>e2d3	0d					  .byte LinkDisplacement	; offset to previous nt
=$e2d4					XtPtr1 ::= *
=57936					WordListLink ::= Nt0 ; remember the nt of this word for later
.e2d4	20 10 e8	jsr $e810		jsr asm_0
=3					CodeLen	.var *-XtPtr1
=$e2d7					Here1 = *	; remember here
>e2d2	03					.byte CodeLen	;patch wh_CodeLength
>e2d7	3a					.byte $3a
>e2d8	64 65 63 2e 78			Name0:	.text "dec.x"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=57949					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e2dd	05					.byte (("dec.x"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>e2de	10					.byte WordFlags	;wh_Flags
>e2df	03					.byte 3	;wh_CodeLength
>e2e0	0d					  .byte LinkDisplacement	; offset to previous nt
=$e2e1					XtPtr1 ::= *
=57949					WordListLink ::= Nt0 ; remember the nt of this word for later
.e2e1	20 07 e8	jsr $e807		jsr asm_2
=3					CodeLen	.var *-XtPtr1
=$e2e4					Here1 = *	; remember here
>e2df	03					.byte CodeLen	;patch wh_CodeLength
>e2e4	de					.byte $de
>e2e5	64 65 63 2e 7a			Name0:	.text "dec.z"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=57962					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e2ea	45					.byte (("dec.z"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>e2eb	10					.byte WordFlags	;wh_Flags
>e2ec	03					.byte 3	;wh_CodeLength
>e2ed	0d					  .byte LinkDisplacement	; offset to previous nt
=$e2ee					XtPtr1 ::= *
=57962					WordListLink ::= Nt0 ; remember the nt of this word for later
.e2ee	20 f5 e7	jsr $e7f5		jsr asm_1
=3					CodeLen	.var *-XtPtr1
=$e2f1					Here1 = *	; remember here
>e2ec	03					.byte CodeLen	;patch wh_CodeLength
>e2f1	c6					.byte $c6
>e2f2	64 65 63 2e 7a 78		Name0:	.text "dec.zx"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=57976					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e2f8	06					.byte (("dec.zx"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=14					LinkDisplacement = Nt0-WordListLink
>e2f9	10					.byte WordFlags	;wh_Flags
>e2fa	03					.byte 3	;wh_CodeLength
>e2fb	0e					  .byte LinkDisplacement	; offset to previous nt
=$e2fc					XtPtr1 ::= *
=57976					WordListLink ::= Nt0 ; remember the nt of this word for later
.e2fc	20 f5 e7	jsr $e7f5		jsr asm_1
=3					CodeLen	.var *-XtPtr1
=$e2ff					Here1 = *	; remember here
>e2fa	03					.byte CodeLen	;patch wh_CodeLength
>e2ff	d6					.byte $d6
>e300	64 65 78			Name0:	.text "dex"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=57987					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e303	03					.byte (("dex"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=11					LinkDisplacement = Nt0-WordListLink
>e304	10					.byte WordFlags	;wh_Flags
>e305	03					.byte 3	;wh_CodeLength
>e306	0b					  .byte LinkDisplacement	; offset to previous nt
=$e307					XtPtr1 ::= *
=57987					WordListLink ::= Nt0 ; remember the nt of this word for later
.e307	20 10 e8	jsr $e810		jsr asm_0
=3					CodeLen	.var *-XtPtr1
=$e30a					Here1 = *	; remember here
>e305	03					.byte CodeLen	;patch wh_CodeLength
>e30a	ca					.byte $ca
>e30b	64 65 79			Name0:	.text "dey"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=57998					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e30e	23					.byte (("dey"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=11					LinkDisplacement = Nt0-WordListLink
>e30f	10					.byte WordFlags	;wh_Flags
>e310	03					.byte 3	;wh_CodeLength
>e311	0b					  .byte LinkDisplacement	; offset to previous nt
=$e312					XtPtr1 ::= *
=57998					WordListLink ::= Nt0 ; remember the nt of this word for later
.e312	20 10 e8	jsr $e810		jsr asm_0
=3					CodeLen	.var *-XtPtr1
=$e315					Here1 = *	; remember here
>e310	03					.byte CodeLen	;patch wh_CodeLength
>e315	88					.byte $88
>e316	65 6f 72			Name0:	.text "eor"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=58009					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e319	43					.byte (("eor"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=11					LinkDisplacement = Nt0-WordListLink
>e31a	10					.byte WordFlags	;wh_Flags
>e31b	03					.byte 3	;wh_CodeLength
>e31c	0b					  .byte LinkDisplacement	; offset to previous nt
=$e31d					XtPtr1 ::= *
=58009					WordListLink ::= Nt0 ; remember the nt of this word for later
.e31d	20 07 e8	jsr $e807		jsr asm_2
=3					CodeLen	.var *-XtPtr1
=$e320					Here1 = *	; remember here
>e31b	03					.byte CodeLen	;patch wh_CodeLength
>e320	4d					.byte $4d
>e321	65 6f 72 2e 23			Name0:	.text "eor.#"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=58022					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e326	65					.byte (("eor.#"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>e327	10					.byte WordFlags	;wh_Flags
>e328	03					.byte 3	;wh_CodeLength
>e329	0d					  .byte LinkDisplacement	; offset to previous nt
=$e32a					XtPtr1 ::= *
=58022					WordListLink ::= Nt0 ; remember the nt of this word for later
.e32a	20 f5 e7	jsr $e7f5		jsr asm_1
=3					CodeLen	.var *-XtPtr1
=$e32d					Here1 = *	; remember here
>e328	03					.byte CodeLen	;patch wh_CodeLength
>e32d	49					.byte $49
>e32e	65 6f 72 2e 78			Name0:	.text "eor.x"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=58035					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e333	05					.byte (("eor.x"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>e334	10					.byte WordFlags	;wh_Flags
>e335	03					.byte 3	;wh_CodeLength
>e336	0d					  .byte LinkDisplacement	; offset to previous nt
=$e337					XtPtr1 ::= *
=58035					WordListLink ::= Nt0 ; remember the nt of this word for later
.e337	20 07 e8	jsr $e807		jsr asm_2
=3					CodeLen	.var *-XtPtr1
=$e33a					Here1 = *	; remember here
>e335	03					.byte CodeLen	;patch wh_CodeLength
>e33a	5d					.byte $5d
>e33b	65 6f 72 2e 79			Name0:	.text "eor.y"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=58048					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e340	25					.byte (("eor.y"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>e341	10					.byte WordFlags	;wh_Flags
>e342	03					.byte 3	;wh_CodeLength
>e343	0d					  .byte LinkDisplacement	; offset to previous nt
=$e344					XtPtr1 ::= *
=58048					WordListLink ::= Nt0 ; remember the nt of this word for later
.e344	20 07 e8	jsr $e807		jsr asm_2
=3					CodeLen	.var *-XtPtr1
=$e347					Here1 = *	; remember here
>e342	03					.byte CodeLen	;patch wh_CodeLength
>e347	59					.byte $59
>e348	65 6f 72 2e 7a			Name0:	.text "eor.z"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=58061					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e34d	45					.byte (("eor.z"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>e34e	10					.byte WordFlags	;wh_Flags
>e34f	03					.byte 3	;wh_CodeLength
>e350	0d					  .byte LinkDisplacement	; offset to previous nt
=$e351					XtPtr1 ::= *
=58061					WordListLink ::= Nt0 ; remember the nt of this word for later
.e351	20 f5 e7	jsr $e7f5		jsr asm_1
=3					CodeLen	.var *-XtPtr1
=$e354					Here1 = *	; remember here
>e34f	03					.byte CodeLen	;patch wh_CodeLength
>e354	45					.byte $45
>e355	65 6f 72 2e 7a 69 79		Name0:	.text "eor.ziy"	;  name of word as a string, ending at wh_NameLastChar
=7					NameLength = *-Name0
=58076					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e35c	27					.byte (("eor.ziy"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=15					LinkDisplacement = Nt0-WordListLink
>e35d	10					.byte WordFlags	;wh_Flags
>e35e	03					.byte 3	;wh_CodeLength
>e35f	0f					  .byte LinkDisplacement	; offset to previous nt
=$e360					XtPtr1 ::= *
=58076					WordListLink ::= Nt0 ; remember the nt of this word for later
.e360	20 f5 e7	jsr $e7f5		jsr asm_1
=3					CodeLen	.var *-XtPtr1
=$e363					Here1 = *	; remember here
>e35e	03					.byte CodeLen	;patch wh_CodeLength
>e363	51					.byte $51
>e364	65 6f 72 2e 7a 78		Name0:	.text "eor.zx"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=58090					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e36a	06					.byte (("eor.zx"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=14					LinkDisplacement = Nt0-WordListLink
>e36b	10					.byte WordFlags	;wh_Flags
>e36c	03					.byte 3	;wh_CodeLength
>e36d	0e					  .byte LinkDisplacement	; offset to previous nt
=$e36e					XtPtr1 ::= *
=58090					WordListLink ::= Nt0 ; remember the nt of this word for later
.e36e	20 f5 e7	jsr $e7f5		jsr asm_1
=3					CodeLen	.var *-XtPtr1
=$e371					Here1 = *	; remember here
>e36c	03					.byte CodeLen	;patch wh_CodeLength
>e371	55					.byte $55
>e372	65 6f 72 2e 7a 78 69		Name0:	.text "eor.zxi"	;  name of word as a string, ending at wh_NameLastChar
=7					NameLength = *-Name0
=58105					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e379	27					.byte (("eor.zxi"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=15					LinkDisplacement = Nt0-WordListLink
>e37a	10					.byte WordFlags	;wh_Flags
>e37b	03					.byte 3	;wh_CodeLength
>e37c	0f					  .byte LinkDisplacement	; offset to previous nt
=$e37d					XtPtr1 ::= *
=58105					WordListLink ::= Nt0 ; remember the nt of this word for later
.e37d	20 f5 e7	jsr $e7f5		jsr asm_1
=3					CodeLen	.var *-XtPtr1
=$e380					Here1 = *	; remember here
>e37b	03					.byte CodeLen	;patch wh_CodeLength
>e380	41					.byte $41
>e381	69 6e 63			Name0:	.text "inc"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=58116					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e384	63					.byte (("inc"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=11					LinkDisplacement = Nt0-WordListLink
>e385	10					.byte WordFlags	;wh_Flags
>e386	03					.byte 3	;wh_CodeLength
>e387	0b					  .byte LinkDisplacement	; offset to previous nt
=$e388					XtPtr1 ::= *
=58116					WordListLink ::= Nt0 ; remember the nt of this word for later
.e388	20 07 e8	jsr $e807		jsr asm_2
=3					CodeLen	.var *-XtPtr1
=$e38b					Here1 = *	; remember here
>e386	03					.byte CodeLen	;patch wh_CodeLength
>e38b	ee					.byte $ee
>e38c	69 6e 63 2e 61			Name0:	.text "inc.a"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=58129					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e391	25					.byte (("inc.a"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>e392	10					.byte WordFlags	;wh_Flags
>e393	03					.byte 3	;wh_CodeLength
>e394	0d					  .byte LinkDisplacement	; offset to previous nt
=$e395					XtPtr1 ::= *
=58129					WordListLink ::= Nt0 ; remember the nt of this word for later
.e395	20 10 e8	jsr $e810		jsr asm_0
=3					CodeLen	.var *-XtPtr1
=$e398					Here1 = *	; remember here
>e393	03					.byte CodeLen	;patch wh_CodeLength
>e398	1a					.byte $1a
>e399	69 6e 63 2e 78			Name0:	.text "inc.x"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=58142					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e39e	05					.byte (("inc.x"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>e39f	10					.byte WordFlags	;wh_Flags
>e3a0	03					.byte 3	;wh_CodeLength
>e3a1	0d					  .byte LinkDisplacement	; offset to previous nt
=$e3a2					XtPtr1 ::= *
=58142					WordListLink ::= Nt0 ; remember the nt of this word for later
.e3a2	20 07 e8	jsr $e807		jsr asm_2
=3					CodeLen	.var *-XtPtr1
=$e3a5					Here1 = *	; remember here
>e3a0	03					.byte CodeLen	;patch wh_CodeLength
>e3a5	fe					.byte $fe
>e3a6	69 6e 63 2e 7a			Name0:	.text "inc.z"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=58155					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e3ab	45					.byte (("inc.z"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>e3ac	10					.byte WordFlags	;wh_Flags
>e3ad	03					.byte 3	;wh_CodeLength
>e3ae	0d					  .byte LinkDisplacement	; offset to previous nt
=$e3af					XtPtr1 ::= *
=58155					WordListLink ::= Nt0 ; remember the nt of this word for later
.e3af	20 f5 e7	jsr $e7f5		jsr asm_1
=3					CodeLen	.var *-XtPtr1
=$e3b2					Here1 = *	; remember here
>e3ad	03					.byte CodeLen	;patch wh_CodeLength
>e3b2	e6					.byte $e6
>e3b3	69 6e 63 2e 7a 78		Name0:	.text "inc.zx"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=58169					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e3b9	06					.byte (("inc.zx"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=14					LinkDisplacement = Nt0-WordListLink
>e3ba	10					.byte WordFlags	;wh_Flags
>e3bb	03					.byte 3	;wh_CodeLength
>e3bc	0e					  .byte LinkDisplacement	; offset to previous nt
=$e3bd					XtPtr1 ::= *
=58169					WordListLink ::= Nt0 ; remember the nt of this word for later
.e3bd	20 f5 e7	jsr $e7f5		jsr asm_1
=3					CodeLen	.var *-XtPtr1
=$e3c0					Here1 = *	; remember here
>e3bb	03					.byte CodeLen	;patch wh_CodeLength
>e3c0	f6					.byte $f6
>e3c1	69 6e 78			Name0:	.text "inx"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=58180					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e3c4	03					.byte (("inx"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=11					LinkDisplacement = Nt0-WordListLink
>e3c5	10					.byte WordFlags	;wh_Flags
>e3c6	03					.byte 3	;wh_CodeLength
>e3c7	0b					  .byte LinkDisplacement	; offset to previous nt
=$e3c8					XtPtr1 ::= *
=58180					WordListLink ::= Nt0 ; remember the nt of this word for later
.e3c8	20 10 e8	jsr $e810		jsr asm_0
=3					CodeLen	.var *-XtPtr1
=$e3cb					Here1 = *	; remember here
>e3c6	03					.byte CodeLen	;patch wh_CodeLength
>e3cb	e8					.byte $e8
>e3cc	69 6e 79			Name0:	.text "iny"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=58191					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e3cf	23					.byte (("iny"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=11					LinkDisplacement = Nt0-WordListLink
>e3d0	10					.byte WordFlags	;wh_Flags
>e3d1	03					.byte 3	;wh_CodeLength
>e3d2	0b					  .byte LinkDisplacement	; offset to previous nt
=$e3d3					XtPtr1 ::= *
=58191					WordListLink ::= Nt0 ; remember the nt of this word for later
.e3d3	20 10 e8	jsr $e810		jsr asm_0
=3					CodeLen	.var *-XtPtr1
=$e3d6					Here1 = *	; remember here
>e3d1	03					.byte CodeLen	;patch wh_CodeLength
>e3d6	c8					.byte $c8
>e3d7	6a 6d 70			Name0:	.text "jmp"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=58202					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e3da	03					.byte (("jmp"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=11					LinkDisplacement = Nt0-WordListLink
>e3db	10					.byte WordFlags	;wh_Flags
>e3dc	03					.byte 3	;wh_CodeLength
>e3dd	0b					  .byte LinkDisplacement	; offset to previous nt
=$e3de					XtPtr1 ::= *
=58202					WordListLink ::= Nt0 ; remember the nt of this word for later
.e3de	20 07 e8	jsr $e807		jsr asm_2
=3					CodeLen	.var *-XtPtr1
=$e3e1					Here1 = *	; remember here
>e3dc	03					.byte CodeLen	;patch wh_CodeLength
>e3e1	4c					.byte $4c
>e3e2	6a 6d 70 2e 69			Name0:	.text "jmp.i"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=58215					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e3e7	25					.byte (("jmp.i"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>e3e8	10					.byte WordFlags	;wh_Flags
>e3e9	03					.byte 3	;wh_CodeLength
>e3ea	0d					  .byte LinkDisplacement	; offset to previous nt
=$e3eb					XtPtr1 ::= *
=58215					WordListLink ::= Nt0 ; remember the nt of this word for later
.e3eb	20 07 e8	jsr $e807		jsr asm_2
=3					CodeLen	.var *-XtPtr1
=$e3ee					Here1 = *	; remember here
>e3e9	03					.byte CodeLen	;patch wh_CodeLength
>e3ee	6c					.byte $6c
>e3ef	6a 73 72			Name0:	.text "jsr"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=58226					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e3f2	43					.byte (("jsr"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=11					LinkDisplacement = Nt0-WordListLink
>e3f3	10					.byte WordFlags	;wh_Flags
>e3f4	03					.byte 3	;wh_CodeLength
>e3f5	0b					  .byte LinkDisplacement	; offset to previous nt
=$e3f6					XtPtr1 ::= *
=58226					WordListLink ::= Nt0 ; remember the nt of this word for later
.e3f6	20 07 e8	jsr $e807		jsr asm_2
=3					CodeLen	.var *-XtPtr1
=$e3f9					Here1 = *	; remember here
>e3f4	03					.byte CodeLen	;patch wh_CodeLength
>e3f9	20					.byte $20
>e3fa	6c 64 61			Name0:	.text "lda"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=58237					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e3fd	23					.byte (("lda"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=11					LinkDisplacement = Nt0-WordListLink
>e3fe	10					.byte WordFlags	;wh_Flags
>e3ff	03					.byte 3	;wh_CodeLength
>e400	0b					  .byte LinkDisplacement	; offset to previous nt
=$e401					XtPtr1 ::= *
=58237					WordListLink ::= Nt0 ; remember the nt of this word for later
.e401	20 07 e8	jsr $e807		jsr asm_2
=3					CodeLen	.var *-XtPtr1
=$e404					Here1 = *	; remember here
>e3ff	03					.byte CodeLen	;patch wh_CodeLength
>e404	ad					.byte $ad
>e405	6c 64 61 2e 23			Name0:	.text "lda.#"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=58250					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e40a	65					.byte (("lda.#"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>e40b	10					.byte WordFlags	;wh_Flags
>e40c	03					.byte 3	;wh_CodeLength
>e40d	0d					  .byte LinkDisplacement	; offset to previous nt
=$e40e					XtPtr1 ::= *
=58250					WordListLink ::= Nt0 ; remember the nt of this word for later
.e40e	20 f5 e7	jsr $e7f5		jsr asm_1
=3					CodeLen	.var *-XtPtr1
=$e411					Here1 = *	; remember here
>e40c	03					.byte CodeLen	;patch wh_CodeLength
>e411	a9					.byte $a9
>e412	6c 64 61 2e 78			Name0:	.text "lda.x"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=58263					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e417	05					.byte (("lda.x"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>e418	10					.byte WordFlags	;wh_Flags
>e419	03					.byte 3	;wh_CodeLength
>e41a	0d					  .byte LinkDisplacement	; offset to previous nt
=$e41b					XtPtr1 ::= *
=58263					WordListLink ::= Nt0 ; remember the nt of this word for later
.e41b	20 07 e8	jsr $e807		jsr asm_2
=3					CodeLen	.var *-XtPtr1
=$e41e					Here1 = *	; remember here
>e419	03					.byte CodeLen	;patch wh_CodeLength
>e41e	bd					.byte $bd
>e41f	6c 64 61 2e 79			Name0:	.text "lda.y"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=58276					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e424	25					.byte (("lda.y"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>e425	10					.byte WordFlags	;wh_Flags
>e426	03					.byte 3	;wh_CodeLength
>e427	0d					  .byte LinkDisplacement	; offset to previous nt
=$e428					XtPtr1 ::= *
=58276					WordListLink ::= Nt0 ; remember the nt of this word for later
.e428	20 07 e8	jsr $e807		jsr asm_2
=3					CodeLen	.var *-XtPtr1
=$e42b					Here1 = *	; remember here
>e426	03					.byte CodeLen	;patch wh_CodeLength
>e42b	b9					.byte $b9
>e42c	6c 64 61 2e 7a			Name0:	.text "lda.z"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=58289					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e431	45					.byte (("lda.z"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>e432	10					.byte WordFlags	;wh_Flags
>e433	03					.byte 3	;wh_CodeLength
>e434	0d					  .byte LinkDisplacement	; offset to previous nt
=$e435					XtPtr1 ::= *
=58289					WordListLink ::= Nt0 ; remember the nt of this word for later
.e435	20 f5 e7	jsr $e7f5		jsr asm_1
=3					CodeLen	.var *-XtPtr1
=$e438					Here1 = *	; remember here
>e433	03					.byte CodeLen	;patch wh_CodeLength
>e438	a5					.byte $a5
>e439	6c 64 61 2e 7a 69 79		Name0:	.text "lda.ziy"	;  name of word as a string, ending at wh_NameLastChar
=7					NameLength = *-Name0
=58304					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e440	27					.byte (("lda.ziy"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=15					LinkDisplacement = Nt0-WordListLink
>e441	10					.byte WordFlags	;wh_Flags
>e442	03					.byte 3	;wh_CodeLength
>e443	0f					  .byte LinkDisplacement	; offset to previous nt
=$e444					XtPtr1 ::= *
=58304					WordListLink ::= Nt0 ; remember the nt of this word for later
.e444	20 f5 e7	jsr $e7f5		jsr asm_1
=3					CodeLen	.var *-XtPtr1
=$e447					Here1 = *	; remember here
>e442	03					.byte CodeLen	;patch wh_CodeLength
>e447	b1					.byte $b1
>e448	6c 64 61 2e 7a 78		Name0:	.text "lda.zx"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=58318					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e44e	06					.byte (("lda.zx"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=14					LinkDisplacement = Nt0-WordListLink
>e44f	10					.byte WordFlags	;wh_Flags
>e450	03					.byte 3	;wh_CodeLength
>e451	0e					  .byte LinkDisplacement	; offset to previous nt
=$e452					XtPtr1 ::= *
=58318					WordListLink ::= Nt0 ; remember the nt of this word for later
.e452	20 f5 e7	jsr $e7f5		jsr asm_1
=3					CodeLen	.var *-XtPtr1
=$e455					Here1 = *	; remember here
>e450	03					.byte CodeLen	;patch wh_CodeLength
>e455	b5					.byte $b5
>e456	6c 64 61 2e 7a 78 69		Name0:	.text "lda.zxi"	;  name of word as a string, ending at wh_NameLastChar
=7					NameLength = *-Name0
=58333					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e45d	27					.byte (("lda.zxi"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=15					LinkDisplacement = Nt0-WordListLink
>e45e	10					.byte WordFlags	;wh_Flags
>e45f	03					.byte 3	;wh_CodeLength
>e460	0f					  .byte LinkDisplacement	; offset to previous nt
=$e461					XtPtr1 ::= *
=58333					WordListLink ::= Nt0 ; remember the nt of this word for later
.e461	20 f5 e7	jsr $e7f5		jsr asm_1
=3					CodeLen	.var *-XtPtr1
=$e464					Here1 = *	; remember here
>e45f	03					.byte CodeLen	;patch wh_CodeLength
>e464	a1					.byte $a1
>e465	6c 64 78			Name0:	.text "ldx"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=58344					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e468	03					.byte (("ldx"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=11					LinkDisplacement = Nt0-WordListLink
>e469	10					.byte WordFlags	;wh_Flags
>e46a	03					.byte 3	;wh_CodeLength
>e46b	0b					  .byte LinkDisplacement	; offset to previous nt
=$e46c					XtPtr1 ::= *
=58344					WordListLink ::= Nt0 ; remember the nt of this word for later
.e46c	20 07 e8	jsr $e807		jsr asm_2
=3					CodeLen	.var *-XtPtr1
=$e46f					Here1 = *	; remember here
>e46a	03					.byte CodeLen	;patch wh_CodeLength
>e46f	ae					.byte $ae
>e470	6c 64 78 2e 23			Name0:	.text "ldx.#"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=58357					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e475	65					.byte (("ldx.#"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>e476	10					.byte WordFlags	;wh_Flags
>e477	03					.byte 3	;wh_CodeLength
>e478	0d					  .byte LinkDisplacement	; offset to previous nt
=$e479					XtPtr1 ::= *
=58357					WordListLink ::= Nt0 ; remember the nt of this word for later
.e479	20 f5 e7	jsr $e7f5		jsr asm_1
=3					CodeLen	.var *-XtPtr1
=$e47c					Here1 = *	; remember here
>e477	03					.byte CodeLen	;patch wh_CodeLength
>e47c	a2					.byte $a2
>e47d	6c 64 78 2e 79			Name0:	.text "ldx.y"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=58370					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e482	25					.byte (("ldx.y"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>e483	10					.byte WordFlags	;wh_Flags
>e484	03					.byte 3	;wh_CodeLength
>e485	0d					  .byte LinkDisplacement	; offset to previous nt
=$e486					XtPtr1 ::= *
=58370					WordListLink ::= Nt0 ; remember the nt of this word for later
.e486	20 07 e8	jsr $e807		jsr asm_2
=3					CodeLen	.var *-XtPtr1
=$e489					Here1 = *	; remember here
>e484	03					.byte CodeLen	;patch wh_CodeLength
>e489	be					.byte $be
>e48a	6c 64 78 2e 7a			Name0:	.text "ldx.z"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=58383					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e48f	45					.byte (("ldx.z"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>e490	10					.byte WordFlags	;wh_Flags
>e491	03					.byte 3	;wh_CodeLength
>e492	0d					  .byte LinkDisplacement	; offset to previous nt
=$e493					XtPtr1 ::= *
=58383					WordListLink ::= Nt0 ; remember the nt of this word for later
.e493	20 f5 e7	jsr $e7f5		jsr asm_1
=3					CodeLen	.var *-XtPtr1
=$e496					Here1 = *	; remember here
>e491	03					.byte CodeLen	;patch wh_CodeLength
>e496	a6					.byte $a6
>e497	6c 64 78 2e 7a 79		Name0:	.text "ldx.zy"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=58397					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e49d	26					.byte (("ldx.zy"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=14					LinkDisplacement = Nt0-WordListLink
>e49e	10					.byte WordFlags	;wh_Flags
>e49f	03					.byte 3	;wh_CodeLength
>e4a0	0e					  .byte LinkDisplacement	; offset to previous nt
=$e4a1					XtPtr1 ::= *
=58397					WordListLink ::= Nt0 ; remember the nt of this word for later
.e4a1	20 f5 e7	jsr $e7f5		jsr asm_1
=3					CodeLen	.var *-XtPtr1
=$e4a4					Here1 = *	; remember here
>e49f	03					.byte CodeLen	;patch wh_CodeLength
>e4a4	b6					.byte $b6
>e4a5	6c 64 79			Name0:	.text "ldy"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=58408					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e4a8	23					.byte (("ldy"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=11					LinkDisplacement = Nt0-WordListLink
>e4a9	10					.byte WordFlags	;wh_Flags
>e4aa	03					.byte 3	;wh_CodeLength
>e4ab	0b					  .byte LinkDisplacement	; offset to previous nt
=$e4ac					XtPtr1 ::= *
=58408					WordListLink ::= Nt0 ; remember the nt of this word for later
.e4ac	20 07 e8	jsr $e807		jsr asm_2
=3					CodeLen	.var *-XtPtr1
=$e4af					Here1 = *	; remember here
>e4aa	03					.byte CodeLen	;patch wh_CodeLength
>e4af	ac					.byte $ac
>e4b0	6c 64 79 2e 23			Name0:	.text "ldy.#"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=58421					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e4b5	65					.byte (("ldy.#"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>e4b6	10					.byte WordFlags	;wh_Flags
>e4b7	03					.byte 3	;wh_CodeLength
>e4b8	0d					  .byte LinkDisplacement	; offset to previous nt
=$e4b9					XtPtr1 ::= *
=58421					WordListLink ::= Nt0 ; remember the nt of this word for later
.e4b9	20 f5 e7	jsr $e7f5		jsr asm_1
=3					CodeLen	.var *-XtPtr1
=$e4bc					Here1 = *	; remember here
>e4b7	03					.byte CodeLen	;patch wh_CodeLength
>e4bc	a0					.byte $a0
>e4bd	6c 64 79 2e 78			Name0:	.text "ldy.x"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=58434					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e4c2	05					.byte (("ldy.x"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>e4c3	10					.byte WordFlags	;wh_Flags
>e4c4	03					.byte 3	;wh_CodeLength
>e4c5	0d					  .byte LinkDisplacement	; offset to previous nt
=$e4c6					XtPtr1 ::= *
=58434					WordListLink ::= Nt0 ; remember the nt of this word for later
.e4c6	20 07 e8	jsr $e807		jsr asm_2
=3					CodeLen	.var *-XtPtr1
=$e4c9					Here1 = *	; remember here
>e4c4	03					.byte CodeLen	;patch wh_CodeLength
>e4c9	bc					.byte $bc
>e4ca	6c 64 79 2e 7a			Name0:	.text "ldy.z"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=58447					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e4cf	45					.byte (("ldy.z"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>e4d0	10					.byte WordFlags	;wh_Flags
>e4d1	03					.byte 3	;wh_CodeLength
>e4d2	0d					  .byte LinkDisplacement	; offset to previous nt
=$e4d3					XtPtr1 ::= *
=58447					WordListLink ::= Nt0 ; remember the nt of this word for later
.e4d3	20 f5 e7	jsr $e7f5		jsr asm_1
=3					CodeLen	.var *-XtPtr1
=$e4d6					Here1 = *	; remember here
>e4d1	03					.byte CodeLen	;patch wh_CodeLength
>e4d6	a4					.byte $a4
>e4d7	6c 64 79 2e 7a 78		Name0:	.text "ldy.zx"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=58461					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e4dd	06					.byte (("ldy.zx"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=14					LinkDisplacement = Nt0-WordListLink
>e4de	10					.byte WordFlags	;wh_Flags
>e4df	03					.byte 3	;wh_CodeLength
>e4e0	0e					  .byte LinkDisplacement	; offset to previous nt
=$e4e1					XtPtr1 ::= *
=58461					WordListLink ::= Nt0 ; remember the nt of this word for later
.e4e1	20 f5 e7	jsr $e7f5		jsr asm_1
=3					CodeLen	.var *-XtPtr1
=$e4e4					Here1 = *	; remember here
>e4df	03					.byte CodeLen	;patch wh_CodeLength
>e4e4	b4					.byte $b4
>e4e5	6c 73 72			Name0:	.text "lsr"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=58472					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e4e8	43					.byte (("lsr"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=11					LinkDisplacement = Nt0-WordListLink
>e4e9	10					.byte WordFlags	;wh_Flags
>e4ea	03					.byte 3	;wh_CodeLength
>e4eb	0b					  .byte LinkDisplacement	; offset to previous nt
=$e4ec					XtPtr1 ::= *
=58472					WordListLink ::= Nt0 ; remember the nt of this word for later
.e4ec	20 07 e8	jsr $e807		jsr asm_2
=3					CodeLen	.var *-XtPtr1
=$e4ef					Here1 = *	; remember here
>e4ea	03					.byte CodeLen	;patch wh_CodeLength
>e4ef	4e					.byte $4e
>e4f0	6c 73 72 2e 61			Name0:	.text "lsr.a"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=58485					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e4f5	25					.byte (("lsr.a"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>e4f6	10					.byte WordFlags	;wh_Flags
>e4f7	03					.byte 3	;wh_CodeLength
>e4f8	0d					  .byte LinkDisplacement	; offset to previous nt
=$e4f9					XtPtr1 ::= *
=58485					WordListLink ::= Nt0 ; remember the nt of this word for later
.e4f9	20 10 e8	jsr $e810		jsr asm_0
=3					CodeLen	.var *-XtPtr1
=$e4fc					Here1 = *	; remember here
>e4f7	03					.byte CodeLen	;patch wh_CodeLength
>e4fc	4a					.byte $4a
>e4fd	6c 73 72 2e 78			Name0:	.text "lsr.x"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=58498					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e502	05					.byte (("lsr.x"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>e503	10					.byte WordFlags	;wh_Flags
>e504	03					.byte 3	;wh_CodeLength
>e505	0d					  .byte LinkDisplacement	; offset to previous nt
=$e506					XtPtr1 ::= *
=58498					WordListLink ::= Nt0 ; remember the nt of this word for later
.e506	20 07 e8	jsr $e807		jsr asm_2
=3					CodeLen	.var *-XtPtr1
=$e509					Here1 = *	; remember here
>e504	03					.byte CodeLen	;patch wh_CodeLength
>e509	5e					.byte $5e
>e50a	6c 73 72 2e 7a			Name0:	.text "lsr.z"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=58511					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e50f	45					.byte (("lsr.z"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>e510	10					.byte WordFlags	;wh_Flags
>e511	03					.byte 3	;wh_CodeLength
>e512	0d					  .byte LinkDisplacement	; offset to previous nt
=$e513					XtPtr1 ::= *
=58511					WordListLink ::= Nt0 ; remember the nt of this word for later
.e513	20 f5 e7	jsr $e7f5		jsr asm_1
=3					CodeLen	.var *-XtPtr1
=$e516					Here1 = *	; remember here
>e511	03					.byte CodeLen	;patch wh_CodeLength
>e516	46					.byte $46
>e517	6c 73 72 2e 7a 78		Name0:	.text "lsr.zx"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=58525					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e51d	06					.byte (("lsr.zx"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=14					LinkDisplacement = Nt0-WordListLink
>e51e	10					.byte WordFlags	;wh_Flags
>e51f	03					.byte 3	;wh_CodeLength
>e520	0e					  .byte LinkDisplacement	; offset to previous nt
=$e521					XtPtr1 ::= *
=58525					WordListLink ::= Nt0 ; remember the nt of this word for later
.e521	20 f5 e7	jsr $e7f5		jsr asm_1
=3					CodeLen	.var *-XtPtr1
=$e524					Here1 = *	; remember here
>e51f	03					.byte CodeLen	;patch wh_CodeLength
>e524	56					.byte $56
>e525	6e 6f 70			Name0:	.text "nop"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=58536					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e528	03					.byte (("nop"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=11					LinkDisplacement = Nt0-WordListLink
>e529	10					.byte WordFlags	;wh_Flags
>e52a	03					.byte 3	;wh_CodeLength
>e52b	0b					  .byte LinkDisplacement	; offset to previous nt
=$e52c					XtPtr1 ::= *
=58536					WordListLink ::= Nt0 ; remember the nt of this word for later
.e52c	20 10 e8	jsr $e810		jsr asm_0
=3					CodeLen	.var *-XtPtr1
=$e52f					Here1 = *	; remember here
>e52a	03					.byte CodeLen	;patch wh_CodeLength
>e52f	ea					.byte $ea
>e530	6f 72 61			Name0:	.text "ora"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=58547					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e533	23					.byte (("ora"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=11					LinkDisplacement = Nt0-WordListLink
>e534	10					.byte WordFlags	;wh_Flags
>e535	03					.byte 3	;wh_CodeLength
>e536	0b					  .byte LinkDisplacement	; offset to previous nt
=$e537					XtPtr1 ::= *
=58547					WordListLink ::= Nt0 ; remember the nt of this word for later
.e537	20 07 e8	jsr $e807		jsr asm_2
=3					CodeLen	.var *-XtPtr1
=$e53a					Here1 = *	; remember here
>e535	03					.byte CodeLen	;patch wh_CodeLength
>e53a	0d					.byte $0d
>e53b	6f 72 61 2e 23			Name0:	.text "ora.#"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=58560					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e540	65					.byte (("ora.#"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>e541	10					.byte WordFlags	;wh_Flags
>e542	03					.byte 3	;wh_CodeLength
>e543	0d					  .byte LinkDisplacement	; offset to previous nt
=$e544					XtPtr1 ::= *
=58560					WordListLink ::= Nt0 ; remember the nt of this word for later
.e544	20 f5 e7	jsr $e7f5		jsr asm_1
=3					CodeLen	.var *-XtPtr1
=$e547					Here1 = *	; remember here
>e542	03					.byte CodeLen	;patch wh_CodeLength
>e547	09					.byte $09
>e548	6f 72 61 2e 78			Name0:	.text "ora.x"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=58573					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e54d	05					.byte (("ora.x"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>e54e	10					.byte WordFlags	;wh_Flags
>e54f	03					.byte 3	;wh_CodeLength
>e550	0d					  .byte LinkDisplacement	; offset to previous nt
=$e551					XtPtr1 ::= *
=58573					WordListLink ::= Nt0 ; remember the nt of this word for later
.e551	20 07 e8	jsr $e807		jsr asm_2
=3					CodeLen	.var *-XtPtr1
=$e554					Here1 = *	; remember here
>e54f	03					.byte CodeLen	;patch wh_CodeLength
>e554	1d					.byte $1d
>e555	6f 72 61 2e 79			Name0:	.text "ora.y"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=58586					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e55a	25					.byte (("ora.y"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>e55b	10					.byte WordFlags	;wh_Flags
>e55c	03					.byte 3	;wh_CodeLength
>e55d	0d					  .byte LinkDisplacement	; offset to previous nt
=$e55e					XtPtr1 ::= *
=58586					WordListLink ::= Nt0 ; remember the nt of this word for later
.e55e	20 07 e8	jsr $e807		jsr asm_2
=3					CodeLen	.var *-XtPtr1
=$e561					Here1 = *	; remember here
>e55c	03					.byte CodeLen	;patch wh_CodeLength
>e561	19					.byte $19
>e562	6f 72 61 2e 7a			Name0:	.text "ora.z"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=58599					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e567	45					.byte (("ora.z"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>e568	10					.byte WordFlags	;wh_Flags
>e569	03					.byte 3	;wh_CodeLength
>e56a	0d					  .byte LinkDisplacement	; offset to previous nt
=$e56b					XtPtr1 ::= *
=58599					WordListLink ::= Nt0 ; remember the nt of this word for later
.e56b	20 f5 e7	jsr $e7f5		jsr asm_1
=3					CodeLen	.var *-XtPtr1
=$e56e					Here1 = *	; remember here
>e569	03					.byte CodeLen	;patch wh_CodeLength
>e56e	05					.byte $05
>e56f	6f 72 61 2e 7a 69 79		Name0:	.text "ora.ziy"	;  name of word as a string, ending at wh_NameLastChar
=7					NameLength = *-Name0
=58614					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e576	27					.byte (("ora.ziy"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=15					LinkDisplacement = Nt0-WordListLink
>e577	10					.byte WordFlags	;wh_Flags
>e578	03					.byte 3	;wh_CodeLength
>e579	0f					  .byte LinkDisplacement	; offset to previous nt
=$e57a					XtPtr1 ::= *
=58614					WordListLink ::= Nt0 ; remember the nt of this word for later
.e57a	20 f5 e7	jsr $e7f5		jsr asm_1
=3					CodeLen	.var *-XtPtr1
=$e57d					Here1 = *	; remember here
>e578	03					.byte CodeLen	;patch wh_CodeLength
>e57d	11					.byte $11
>e57e	6f 72 61 2e 7a 78		Name0:	.text "ora.zx"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=58628					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e584	06					.byte (("ora.zx"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=14					LinkDisplacement = Nt0-WordListLink
>e585	10					.byte WordFlags	;wh_Flags
>e586	03					.byte 3	;wh_CodeLength
>e587	0e					  .byte LinkDisplacement	; offset to previous nt
=$e588					XtPtr1 ::= *
=58628					WordListLink ::= Nt0 ; remember the nt of this word for later
.e588	20 f5 e7	jsr $e7f5		jsr asm_1
=3					CodeLen	.var *-XtPtr1
=$e58b					Here1 = *	; remember here
>e586	03					.byte CodeLen	;patch wh_CodeLength
>e58b	15					.byte $15
>e58c	6f 72 61 2e 7a 78 69		Name0:	.text "ora.zxi"	;  name of word as a string, ending at wh_NameLastChar
=7					NameLength = *-Name0
=58643					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e593	27					.byte (("ora.zxi"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=15					LinkDisplacement = Nt0-WordListLink
>e594	10					.byte WordFlags	;wh_Flags
>e595	03					.byte 3	;wh_CodeLength
>e596	0f					  .byte LinkDisplacement	; offset to previous nt
=$e597					XtPtr1 ::= *
=58643					WordListLink ::= Nt0 ; remember the nt of this word for later
.e597	20 f5 e7	jsr $e7f5		jsr asm_1
=3					CodeLen	.var *-XtPtr1
=$e59a					Here1 = *	; remember here
>e595	03					.byte CodeLen	;patch wh_CodeLength
>e59a	01					.byte $01
>e59b	70 68 61			Name0:	.text "pha"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=58654					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e59e	23					.byte (("pha"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=11					LinkDisplacement = Nt0-WordListLink
>e59f	10					.byte WordFlags	;wh_Flags
>e5a0	03					.byte 3	;wh_CodeLength
>e5a1	0b					  .byte LinkDisplacement	; offset to previous nt
=$e5a2					XtPtr1 ::= *
=58654					WordListLink ::= Nt0 ; remember the nt of this word for later
.e5a2	20 10 e8	jsr $e810		jsr asm_0
=3					CodeLen	.var *-XtPtr1
=$e5a5					Here1 = *	; remember here
>e5a0	03					.byte CodeLen	;patch wh_CodeLength
>e5a5	48					.byte $48
>e5a6	70 68 70			Name0:	.text "php"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=58665					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e5a9	03					.byte (("php"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=11					LinkDisplacement = Nt0-WordListLink
>e5aa	10					.byte WordFlags	;wh_Flags
>e5ab	03					.byte 3	;wh_CodeLength
>e5ac	0b					  .byte LinkDisplacement	; offset to previous nt
=$e5ad					XtPtr1 ::= *
=58665					WordListLink ::= Nt0 ; remember the nt of this word for later
.e5ad	20 10 e8	jsr $e810		jsr asm_0
=3					CodeLen	.var *-XtPtr1
=$e5b0					Here1 = *	; remember here
>e5ab	03					.byte CodeLen	;patch wh_CodeLength
>e5b0	08					.byte $08
>e5b1	70 6c 61			Name0:	.text "pla"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=58676					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e5b4	23					.byte (("pla"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=11					LinkDisplacement = Nt0-WordListLink
>e5b5	10					.byte WordFlags	;wh_Flags
>e5b6	03					.byte 3	;wh_CodeLength
>e5b7	0b					  .byte LinkDisplacement	; offset to previous nt
=$e5b8					XtPtr1 ::= *
=58676					WordListLink ::= Nt0 ; remember the nt of this word for later
.e5b8	20 10 e8	jsr $e810		jsr asm_0
=3					CodeLen	.var *-XtPtr1
=$e5bb					Here1 = *	; remember here
>e5b6	03					.byte CodeLen	;patch wh_CodeLength
>e5bb	68					.byte $68
>e5bc	70 6c 70			Name0:	.text "plp"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=58687					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e5bf	03					.byte (("plp"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=11					LinkDisplacement = Nt0-WordListLink
>e5c0	10					.byte WordFlags	;wh_Flags
>e5c1	03					.byte 3	;wh_CodeLength
>e5c2	0b					  .byte LinkDisplacement	; offset to previous nt
=$e5c3					XtPtr1 ::= *
=58687					WordListLink ::= Nt0 ; remember the nt of this word for later
.e5c3	20 10 e8	jsr $e810		jsr asm_0
=3					CodeLen	.var *-XtPtr1
=$e5c6					Here1 = *	; remember here
>e5c1	03					.byte CodeLen	;patch wh_CodeLength
>e5c6	28					.byte $28
>e5c7	72 6f 6c			Name0:	.text "rol"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=58698					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e5ca	83					.byte (("rol"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=11					LinkDisplacement = Nt0-WordListLink
>e5cb	10					.byte WordFlags	;wh_Flags
>e5cc	03					.byte 3	;wh_CodeLength
>e5cd	0b					  .byte LinkDisplacement	; offset to previous nt
=$e5ce					XtPtr1 ::= *
=58698					WordListLink ::= Nt0 ; remember the nt of this word for later
.e5ce	20 07 e8	jsr $e807		jsr asm_2
=3					CodeLen	.var *-XtPtr1
=$e5d1					Here1 = *	; remember here
>e5cc	03					.byte CodeLen	;patch wh_CodeLength
>e5d1	2e					.byte $2e
>e5d2	72 6f 6c 2e 61			Name0:	.text "rol.a"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=58711					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e5d7	25					.byte (("rol.a"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>e5d8	10					.byte WordFlags	;wh_Flags
>e5d9	03					.byte 3	;wh_CodeLength
>e5da	0d					  .byte LinkDisplacement	; offset to previous nt
=$e5db					XtPtr1 ::= *
=58711					WordListLink ::= Nt0 ; remember the nt of this word for later
.e5db	20 10 e8	jsr $e810		jsr asm_0
=3					CodeLen	.var *-XtPtr1
=$e5de					Here1 = *	; remember here
>e5d9	03					.byte CodeLen	;patch wh_CodeLength
>e5de	2a					.byte $2a
>e5df	72 6f 6c 2e 78			Name0:	.text "rol.x"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=58724					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e5e4	05					.byte (("rol.x"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>e5e5	10					.byte WordFlags	;wh_Flags
>e5e6	03					.byte 3	;wh_CodeLength
>e5e7	0d					  .byte LinkDisplacement	; offset to previous nt
=$e5e8					XtPtr1 ::= *
=58724					WordListLink ::= Nt0 ; remember the nt of this word for later
.e5e8	20 07 e8	jsr $e807		jsr asm_2
=3					CodeLen	.var *-XtPtr1
=$e5eb					Here1 = *	; remember here
>e5e6	03					.byte CodeLen	;patch wh_CodeLength
>e5eb	3e					.byte $3e
>e5ec	72 6f 6c 2e 7a			Name0:	.text "rol.z"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=58737					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e5f1	45					.byte (("rol.z"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>e5f2	10					.byte WordFlags	;wh_Flags
>e5f3	03					.byte 3	;wh_CodeLength
>e5f4	0d					  .byte LinkDisplacement	; offset to previous nt
=$e5f5					XtPtr1 ::= *
=58737					WordListLink ::= Nt0 ; remember the nt of this word for later
.e5f5	20 f5 e7	jsr $e7f5		jsr asm_1
=3					CodeLen	.var *-XtPtr1
=$e5f8					Here1 = *	; remember here
>e5f3	03					.byte CodeLen	;patch wh_CodeLength
>e5f8	26					.byte $26
>e5f9	72 6f 6c 2e 7a 78		Name0:	.text "rol.zx"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=58751					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e5ff	06					.byte (("rol.zx"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=14					LinkDisplacement = Nt0-WordListLink
>e600	10					.byte WordFlags	;wh_Flags
>e601	03					.byte 3	;wh_CodeLength
>e602	0e					  .byte LinkDisplacement	; offset to previous nt
=$e603					XtPtr1 ::= *
=58751					WordListLink ::= Nt0 ; remember the nt of this word for later
.e603	20 f5 e7	jsr $e7f5		jsr asm_1
=3					CodeLen	.var *-XtPtr1
=$e606					Here1 = *	; remember here
>e601	03					.byte CodeLen	;patch wh_CodeLength
>e606	36					.byte $36
>e607	72 6f 72			Name0:	.text "ror"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=58762					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e60a	43					.byte (("ror"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=11					LinkDisplacement = Nt0-WordListLink
>e60b	10					.byte WordFlags	;wh_Flags
>e60c	03					.byte 3	;wh_CodeLength
>e60d	0b					  .byte LinkDisplacement	; offset to previous nt
=$e60e					XtPtr1 ::= *
=58762					WordListLink ::= Nt0 ; remember the nt of this word for later
.e60e	20 07 e8	jsr $e807		jsr asm_2
=3					CodeLen	.var *-XtPtr1
=$e611					Here1 = *	; remember here
>e60c	03					.byte CodeLen	;patch wh_CodeLength
>e611	6e					.byte $6e
>e612	72 6f 72 2e 61			Name0:	.text "ror.a"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=58775					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e617	25					.byte (("ror.a"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>e618	10					.byte WordFlags	;wh_Flags
>e619	03					.byte 3	;wh_CodeLength
>e61a	0d					  .byte LinkDisplacement	; offset to previous nt
=$e61b					XtPtr1 ::= *
=58775					WordListLink ::= Nt0 ; remember the nt of this word for later
.e61b	20 10 e8	jsr $e810		jsr asm_0
=3					CodeLen	.var *-XtPtr1
=$e61e					Here1 = *	; remember here
>e619	03					.byte CodeLen	;patch wh_CodeLength
>e61e	6a					.byte $6a
>e61f	72 6f 72 2e 78			Name0:	.text "ror.x"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=58788					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e624	05					.byte (("ror.x"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>e625	10					.byte WordFlags	;wh_Flags
>e626	03					.byte 3	;wh_CodeLength
>e627	0d					  .byte LinkDisplacement	; offset to previous nt
=$e628					XtPtr1 ::= *
=58788					WordListLink ::= Nt0 ; remember the nt of this word for later
.e628	20 07 e8	jsr $e807		jsr asm_2
=3					CodeLen	.var *-XtPtr1
=$e62b					Here1 = *	; remember here
>e626	03					.byte CodeLen	;patch wh_CodeLength
>e62b	7e					.byte $7e
>e62c	72 6f 72 2e 7a			Name0:	.text "ror.z"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=58801					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e631	45					.byte (("ror.z"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>e632	10					.byte WordFlags	;wh_Flags
>e633	03					.byte 3	;wh_CodeLength
>e634	0d					  .byte LinkDisplacement	; offset to previous nt
=$e635					XtPtr1 ::= *
=58801					WordListLink ::= Nt0 ; remember the nt of this word for later
.e635	20 f5 e7	jsr $e7f5		jsr asm_1
=3					CodeLen	.var *-XtPtr1
=$e638					Here1 = *	; remember here
>e633	03					.byte CodeLen	;patch wh_CodeLength
>e638	66					.byte $66
>e639	72 6f 72 2e 7a 78		Name0:	.text "ror.zx"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=58815					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e63f	06					.byte (("ror.zx"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=14					LinkDisplacement = Nt0-WordListLink
>e640	10					.byte WordFlags	;wh_Flags
>e641	03					.byte 3	;wh_CodeLength
>e642	0e					  .byte LinkDisplacement	; offset to previous nt
=$e643					XtPtr1 ::= *
=58815					WordListLink ::= Nt0 ; remember the nt of this word for later
.e643	20 f5 e7	jsr $e7f5		jsr asm_1
=3					CodeLen	.var *-XtPtr1
=$e646					Here1 = *	; remember here
>e641	03					.byte CodeLen	;patch wh_CodeLength
>e646	76					.byte $76
>e647	72 74 69			Name0:	.text "rti"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=58826					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e64a	23					.byte (("rti"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=11					LinkDisplacement = Nt0-WordListLink
>e64b	10					.byte WordFlags	;wh_Flags
>e64c	03					.byte 3	;wh_CodeLength
>e64d	0b					  .byte LinkDisplacement	; offset to previous nt
=$e64e					XtPtr1 ::= *
=58826					WordListLink ::= Nt0 ; remember the nt of this word for later
.e64e	20 10 e8	jsr $e810		jsr asm_0
=3					CodeLen	.var *-XtPtr1
=$e651					Here1 = *	; remember here
>e64c	03					.byte CodeLen	;patch wh_CodeLength
>e651	40					.byte $40
>e652	72 74 73			Name0:	.text "rts"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=58837					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e655	63					.byte (("rts"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=11					LinkDisplacement = Nt0-WordListLink
>e656	10					.byte WordFlags	;wh_Flags
>e657	03					.byte 3	;wh_CodeLength
>e658	0b					  .byte LinkDisplacement	; offset to previous nt
=$e659					XtPtr1 ::= *
=58837					WordListLink ::= Nt0 ; remember the nt of this word for later
.e659	20 10 e8	jsr $e810		jsr asm_0
=3					CodeLen	.var *-XtPtr1
=$e65c					Here1 = *	; remember here
>e657	03					.byte CodeLen	;patch wh_CodeLength
>e65c	60					.byte $60
>e65d	73 62 63			Name0:	.text "sbc"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=58848					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e660	63					.byte (("sbc"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=11					LinkDisplacement = Nt0-WordListLink
>e661	10					.byte WordFlags	;wh_Flags
>e662	03					.byte 3	;wh_CodeLength
>e663	0b					  .byte LinkDisplacement	; offset to previous nt
=$e664					XtPtr1 ::= *
=58848					WordListLink ::= Nt0 ; remember the nt of this word for later
.e664	20 07 e8	jsr $e807		jsr asm_2
=3					CodeLen	.var *-XtPtr1
=$e667					Here1 = *	; remember here
>e662	03					.byte CodeLen	;patch wh_CodeLength
>e667	ed					.byte $ed
>e668	73 62 63 2e 23			Name0:	.text "sbc.#"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=58861					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e66d	65					.byte (("sbc.#"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>e66e	10					.byte WordFlags	;wh_Flags
>e66f	03					.byte 3	;wh_CodeLength
>e670	0d					  .byte LinkDisplacement	; offset to previous nt
=$e671					XtPtr1 ::= *
=58861					WordListLink ::= Nt0 ; remember the nt of this word for later
.e671	20 f5 e7	jsr $e7f5		jsr asm_1
=3					CodeLen	.var *-XtPtr1
=$e674					Here1 = *	; remember here
>e66f	03					.byte CodeLen	;patch wh_CodeLength
>e674	e9					.byte $e9
>e675	73 62 63 2e 78			Name0:	.text "sbc.x"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=58874					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e67a	05					.byte (("sbc.x"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>e67b	10					.byte WordFlags	;wh_Flags
>e67c	03					.byte 3	;wh_CodeLength
>e67d	0d					  .byte LinkDisplacement	; offset to previous nt
=$e67e					XtPtr1 ::= *
=58874					WordListLink ::= Nt0 ; remember the nt of this word for later
.e67e	20 07 e8	jsr $e807		jsr asm_2
=3					CodeLen	.var *-XtPtr1
=$e681					Here1 = *	; remember here
>e67c	03					.byte CodeLen	;patch wh_CodeLength
>e681	fd					.byte $fd
>e682	73 62 63 2e 79			Name0:	.text "sbc.y"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=58887					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e687	25					.byte (("sbc.y"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>e688	10					.byte WordFlags	;wh_Flags
>e689	03					.byte 3	;wh_CodeLength
>e68a	0d					  .byte LinkDisplacement	; offset to previous nt
=$e68b					XtPtr1 ::= *
=58887					WordListLink ::= Nt0 ; remember the nt of this word for later
.e68b	20 07 e8	jsr $e807		jsr asm_2
=3					CodeLen	.var *-XtPtr1
=$e68e					Here1 = *	; remember here
>e689	03					.byte CodeLen	;patch wh_CodeLength
>e68e	f9					.byte $f9
>e68f	73 62 63 2e 7a			Name0:	.text "sbc.z"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=58900					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e694	45					.byte (("sbc.z"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>e695	10					.byte WordFlags	;wh_Flags
>e696	03					.byte 3	;wh_CodeLength
>e697	0d					  .byte LinkDisplacement	; offset to previous nt
=$e698					XtPtr1 ::= *
=58900					WordListLink ::= Nt0 ; remember the nt of this word for later
.e698	20 f5 e7	jsr $e7f5		jsr asm_1
=3					CodeLen	.var *-XtPtr1
=$e69b					Here1 = *	; remember here
>e696	03					.byte CodeLen	;patch wh_CodeLength
>e69b	e5					.byte $e5
>e69c	73 62 63 2e 7a 69 79		Name0:	.text "sbc.ziy"	;  name of word as a string, ending at wh_NameLastChar
=7					NameLength = *-Name0
=58915					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e6a3	27					.byte (("sbc.ziy"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=15					LinkDisplacement = Nt0-WordListLink
>e6a4	10					.byte WordFlags	;wh_Flags
>e6a5	03					.byte 3	;wh_CodeLength
>e6a6	0f					  .byte LinkDisplacement	; offset to previous nt
=$e6a7					XtPtr1 ::= *
=58915					WordListLink ::= Nt0 ; remember the nt of this word for later
.e6a7	20 f5 e7	jsr $e7f5		jsr asm_1
=3					CodeLen	.var *-XtPtr1
=$e6aa					Here1 = *	; remember here
>e6a5	03					.byte CodeLen	;patch wh_CodeLength
>e6aa	f1					.byte $f1
>e6ab	73 62 63 2e 7a 78		Name0:	.text "sbc.zx"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=58929					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e6b1	06					.byte (("sbc.zx"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=14					LinkDisplacement = Nt0-WordListLink
>e6b2	10					.byte WordFlags	;wh_Flags
>e6b3	03					.byte 3	;wh_CodeLength
>e6b4	0e					  .byte LinkDisplacement	; offset to previous nt
=$e6b5					XtPtr1 ::= *
=58929					WordListLink ::= Nt0 ; remember the nt of this word for later
.e6b5	20 f5 e7	jsr $e7f5		jsr asm_1
=3					CodeLen	.var *-XtPtr1
=$e6b8					Here1 = *	; remember here
>e6b3	03					.byte CodeLen	;patch wh_CodeLength
>e6b8	f5					.byte $f5
>e6b9	73 62 63 2e 7a 78 69		Name0:	.text "sbc.zxi"	;  name of word as a string, ending at wh_NameLastChar
=7					NameLength = *-Name0
=58944					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e6c0	27					.byte (("sbc.zxi"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=15					LinkDisplacement = Nt0-WordListLink
>e6c1	10					.byte WordFlags	;wh_Flags
>e6c2	03					.byte 3	;wh_CodeLength
>e6c3	0f					  .byte LinkDisplacement	; offset to previous nt
=$e6c4					XtPtr1 ::= *
=58944					WordListLink ::= Nt0 ; remember the nt of this word for later
.e6c4	20 f5 e7	jsr $e7f5		jsr asm_1
=3					CodeLen	.var *-XtPtr1
=$e6c7					Here1 = *	; remember here
>e6c2	03					.byte CodeLen	;patch wh_CodeLength
>e6c7	e1					.byte $e1
>e6c8	73 65 63			Name0:	.text "sec"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=58955					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e6cb	63					.byte (("sec"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=11					LinkDisplacement = Nt0-WordListLink
>e6cc	10					.byte WordFlags	;wh_Flags
>e6cd	03					.byte 3	;wh_CodeLength
>e6ce	0b					  .byte LinkDisplacement	; offset to previous nt
=$e6cf					XtPtr1 ::= *
=58955					WordListLink ::= Nt0 ; remember the nt of this word for later
.e6cf	20 10 e8	jsr $e810		jsr asm_0
=3					CodeLen	.var *-XtPtr1
=$e6d2					Here1 = *	; remember here
>e6cd	03					.byte CodeLen	;patch wh_CodeLength
>e6d2	38					.byte $38
>e6d3	73 65 64			Name0:	.text "sed"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=58966					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e6d6	83					.byte (("sed"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=11					LinkDisplacement = Nt0-WordListLink
>e6d7	10					.byte WordFlags	;wh_Flags
>e6d8	03					.byte 3	;wh_CodeLength
>e6d9	0b					  .byte LinkDisplacement	; offset to previous nt
=$e6da					XtPtr1 ::= *
=58966					WordListLink ::= Nt0 ; remember the nt of this word for later
.e6da	20 10 e8	jsr $e810		jsr asm_0
=3					CodeLen	.var *-XtPtr1
=$e6dd					Here1 = *	; remember here
>e6d8	03					.byte CodeLen	;patch wh_CodeLength
>e6dd	f8					.byte $f8
>e6de	73 65 69			Name0:	.text "sei"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=58977					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e6e1	23					.byte (("sei"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=11					LinkDisplacement = Nt0-WordListLink
>e6e2	10					.byte WordFlags	;wh_Flags
>e6e3	03					.byte 3	;wh_CodeLength
>e6e4	0b					  .byte LinkDisplacement	; offset to previous nt
=$e6e5					XtPtr1 ::= *
=58977					WordListLink ::= Nt0 ; remember the nt of this word for later
.e6e5	20 10 e8	jsr $e810		jsr asm_0
=3					CodeLen	.var *-XtPtr1
=$e6e8					Here1 = *	; remember here
>e6e3	03					.byte CodeLen	;patch wh_CodeLength
>e6e8	78					.byte $78
>e6e9	73 74 61			Name0:	.text "sta"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=58988					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e6ec	23					.byte (("sta"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=11					LinkDisplacement = Nt0-WordListLink
>e6ed	10					.byte WordFlags	;wh_Flags
>e6ee	03					.byte 3	;wh_CodeLength
>e6ef	0b					  .byte LinkDisplacement	; offset to previous nt
=$e6f0					XtPtr1 ::= *
=58988					WordListLink ::= Nt0 ; remember the nt of this word for later
.e6f0	20 07 e8	jsr $e807		jsr asm_2
=3					CodeLen	.var *-XtPtr1
=$e6f3					Here1 = *	; remember here
>e6ee	03					.byte CodeLen	;patch wh_CodeLength
>e6f3	8d					.byte $8d
>e6f4	73 74 61 2e 78			Name0:	.text "sta.x"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=59001					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e6f9	05					.byte (("sta.x"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>e6fa	10					.byte WordFlags	;wh_Flags
>e6fb	03					.byte 3	;wh_CodeLength
>e6fc	0d					  .byte LinkDisplacement	; offset to previous nt
=$e6fd					XtPtr1 ::= *
=59001					WordListLink ::= Nt0 ; remember the nt of this word for later
.e6fd	20 07 e8	jsr $e807		jsr asm_2
=3					CodeLen	.var *-XtPtr1
=$e700					Here1 = *	; remember here
>e6fb	03					.byte CodeLen	;patch wh_CodeLength
>e700	9d					.byte $9d
>e701	73 74 61 2e 79			Name0:	.text "sta.y"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=59014					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e706	25					.byte (("sta.y"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>e707	10					.byte WordFlags	;wh_Flags
>e708	03					.byte 3	;wh_CodeLength
>e709	0d					  .byte LinkDisplacement	; offset to previous nt
=$e70a					XtPtr1 ::= *
=59014					WordListLink ::= Nt0 ; remember the nt of this word for later
.e70a	20 07 e8	jsr $e807		jsr asm_2
=3					CodeLen	.var *-XtPtr1
=$e70d					Here1 = *	; remember here
>e708	03					.byte CodeLen	;patch wh_CodeLength
>e70d	99					.byte $99
>e70e	73 74 61 2e 7a			Name0:	.text "sta.z"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=59027					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e713	45					.byte (("sta.z"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>e714	10					.byte WordFlags	;wh_Flags
>e715	03					.byte 3	;wh_CodeLength
>e716	0d					  .byte LinkDisplacement	; offset to previous nt
=$e717					XtPtr1 ::= *
=59027					WordListLink ::= Nt0 ; remember the nt of this word for later
.e717	20 f5 e7	jsr $e7f5		jsr asm_1
=3					CodeLen	.var *-XtPtr1
=$e71a					Here1 = *	; remember here
>e715	03					.byte CodeLen	;patch wh_CodeLength
>e71a	85					.byte $85
>e71b	73 74 61 2e 7a 69 79		Name0:	.text "sta.ziy"	;  name of word as a string, ending at wh_NameLastChar
=7					NameLength = *-Name0
=59042					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e722	27					.byte (("sta.ziy"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=15					LinkDisplacement = Nt0-WordListLink
>e723	10					.byte WordFlags	;wh_Flags
>e724	03					.byte 3	;wh_CodeLength
>e725	0f					  .byte LinkDisplacement	; offset to previous nt
=$e726					XtPtr1 ::= *
=59042					WordListLink ::= Nt0 ; remember the nt of this word for later
.e726	20 f5 e7	jsr $e7f5		jsr asm_1
=3					CodeLen	.var *-XtPtr1
=$e729					Here1 = *	; remember here
>e724	03					.byte CodeLen	;patch wh_CodeLength
>e729	91					.byte $91
>e72a	73 74 61 2e 7a 78		Name0:	.text "sta.zx"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=59056					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e730	06					.byte (("sta.zx"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=14					LinkDisplacement = Nt0-WordListLink
>e731	10					.byte WordFlags	;wh_Flags
>e732	03					.byte 3	;wh_CodeLength
>e733	0e					  .byte LinkDisplacement	; offset to previous nt
=$e734					XtPtr1 ::= *
=59056					WordListLink ::= Nt0 ; remember the nt of this word for later
.e734	20 f5 e7	jsr $e7f5		jsr asm_1
=3					CodeLen	.var *-XtPtr1
=$e737					Here1 = *	; remember here
>e732	03					.byte CodeLen	;patch wh_CodeLength
>e737	95					.byte $95
>e738	73 74 61 2e 7a 78 69		Name0:	.text "sta.zxi"	;  name of word as a string, ending at wh_NameLastChar
=7					NameLength = *-Name0
=59071					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e73f	27					.byte (("sta.zxi"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=15					LinkDisplacement = Nt0-WordListLink
>e740	10					.byte WordFlags	;wh_Flags
>e741	03					.byte 3	;wh_CodeLength
>e742	0f					  .byte LinkDisplacement	; offset to previous nt
=$e743					XtPtr1 ::= *
=59071					WordListLink ::= Nt0 ; remember the nt of this word for later
.e743	20 f5 e7	jsr $e7f5		jsr asm_1
=3					CodeLen	.var *-XtPtr1
=$e746					Here1 = *	; remember here
>e741	03					.byte CodeLen	;patch wh_CodeLength
>e746	81					.byte $81
>e747	73 74 78			Name0:	.text "stx"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=59082					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e74a	03					.byte (("stx"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=11					LinkDisplacement = Nt0-WordListLink
>e74b	10					.byte WordFlags	;wh_Flags
>e74c	03					.byte 3	;wh_CodeLength
>e74d	0b					  .byte LinkDisplacement	; offset to previous nt
=$e74e					XtPtr1 ::= *
=59082					WordListLink ::= Nt0 ; remember the nt of this word for later
.e74e	20 07 e8	jsr $e807		jsr asm_2
=3					CodeLen	.var *-XtPtr1
=$e751					Here1 = *	; remember here
>e74c	03					.byte CodeLen	;patch wh_CodeLength
>e751	8e					.byte $8e
>e752	73 74 78 2e 7a			Name0:	.text "stx.z"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=59095					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e757	45					.byte (("stx.z"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>e758	10					.byte WordFlags	;wh_Flags
>e759	03					.byte 3	;wh_CodeLength
>e75a	0d					  .byte LinkDisplacement	; offset to previous nt
=$e75b					XtPtr1 ::= *
=59095					WordListLink ::= Nt0 ; remember the nt of this word for later
.e75b	20 f5 e7	jsr $e7f5		jsr asm_1
=3					CodeLen	.var *-XtPtr1
=$e75e					Here1 = *	; remember here
>e759	03					.byte CodeLen	;patch wh_CodeLength
>e75e	86					.byte $86
>e75f	73 74 78 2e 7a 79		Name0:	.text "stx.zy"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=59109					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e765	26					.byte (("stx.zy"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=14					LinkDisplacement = Nt0-WordListLink
>e766	10					.byte WordFlags	;wh_Flags
>e767	03					.byte 3	;wh_CodeLength
>e768	0e					  .byte LinkDisplacement	; offset to previous nt
=$e769					XtPtr1 ::= *
=59109					WordListLink ::= Nt0 ; remember the nt of this word for later
.e769	20 f5 e7	jsr $e7f5		jsr asm_1
=3					CodeLen	.var *-XtPtr1
=$e76c					Here1 = *	; remember here
>e767	03					.byte CodeLen	;patch wh_CodeLength
>e76c	96					.byte $96
>e76d	73 74 79			Name0:	.text "sty"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=59120					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e770	23					.byte (("sty"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=11					LinkDisplacement = Nt0-WordListLink
>e771	10					.byte WordFlags	;wh_Flags
>e772	03					.byte 3	;wh_CodeLength
>e773	0b					  .byte LinkDisplacement	; offset to previous nt
=$e774					XtPtr1 ::= *
=59120					WordListLink ::= Nt0 ; remember the nt of this word for later
.e774	20 07 e8	jsr $e807		jsr asm_2
=3					CodeLen	.var *-XtPtr1
=$e777					Here1 = *	; remember here
>e772	03					.byte CodeLen	;patch wh_CodeLength
>e777	8c					.byte $8c
>e778	73 74 79 2e 7a			Name0:	.text "sty.z"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=59133					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e77d	45					.byte (("sty.z"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>e77e	10					.byte WordFlags	;wh_Flags
>e77f	03					.byte 3	;wh_CodeLength
>e780	0d					  .byte LinkDisplacement	; offset to previous nt
=$e781					XtPtr1 ::= *
=59133					WordListLink ::= Nt0 ; remember the nt of this word for later
.e781	20 f5 e7	jsr $e7f5		jsr asm_1
=3					CodeLen	.var *-XtPtr1
=$e784					Here1 = *	; remember here
>e77f	03					.byte CodeLen	;patch wh_CodeLength
>e784	84					.byte $84
>e785	73 74 79 2e 7a 78		Name0:	.text "sty.zx"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=59147					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e78b	06					.byte (("sty.zx"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=14					LinkDisplacement = Nt0-WordListLink
>e78c	10					.byte WordFlags	;wh_Flags
>e78d	03					.byte 3	;wh_CodeLength
>e78e	0e					  .byte LinkDisplacement	; offset to previous nt
=$e78f					XtPtr1 ::= *
=59147					WordListLink ::= Nt0 ; remember the nt of this word for later
.e78f	20 f5 e7	jsr $e7f5		jsr asm_1
=3					CodeLen	.var *-XtPtr1
=$e792					Here1 = *	; remember here
>e78d	03					.byte CodeLen	;patch wh_CodeLength
>e792	94					.byte $94
>e793	74 61 78			Name0:	.text "tax"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=59158					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e796	03					.byte (("tax"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=11					LinkDisplacement = Nt0-WordListLink
>e797	10					.byte WordFlags	;wh_Flags
>e798	03					.byte 3	;wh_CodeLength
>e799	0b					  .byte LinkDisplacement	; offset to previous nt
=$e79a					XtPtr1 ::= *
=59158					WordListLink ::= Nt0 ; remember the nt of this word for later
.e79a	20 10 e8	jsr $e810		jsr asm_0
=3					CodeLen	.var *-XtPtr1
=$e79d					Here1 = *	; remember here
>e798	03					.byte CodeLen	;patch wh_CodeLength
>e79d	aa					.byte $aa
>e79e	74 61 79			Name0:	.text "tay"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=59169					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e7a1	23					.byte (("tay"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=11					LinkDisplacement = Nt0-WordListLink
>e7a2	10					.byte WordFlags	;wh_Flags
>e7a3	03					.byte 3	;wh_CodeLength
>e7a4	0b					  .byte LinkDisplacement	; offset to previous nt
=$e7a5					XtPtr1 ::= *
=59169					WordListLink ::= Nt0 ; remember the nt of this word for later
.e7a5	20 10 e8	jsr $e810		jsr asm_0
=3					CodeLen	.var *-XtPtr1
=$e7a8					Here1 = *	; remember here
>e7a3	03					.byte CodeLen	;patch wh_CodeLength
>e7a8	a8					.byte $a8
>e7a9	74 73 78			Name0:	.text "tsx"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=59180					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e7ac	03					.byte (("tsx"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=11					LinkDisplacement = Nt0-WordListLink
>e7ad	10					.byte WordFlags	;wh_Flags
>e7ae	03					.byte 3	;wh_CodeLength
>e7af	0b					  .byte LinkDisplacement	; offset to previous nt
=$e7b0					XtPtr1 ::= *
=59180					WordListLink ::= Nt0 ; remember the nt of this word for later
.e7b0	20 10 e8	jsr $e810		jsr asm_0
=3					CodeLen	.var *-XtPtr1
=$e7b3					Here1 = *	; remember here
>e7ae	03					.byte CodeLen	;patch wh_CodeLength
>e7b3	ba					.byte $BA
>e7b4	74 78 61			Name0:	.text "txa"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=59191					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e7b7	23					.byte (("txa"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=11					LinkDisplacement = Nt0-WordListLink
>e7b8	10					.byte WordFlags	;wh_Flags
>e7b9	03					.byte 3	;wh_CodeLength
>e7ba	0b					  .byte LinkDisplacement	; offset to previous nt
=$e7bb					XtPtr1 ::= *
=59191					WordListLink ::= Nt0 ; remember the nt of this word for later
.e7bb	20 10 e8	jsr $e810		jsr asm_0
=3					CodeLen	.var *-XtPtr1
=$e7be					Here1 = *	; remember here
>e7b9	03					.byte CodeLen	;patch wh_CodeLength
>e7be	8a					.byte $8a
>e7bf	74 78 73			Name0:	.text "txs"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=59202					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e7c2	63					.byte (("txs"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=11					LinkDisplacement = Nt0-WordListLink
>e7c3	10					.byte WordFlags	;wh_Flags
>e7c4	03					.byte 3	;wh_CodeLength
>e7c5	0b					  .byte LinkDisplacement	; offset to previous nt
=$e7c6					XtPtr1 ::= *
=59202					WordListLink ::= Nt0 ; remember the nt of this word for later
.e7c6	20 10 e8	jsr $e810		jsr asm_0
=3					CodeLen	.var *-XtPtr1
=$e7c9					Here1 = *	; remember here
>e7c4	03					.byte CodeLen	;patch wh_CodeLength
>e7c9	9a					.byte $9a
>e7ca	74 79 61			Name0:	.text "tya"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=59213					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e7cd	23					.byte (("tya"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=11					LinkDisplacement = Nt0-WordListLink
>e7ce	10					.byte WordFlags	;wh_Flags
>e7cf	03					.byte 3	;wh_CodeLength
>e7d0	0b					  .byte LinkDisplacement	; offset to previous nt
=$e7d1					XtPtr1 ::= *
=59213					WordListLink ::= Nt0 ; remember the nt of this word for later
.e7d1	20 10 e8	jsr $e810		jsr asm_0
=3					CodeLen	.var *-XtPtr1
=$e7d4					Here1 = *	; remember here
>e7cf	03					.byte CodeLen	;patch wh_CodeLength
>e7d4	98					.byte $98
=59213					asm_table = WordListLink ; head of instruction word list for disassembler
.e7d5					asm_r:
.e7d5	68		pla			pla		; pop RTS addr
.e7d6	a8		tay			tay
.e7d7	68		pla			pla
.e7d8	20 13 e8	jsr $e813		jsr asm_op	; compile opcode
.e7db	b5 25		lda $25,x		lda DStack+1,x	; check range
.e7dd	f0 09		beq $e7e8		beq _plus
.e7df	c9 ff		cmp #$ff		cmp #$ff
.e7e1	f0 0b		beq $e7ee		beq _minus
.e7e3	a9 f5		lda #$f5	_err:	lda #$100+err_OutOfRange
.e7e5	4c 63 c4	jmp $c463		jmp ThrowA
.e7e8	b5 24		lda $24,x	_plus:	lda DStack+0,x
.e7ea	30 f7		bmi $e7e3		bmi _err
.e7ec	10 04		bpl $e7f2		bpl _store
.e7ee	b5 24		lda $24,x	_minus:	lda DStack+0,x
.e7f0	10 f1		bpl $e7e3		bpl _err
.e7f2	4c 36 dd	jmp $dd36	_store:	jmp C_Comma
.e7f5					asm_1:
.e7f5	68		pla			pla		; pop RTS addr
.e7f6	a8		tay			tay
.e7f7	68		pla			pla
.e7f8	20 13 e8	jsr $e813		jsr asm_op	; compile opcode
.e7fb	b5 25		lda $25,x		lda DStack+1,x	; compile operand
.e7fd	d0 03		bne $e802		bne _err
.e7ff	4c 36 dd	jmp $dd36	_store:	jmp C_Comma
.e802	a9 f5		lda #$f5	_err:	lda #$100+err_OutOfRange
.e804	4c 63 c4	jmp $c463		jmp ThrowA
.e807					asm_2:
.e807	68		pla			pla		; pop RTS addr
.e808	a8		tay			tay
.e809	68		pla			pla
.e80a	20 13 e8	jsr $e813		jsr asm_op	; compile opcode
.e80d	4c 4d dd	jmp $dd4d		jmp Comma	; compile operand
.e810					asm_0:
.e810	68		pla			pla		; pop RTS addr
.e811	a8		tay			tay
.e812	68		pla			pla
.e813	84 14		sty $14		asm_op:	sty tmp1+0	; save RTS addr
.e815	85 15		sta $15			sta tmp1+1
.e817	a0 01		ldy #$01		ldy #1		; get opcode byte
.e819	b1 14		lda ($14),y		lda (tmp1),y
.e81b	4c 39 dd	jmp $dd39		jmp C_Comma_A	; compile opcode
>e81e	70 75 73 68 2d 61		Name0:	.text "push-a"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=59300					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e824	26					.byte (("push-a"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=24					WordFlags ::= IM+NN	; modifiable copy, remember for later
=87					LinkDisplacement = Nt0-WordListLink
>e825	18					.byte WordFlags	;wh_Flags
>e826	03					.byte 3	;wh_CodeLength
>e827	57					  .byte LinkDisplacement	; offset to previous nt
=$e828					XtPtr1 ::= *
=59300					WordListLink ::= Nt0 ; remember the nt of this word for later
.e828	a9 e4		lda #$e4			lda #<PushZA
.e82a	a0 c7		ldy #$c7			ldy #>PushZA
.e82c	4c 73 dd	jmp $dd73			jmp Jsr_Comma_YA
=7					CodeLen	.var *-XtPtr1
=$e82f					Here1 = *	; remember here
>e826	07					.byte CodeLen	;patch wh_CodeLength
>e82f	2d 2d 3e			Name0:	.text "-->"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=59314					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e832	c3					.byte (("-->"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=24					WordFlags ::= IM+NN	; modifiable copy, remember for later
=14					LinkDisplacement = Nt0-WordListLink
=26						  WordFlags ::= WordFlags | DB
>e833	1a					.byte WordFlags	;wh_Flags
>e834	08					.byte 8	;wh_CodeLength
>e835	0e					  .byte LinkDisplacement	; offset to previous nt
>e836	62 da					  .word Here		; pointer to xt
=0					XtPtr1 ::= 0
=59314					WordListLink ::= Nt0 ; remember the nt of this word for later
>e838	3c 6a				Name0:	.text "<j"	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=59322					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e83a	42					.byte (("<j"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$08					WordFlags ::= IM	; modifiable copy, remember for later
=8					LinkDisplacement = Nt0-WordListLink
>e83b	08					.byte WordFlags	;wh_Flags
>e83c	03					.byte 3	;wh_CodeLength
>e83d	08					  .byte LinkDisplacement	; offset to previous nt
=$e83e					XtPtr1 ::= *
=59322					WordListLink ::= Nt0 ; remember the nt of this word for later
=0					CodeLen	.var *-XtPtr1
=$e83e					Here1 = *	; remember here
>e83c	00					.byte CodeLen	;patch wh_CodeLength
.e83e	60		rts				rts
>e83f	3c 62				Name0:	.text "<b"	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=59329					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e841	42					.byte (("<b"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=24					WordFlags ::= IM+NN	; modifiable copy, remember for later
=7					LinkDisplacement = Nt0-WordListLink
>e842	18					.byte WordFlags	;wh_Flags
>e843	03					.byte 3	;wh_CodeLength
>e844	07					  .byte LinkDisplacement	; offset to previous nt
=$e845					XtPtr1 ::= *
=59329					WordListLink ::= Nt0 ; remember the nt of this word for later
.e845					asm_back_branch:
.e845	20 62 da	jsr $da62			jsr Here		; ( addr-l addr-h )
.e848	20 03 dc	jsr $dc03			jsr Minus		; ( offset )
.e84b	a9 fe		lda #$fe			lda #$fe
.e84d	4c 85 da	jmp $da85			jmp Minus_A
=11					CodeLen	.var *-XtPtr1
=$e850					Here1 = *	; remember here
>e843	0b					.byte CodeLen	;patch wh_CodeLength
>e850	44 69 73 41 73 6d		Name0:	.text "DisAsm"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=59350					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e856	a6					.byte (("DisAsm"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=21					LinkDisplacement = Nt0-WordListLink
>e857	10					.byte WordFlags	;wh_Flags
>e858	03					.byte 3	;wh_CodeLength
>e859	15					  .byte LinkDisplacement	; offset to previous nt
=$e85a					XtPtr1 ::= *
=59350					WordListLink ::= Nt0 ; remember the nt of this word for later
.e85a	20 a2 d4	jsr $d4a2	DisAsm:		jsr Bounds		; ( addr_end addr )
.e85d					_instr:
.e85d	b5 24		lda $24,x			lda DStack+0,x		; addr >= addr_end?
.e85f	d5 26		cmp $26,x			cmp DStack+2,x
.e861	b5 25		lda $25,x			lda DStack+1,x
.e863	f5 27		sbc $27,x			sbc DStack+3,x
.e865	90 03		bcc $e86a			bcc +
.e867	4c 6d d5	jmp $d56d			jmp Two_drop		; discard parms & return
.e86a					+
.e86a	20 4c bb	jsr $bb4c			jsr CR			; new line
.e86d	20 cd df	jsr $dfcd			jsr Dup			; print address
.e870	20 ec b8	jsr $b8ec			jsr Dot_Hex
.e873	20 28 de	jsr $de28			jsr Space
.e876	a1 24		lda ($24,x)			lda (DStack+0,x)	; print opcode byte
.e878	20 d8 e9	jsr $e9d8			jsr _print_a
.e87b	a1 24		lda ($24,x)			lda (DStack+0,x)	; save opcode
.e87d	85 18		sta $18				sta tmp3
.e87f	20 95 da	jsr $da95			jsr One_plus
.e882	a9 4d		lda #$4d			lda #<asm_table		; for each asm opcode word
.e884	a0 e7		ldy #$e7			ldy #>asm_table
.e886	85 14		sta $14				sta tmp1+0
.e888	84 15		sty $15				sty tmp1+1
.e88a	d0 05		bne $e891			bne _WTest
.e88c	20 95 82	jsr $8295	_WNext:		jsr LinkNext		;   next entry
.e88f	f0 2b		beq $e8bc			beq _unknown2
.e891	20 b6 cd	jsr $cdb6	_WTest:		jsr NameToIntTmp	; tmp2= xt
.e894	a0 03		ldy #$03			ldy #3			;   opcode match?
.e896	b1 16		lda ($16),y			lda (tmp2),y
.e898	c5 18		cmp $18				cmp tmp3
.e89a	d0 f0		bne $e88c			bne _WNext
.e89c	a5 18		lda $18				lda tmp3		; save opcode
.e89e	48		pha				pha
.e89f	a5 15		lda $15				lda tmp1+1		; save its nt
.e8a1	48		pha				pha
.e8a2	a5 14		lda $14				lda tmp1+0
.e8a4	48		pha				pha
.e8a5	a0 01		ldy #$01			ldy #1			; get processor routine addr lo byte from JSR
.e8a7	b1 16		lda ($16),y			lda (tmp2),y
.e8a9	c9 10		cmp #$10			cmp #<asm_0		; goto disasm processor
.e8ab	f0 1a		beq $e8c7			beq _c0
.e8ad	c9 f5		cmp #$f5			cmp #<asm_1
.e8af	f0 4c		beq $e8fd			beq _c1
.e8b1	c9 07		cmp #$07			cmp #<asm_2
.e8b3	f0 64		beq $e919			beq _c2
.e8b5	c9 d5		cmp #$d5			cmp #<asm_r
.e8b7	f0 1b		beq $e8d4			beq _cr
.e8b9					_unknown:
.e8b9	68		pla				pla			; RDrop nt
.e8ba	68		pla				pla
.e8bb	68		pla				pla			; RDrop opcode
.e8bc	20 b9 e9	jsr $e9b9	_unknown2:	jsr _tab		; to source area
.e8bf	a9 3f		lda #$3f			lda #'?'
.e8c1	20 1c de	jsr $de1c			jsr Emit_A
.e8c4	4c 5d e8	jmp $e85d			jmp _instr
.e8c7					_c0:
.e8c7	20 b9 e9	jsr $e9b9			jsr _tab		; to source area
.e8ca	68		pla				pla			; get opcode word nt
.e8cb	a8		tay				tay
.e8cc	68		pla				pla
.e8cd	20 be e9	jsr $e9be			jsr _print_opcode
.e8d0	68		pla				pla			; discard opcode
.e8d1	4c 5d e8	jmp $e85d			jmp _instr
.e8d4					_cr:
.e8d4	20 cf e9	jsr $e9cf			jsr _get_byte		; get displacement byte
.e8d7	a0 00		ldy #$00			ldy #0			; sign extend displacement
.e8d9	09 00		ora #$00			ora #0
.e8db	10 01		bpl $e8de			bpl +
.e8dd	88		dey				dey
.e8de	20 b5 c7	jsr $c7b5	+		jsr PushYA
.e8e1	20 cd df	jsr $dfcd			jsr Dup			; save for TypeSymbol
.e8e4	20 b9 e9	jsr $e9b9			jsr _tab		; to source area
.e8e7	20 1c dc	jsr $dc1c			jsr Dot			; print dest address
.e8ea	68		pla				pla			; get opcode word nt
.e8eb	a8		tay				tay
.e8ec	68		pla				pla
.e8ed	20 be e9	jsr $e9be			jsr _print_opcode
.e8f0	68		pla				pla			; discard opcode
.e8f1	20 a4 df	jsr $dfa4			jsr Over		; calc dest addr
.e8f4	20 ea db	jsr $dbea			jsr Plus
.e8f7	20 98 81	jsr $8198			jsr TypeSymbol		; print dest addr symbolic
.e8fa	4c 5d e8	jmp $e85d			jmp _instr
.e8fd					_c1:
.e8fd	20 cf e9	jsr $e9cf			jsr _get_byte		; get operand
.e900	20 e4 c7	jsr $c7e4			jsr PushZA
.e903	20 b9 e9	jsr $e9b9			jsr _tab		; to source area
.e906	20 cd df	jsr $dfcd			jsr Dup
.e909	20 4d dc	jsr $dc4d			jsr U_Dot		; print operand
.e90c	68		pla				pla			; get opcode word nt
.e90d	a8		tay				tay
.e90e	68		pla				pla
.e90f	20 be e9	jsr $e9be			jsr _print_opcode
.e912	68		pla				pla			; discard opcode
.e913	20 98 81	jsr $8198			jsr TypeSymbol
.e916	4c 5d e8	jmp $e85d			jmp _instr
.e919					_c2:
.e919	20 cf e9	jsr $e9cf			jsr _get_byte		; get operand lo byte
.e91c	48		pha				pha
.e91d	20 cf e9	jsr $e9cf			jsr _get_byte		; get operand hi byte
.e920	ca		dex				dex			; push operand bytes
.e921	ca		dex				dex
.e922	95 25		sta $25,x			sta DStack+1,x
.e924	68		pla				pla
.e925	95 24		sta $24,x			sta DStack+0,x
.e927	20 b9 e9	jsr $e9b9			jsr _tab		; to source area
.e92a	20 cd df	jsr $dfcd			jsr Dup
.e92d	20 4d dc	jsr $dc4d			jsr U_Dot		; print operand
.e930	68		pla				pla			; AY= opcode word nt
.e931	a8		tay				tay
.e932	68		pla				pla
.e933	20 be e9	jsr $e9be			jsr _print_opcode
.e936	20 cd df	jsr $dfcd			jsr Dup
.e939	20 98 81	jsr $8198			jsr TypeSymbol		; print operand as symbol
.e93c	68		pla				pla			; get opcode
.e93d	c9 20		cmp #$20			cmp #$20		;  JSR
.e93f	f0 09		beq $e94a			beq _jsr
.e941	e8		inx		_jdrop:		inx			; Drop operand
.e942	e8		inx				inx
.e943	4c 5d e8	jmp $e85d			jmp _instr		; ( addr_end addr )
.e946	e8		inx		_2drop:		inx			; Drop jsr_nt
.e947	e8		inx				inx
.e948	d0 f7		bne $e941			bne _jdrop
.e94a					_jsr:
.e94a	20 de c3	jsr $c3de			jsr PopYA		; pop JSR operand
.e94d	c9 b8		cmp #$b8			cmp #<sliteral_runtime	; string literal?
.e94f	d0 42		bne $e993			bne _not_sliteral
.e951	c0 c8		cpy #$c8			cpy #>sliteral_runtime
.e953	d0 3e		bne $e993			bne _not_sliteral
.e955	20 4c bb	jsr $bb4c			jsr CR
.e958	20 cd df	jsr $dfcd			jsr Dup			; ( addr_end addr addr )
.e95b	20 ec b8	jsr $b8ec			jsr Dot_Hex
.e95e	20 28 de	jsr $de28			jsr Space
.e961	20 cd df	jsr $dfcd			jsr Dup			; ( addr_end ? addr )
.e964	20 cf e9	jsr $e9cf			jsr _get_byte		; get JMP opcode
.e967	20 cf e9	jsr $e9cf			jsr _get_byte		; get JMP addr lo byte
.e96a	95 26		sta $26,x			sta DStack+2,x
.e96c	20 cf e9	jsr $e9cf			jsr _get_byte		; get JMP addr hi byte
.e96f	95 27		sta $27,x			sta DStack+3,x		; ( addr_end string_end addr )
.e971	20 4c bb	jsr $bb4c			jsr CR
.e974	20 cd df	jsr $dfcd			jsr Dup
.e977	20 ec b8	jsr $b8ec			jsr Dot_Hex
.e97a	20 28 de	jsr $de28			jsr Space
.e97d	b5 24		lda $24,x	_slit_11:	lda DStack+0,x		; done with string data?
.e97f	d5 26		cmp $26,x			cmp DStack+2,x
.e981	b5 25		lda $25,x			lda DStack+1,x
.e983	f5 27		sbc $27,x			sbc DStack+3,x
.e985	b0 06		bcs $e98d			bcs _slit_19
.e987	20 cf e9	jsr $e9cf			jsr _get_byte
.e98a	4c 7d e9	jmp $e97d			jmp _slit_11
.e98d					_slit_19:
.e98d	20 c8 d9	jsr $d9c8			jsr Nip			; ( addr_end addr )
.e990	4c 5d e8	jmp $e85d			jmp _instr
.e993					_not_sliteral:
.e993	c9 48		cmp #$48			cmp #<FLiti		; float literal?
.e995	d0 1f		bne $e9b6			bne _not_FLiti
.e997	c0 88		cpy #$88			cpy #>FLiti
.e999	d0 1b		bne $e9b6			bne _not_FLiti
.e99b	20 4c bb	jsr $bb4c			jsr CR
.e99e	20 cd df	jsr $dfcd			jsr Dup			; ( addr_end addr addr )
.e9a1	20 ec b8	jsr $b8ec			jsr Dot_Hex
.e9a4	20 28 de	jsr $de28			jsr Space
.e9a7	20 cf e9	jsr $e9cf			jsr _get_byte
.e9aa	20 cf e9	jsr $e9cf			jsr _get_byte
.e9ad	20 cf e9	jsr $e9cf			jsr _get_byte
.e9b0	20 cf e9	jsr $e9cf			jsr _get_byte
.e9b3	20 cf e9	jsr $e9cf			jsr _get_byte
.e9b6					_not_FLiti:
.e9b6	4c 5d e8	jmp $e85d			jmp _instr
.e9b9					_tab:
.e9b9	a9 09		lda #$09			lda #9
.e9bb	4c 1c de	jmp $de1c			jmp Emit_A
.e9be					_print_opcode:
.e9be	20 df df	jsr $dfdf			jsr PushAY		; save opcode word nt
.e9c1	20 28 de	jsr $de28			jsr Space
.e9c4	20 f2 cd	jsr $cdf2			jsr Name_To_String	; get name string
.e9c7	4c 34 de	jmp $de34			jmp Type		; type word name
.e9ca					_get_byte_silent:
.e9ca	a1 24		lda ($24,x)			lda (DStack+0,x)
.e9cc	4c 95 da	jmp $da95			jmp One_plus
.e9cf					_get_byte:
.e9cf	20 ca e9	jsr $e9ca			jsr _get_byte_silent
.e9d2	48		pha				pha
.e9d3	20 d8 e9	jsr $e9d8			jsr _print_a
.e9d6	68		pla				pla
.e9d7	60		rts				rts
.e9d8					_print_a:
.e9d8	20 e4 c7	jsr $c7e4			jsr PushZA
.e9db	20 cb b8	jsr $b8cb			jsr C_Dot_Hex
.e9de	4c 28 de	jmp $de28			jmp Space
=59350					assembler_dictionary_start = WordListLink ; END of ASSEMBLER-WORDLIST
=0					WordListLink .var 0	; start wordlist
>e9e1	6c				Name0:	.text "l"	;  name of word as a string, ending at wh_NameLastChar
=1					NameLength = *-Name0
=59746					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e9e2	81					.byte (("l"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=59746					LinkDisplacement = Nt0-WordListLink
=$11						  WordFlags ::= WordFlags | FP
>e9e3	11					.byte WordFlags	;wh_Flags
>e9e4	03					.byte 3	;wh_CodeLength
>e9e5	00 00					  .word WordListLink
=$e9e7					XtPtr1 ::= *
=59746					WordListLink ::= Nt0 ; remember the nt of this word for later
.e9e7	4c b0 b4	jmp $b4b0	Editor_l:	jmp ListScr
=3					CodeLen	.var *-XtPtr1
=$e9ea					Here1 = *	; remember here
>e9e4	03					.byte CodeLen	;patch wh_CodeLength
.e9ea					Editor_Screen_Helper:
.e9ea	20 cd df	jsr $dfcd			jsr Dup
.e9ed	20 c2 b2	jsr $b2c2			jsr Scr
.e9f0	20 0e df	jsr $df0e			jsr Store
.e9f3	4c cd b3	jmp $b3cd			jmp Buffer
>e9f6	65 6e 74 65 72 2d 73 63		Name0:	.text "enter-screen"	;  name of word as a string, ending at wh_NameLastChar
>e9fe	72 65 65 6e
=12					NameLength = *-Name0
=59778					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>ea02	cc					.byte (("enter-screen"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=32					LinkDisplacement = Nt0-WordListLink
>ea03	10					.byte WordFlags	;wh_Flags
>ea04	03					.byte 3	;wh_CodeLength
>ea05	20					  .byte LinkDisplacement	; offset to previous nt
=$ea06					XtPtr1 ::= *
=59778					WordListLink ::= Nt0 ; remember the nt of this word for later
.ea06					Editor_Enter_Screen:
.ea06	20 ea e9	jsr $e9ea			jsr Editor_Screen_Helper
.ea09	a9 00		lda #$00			lda #0			; Overwrite the lines one at a time.
.ea0b	95 24		sta $24,x	_loop:		sta DStack+0,x
.ea0d	20 e4 c7	jsr $c7e4			jsr PushZA		; Put the current line number on the stack.
.ea10	20 70 ea	jsr $ea70			jsr Editor_o		; prompt for overwrite.
.ea13	f6 24		inc $24,x			inc DStack+0,x		; Move on to the next line.
.ea15	b5 24		lda $24,x			lda DStack+0,x
.ea17	c9 10		cmp #$10			cmp #16
.ea19	90 f0		bcc $ea0b			bcc _loop
.ea1b	e8		inx				inx			; Drop work area
.ea1c	e8		inx				inx
=23					CodeLen	.var *-XtPtr1
=$ea1d					Here1 = *	; remember here
>ea04	17					.byte CodeLen	;patch wh_CodeLength
.ea1d	60		rts				rts
>ea1e	6c 69 6e 65			Name0:	.text "line"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=59810					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>ea22	a4					.byte (("line"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=32					LinkDisplacement = Nt0-WordListLink
>ea23	10					.byte WordFlags	;wh_Flags
>ea24	03					.byte 3	;wh_CodeLength
>ea25	20					  .byte LinkDisplacement	; offset to previous nt
=$ea26					XtPtr1 ::= *
=59810					WordListLink ::= Nt0 ; remember the nt of this word for later
.ea26					Editor_line:
.ea26	a9 06		lda #$06			lda #6		; Multiply the TOS by 64 (chars/line) to compute offset.
.ea28	20 87 db	jsr $db87			jsr LShift_A	; *64 is same as left shift 6 times.
.ea2b	20 c2 b2	jsr $b2c2			jsr Scr
.ea2e	20 f5 de	jsr $def5			jsr Fetch
.ea31	20 65 b3	jsr $b365			jsr Block
.ea34	4c ea db	jmp $dbea			jmp Plus
=17					CodeLen	.var *-XtPtr1
=$ea37					Here1 = *	; remember here
>ea24	11					.byte CodeLen	;patch wh_CodeLength
>ea37	65 72 61 73 65 2d 73 63		Name0:	.text "erase-screen"	;  name of word as a string, ending at wh_NameLastChar
>ea3f	72 65 65 6e
=12					NameLength = *-Name0
=59843					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>ea43	cc					.byte (("erase-screen"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=33					LinkDisplacement = Nt0-WordListLink
>ea44	10					.byte WordFlags	;wh_Flags
>ea45	03					.byte 3	;wh_CodeLength
>ea46	21					  .byte LinkDisplacement	; offset to previous nt
=$ea47					XtPtr1 ::= *
=59843					WordListLink ::= Nt0 ; remember the nt of this word for later
.ea47					Editor_Erase_Screen:
.ea47	20 ea e9	jsr $e9ea			jsr Editor_Screen_Helper
.ea4a	a9 00		lda #$00			lda #<1024
.ea4c	a0 04		ldy #$04			ldy #>1024
.ea4e	20 b5 c7	jsr $c7b5			jsr PushYA
.ea51	20 38 ce	jsr $ce38			jsr Blank		; Erase the entire block (fill with spaces).
.ea54	4c ba b3	jmp $b3ba			jmp Update		; Mark buffer as updated.
=16					CodeLen	.var *-XtPtr1
=$ea57					Here1 = *	; remember here
>ea45	10					.byte CodeLen	;patch wh_CodeLength
>ea57	65 6c				Name0:	.text "el"	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=59865					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>ea59	82					.byte (("el"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=22					LinkDisplacement = Nt0-WordListLink
>ea5a	10					.byte WordFlags	;wh_Flags
>ea5b	03					.byte 3	;wh_CodeLength
>ea5c	16					  .byte LinkDisplacement	; offset to previous nt
=$ea5d					XtPtr1 ::= *
=59865					WordListLink ::= Nt0 ; remember the nt of this word for later
.ea5d					Editor_el:
.ea5d	20 26 ea	jsr $ea26			jsr Editor_line
.ea60	a9 40		lda #$40			lda #64			;(# of chars/line)
.ea62	20 e4 c7	jsr $c7e4			jsr PushZA
.ea65	20 38 ce	jsr $ce38			jsr Blank		; Fill with spaces.
.ea68	4c ba b3	jmp $b3ba			jmp Update		; Mark buffer as updated.
=14					CodeLen	.var *-XtPtr1
=$ea6b					Here1 = *	; remember here
>ea5b	0e					.byte CodeLen	;patch wh_CodeLength
>ea6b	6f				Name0:	.text "o"	;  name of word as a string, ending at wh_NameLastChar
=1					NameLength = *-Name0
=59884					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>ea6c	e1					.byte (("o"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=19					LinkDisplacement = Nt0-WordListLink
>ea6d	10					.byte WordFlags	;wh_Flags
>ea6e	03					.byte 3	;wh_CodeLength
>ea6f	13					  .byte LinkDisplacement	; offset to previous nt
=$ea70					XtPtr1 ::= *
=59884					WordListLink ::= Nt0 ; remember the nt of this word for later
.ea70					Editor_o:
.ea70	20 4c bb	jsr $bb4c			jsr CR
.ea73	20 cd df	jsr $dfcd			jsr Dup
.ea76	a9 02		lda #$02			lda #2
.ea78	20 7f dc	jsr $dc7f			jsr U_Dot_R_A
.ea7b	20 28 de	jsr $de28			jsr Space
.ea7e	a9 2a		lda #$2a			lda #'*'
.ea80	20 1c de	jsr $de1c			jsr Emit_A
.ea83	20 28 de	jsr $de28			jsr Space
.ea86	20 26 ea	jsr $ea26			jsr Editor_line
.ea89	20 cd df	jsr $dfcd			jsr Dup		; Save a copy of the line address for later.
.ea8c	a9 40		lda #$40			lda #64		; chars/line
.ea8e	20 e4 c7	jsr $c7e4			jsr PushZA
.ea91	20 d9 d2	jsr $d2d9			jsr Accept
.ea94	20 cd df	jsr $dfcd			jsr Dup
.ea97	20 d3 de	jsr $ded3			jsr Not_Rot
.ea9a	20 ea db	jsr $dbea			jsr Plus
.ea9d	a9 40		lda #$40			lda #64		; chars/line
.ea9f	20 e4 c7	jsr $c7e4			jsr PushZA
.eaa2	20 ae de	jsr $deae			jsr Rot
.eaa5	20 03 dc	jsr $dc03			jsr Minus
.eaa8	20 38 ce	jsr $ce38			jsr Blank
.eaab	4c ba b3	jmp $b3ba			jmp Update
=62					CodeLen	.var *-XtPtr1
=$eaae					Here1 = *	; remember here
>ea6e	3e					.byte CodeLen	;patch wh_CodeLength
=59884					editor_dictionary_start = WordListLink ; END of EDITOR-WORDLIST

;******  Processing file: platform/../strings.asm

>eaae	20 6f 6b 00			str_ok:         .text " ok", 0         ; note space at beginning
>eab2	20 63 6f 6d 70 69 6c 65		str_compiled:   .text " compiled", 0   ; note space at beginning
>eaba	64 00
>eabc	72 65 64 65 66 69 6e 65		str_redefined:  .text "redefined ", 0  ; note space at end
>eac4	64 20 00
>eac7	66 6c 61 67 73 3a 00		str_see_flags:  .text "flags:", 0
>eace	6e 74 3a 20 24 00		str_see_nt:     .text "nt: $", 0
>ead4	78 74 3a 20 24 00		str_see_xt:     .text "xt: $", 0
>eada	73 69 7a 65 3a 20 23 00		str_see_size:   .text "size: #", 0
.eae2					Exception_Text_List:
>eae2	ff 00					.text $100+err_Abort,0
>eae4	fe 00					.text $100+err_AbortQuote,0
>eae6	fd 53 74 61 63 6b 20 4f			.text $100+err_Stack_Overflow,"Stack Overflow",0
>eaee	76 65 72 66 6c 6f 77 00
>eaf6	fc 53 74 61 63 6b 20 55			.text $100+err_Stack_Underflow,"Stack Underflow",0
>eafe	6e 64 65 72 66 6c 6f 77 00
>eb07	f9 64 6f 2d 6c 6f 6f 70			.text $100+err_DoLoop_TooDeep,"do-loops nested too deeply during execution",0
>eb0f	73 20 6e 65 73 74 65 64 20 74 6f 6f 20 64 65 65
>eb1f	70 6c 79 20 64 75 72 69 6e 67 20 65 78 65 63 75
>eb2f	74 69 6f 6e 00
>eb34	f6 44 69 76 69 64 65 20			.text $100+err_DivideBy0,"Divide by 0",0
>eb3c	62 79 20 30 00
>eb41	f5 6f 75 74 20 6f 66 20			.text $100+err_OutOfRange,"out of range",0
>eb49	72 61 6e 67 65 00
>eb4f	f4 61 72 67 75 6d 65 6e			.text $100+err_ArgTypeMismatch,"argument type mismatch",0
>eb57	74 20 74 79 70 65 20 6d 69 73 6d 61 74 63 68 00
>eb67	f3 55 6e 64 65 66 69 6e			.text $100+err_UndefinedWord,"Undefined word",0
>eb6f	65 64 20 77 6f 72 64 00
>eb77	f2 49 6e 74 65 72 70 72			.text $100+err_CompileOnly,"Interpreting a Compile-only word",0
>eb7f	65 74 69 6e 67 20 61 20 43 6f 6d 70 69 6c 65 2d
>eb8f	6f 6e 6c 79 20 77 6f 72 64 00
>eb99	eb 75 6e 73 75 70 70 6f			.text $100+err_Unsupported,"unsupported operation",0 ;  (e.g., AT-XY on a too-dumb terminal)
>eba1	72 74 65 64 20 6f 70 65 72 61 74 69 6f 6e 00
>ebb0	ea 63 6f 6e 74 72 6f 6c			.text $100+err_ControlMismatch,"control structure mismatch",0
>ebb8	20 73 74 72 75 63 74 75 72 65 20 6d 69 73 6d 61
>ebc8	74 63 68 00
>ebcc	e0 69 6e 76 61 6c 69 64			.text $100+err_InvalidName,"invalid name",0 ; argument (e.g., TO name)
>ebd4	20 6e 61 6d 65 00
>ebda	df 62 6c 6f 63 6b 20 72			.text $100+err_BlockRead,"block read",0
>ebe2	65 61 64 00
>ebe6	de 62 6c 6f 63 6b 20 77			.text $100+err_BlockWrite,"block write",0
>ebee	72 69 74 65 00
>ebf3	d6 46 50 20 64 69 76 69			.text $100+err_FPDivideBy0,"FP divide by zero",0
>ebfb	64 65 20 62 79 20 7a 65 72 6f 00
>ec06	d5 46 50 20 72 65 73 75			.text $100+err_FPOutOfRange,"FP result out of range",0
>ec0e	6c 74 20 6f 75 74 20 6f 66 20 72 61 6e 67 65 00
>ec1e	d4 46 50 20 73 74 61 63			.text $100+err_FPStackOverflow,"FP stack overflow",0
>ec26	6b 20 6f 76 65 72 66 6c 6f 77 00
>ec31	d3 46 50 20 73 74 61 63			.text $100+err_FPStackUnderflow,"FP stack underflow",0
>ec39	6b 20 75 6e 64 65 72 66 6c 6f 77 00
>ec45	d2 46 50 20 69 6e 76 61			.text $100+err_FPInvalidArg,"FP invalid argument",0
>ec4d	6c 69 64 20 61 72 67 75 6d 65 6e 74 00
>ec5a	ca 46 50 20 75 6e 64 65			.text $100+err_FPUnderflow,"FP underflow",0
>ec62	72 66 6c 6f 77 00
>ec68	c5 41 4c 4c 4f 43 41 54			.text $100+err_Allocate,"ALLOCATE",0
>ec70	45 00
>ec72	c4 46 52 45 45 00			.text $100+err_Free,"FREE",0
>ec78	6b 52 65 66 69 6c 6c 00			.text $100+err_Refill,"Refill",0
>ec80	6a 44 65 66 65 72 20 6e			.text $100+err_Defer,"Defer not set",0
>ec88	6f 74 20 73 65 74 00
>ec8f	69 41 6c 72 65 61 64 79			.text $100+err_AlreadyInterpreting,"Already interpreting",0
>ec97	20 69 6e 74 65 72 70 72 65 74 69 6e 67 00
>eca5	68 41 6c 72 65 61 64 79			.text $100+err_AlreadyCompiling,"Already compiling",0
>ecad	20 63 6f 6d 70 69 6c 69 6e 67 00
>ecb8	66 4e 6f 20 77 6f 72 64			.text $100+err_TooManyWordlists,"No wordlists available",0
>ecc0	6c 69 73 74 73 20 61 76 61 69 6c 61 62 6c 65 00
>ecd0	00					.text 0 ; end of list

;******  Return to file: platform/../taliforth.asm


;******  Return to file: platform/platform-py65mon.asm

>0766					hist_buff: .fill 8*128	; Input History for ACCEPT
.0b66					cp0:
=$f001					c65_putc	= $f001 ;  putc    Write here to send the byte to stdout
=$f003					c65_kbhit	= $f003 ;  kbit    Return non-zero if key ready to fetch with getc
=$f004					c65_getc	= $f004 ;  getc    Non-blocking read from stdin, returns 0 if no byte ready
=$f006					c65_start	= $f006 ;  start   Reading here starts the cycle counter
=$f007					c65_stop	= $f007 ;  stop    Reading here stops the cycle counter
=$f008					c65_cycles	= $f008 ; cycles  Current 32 bit cycle count in NUXI order
=$f010					c65_blkio	= $f010 ;  blkio   Write here to execute a block IO action (see below)
=$f011					c65_status	= $f011 ;  status  Read block IO status here
=$f012					c65_blknum	= $f012 ; blknum  word, Block number to read/write
=$f014					c65_buffer	= $f014 ; buffer  word, Start of 1024 byte memory buffer to read/write
.f100					v_nmi:
.f100					v_reset:
.f100					v_irq:
.f100					kernel_init:
.f100	78		sei		                sei             ; Disable interrupts
.f101	a2 00		ldx #$00	                ldx #0
.f103	bd 83 f1	lda $f183,x	-               lda s_kernel_id,x
.f106	f0 06		beq $f10e	                beq _done
.f108	20 21 f1	jsr $f121	                jsr kernel_putc
.f10b	e8		inx		                inx
.f10c	d0 f5		bne $f103	                bne -
.f10e					_done:
.f10e	2c 06 f0	bit $f006			bit c65_start		; start the cycle counter
.f111	4c 06 b1	jmp $b106	                jmp forth
.f114					kernel_getc:
.f114					_loop:
.f114	ee 35 03	inc $0335	                inc RndState+0	; randomize
.f117	ad 04 f0	lda $f004	                lda c65_getc
.f11a	f0 f8		beq $f114	                beq _loop
.f11c	60		rts		                rts
.f11d					kernel_havekey:
.f11d	ad 03 f0	lda $f003			lda c65_kbhit
.f120	60		rts				rts
.f121					kernel_putc:
.f121	8d 01 f0	sta $f001	                sta c65_putc
.f124	60		rts		                rts
.f125					platform_bye:
.f125	00		brk #		                brk
.f126					platform_CCAt:
.f126	ca		dex				dex			; allot DStack space
.f127	ca		dex				dex
.f128	ca		dex				dex
.f129	ca		dex				dex
.f12a	2c 07 f0	bit $f007			bit c65_stop		; stop the cycle counter so we can read it
.f12d	ad 08 f0	lda $f008			lda c65_cycles+0	; cycles  Current 32 bit cycle count in NUXI order
.f130	95 24		sta $24,x			sta DStack+0,x
.f132	ad 09 f0	lda $f009			lda c65_cycles+1
.f135	95 25		sta $25,x			sta DStack+1,x
.f137	ad 0a f0	lda $f00a			lda c65_cycles+2
.f13a	95 26		sta $26,x			sta DStack+2,x
.f13c	ad 0b f0	lda $f00b			lda c65_cycles+3
.f13f	95 27		sta $27,x			sta DStack+3,x
.f141	2c 06 f0	bit $f006			bit c65_start		; restart the cycle counter
.f144	60		rts		                rts
.f145					Platform_Block_Read:
.f145	20 58 f1	jsr $f158			jsr Platform_BlockParms
.f148	a9 01		lda #$01			lda #1			; read
.f14a	8d 10 f0	sta $f010			sta c65_blkio
.f14d	ad 11 f0	lda $f011			lda c65_status
.f150	f0 05		beq $f157			beq +
.f152	a9 df		lda #$df			lda #$100+err_BlockRead
.f154	20 63 c4	jsr $c463			jsr ThrowA
.f157	60		rts		+		rts
.f158					Platform_BlockParms:
.f158	20 de c3	jsr $c3de			jsr PopYA		; set block #
.f15b	8d 12 f0	sta $f012			sta c65_blknum+0
.f15e	8c 13 f0	sty $f013			sty c65_blknum+1
.f161	20 de c3	jsr $c3de			jsr PopYA		; set buffer addr
.f164	8d 14 f0	sta $f014			sta c65_buffer+0
.f167	8c 15 f0	sty $f015			sty c65_buffer+1
.f16a	a9 ff		lda #$ff			lda #$ff		; in case c65 isn't talking
.f16c	8d 11 f0	sta $f011			sta c65_status
.f16f	60		rts				rts
.f170					Platform_Block_Write:
.f170	20 58 f1	jsr $f158			jsr Platform_BlockParms
.f173	a9 02		lda #$02			lda #2			; write
.f175	8d 10 f0	sta $f010			sta c65_blkio
.f178	ad 11 f0	lda $f011			lda c65_status
.f17b	f0 05		beq $f182			beq +
.f17d	a9 de		lda #$de			lda #$100+err_BlockWrite
.f17f	20 63 c4	jsr $c463			jsr ThrowA
.f182	60		rts		+		rts
.f183					s_kernel_id:
>f183	54 61 6c 69 20 46 6f 72		        .text "Tali Forth 2 remix default kernel for py65mon (31 May 2024)", AscLF, 0
>f18b	74 68 20 32 20 72 65 6d 69 78 20 64 65 66 61 75
>f19b	6c 74 20 6b 65 72 6e 65 6c 20 66 6f 72 20 70 79
>f1ab	36 35 6d 6f 6e 20 28 33 31 20 4d 61 79 20 32 30
>f1bb	32 34 29 0a 00
>fffa	00 f1				.word v_nmi
>fffc	00 f1				.word v_reset
>fffe	00 f1				.word v_irq

;******  End of listing
