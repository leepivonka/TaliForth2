
; 64tass Turbo Assembler Macro V1.59.3120 listing file
; 64tass --nostart --list=docs/65816S-listing.txt --labels=docs/65816S-labelmap.txt --output TaliForth-65816S.bin platform/platform-65816S.asm
; Tue Jan 06 18:28:47 2026

;Offset	;Hex		;Monitor	;Source

;******  Processing input file: platform/platform-65816S.asm

=$0100					RStack = $0100	; begin of 6502 Return Stack
=$ff					rsp0      = $ff		; initial Return Stack Pointer (6502 stack)
=$8000					cp_end    = $8000	; Last RAM byte available for code
=84					PadOffset = 84	; offset from CP to PAD (holds number strings)
=79					MAX_LINE_LENGTH  = 79      ; output line size
=24					DSDim = 24	; # of cells in data stack
=10					FSDim = 10	; # of entries in floating-point stack
=8					DoStkDim = 8	; # of entries in Do stack
=					TALI_OPTIONAL_WORDS := ["fp","fpe","fpe2","fptrancendentals", "ed", "editor", "ramdrive", "block", "environment?", "assembler", "wordlist" ]
=["cr","lf"]				TALI_OPTION_CR_EOL := [ "cr", "lf" ]
=$ff					bsize     = $ff		; size of input/output buffers
>0200					buffer0: .fill bsize	; input buffer

;******  Processing file: platform/../taliforth.asm

=					TALI_OPTIONAL_WORDS := ["fp","fpe","fpe2", "fpieee","fptrancendentals", "fphyperbolic", "ed", "editor", "ramdrive", "block", "environment?", "assembler", "wordlist" ]
=-1					err_Abort		= -1
=-2					err_AbortQuote		= -2
=-3					err_Stack_Overflow	= -3
=-4					err_Stack_Underflow	= -4
=-5					err_Return_Stack_Overflow = -5
=-6					err_Return_Stack_Underflow = -6
=-7					err_DoLoop_TooDeep	= -7	; do-loops nested too deeply during execution
=-8					err_Dictionary_Overflow	= -8
=-9					err_InvalidMemoryAddr	= -9	; invalid memory address
=-10					err_DivideBy0		= -10	; division by zero
=-11					err_OutOfRange		= -11	; result out of range
=-12					err_ArgTypeMismatch	= -12	; argument type mismatch
=-13					err_UndefinedWord	= -13
=-14					err_CompileOnly		= -14	; interpreting a compile-only word
=-15					err_Forget		= -15	; invalid FORGET
=-16					err_EmptyName		= -16	; attempt to use zero-length string as a name
=-17					err_PicStringOverflow	= -17	; pictured numeric output string overflow
=-18					err_ParsedStringOverflow = -18	; parsed string overflow
=-19					err_NameTooLong		= -19	; definition name too long
=-20					err_WriteToRO		= -20	; write to a read-only location
=-21					err_Unsupported		= -21	; unsupported operation  (e.g., AT-XY on a too-dumb terminal)
=-22					err_ControlMismatch	= -22	; control structure mismatch
=-23					err_AddrAlignment	= -23	; address alignment exception
=-24					err_InvalidNumericArg	= -24	; invalid numeric argument
=-25					err_ReturnStackImbalance = -25	; return stack imbalance
=-26					err_LoopParmUnavailable = -26	; loop parameters unavailable
=-27					err_InvalidRecursion	= -27	; invalid recursion
=-28					err_UserInterrupt	= -28	; user interrupt
=-29					err_CompilerNesting	= -29	; compiler nesting
=-30					err_Obsolete		= -30	; obsolescent feature
=-31					err_NoBody		= -31	; >BODY used on non-CREATEd definition
=-32					err_InvalidName		= -32	; invalid name argument (e.g., TO name)
=-33					err_BlockRead		= -33	; block read exception
=-34					err_BlockWrite		= -34	; block write exception
=-35					err_InvalidBlock	= -35	; invalid block number
=-36					err_InvalidFilePosition = -36	; invalid file position
=-37					err_FileIO		= -37	; file I/O exception
=-38					err_FileMissing		= -38	; non-existent file
=-39					err_EndOfFile		= -39	; unexpected end of file
=-40					err_InvalidBase		= -40	; invalid BASE for floating point conversion
=-41					err_LossOfPrecision	= -41	; loss of precision
=-42					err_FPDivideBy0		= -42	; floating-point divide by zero
=-43					err_FPOutOfRange	= -43	; floating-point result out of range
=-44					err_FPStackOverflow	= -44	; floating-point stack overflow
=-45					err_FPStackUnderflow	= -45	; floating-point stack underflow
=-46					err_FPInvalidArg	= -46	; floating-point invalid argument
=-47					err_CompileWordsDeleted = -47	; compilation word list deleted
=-48					err_PostponeInvalid	= -48	; invalid POSTPONE
=-49					err_SearchOrderOverflow = -49	; search-order overflow
=-50					err_SearchOrderUnderflow = -50	; search-order underflow
=-51					err_CompileWordlistChanged = -51 ; compilation word list changed
=-52					err_ControlStackOverflow = -52	; control-flow stack overflow
=-53					err_ExceptionStackOverflow = -53 ; exception stack overflow
=-54					err_FPUnderflow		= -54	; floating-point underflow
=-55					err_FPFault		= -55	; floating-point unidentified fault
=-56					err_Quit		= -56	; QUIT
=-57					err_ConsoleIO		= -57	; exception in sending or receiving a character
=-58					err_BracketIf		= -58	; [IF], [ELSE], or [THEN] exception
=-59					err_Allocate		= -59	; ALLOCATE
=-60					err_Free		= -60	; FREE
=-61					err_Resize		= -61	; RESIZE
=-62					err_CloseFile		= -62	; CLOSE-FILE
=-63					err_CreateFile		= -63	; CREATE-FILE
=-64					err_DeleteFile		= -64	; DELETE-FILE
=-65					err_FilePosition	= -65	; FILE-POSITION
=-66					err_FileSize		= -66	; FILE-SIZE
=-67					err_FileStatus		= -67	; FILE-STATUS
=-68					err_FlushFile		= -68	; FLUSH-FILE
=-69					err_OpenFile		= -69	; OPEN-FILE
=-70					err_ReadFile		= -70	; READ-FILE
=-71					err_ReadLine		= -71	; READ-LINE
=-72					err_RenameFile		= -72	; RENAME-FILE
=-73					err_RepositionFile	= -73	; REPOSITION-FILE
=-74					err_ResizeFile		= -74	; RESIZE-FILE
=-75					err_WriteFile		= -75	; WRITE-FILE
=-76					err_WriteLine		= -76	; WRITE-LINE
=-77					err_MalformedXChar	= -77	; Malformed xchar
=-78					err_Substitute		= -78	; SUBSTITUTE
=-79					err_Replaces		= -79	; REPLACES
=-149					err_Refill		= -149	; Refill failed
=-150					err_Defer		= -150	; Defer not set
=-151					err_AlreadyInterpreting	= -151	; entering interpret when already interpreting
=-152					err_AlreadyCompiling	= -152	; entering compile when already compiling
=-154					err_TooManyWordlists   	= -154
.0000					zp0:
>0000					cp:	.word ?		; Compiler Pointer (see HERE)
>0002					InSrc:	.word ?		; input Source for SOURCE-ID
>0004					Cib:	.word ?		; address of current input buffer
>0006					CibLen:	.word ?		; length of current input buffer
>0008					ToIn:	.word ?		; pointer to CIB (>IN in Forth)
>000a					state:	.word ?		; STATE: -1 compile, 0 interpret
>000c					status: .word ?		; internal status flags
>000e					WorkWord: .word ?	; nt or xt of word being compiled (see status)
>0010					dp:	.word ?		; Dictionary Pointer temp
>0012					DoIndex: .word ?	; current Do index
>0014					tmp1:	.word ?		; temporary storage
>0016					tmp2:	.word ?		; temporary storage
>0018					tmp3:	.word ?		; temporary storage
>001a					tmp4:	.word ?		; temporary storage (tmpdsp)
>001c					tmp5:	.word ?		; temporary storage (tmptos)
>001e					tmp6:	.word ?		; temporary
>0020					editor1: .word ?	; temporary for editors
>0022					editor2: .word ?	; temporary for editors
>0024					editor3: .word ?	; temporary for editors
>0026					DStack:	.fill DSDim*2	; data stack
.8000					Cold_zp_table:
>8000	66 0b					.word cp0		; cp
>8002	00 00					.word 0			; insrc (SOURCE-ID is 0 for keyboard)
>8004	00 02					.word buffer0		; cib
>8006	00 00					.word 0			; ciblen
>8008	00 00					.word 0			; toin
>800a	00 00					.word 0			; state (0 = interpret)
>800c	00 00					.word 0			; status
=14					Cold_zp_table_length = *-Cold_zp_table
.02ff					User0:
>02ff					PrecisionV: .byte ?	; # of decimal places for FP print
>0300					base:	.word ?		; number radix, default decimal
>0302					nc_limit: .word ?	; limit for Native Compile size
>0304					uf_strip: .word ?	; flag variable that determines if underflow
>0306					output:	.word ?		; vector for EMIT
>0308					input:	.word ?		; vector for KEY
>030a					HaveKey: .word ?	; vector for KEY?
>030c					BlkV:	.word ?		; BLK
>030e					ScrV:	.word ?		; SCR
>0310					CurrentV: .byte ?	; CURRENT (byte) (Compilation wordlist)
>0311					Num_WordlistsV: .byte ?	; #WORDLISTS (byte)
=12					max_wordlists = 12	; Maximum number of wordlists supported
>0312					WordlistsV: .fill 2*max_wordlists	; WORDLISTS (cells)
>032a					Num_OrderV: .byte ?	; #ORDER (byte)
>032b					Search_OrderV: .fill 9	; SEARCH-ORDER (bytes)
.0334					MarkEnd:
>0334					ToHold:	.byte ?		; pad buffer index for formatted output
>0335					RndState: .dword ?	; random # state
=0					wid_Forth = 0
=1					wid_Editor = 1
=2					wid_Assembler = 2
=3					wid_Root = 3
.800e					Cold_user_table:
>800e	08					.byte 8			; PrecisionV
>800f	0a 00					.word 10		; base
>8011	08 00					.word 8			; nc-limit
>8013	00 00					.word 0			; uf_strip (off by default)
>8015	30 f1					.word kernel_putc	; output
>8017	21 f1					.word kernel_getc	; input
>8019	2b f1					.word kernel_havekey	; havekey
>801b	00 00					.word 0				; BLK
>801d	00 00					.word 0				; SCR
>801f	00					.byte 0				; CURRENT = FORTH-WORDLIST
>8020	04					.byte 4				; #WORDLISTS (FORTH EDITOR ASSEMBLER ROOT)
>8021	46 e1					.word forth_dictionary_start	; FORTH-WORDLIST
>8023	ab eb					.word editor_dictionary_start	; EDITOR-WORDLIST
>8025	95 e9					.word assembler_dictionary_start ; ASSEMBLER-WORDLIST
>8027	85 e1					.word root_dictionary_start	; ROOT-WORDLIST
>8029	00 00 00 00 00 00 00 00			.word 0,0,0,0,0,0,0,0		; User wordlists
>8031	00 00 00 00 00 00 00 00
>8039	02					.byte 2				; #ORDER
>803a	00 02 00 00 00 00 00 00			.byte wid_Forth,wid_Assembler,0,0,0,0,0,0,0	; search-order
>8042	00
=53					Cold_user_table_length = *-Cold_user_table
=$03					AscCC   = $03	; break (CTRL-c)
=$07					AscBELL = $07	; bell sound
=$08					AscBS   = $08	; backspace
=$09					AscHT	= $09	; tab
=$0a					AscLF   = $0a	; line feed
=$0b					AScVT	= $0b	; vertical tab
=$0c					AscFF	= $0c	; form feed
=$0d					AscCR   = $0d	; carriage return
=$0e					AscCN   = $0e	; CTRL-n (used to recall next input history)
=$10					AscCP   = $10	; CTRL-p (used to recall previous input history)
=$1b					AscESC  = $1b	; escape
=$20					AscSP   = $20	; space
=$22					AscDQuote = $22	; double quote
=$5c					AscBackslash = $5c ; backslash
=$7f					AscDEL  = $7f	; delete (CTRL-h)
>0000							.fill $80	; |  unused space |   To align the last char of name.
=127					wh_NameLastChar	= *-1		; |		  |   Last char of name.
>0080					wh_HashNameLen:			    .byte ?	; |
=$e0					wh_HashMask		=	    %11100000	; |      lo 3 bits of last char of name
=$1f					wh_NameLengthMask	=	    %00011111	; |      length of name
>0081					wh_Flags:			    .byte ?	; |  flag bits
=$01					FP	=			    %00000001	; |	Far previous NT (two byte pointer rather than one byte offset)
=$02					DB	=			    %00000010	; |	Disjoint body (two byte pointer rather than adjoining body code)
=$04					CO	=			    %00000100	; |	Compile Only
=$08					IM	=			    %00001000	; |     Immediate Word
=$10					NN	=			    %00010000	; |	    | 1 | 0 |  NN : Word can only be called by JSR (never native)
=$20					AN	=			    %00100000  	; |	    | 0 | 1 |  AN : Word can only be inlined (always native)
=$30					ST	=			    %00110000	; |	    | 1 | 1 |  ST : Normal word with return stack juggling that
=3					wh_HeaderExtendMask =		     FP+DB	; |	of the header length directly by adding 4 to `flags & %00000011`.
=$40					UF	=			    %01000000   ; |     strippable underflow
>0082					wh_CodeLength:			   .byte ?	; |  Code length  |   Code length for native compile, max 255
.0083					wh_LinkNt:
=0					WordFlags .var 0 ; initialize for macro
=0					XtPtr1  .var 0  ; initialize for macro
=0					WordListLink .var 0	 ; start of FORTH wordlist
>8043	43 6f 6c 64			Name0:	.text "Cold"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=32711					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>8047	84					.byte (("Cold"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=32711					LinkDisplacement = Nt0-WordListLink
=$11						  WordFlags ::= WordFlags | FP
>8048	11					.byte WordFlags	;wh_Flags
>8049	03					.byte 3	;wh_CodeLength
>804a	00 00					  .word WordListLink
=$804c					XtPtr1 ::= *
=32711					WordListLink ::= Nt0 ; remember the nt of this word for later
.804c					Cold:
.804c	d8		cld				cld
.804d	a2 ff		ldx #$ff			ldx #rsp0		; Initialize 6502 stack (Return Stack)
.804f	9a		txs				txs
.8050	a2 0d		ldx #$0d			ldx #Cold_zp_table_length-1 ; Initialize important zero page variables from ROM
.8052	bd 00 80	lda $8000,x	-		lda Cold_zp_table,x	;   We can use X here
.8055	95 00		sta $00,x			sta zp0,x		;   because Tali hasn't set up the param stack yet.
.8057	ca		dex				dex
.8058	10 f8		bpl $8052			bpl -
.805a	a0 34		ldy #$34			ldy #Cold_user_table_length-1	; Initialize the user variables.
.805c	b9 0e 80	lda $800e,y	-		lda Cold_user_table,y
.805f	99 ff 02	sta $02ff,y			sta User0,y
.8062	88		dey				dey
.8063	10 f7		bpl $805c			bpl -
.8065	20 4a c6	jsr $c64a			jsr Empty_Stack		; Clear Data Stack. This is repeated in ABORT, but this way we
.8068	20 3e b3	jsr $b33e			jsr BlockInit
.806b	20 b7 bc	jsr $bcb7			jsr CR
.806e	a9 9c		lda #$9c			lda #<forth_words_start		; push start address
.8070	a0 80		ldy #$80			ldy #>forth_words_start
.8072	20 2e c9	jsr $c92e			jsr PushYA
.8075	a9 d1		lda #$d1			lda #<forth_words_len		; push length
.8077	a0 00		ldy #$00			ldy #>forth_words_len
.8079	20 2e c9	jsr $c92e			jsr PushYA
.807c	20 67 c1	jsr $c167			jsr Evaluate
.807f	a9 00		lda #$00			lda #0
.8081	8d 66 07	sta $0766			sta hist_buff
.8084	8d e6 07	sta $07e6			sta hist_buff+$80
.8087	8d 66 08	sta $0866			sta hist_buff+$100
.808a	8d e6 08	sta $08e6			sta hist_buff+$180
.808d	8d 66 09	sta $0966			sta hist_buff+$200
.8090	8d e6 09	sta $09e6			sta hist_buff+$280
.8093	8d 66 0a	sta $0a66			sta hist_buff+$300
.8096	8d e6 0a	sta $0ae6			sta hist_buff+$380
.8099	4c fc c5	jmp $c5fc			jmp Abort_Core2	;Quit
=80					CodeLen	.var *-XtPtr1
=$809c					Here1 = *	; remember here
>8049	50					.byte CodeLen	;patch wh_CodeLength
>809c	20 63 72 20 2e 28 20 54		forth_words_start: .binary "forth_words.asc" ; High-level Forth words, see forth_code/README.md
>80a4	61 6c 69 20 46 6f 72 74 68 20 32 20 72 65 6d 69
>80b4	78 20 66 6f 72 20 74 68 65 20 36 35 30 32 29 20
>80c4	63 72 20 2e 28 20 56 65 72 73 69 6f 6e 20 32 38
>80d4	20 4d 61 79 20 32 30 32 35 20 29 20 63 72 20 2e
>80e4	28 20 43 6f 70 79 72 69 67 68 74 20 32 30 31 34
>80f4	2d 32 30 32 34 20 53 63 6f 74 20 57 2e 20 53 74
>8104	65 76 65 6e 73 6f 6e 2c 20 53 61 6d 20 43 6f 6c
>8114	77 65 6c 6c 29 20 63 72 20 2e 28 20 54 61 6c 69
>8124	20 46 6f 72 74 68 20 32 20 63 6f 6d 65 73 20 77
>8134	69 74 68 20 61 62 73 6f 6c 75 74 65 6c 79 20 4e
>8144	4f 20 57 41 52 52 41 4e 54 59 29 20 63 72 20 2e
>8154	28 20 54 79 70 65 20 27 62 79 65 27 20 74 6f 20
>8164	65 78 69 74 29 20 63 72 20
=209					forth_words_len = *-forth_words_start
>816d					user_words_start: .binary "user_words.asc" ; User-defined Forth words, see forth_code/README.md
=0					user_words_len = *-user_words_start
>816d	4e 6f 4f 70			Name0:	.text "NoOp"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=33009					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>8171	04					.byte (("NoOp"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=0					WordFlags ::= 0	; modifiable copy, remember for later
=298					LinkDisplacement = Nt0-WordListLink
=1						  WordFlags ::= WordFlags | FP
>8172	01					.byte WordFlags	;wh_Flags
>8173	03					.byte 3	;wh_CodeLength
>8174	c7 7f					  .word WordListLink
=$8176					XtPtr1 ::= *
=33009					WordListLink ::= Nt0 ; remember the nt of this word for later
.8176	ea		nop				nop
=1					CodeLen	.var *-XtPtr1
=$8177					Here1 = *	; remember here
>8173	01					.byte CodeLen	;patch wh_CodeLength
.8177	60		rts				rts
>8178	43 43 40			Name0:	.text "CC@"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=33019					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>817b	03					.byte (("CC@"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=10					LinkDisplacement = Nt0-WordListLink
=$12						  WordFlags ::= WordFlags | DB
>817c	12					.byte WordFlags	;wh_Flags
>817d	08					.byte 8	;wh_CodeLength
>817e	0a					  .byte LinkDisplacement	; offset to previous nt
>817f	38 f1					  .word platform_CCAT		; pointer to xt
=0					XtPtr1 ::= 0
=33019					WordListLink ::= Nt0 ; remember the nt of this word for later
>8181	42 79 65			Name0:	.text "Bye"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=33028					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>8184	a3					.byte (("Bye"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=9					LinkDisplacement = Nt0-WordListLink
=$12						  WordFlags ::= WordFlags | DB
>8185	12					.byte WordFlags	;wh_Flags
>8186	08					.byte 8	;wh_CodeLength
>8187	09					  .byte LinkDisplacement	; offset to previous nt
>8188	37 f1					  .word platform_bye		; pointer to xt
=0					XtPtr1 ::= 0
=33028					WordListLink ::= Nt0 ; remember the nt of this word for later
>818a	54 79 70 65 53 79 6d 62		Name0:	.text "TypeSymbol"	;  name of word as a string, ending at wh_NameLastChar
>8192	6f 6c
=10					NameLength = *-Name0
=33044					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>8194	8a					.byte (("TypeSymbol"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=16					LinkDisplacement = Nt0-WordListLink
>8195	10					.byte WordFlags	;wh_Flags
>8196	03					.byte 3	;wh_CodeLength
>8197	10					  .byte LinkDisplacement	; offset to previous nt
=$8198					XtPtr1 ::= *
=33044					WordListLink ::= Nt0 ; remember the nt of this word for later
.8198	20 4b ca	jsr $ca4b	TypeSymbol:	jsr SLiteral_runtime
.819b	4c a3 81	jmp $81a3			  jmp +
>819e	20 20 28 20 24					  .text "  ( $"
.81a3	20 f1 df	jsr $dff1	+		jsr Type
.81a6	20 8a e1	jsr $e18a			jsr Dup
.81a9	20 57 ba	jsr $ba57			jsr Dot_Hex
.81ac	20 e5 df	jsr $dfe5			jsr Space
.81af	20 d6 81	jsr $81d6			jsr DictSearchXt	; ( addr_end addr operand offset nt )
.81b2	20 85 cf	jsr $cf85			jsr Name_To_String	; Change nt into the name
.81b5	20 f1 df	jsr $dff1			jsr Type		; print it.
.81b8	20 e5 df	jsr $dfe5			jsr Space
.81bb	b5 26		lda $26,x			lda DStack+0,x		; if non-zero offset
.81bd	15 27		ora $27,x			ora DStack+1,x
.81bf	f0 0b		beq $81cc			beq +
.81c1	a9 2b		lda #$2b			lda #'+'		;   print offset
.81c3	20 cd df	jsr $dfcd			jsr Emit_A
.81c6	20 8a e1	jsr $e18a			jsr Dup
.81c9	20 f3 dd	jsr $ddf3			jsr U_Dot
.81cc	e8		inx		+		inx
.81cd	e8		inx				inx
.81ce	a9 29		lda #$29			lda #')'
.81d0	20 cd df	jsr $dfcd			jsr Emit_A
.81d3	4c e5 df	jmp $dfe5			jmp Space
=62					CodeLen	.var *-XtPtr1
=$81d6					Here1 = *	; remember here
>8196	3e					.byte CodeLen	;patch wh_CodeLength
.81d6					DictSearchXt:
.81d6	ca		dex				dex			; alloc nt
.81d7	ca		dex				dex
.81d8	20 61 e1	jsr $e161			jsr Over		; alloc xt
.81db	a9 ff		lda #$ff			lda #$ff		; init best offset
.81dd	95 2b		sta $2b,x			sta DStack+5,x		; ( offset nt xt )
.81df	a9 fe		lda #$fe			lda #$100-2		; for each wordlist
.81e1	48		pha				pha
.81e2	68		pla		_ListNext:	pla
.81e3	18		clc				clc
.81e4	69 02		adc #$02			adc #2			; to next wordlist
.81e6	c9 18		cmp #$18			cmp #max_wordlists*2
.81e8	b0 10		bcs $81fa			bcs _ListDone
.81ea	48		pha				pha
.81eb	a8		tay				tay
.81ec	b9 12 03	lda $0312,y			lda WordlistsV+0,y	; Get the DP for that wordlist.
.81ef	85 14		sta $14				sta tmp1+0
.81f1	b9 13 03	lda $0313,y			lda WordlistsV+1,y
.81f4	85 15		sta $15				sta tmp1+1
.81f6	d0 0a		bne $8202			bne _WordTest
.81f8	f0 e8		beq $81e2			beq _ListNext		;   empty list
.81fa	e8		inx		_ListDone:	inx			; Drop pattern xt
.81fb	e8		inx				inx			; ( offset nt )
.81fc	60		rts				rts
.81fd	20 95 82	jsr $8295	_WordNext:	jsr LinkNext		; tmp1= next nt in list
.8200	f0 e0		beq $81e2			beq _ListNext		; end of Dictionary?
.8202	20 49 cf	jsr $cf49	_WordTest:	jsr NameToIntTmp	; tmp2 = xt of this word
.8205	38		sec				sec			; tmp3 = xt offset for this word
.8206	b5 26		lda $26,x			lda DStack+0,x
.8208	e5 16		sbc $16				sbc tmp2+0
.820a	85 18		sta $18				sta tmp3+0
.820c	b5 27		lda $27,x			lda DStack+1,x
.820e	e5 17		sbc $17				sbc tmp2+1
.8210	85 19		sta $19				sta tmp3+1
.8212	20 7a 82	jsr $827a			jsr _test
.8215	a0 00		ldy #$00			ldy #0			; is this word a constant?
.8217	b1 16		lda ($16),y			lda (tmp2),y
.8219	c9 a0		cmp #$a0			cmp #$a0
.821b	f0 2a		beq $8247			beq _PushYA
.821d	c9 a9		cmp #$a9			cmp #$a9
.821f	f0 02		beq $8223			beq _PushZA
.8221	d0 da		bne $81fd			bne _WordNext
.8223	c8		iny		_PushZA:	iny			; get lda # operand
.8224	b5 26		lda $26,x			lda DStack+0,x
.8226	f1 16		sbc ($16),y			sbc (tmp2),y
.8228	85 18		sta $18				sta tmp3+0
.822a	b5 27		lda $27,x			lda DStack+1,x
.822c	e9 00		sbc #$00			sbc #0
.822e	85 19		sta $19				sta tmp3+1
.8230	c8		iny				iny			; check jmp opcode
.8231	b1 16		lda ($16),y			lda (tmp2),y
.8233	c9 4c		cmp #$4c			cmp #$4c
.8235	d0 c6		bne $81fd			bne _WordNext
.8237	c8		iny				iny			; check jmp operand lo
.8238	b1 16		lda ($16),y			lda (tmp2),y
.823a	c9 5d		cmp #$5d			cmp #<PushZA
.823c	d0 bf		bne $81fd			bne _WordNext
.823e	c8		iny				iny			; check jmp operand hi
.823f	b1 16		lda ($16),y			lda (tmp2),y
.8241	c9 c9		cmp #$c9			cmp #>PushZA
.8243	f0 2f		beq $8274			beq _KTest
.8245	d0 b6		bne $81fd			bne _WordNext
.8247	a0 02		ldy #$02	_PushYA:	ldy #2			; check LDA # opcode
.8249	b1 16		lda ($16),y			lda (tmp2),y
.824b	c9 a9		cmp #$a9			cmp #$a9
.824d	d0 ae		bne $81fd			bne _WordNext
.824f	c8		iny				iny			; get lda # operand
.8250	b5 26		lda $26,x			lda DStack+0,x
.8252	f1 16		sbc ($16),y			sbc (tmp2),y
.8254	85 18		sta $18				sta tmp3+0
.8256	a0 01		ldy #$01			ldy #1			; get LDY # operand
.8258	b5 27		lda $27,x			lda DStack+1,x
.825a	f1 16		sbc ($16),y			sbc (tmp2),y
.825c	85 19		sta $19				sta tmp3+1
.825e	a0 04		ldy #$04			ldy #4			; check JMP opcode
.8260	b1 16		lda ($16),y			lda (tmp2),y
.8262	c9 4c		cmp #$4c			cmp #$4c
.8264	d0 97		bne $81fd			bne _WordNext
.8266	c8		iny				iny			; check JMP operand lo
.8267	b1 16		lda ($16),y			lda (tmp2),y
.8269	c9 2e		cmp #$2e			cmp #<PushYA
.826b	d0 0a		bne $8277			bne _WordNext3
.826d	c8		iny				iny			; check JMP operand hi
.826e	b1 16		lda ($16),y			lda (tmp2),y
.8270	c9 c9		cmp #$c9			cmp #>PushYA
.8272	d0 03		bne $8277			bne _WordNext3
.8274	20 7a 82	jsr $827a	_KTest:		jsr _test
.8277	4c fd 81	jmp $81fd	_WordNext3:	jmp _WordNext
.827a					_test:
.827a	a5 18		lda $18				lda tmp3+0		; this word have smaller offset?
.827c	d5 2a		cmp $2a,x			cmp DStack+4,x
.827e	a5 19		lda $19				lda tmp3+1
.8280	f5 2b		sbc $2b,x			sbc DStack+5,x
.8282	b0 10		bcs $8294			bcs _trts
.8284	a5 18		lda $18				lda tmp3+0		;   save this better offset
.8286	a4 19		ldy $19				ldy tmp3+1
.8288	95 2a		sta $2a,x			sta DStack+4,x
.828a	94 2b		sty $2b,x			sty DStack+5,x
.828c	a5 14		lda $14				lda tmp1+0		;   save this better nt
.828e	a4 15		ldy $15				ldy tmp1+1
.8290	95 28		sta $28,x			sta DStack+2,x
.8292	94 29		sty $29,x			sty DStack+3,x
.8294	60		rts		_trts:		rts
.8295					LinkNext:
.8295	a0 81		ldy #$81			ldy #wh_Flags		; which kind of wh_LinkNt?
.8297	b1 14		lda ($14),y			lda (tmp1),y
.8299	29 01		and #$01			and #FP
.829b	f0 0e		beq $82ab			beq _LinkShort
.829d	a0 84		ldy #$84	_LinkLong:	ldy #wh_LinkNt+1	; tmp1 = tmp1->LinkNt (ptr)
.829f	b1 14		lda ($14),y			lda (tmp1),y
.82a1	48		pha				pha
.82a2	88		dey				dey
.82a3	b1 14		lda ($14),y			lda (tmp1),y
.82a5	85 14		sta $14				sta tmp1+0
.82a7	68		pla				pla
.82a8	85 15		sta $15				sta tmp1+1
.82aa	60		rts				rts
.82ab	a0 83		ldy #$83	_LinkShort:	ldy #wh_LinkNt		; tmp1 -= tmp1->LinkNt byte offset
.82ad	38		sec				sec
.82ae	a5 14		lda $14				lda tmp1+0
.82b0	f1 14		sbc ($14),y			sbc (tmp1),y
.82b2	85 14		sta $14				sta tmp1+0
.82b4	a5 15		lda $15				lda tmp1+1
.82b6	e9 00		sbc #$00			sbc #0
.82b8	85 15		sta $15				sta tmp1+1
.82ba	60		rts				rts
>82bb	44 53 74 61 63 6b		Name0:	.text "DStack"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=33345					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>82c1	66					.byte (("DStack"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=301					LinkDisplacement = Nt0-WordListLink
=$11						  WordFlags ::= WordFlags | FP
>82c2	11					.byte WordFlags	;wh_Flags
>82c3	03					.byte 3	;wh_CodeLength
>82c4	14 81					  .word WordListLink
=$82c6					XtPtr1 ::= *
=33345					WordListLink ::= Nt0 ; remember the nt of this word for later
.82c6	a9 26		lda #$26			lda #DStack
.82c8	4c 5d c9	jmp $c95d			jmp PushZA
=5					CodeLen	.var *-XtPtr1
=$82cb					Here1 = *	; remember here
>82c3	05					.byte CodeLen	;patch wh_CodeLength
>82cb	52 53 74 61 63 6b		Name0:	.text "RStack"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=33361					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>82d1	66					.byte (("RStack"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=16					LinkDisplacement = Nt0-WordListLink
>82d2	10					.byte WordFlags	;wh_Flags
>82d3	03					.byte 3	;wh_CodeLength
>82d4	10					  .byte LinkDisplacement	; offset to previous nt
=$82d5					XtPtr1 ::= *
=33361					WordListLink ::= Nt0 ; remember the nt of this word for later
.82d5	a9 00		lda #$00			lda #<RStack
.82d7	a0 01		ldy #$01			ldy #>RStack
.82d9	4c 2e c9	jmp $c92e			jmp PushYA
=7					CodeLen	.var *-XtPtr1
=$82dc					Here1 = *	; remember here
>82d3	07					.byte CodeLen	;patch wh_CodeLength
>82dc	52 6e 64 53 74 61 74 65		Name0:	.text "RndState"	;  name of word as a string, ending at wh_NameLastChar
=8					NameLength = *-Name0
=33380					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>82e4	a8					.byte (("RndState"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=19					LinkDisplacement = Nt0-WordListLink
>82e5	10					.byte WordFlags	;wh_Flags
>82e6	03					.byte 3	;wh_CodeLength
>82e7	13					  .byte LinkDisplacement	; offset to previous nt
=$82e8					XtPtr1 ::= *
=33380					WordListLink ::= Nt0 ; remember the nt of this word for later
.82e8	a9 35		lda #$35			lda #<RndState
.82ea	a0 03		ldy #$03			ldy #>RndState
.82ec	4c 2e c9	jmp $c92e			jmp PushYA
=7					CodeLen	.var *-XtPtr1
=$82ef					Here1 = *	; remember here
>82e6	07					.byte CodeLen	;patch wh_CodeLength
>82ef	52 61 6e 64			Name0:	.text "Rand"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=33395					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>82f3	84					.byte (("Rand"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=0					WordFlags ::= 0	; modifiable copy, remember for later
=15					LinkDisplacement = Nt0-WordListLink
>82f4	00					.byte WordFlags	;wh_Flags
>82f5	03					.byte 3	;wh_CodeLength
>82f6	0f					  .byte LinkDisplacement	; offset to previous nt
=$82f7					XtPtr1 ::= *
=33395					WordListLink ::= Nt0 ; remember the nt of this word for later
.82f7					Rand:
.82f7	4e 36 03	lsr $0336			lsr RndState+1
.82fa	6e 35 03	ror $0335			ror RndState+0
.82fd	6e 38 03	ror $0338			ror RndState+3
.8300	6e 37 03	ror $0337			ror RndState+2
.8303	90 10		bcc $8315			bcc _19			;  IfCs,
.8305	ad 36 03	lda $0336			lda RndState+1
.8308	49 d0		eor #$d0			eor #$d0
.830a	8d 36 03	sta $0336			sta RndState+1
.830d	ad 37 03	lda $0337			lda RndState+2
.8310	49 01		eor #$01			eor #$01
.8312	8d 37 03	sta $0337			sta RndState+2
.8315					_19:
.8315	ad 37 03	lda $0337			lda RndState+2
.8318	ac 38 03	ldy $0338			ldy RndState+3
=36					CodeLen	.var *-XtPtr1
=$831b					Here1 = *	; remember here
>82f5	24					.byte CodeLen	;patch wh_CodeLength
.831b	60		rts				rts
>831c	52 61 6e 64 4d			Name0:	.text "RandM"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=33441					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>8321	a5					.byte (("RandM"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=46					LinkDisplacement = Nt0-WordListLink
>8322	10					.byte WordFlags	;wh_Flags
>8323	03					.byte 3	;wh_CodeLength
>8324	2e					  .byte LinkDisplacement	; offset to previous nt
=$8325					XtPtr1 ::= *
=33441					WordListLink ::= Nt0 ; remember the nt of this word for later
.8325	20 8a e1	jsr $e18a	RandM:		jsr Dup		; ( umod umod )
.8328	20 f7 82	jsr $82f7			jsr Rand
.832b	4a		lsr a				lsr a		; make positive
.832c	95 29		sta $29,x			sta DStack+3,x
.832e	94 28		sty $28,x			sty DStack+2,x	; ( rand umod )
.8330	4c dd c0	jmp $c0dd			jmp Mod
=14					CodeLen	.var *-XtPtr1
=$8333					Here1 = *	; remember here
>8323	0e					.byte CodeLen	;patch wh_CodeLength
>0056					FIndex:	.byte ?		; floating-point stack index. empty=FSDim, full=0
>0057					FSExp:   .fill FSDim	; byte array[FSDim] FP stack exponent
>0061					FSMant0: .fill FSDim	; byte array[FSDim] FP stack mantissa MSByte
>006b					FSMant1: .fill FSDim	; byte array[FSDim] FP stack mantissa 2nd
>0075					FSMant2: .fill FSDim	; byte array[FSDim] FP stack mantissa 3rd
>007f					FSMant3: .fill FSDim	; byte array[FSDim] FP stack mantissa 4th
>8333	46 49 6e 64 65 78		Name0:	.text "FIndex"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=33465					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>8339	06					.byte (("FIndex"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=24					LinkDisplacement = Nt0-WordListLink
>833a	10					.byte WordFlags	;wh_Flags
>833b	03					.byte 3	;wh_CodeLength
>833c	18					  .byte LinkDisplacement	; offset to previous nt
=$833d					XtPtr1 ::= *
=33465					WordListLink ::= Nt0 ; remember the nt of this word for later
.833d	a9 56		lda #$56			lda #FIndex
.833f	4c 5d c9	jmp $c95d			jmp PushZA
=5					CodeLen	.var *-XtPtr1
=$8342					Here1 = *	; remember here
>833b	05					.byte CodeLen	;patch wh_CodeLength
>8342	46 53 44 69 6d			Name0:	.text "FSDim"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=33479					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>8347	a5					.byte (("FSDim"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=14					LinkDisplacement = Nt0-WordListLink
>8348	10					.byte WordFlags	;wh_Flags
>8349	03					.byte 3	;wh_CodeLength
>834a	0e					  .byte LinkDisplacement	; offset to previous nt
=$834b					XtPtr1 ::= *
=33479					WordListLink ::= Nt0 ; remember the nt of this word for later
.834b	a9 0a		lda #$0a			lda #FSDim
.834d	4c 5d c9	jmp $c95d			jmp PushZA
=5					CodeLen	.var *-XtPtr1
=$8350					Here1 = *	; remember here
>8349	05					.byte CodeLen	;patch wh_CodeLength
>8350	46 53 45 78 70			Name0:	.text "FSExp"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=33493					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>8355	05					.byte (("FSExp"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=14					LinkDisplacement = Nt0-WordListLink
>8356	10					.byte WordFlags	;wh_Flags
>8357	03					.byte 3	;wh_CodeLength
>8358	0e					  .byte LinkDisplacement	; offset to previous nt
=$8359					XtPtr1 ::= *
=33493					WordListLink ::= Nt0 ; remember the nt of this word for later
.8359	a9 57		lda #$57			lda #FSExp
.835b	4c 5d c9	jmp $c95d			jmp PushZA
=5					CodeLen	.var *-XtPtr1
=$835e					Here1 = *	; remember here
>8357	05					.byte CodeLen	;patch wh_CodeLength
>835e	46 53 4d 61 6e 74 30		Name0:	.text "FSMant0"	;  name of word as a string, ending at wh_NameLastChar
=7					NameLength = *-Name0
=33509					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>8365	07					.byte (("FSMant0"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=16					LinkDisplacement = Nt0-WordListLink
>8366	10					.byte WordFlags	;wh_Flags
>8367	03					.byte 3	;wh_CodeLength
>8368	10					  .byte LinkDisplacement	; offset to previous nt
=$8369					XtPtr1 ::= *
=33509					WordListLink ::= Nt0 ; remember the nt of this word for later
.8369	a9 61		lda #$61			lda #FSMant0
.836b	4c 5d c9	jmp $c95d			jmp PushZA
=5					CodeLen	.var *-XtPtr1
=$836e					Here1 = *	; remember here
>8367	05					.byte CodeLen	;patch wh_CodeLength
>836e	46 53 4d 61 6e 74 31		Name0:	.text "FSMant1"	;  name of word as a string, ending at wh_NameLastChar
=7					NameLength = *-Name0
=33525					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>8375	27					.byte (("FSMant1"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=16					LinkDisplacement = Nt0-WordListLink
>8376	10					.byte WordFlags	;wh_Flags
>8377	03					.byte 3	;wh_CodeLength
>8378	10					  .byte LinkDisplacement	; offset to previous nt
=$8379					XtPtr1 ::= *
=33525					WordListLink ::= Nt0 ; remember the nt of this word for later
.8379	a9 6b		lda #$6b			lda #FSMant1
.837b	4c 5d c9	jmp $c95d			jmp PushZA
=5					CodeLen	.var *-XtPtr1
=$837e					Here1 = *	; remember here
>8377	05					.byte CodeLen	;patch wh_CodeLength
>837e	46 53 4d 61 6e 74 32		Name0:	.text "FSMant2"	;  name of word as a string, ending at wh_NameLastChar
=7					NameLength = *-Name0
=33541					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>8385	47					.byte (("FSMant2"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=16					LinkDisplacement = Nt0-WordListLink
>8386	10					.byte WordFlags	;wh_Flags
>8387	03					.byte 3	;wh_CodeLength
>8388	10					  .byte LinkDisplacement	; offset to previous nt
=$8389					XtPtr1 ::= *
=33541					WordListLink ::= Nt0 ; remember the nt of this word for later
.8389	a9 75		lda #$75			lda #FSMant2
.838b	4c 5d c9	jmp $c95d			jmp PushZA
=5					CodeLen	.var *-XtPtr1
=$838e					Here1 = *	; remember here
>8387	05					.byte CodeLen	;patch wh_CodeLength
>838e	46 53 4d 61 6e 74 33		Name0:	.text "FSMant3"	;  name of word as a string, ending at wh_NameLastChar
=7					NameLength = *-Name0
=33557					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>8395	67					.byte (("FSMant3"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=16					LinkDisplacement = Nt0-WordListLink
>8396	10					.byte WordFlags	;wh_Flags
>8397	03					.byte 3	;wh_CodeLength
>8398	10					  .byte LinkDisplacement	; offset to previous nt
=$8399					XtPtr1 ::= *
=33557					WordListLink ::= Nt0 ; remember the nt of this word for later
.8399	a9 7f		lda #$7f			lda #FSMant3
.839b	4c 5d c9	jmp $c95d			jmp PushZA
=5					CodeLen	.var *-XtPtr1
=$839e					Here1 = *	; remember here
>8397	05					.byte CodeLen	;patch wh_CodeLength
=5					Float_Size = 5 ; # of bytes in memory for a float
>839e	46 6c 6f 61 74			Name0:	.text "Float"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=33571					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>83a3	85					.byte (("Float"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=14					LinkDisplacement = Nt0-WordListLink
>83a4	10					.byte WordFlags	;wh_Flags
>83a5	03					.byte 3	;wh_CodeLength
>83a6	0e					  .byte LinkDisplacement	; offset to previous nt
=$83a7					XtPtr1 ::= *
=33571					WordListLink ::= Nt0 ; remember the nt of this word for later
.83a7	a9 05		lda #$05	Float:		lda #Float_Size
.83a9	4c 5d c9	jmp $c95d			jmp PushZA
=5					CodeLen	.var *-XtPtr1
=$83ac					Here1 = *	; remember here
>83a5	05					.byte CodeLen	;patch wh_CodeLength
>83ac	46 6c 6f 61 74 2b		Name0:	.text "Float+"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=33586					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>83b2	66					.byte (("Float+"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=15					LinkDisplacement = Nt0-WordListLink
>83b3	10					.byte WordFlags	;wh_Flags
>83b4	03					.byte 3	;wh_CodeLength
>83b5	0f					  .byte LinkDisplacement	; offset to previous nt
=$83b6					XtPtr1 ::= *
=33586					WordListLink ::= Nt0 ; remember the nt of this word for later
.83b6	a9 05		lda #$05	FloatPlus:	lda #Float_Size
.83b8	4c da db	jmp $dbda			jmp Plus_A
=5					CodeLen	.var *-XtPtr1
=$83bb					Here1 = *	; remember here
>83b4	05					.byte CodeLen	;patch wh_CodeLength
>83bb	46 6c 6f 61 74 73		Name0:	.text "Floats"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=33601					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>83c1	66					.byte (("Floats"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=15					LinkDisplacement = Nt0-WordListLink
>83c2	10					.byte WordFlags	;wh_Flags
>83c3	03					.byte 3	;wh_CodeLength
>83c4	0f					  .byte LinkDisplacement	; offset to previous nt
=$83c5					XtPtr1 ::= *
=33601					WordListLink ::= Nt0 ; remember the nt of this word for later
.83c5	20 a7 83	jsr $83a7	Floats:		jsr Float
.83c8	4c f3 bf	jmp $bff3			jmp Star
=6					CodeLen	.var *-XtPtr1
=$83cb					Here1 = *	; remember here
>83c3	06					.byte CodeLen	;patch wh_CodeLength
>83cb	46 41 6c 69 67 6e		Name0:	.text "FAlign"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=33617					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>83d1	c6					.byte (("FAlign"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=0					WordFlags ::= 0	; modifiable copy, remember for later
=16					LinkDisplacement = Nt0-WordListLink
>83d2	00					.byte WordFlags	;wh_Flags
>83d3	03					.byte 3	;wh_CodeLength
>83d4	10					  .byte LinkDisplacement	; offset to previous nt
=$83d5					XtPtr1 ::= *
=33617					WordListLink ::= Nt0 ; remember the nt of this word for later
.83d5					FAlign:
=0					CodeLen	.var *-XtPtr1
=$83d5					Here1 = *	; remember here
>83d3	00					.byte CodeLen	;patch wh_CodeLength
.83d5	60		rts				rts
>83d6	46 41 6c 69 67 6e 65 64		Name0:	.text "FAligned"	;  name of word as a string, ending at wh_NameLastChar
=8					NameLength = *-Name0
=33630					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>83de	88					.byte (("FAligned"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=0					WordFlags ::= 0	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>83df	00					.byte WordFlags	;wh_Flags
>83e0	03					.byte 3	;wh_CodeLength
>83e1	0d					  .byte LinkDisplacement	; offset to previous nt
=$83e2					XtPtr1 ::= *
=33630					WordListLink ::= Nt0 ; remember the nt of this word for later
.83e2					FAligned:
=0					CodeLen	.var *-XtPtr1
=$83e2					Here1 = *	; remember here
>83e0	00					.byte CodeLen	;patch wh_CodeLength
.83e2	60		rts				rts
>83e3	48 65 78 3e 46			Name0:	.text "Hex>F"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=33640					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>83e8	c5					.byte (("Hex>F"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=10					LinkDisplacement = Nt0-WordListLink
>83e9	10					.byte WordFlags	;wh_Flags
>83ea	03					.byte 3	;wh_CodeLength
>83eb	0a					  .byte LinkDisplacement	; offset to previous nt
=$83ec					XtPtr1 ::= *
=33640					WordListLink ::= Nt0 ; remember the nt of this word for later
.83ec	20 d4 84	jsr $84d4	PartsToF:	jsr FAllocX		; alloc FP stack entry, X= FP stack index
.83ef	a6 14		ldx $14				ldx tmp1+0		; restore data stack index
.83f1	a4 56		ldy $56				ldy FIndex		; Y= FP stack index
.83f3	20 47 c5	jsr $c547			jsr PopA		; pop n_exp
.83f6	99 57 00	sta $0057,y			sta FSExp,y
.83f9	b5 27		lda $27,x			lda DStack+1,x
.83fb	99 61 00	sta $0061,y			sta FSMant0,y
.83fe	b5 26		lda $26,x			lda DStack+0,x
.8400	99 6b 00	sta $006b,y			sta FSMant1,y
.8403	b5 29		lda $29,x			lda DStack+3,x
.8405	99 75 00	sta $0075,y			sta FSMant2,y
.8408	b5 28		lda $28,x			lda DStack+2,x
.840a	99 7f 00	sta $007f,y			sta FSMant3,y
.840d	4c 04 d7	jmp $d704			jmp Two_Drop
=36					CodeLen	.var *-XtPtr1
=$8410					Here1 = *	; remember here
>83ea	24					.byte CodeLen	;patch wh_CodeLength
>8410	46 3e 48 65 78			Name0:	.text "F>Hex"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=33685					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>8415	05					.byte (("F>Hex"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=45					LinkDisplacement = Nt0-WordListLink
>8416	10					.byte WordFlags	;wh_Flags
>8417	03					.byte 3	;wh_CodeLength
>8418	2d					  .byte LinkDisplacement	; offset to previous nt
=$8419					XtPtr1 ::= *
=33685					WordListLink ::= Nt0 ; remember the nt of this word for later
.8419	a4 56		ldy $56		FToParts:	ldy FIndex	; Y= FP stack index
.841b	c0 0a		cpy #$0a			cpy #FSDim-0	; check FP stack for >=1 entries
.841d	b0 47		bcs $8466			bcs Throw_FPStack_10
.841f	ca		dex				dex		; alloc d_mantissa
.8420	ca		dex				dex
.8421	ca		dex				dex
.8422	ca		dex				dex
.8423	ca		dex				dex		; alloc n_exponent
.8424	ca		dex				dex
.8425	b9 61 00	lda $0061,y			lda FSMant0,y	; copy mantissa
.8428	95 29		sta $29,x			sta DStack+3,x
.842a	b9 6b 00	lda $006b,y			lda FSMant1,y
.842d	95 28		sta $28,x			sta DStack+2,x
.842f	b9 75 00	lda $0075,y			lda FSMant2,y
.8432	95 2b		sta $2b,x			sta DStack+5,x
.8434	b9 7f 00	lda $007f,y			lda FSMant3,y
.8437	95 2a		sta $2a,x			sta DStack+4,x
.8439	b9 57 00	lda $0057,y			lda FSExp,y	; copy exponent
.843c	95 26		sta $26,x			sta DStack+0,x
.843e	29 80		and #$80			and #$80	;   sign extend
.8440	f0 02		beq $8444			beq +
.8442	a9 ff		lda #$ff			lda #$ff
.8444	95 27		sta $27,x	+		sta DStack+1,x
.8446	e6 56		inc $56				inc FIndex	; FDrop r
=47					CodeLen	.var *-XtPtr1
=$8448					Here1 = *	; remember here
>8417	2f					.byte CodeLen	;patch wh_CodeLength
.8448	60		rts				rts
>8449	46 2e 48 65 78			Name0:	.text "F.Hex"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=33742					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>844e	05					.byte (("F.Hex"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=57					LinkDisplacement = Nt0-WordListLink
>844f	10					.byte WordFlags	;wh_Flags
>8450	03					.byte 3	;wh_CodeLength
>8451	39					  .byte LinkDisplacement	; offset to previous nt
=$8452					XtPtr1 ::= *
=33742					WordListLink ::= Nt0 ; remember the nt of this word for later
.8452	20 19 84	jsr $8419	FDotHex:	jsr FToParts	; get parts of r
.8455	20 90 e0	jsr $e090			jsr Not_Rot
.8458	20 57 ba	jsr $ba57			jsr Dot_Hex	; do mantissa
.845b	20 57 ba	jsr $ba57			jsr Dot_Hex
.845e	a9 3a		lda #$3a			lda #':'
.8460	20 cd df	jsr $dfcd			jsr Emit_A
.8463	4c 36 ba	jmp $ba36			jmp C_Dot_Hex	; do exponent
=20					CodeLen	.var *-XtPtr1
=$8466					Here1 = *	; remember here
>8450	14					.byte CodeLen	;patch wh_CodeLength
.8466	4c dd 84	jmp $84dd	Throw_FPStack_10: jmp Throw_FPStack
>8469	46 43 6d 70 41			Name0:	.text "FCmpA"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=33774					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>846e	25					.byte (("FCmpA"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=32					LinkDisplacement = Nt0-WordListLink
>846f	10					.byte WordFlags	;wh_Flags
>8470	03					.byte 3	;wh_CodeLength
>8471	20					  .byte LinkDisplacement	; offset to previous nt
=$8472					XtPtr1 ::= *
=33774					WordListLink ::= Nt0 ; remember the nt of this word for later
.8472	86 14		stx $14		FCmpA:		stx tmp1		; save data stack index
.8474	a6 56		ldx $56				ldx FIndex		; X= FP stack index
.8476	e0 09		cpx #$09			cpx #FSDim-1		; check FP stack for >=2 entries
.8478	b0 ec		bcs $8466			bcs Throw_FPStack_10
.847a	b5 61		lda $61,x			lda FSMant0+0,x		; r2 mantissa == 0 ?
.847c	f0 35		beq $84b3			beq _r2Zero
.847e	b4 62		ldy $62,x			ldy FSMant0+1,x		; r1 mantissa == 0 ?
.8480	f0 2b		beq $84ad			beq _r1Zero
.8482	55 62		eor $62,x			eor FSMant0+1,x		; compare mantissa sign
.8484	30 3d		bmi $84c3			bmi _MantissaSignDifferent
.8486	38		sec				sec			; compare exponent
.8487	b5 58		lda $58,x			lda FSExp+1,x
.8489	f5 57		sbc $57,x			sbc FSExp+0,x
.848b	d0 2b		bne $84b8			bne _ExponentDifferent
.848d	98		tya				tya			; compare mantissa MSB
.848e	f5 61		sbc $61,x			sbc FSMant0+0,x		;   always same sign so can't overflow
.8490	d0 17		bne $84a9			bne _13
.8492	b5 6c		lda $6c,x			lda FSMant1+1,x		; compare mantissa 1
.8494	f5 6b		sbc $6b,x			sbc FSMant1+0,x
.8496	d0 0c		bne $84a4			bne _12
.8498	b5 76		lda $76,x			lda FSMant2+1,x		; compare mantissa 2
.849a	f5 75		sbc $75,x			sbc FSMant2+0,x
.849c	d0 06		bne $84a4			bne _12
.849e	b5 80		lda $80,x			lda FSMant3+1,x		; compare mantissa LSB
.84a0	f5 7f		sbc $7f,x			sbc FSMant3+0,x
.84a2	f0 05		beq $84a9			beq _13
.84a4	6a		ror a		_12:		ror a
.84a5	49 80		eor #$80	_14:		eor #$80
.84a7	09 01		ora #$01			ora #1
.84a9	a6 14		ldx $14		_13:		ldx tmp1		; restore data stack index
.84ab	a8		tay				tay			; set CPU flags
.84ac	60		rts				rts
.84ad	b5 61		lda $61,x	_r1Zero:	lda FSMant0+0,x		; return 0-r2
.84af	d0 f4		bne $84a5			bne _14
.84b1	f0 f6		beq $84a9			beq _13
.84b3	b5 62		lda $62,x	_r2Zero:	lda FSMant0+1,x		; return r1
.84b5	4c a9 84	jmp $84a9			jmp _13
.84b8					_ExponentDifferent:
.84b8	50 02		bvc $84bc			bvc +
.84ba	49 80		eor #$80			eor #$80
.84bc					+
.84bc	55 61		eor $61,x			eor FSMant0+0,x
.84be	a6 14		ldx $14				ldx tmp1		; restore data stack index
.84c0	09 01		ora #$01			ora #1			; set CPU flags
.84c2	60		rts				rts
.84c3					_MantissaSignDifferent:
.84c3	98		tya				tya
.84c4	a6 14		ldx $14				ldx tmp1		; restore data stack index
.84c6	09 01		ora #$01			ora #1
.84c8	60		rts				rts
=87					CodeLen	.var *-XtPtr1
=$84c9					Here1 = *	; remember here
>8470	57					.byte CodeLen	;patch wh_CodeLength
>84c9	46 41 6c 6c 6f 63 58		Name0:	.text "FAllocX"	;  name of word as a string, ending at wh_NameLastChar
=7					NameLength = *-Name0
=33872					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>84d0	07					.byte (("FAllocX"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=98					LinkDisplacement = Nt0-WordListLink
>84d1	10					.byte WordFlags	;wh_Flags
>84d2	03					.byte 3	;wh_CodeLength
>84d3	62					  .byte LinkDisplacement	; offset to previous nt
=$84d4					XtPtr1 ::= *
=33872					WordListLink ::= Nt0 ; remember the nt of this word for later
.84d4					FAllocX:
.84d4	86 14		stx $14				stx tmp1		; save data stack index
.84d6	c6 56		dec $56				dec FIndex		; alloc FP stack entry
.84d8	30 03		bmi $84dd			bmi Throw_FpStack	;   if FP stack overflow (or massive underflow)
.84da	a6 56		ldx $56				ldx FIndex		; X= floating point stack index
=8					CodeLen	.var *-XtPtr1
=$84dc					Here1 = *	; remember here
>84d2	08					.byte CodeLen	;patch wh_CodeLength
.84dc	60		rts				rts		; return X= FP stack index
.84dd					Throw_FPStack:
.84dd	30 05		bmi $84e4			bmi _over
.84df	a9 d3		lda #$d3			lda #$100+err_FPStackUnderflow
.84e1	4c dc c5	jmp $c5dc	_9:		jmp ThrowA
.84e4	a9 d4		lda #$d4	_over:		lda #$100+err_FPStackOverflow
.84e6	d0 f9		bne $84e1			bne _9
.84e8					Throw_FpOutOfRange:
.84e8	a9 d5		lda #$d5			lda #$100+err_FpOutOfRange
.84ea	4c dc c5	jmp $c5dc			jmp ThrowA
>84ed	46 4d 61 78			Name0:	.text "FMax"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=33905					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>84f1	04					.byte (("FMax"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=33					LinkDisplacement = Nt0-WordListLink
>84f2	10					.byte WordFlags	;wh_Flags
>84f3	03					.byte 3	;wh_CodeLength
>84f4	21					  .byte LinkDisplacement	; offset to previous nt
=$84f5					XtPtr1 ::= *
=33905					WordListLink ::= Nt0 ; remember the nt of this word for later
.84f5	20 72 84	jsr $8472	FMax:		jsr FCmpA
.84f8	10 2c		bpl $8526			bpl FDrop
.84fa	30 4d		bmi $8549			bmi FNip
=7					CodeLen	.var *-XtPtr1
=$84fc					Here1 = *	; remember here
>84f3	07					.byte CodeLen	;patch wh_CodeLength
>84fc	46 4d 69 6e			Name0:	.text "FMin"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=33920					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>8500	c4					.byte (("FMin"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=15					LinkDisplacement = Nt0-WordListLink
>8501	10					.byte WordFlags	;wh_Flags
>8502	03					.byte 3	;wh_CodeLength
>8503	0f					  .byte LinkDisplacement	; offset to previous nt
=$8504					XtPtr1 ::= *
=33920					WordListLink ::= Nt0 ; remember the nt of this word for later
.8504	20 72 84	jsr $8472	FMin:		jsr FCmpA
.8507	30 1d		bmi $8526			bmi FDrop
.8509	10 3e		bpl $8549			bpl FNip
=7					CodeLen	.var *-XtPtr1
=$850b					Here1 = *	; remember here
>8502	07					.byte CodeLen	;patch wh_CodeLength
>850b	46 44 65 70 74 68		Name0:	.text "FDepth"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=33937					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>8511	06					.byte (("FDepth"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=17					LinkDisplacement = Nt0-WordListLink
>8512	10					.byte WordFlags	;wh_Flags
>8513	03					.byte 3	;wh_CodeLength
>8514	11					  .byte LinkDisplacement	; offset to previous nt
=$8515					XtPtr1 ::= *
=33937					WordListLink ::= Nt0 ; remember the nt of this word for later
.8515	a9 0a		lda #$0a	FDepth:		lda #FSDim
.8517	38		sec				sec
.8518	e5 56		sbc $56				sbc FIndex
.851a	4c 5d c9	jmp $c95d			jmp PushZA
=8					CodeLen	.var *-XtPtr1
=$851d					Here1 = *	; remember here
>8513	08					.byte CodeLen	;patch wh_CodeLength
>851d	46 44 72 6f 70			Name0:	.text "FDrop"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=33954					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>8522	05					.byte (("FDrop"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=17					LinkDisplacement = Nt0-WordListLink
>8523	10					.byte WordFlags	;wh_Flags
>8524	03					.byte 3	;wh_CodeLength
>8525	11					  .byte LinkDisplacement	; offset to previous nt
=$8526					XtPtr1 ::= *
=33954					WordListLink ::= Nt0 ; remember the nt of this word for later
.8526	a5 56		lda $56		FDrop:		lda FIndex	; load FP stack index
.8528	c9 0a		cmp #$0a			cmp #FSDim	; check FP stack for >=1 entries
.852a	b0 12		bcs $853e			bcs Throw_FPStack_10a
.852c	e6 56		inc $56				inc FIndex
=8					CodeLen	.var *-XtPtr1
=$852e					Here1 = *	; remember here
>8524	08					.byte CodeLen	;patch wh_CodeLength
.852e	60		rts				rts
>852f	46 32 44 72 6f 70		Name0:	.text "F2Drop"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=33973					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>8535	06					.byte (("F2Drop"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=19					LinkDisplacement = Nt0-WordListLink
>8536	10					.byte WordFlags	;wh_Flags
>8537	03					.byte 3	;wh_CodeLength
>8538	13					  .byte LinkDisplacement	; offset to previous nt
=$8539					XtPtr1 ::= *
=33973					WordListLink ::= Nt0 ; remember the nt of this word for later
.8539	e6 56		inc $56		F2Drop:		inc FIndex
.853b	4c 26 85	jmp $8526			jmp FDrop
=5					CodeLen	.var *-XtPtr1
=$853e					Here1 = *	; remember here
>8537	05					.byte CodeLen	;patch wh_CodeLength
.853e	4c dd 84	jmp $84dd	Throw_FPStack_10a: jmp Throw_FPStack
>8541	46 4e 69 70			Name0:	.text "FNip"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=33989					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>8545	04					.byte (("FNip"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=0					WordFlags ::= 0	; modifiable copy, remember for later
=16					LinkDisplacement = Nt0-WordListLink
>8546	00					.byte WordFlags	;wh_Flags
>8547	03					.byte 3	;wh_CodeLength
>8548	10					  .byte LinkDisplacement	; offset to previous nt
=$8549					XtPtr1 ::= *
=33989					WordListLink ::= Nt0 ; remember the nt of this word for later
.8549	86 14		stx $14		FNip:		stx tmp1		; save data stack index
.854b	a6 56		ldx $56				ldx FIndex		; X= FP stack index
.854d	e0 09		cpx #$09			cpx #FSDim-1		; check FP stack for >=2 entries
.854f	b0 ed		bcs $853e			bcs Throw_FPStack_10a
.8551	b5 57		lda $57,x			lda FSExp+0,x		; copy exponent
.8553	95 58		sta $58,x			sta FSExp+1,x
.8555	b5 61		lda $61,x			lda FSMant0+0,x		; copy mantissa
.8557	95 62		sta $62,x			sta FSMant0+1,x
.8559	b5 6b		lda $6b,x			lda FSMant1+0,x
.855b	95 6c		sta $6c,x			sta FSMant1+1,x
.855d	b5 75		lda $75,x			lda FSMant2+0,x
.855f	95 76		sta $76,x			sta FSMant2+1,x
.8561	b5 7f		lda $7f,x			lda FSMant3+0,x
.8563	95 80		sta $80,x			sta FSMant3+1,x
.8565	e6 56		inc $56				inc FIndex		; FDrop
.8567	a6 14		ldx $14				ldx tmp1		; restore data stack index
=32					CodeLen	.var *-XtPtr1
=$8569					Here1 = *	; remember here
>8547	20					.byte CodeLen	;patch wh_CodeLength
.8569	60		rts				rts
>856a	46 44 75 70			Name0:	.text "FDup"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=34030					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>856e	04					.byte (("FDup"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=0					WordFlags ::= 0	; modifiable copy, remember for later
=41					LinkDisplacement = Nt0-WordListLink
>856f	00					.byte WordFlags	;wh_Flags
>8570	03					.byte 3	;wh_CodeLength
>8571	29					  .byte LinkDisplacement	; offset to previous nt
=$8572					XtPtr1 ::= *
=34030					WordListLink ::= Nt0 ; remember the nt of this word for later
.8572					FDup:
.8572	86 14		stx $14				stx tmp1+0	; save data stack index
.8574	c6 56		dec $56				dec FIndex	; alloc a FP stack entry
.8576	30 7f		bmi $85f7			bmi Throw_FPStack_11	;   if FP stack overflow (or massive underflow)
.8578	a6 56		ldx $56				ldx FIndex	; X= Floating Point stack index
.857a	b5 58		lda $58,x			lda FSExp+1,x		; copy exponent
.857c	95 57		sta $57,x			sta FSExp+0,x
.857e	b5 62		lda $62,x			lda FSMant0+1,x		; copy mantissa
.8580	95 61		sta $61,x			sta FSMant0+0,x
.8582	b5 6c		lda $6c,x			lda FSMant1+1,x
.8584	95 6b		sta $6b,x			sta FSMant1+0,x
.8586	b5 76		lda $76,x			lda FSMant2+1,x
.8588	95 75		sta $75,x			sta FSMant2+0,x
.858a	b5 80		lda $80,x			lda FSMant3+1,x
.858c	95 7f		sta $7f,x			sta FSMant3+0,x
.858e	a6 14		ldx $14				ldx tmp1+0		; restore data stack index
=30					CodeLen	.var *-XtPtr1
=$8590					Here1 = *	; remember here
>8570	1e					.byte CodeLen	;patch wh_CodeLength
.8590	60		rts				rts
>8591	46 4f 76 65 72			Name0:	.text "FOver"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=34070					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>8596	45					.byte (("FOver"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=0					WordFlags ::= 0	; modifiable copy, remember for later
=40					LinkDisplacement = Nt0-WordListLink
>8597	00					.byte WordFlags	;wh_Flags
>8598	03					.byte 3	;wh_CodeLength
>8599	28					  .byte LinkDisplacement	; offset to previous nt
=$859a					XtPtr1 ::= *
=34070					WordListLink ::= Nt0 ; remember the nt of this word for later
.859a					FOver:
.859a	86 14		stx $14				stx tmp1+0	; save data stack index
.859c	c6 56		dec $56				dec FIndex	; alloc a FP stack entry
.859e	30 57		bmi $85f7			bmi Throw_FPStack_11	;   if FP stack overflow (or massive underflow)
.85a0	a6 56		ldx $56				ldx FIndex	; X= Floating Point stack index
.85a2	b5 59		lda $59,x			lda FSExp+2,x		; copy exponent
.85a4	95 57		sta $57,x			sta FSExp+0,x
.85a6	b5 63		lda $63,x			lda FSMant0+2,x		; copy mantissa
.85a8	95 61		sta $61,x			sta FSMant0+0,x
.85aa	b5 6d		lda $6d,x			lda FSMant1+2,x
.85ac	95 6b		sta $6b,x			sta FSMant1+0,x
.85ae	b5 77		lda $77,x			lda FSMant2+2,x
.85b0	95 75		sta $75,x			sta FSMant2+0,x
.85b2	b5 81		lda $81,x			lda FSMant3+2,x
.85b4	95 7f		sta $7f,x			sta FSMant3+0,x
.85b6	a6 14		ldx $14				ldx tmp1+0		; restore data stack index
=30					CodeLen	.var *-XtPtr1
=$85b8					Here1 = *	; remember here
>8598	1e					.byte CodeLen	;patch wh_CodeLength
.85b8	60		rts				rts
>85b9	46 50 69 63 6b			Name0:	.text "FPick"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=34110					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>85be	65					.byte (("FPick"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=0					WordFlags ::= 0	; modifiable copy, remember for later
=40					LinkDisplacement = Nt0-WordListLink
>85bf	00					.byte WordFlags	;wh_Flags
>85c0	03					.byte 3	;wh_CodeLength
>85c1	28					  .byte LinkDisplacement	; offset to previous nt
=$85c2					XtPtr1 ::= *
=34110					WordListLink ::= Nt0 ; remember the nt of this word for later
.85c2	20 47 c5	jsr $c547	FPick:		jsr PopA		; pop u (desired entry #)
.85c5	18		clc		FPickA:		clc			; Y= fp stack index of [u]
.85c6	65 56		adc $56				adc FIndex
.85c8	a8		tay		FPick3:		tay
.85c9	20 d4 84	jsr $84d4			jsr FAllocX		; alloc FP stack entry, X=fp stack index
.85cc	b9 57 00	lda $0057,y			lda FSExp,y		; copy exponent
.85cf	95 57		sta $57,x			sta FSExp,x
.85d1	b9 61 00	lda $0061,y			lda FSMant0,y		; copy mantissa
.85d4	95 61		sta $61,x			sta FSMant0,x
.85d6	b9 6b 00	lda $006b,y			lda FSMant1,y
.85d9	95 6b		sta $6b,x			sta FSMant1,x
.85db	b9 75 00	lda $0075,y			lda FSMant2,y
.85de	95 75		sta $75,x			sta FSMant2,x
.85e0	b9 7f 00	lda $007f,y			lda FSMant3,y
.85e3	95 7f		sta $7f,x			sta FSMant3,x
.85e5	a6 14		ldx $14				ldx tmp1+0		; restore data stack index
=37					CodeLen	.var *-XtPtr1
=$85e7					Here1 = *	; remember here
>85c0	25					.byte CodeLen	;patch wh_CodeLength
.85e7	60		rts				rts
>85e8	46 32 44 75 70			Name0:	.text "F2Dup"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=34157					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>85ed	05					.byte (("F2Dup"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=47					LinkDisplacement = Nt0-WordListLink
>85ee	10					.byte WordFlags	;wh_Flags
>85ef	03					.byte 3	;wh_CodeLength
>85f0	2f					  .byte LinkDisplacement	; offset to previous nt
=$85f1					XtPtr1 ::= *
=34157					WordListLink ::= Nt0 ; remember the nt of this word for later
.85f1	20 9a 85	jsr $859a	F2Dup:		jsr FOver
.85f4	4c 9a 85	jmp $859a			jmp FOver
=6					CodeLen	.var *-XtPtr1
=$85f7					Here1 = *	; remember here
>85ef	06					.byte CodeLen	;patch wh_CodeLength
.85f7	4c dd 84	jmp $84dd	Throw_FPStack_11: jmp Throw_FPStack
>85fa	46 53 77 61 70			Name0:	.text "FSwap"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=34175					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>85ff	05					.byte (("FSwap"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=0					WordFlags ::= 0	; modifiable copy, remember for later
=18					LinkDisplacement = Nt0-WordListLink
>8600	00					.byte WordFlags	;wh_Flags
>8601	03					.byte 3	;wh_CodeLength
>8602	12					  .byte LinkDisplacement	; offset to previous nt
=$8603					XtPtr1 ::= *
=34175					WordListLink ::= Nt0 ; remember the nt of this word for later
.8603	86 14		stx $14		FSwap:		stx tmp1+0		; save data stack index
.8605	a6 56		ldx $56				ldx FIndex		; X=FP stack index
.8607	e0 09		cpx #$09			cpx #FSDim-1	; check FP stack for >=2 entries
.8609	b0 ec		bcs $85f7			bcs Throw_FPStack_11
.860b	b5 57		lda $57,x			lda FSExp+0,x		; do FSExp
.860d	b4 58		ldy $58,x			ldy FSExp+1,x
.860f	95 58		sta $58,x			sta FSExp+1,x
.8611	94 57		sty $57,x			sty FSExp+0,x	; sty dir,x exists
.8613	b5 61		lda $61,x			lda FSMant0+0,x		; do FSMant0
.8615	b4 62		ldy $62,x			ldy FSMant0+1,x
.8617	95 62		sta $62,x			sta FSMant0+1,x
.8619	94 61		sty $61,x			sty FSMant0+0,x	; sty dir,x exists
.861b	b5 6b		lda $6b,x			lda FSMant1+0,x		; do FSMant1
.861d	b4 6c		ldy $6c,x			ldy FSMant1+1,x
.861f	95 6c		sta $6c,x			sta FSMant1+1,x
.8621	94 6b		sty $6b,x			sty FSMant1+0,x	; sty dir,x exists
.8623	b5 75		lda $75,x			lda FSMant2+0,x		; do FSMant2
.8625	b4 76		ldy $76,x			ldy FSMant2+1,x
.8627	95 76		sta $76,x			sta FSMant2+1,x
.8629	94 75		sty $75,x			sty FSMant2+0,x	; sty dir,x exists
.862b	b5 7f		lda $7f,x			lda FSMant3+0,x		; do FSMant3
.862d	b4 80		ldy $80,x			ldy FSMant3+1,x
.862f	95 80		sta $80,x			sta FSMant3+1,x
.8631	94 7f		sty $7f,x			sty FSMant3+0,x	; sty dir,x exists
.8633	a6 14		ldx $14				ldx tmp1+0		; restore data stack index
=50					CodeLen	.var *-XtPtr1
=$8635					Here1 = *	; remember here
>8601	32					.byte CodeLen	;patch wh_CodeLength
.8635	60		rts				rts
>8636	46 54 75 63 6b			Name0:	.text "FTuck"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=34235					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>863b	65					.byte (("FTuck"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=60					LinkDisplacement = Nt0-WordListLink
>863c	10					.byte WordFlags	;wh_Flags
>863d	03					.byte 3	;wh_CodeLength
>863e	3c					  .byte LinkDisplacement	; offset to previous nt
=$863f					XtPtr1 ::= *
=34235					WordListLink ::= Nt0 ; remember the nt of this word for later
.863f	20 03 86	jsr $8603	FTuck:		jsr FSwap
.8642	4c 9a 85	jmp $859a			jmp FOver
=6					CodeLen	.var *-XtPtr1
=$8645					Here1 = *	; remember here
>863d	06					.byte CodeLen	;patch wh_CodeLength
>8645	46 52 6f 74			Name0:	.text "FRot"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=34249					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>8649	84					.byte (("FRot"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=0					WordFlags ::= 0	; modifiable copy, remember for later
=14					LinkDisplacement = Nt0-WordListLink
>864a	00					.byte WordFlags	;wh_Flags
>864b	03					.byte 3	;wh_CodeLength
>864c	0e					  .byte LinkDisplacement	; offset to previous nt
=$864d					XtPtr1 ::= *
=34249					WordListLink ::= Nt0 ; remember the nt of this word for later
.864d	86 14		stx $14		FRot:		stx tmp1		; save data stack index
.864f	a5 56		lda $56				lda FIndex		; for FSMant3, FSMant2, FSMant1, FSMant0, FSExp
.8651	c9 08		cmp #$08			cmp #FSDim-2		; check FP stack for >=3 entries
.8653	b0 a2		bcs $85f7			bcs Throw_FPStack_11
.8655	18		clc				clc
.8656	69 28		adc #$28			adc #4*FSDim
.8658	38		sec				sec
.8659	aa		tax		_2:		tax
.865a	b4 59		ldy $59,x			ldy FSExp+2,x		;   do a byte
.865c	b5 58		lda $58,x			lda FSExp+1,x
.865e	95 59		sta $59,x			sta FSExp+2,x
.8660	b5 57		lda $57,x			lda FSExp+0,x
.8662	95 58		sta $58,x			sta FSExp+1,x
.8664	94 57		sty $57,x			sty FSExp+0,x	; sty dir,x exists
.8666	8a		txa				txa			;   next byte
.8667	e9 0a		sbc #$0a			sbc #FSDim
.8669	b0 ee		bcs $8659			bcs _2			; until done
.866b	a6 14		ldx $14				ldx tmp1		; restore param stack index
=32					CodeLen	.var *-XtPtr1
=$866d					Here1 = *	; remember here
>864b	20					.byte CodeLen	;patch wh_CodeLength
.866d	60		rts				rts
>866e	46 2d 52 6f 74			Name0:	.text "F-Rot"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=34291					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>8673	85					.byte (("F-Rot"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=42					LinkDisplacement = Nt0-WordListLink
>8674	10					.byte WordFlags	;wh_Flags
>8675	03					.byte 3	;wh_CodeLength
>8676	2a					  .byte LinkDisplacement	; offset to previous nt
=$8677					XtPtr1 ::= *
=34291					WordListLink ::= Nt0 ; remember the nt of this word for later
.8677	20 4d 86	jsr $864d	FMRot:		jsr FRot
.867a	4c 4d 86	jmp $864d			jmp FRot
=6					CodeLen	.var *-XtPtr1
=$867d					Here1 = *	; remember here
>8675	06					.byte CodeLen	;patch wh_CodeLength
.867d	4c ae c5	jmp $c5ae	Throw_Stack_33: jmp Throw_Stack
>8680	27 46 40			Name0:	.text "'F@"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=34307					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>8683	03					.byte (("'F@"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=28					WordFlags ::= IM+CO+NN	; modifiable copy, remember for later
=16					LinkDisplacement = Nt0-WordListLink
>8684	1c					.byte WordFlags	;wh_Flags
>8685	03					.byte 3	;wh_CodeLength
>8686	10					  .byte LinkDisplacement	; offset to previous nt
=$8687					XtPtr1 ::= *
=34307					WordListLink ::= Nt0 ; remember the nt of this word for later
.8687	20 d4 cd	jsr $cdd4			jsr Tick		; get named FVariable data addr
.868a	20 2f e0	jsr $e02f			jsr Execute
.868d	20 15 c9	jsr $c915			jsr ldya_immed_comma	; compile loading addr to YA
.8690	a9 b2		lda #$b2			lda #<FAt_YA		; compile jsr FAt_YA
.8692	a0 86		ldy #$86			ldy #>FAt_YA
.8694	4c 25 df	jmp $df25			jmp Jsr_Comma_YA
=16					CodeLen	.var *-XtPtr1
=$8697					Here1 = *	; remember here
>8685	10					.byte CodeLen	;patch wh_CodeLength
>8697	46 40 5f 59 41			Name0:	.text "F@_YA"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=34332					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>869c	25					.byte (("F@_YA"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=25					LinkDisplacement = Nt0-WordListLink
=$12						  WordFlags ::= WordFlags | DB
>869d	12					.byte WordFlags	;wh_Flags
>869e	03					.byte 3	;wh_CodeLength
>869f	19					  .byte LinkDisplacement	; offset to previous nt
>86a0	b2 86					  .word FAt_YA		; pointer to xt
=0					XtPtr1 ::= 0
=34332					WordListLink ::= Nt0 ; remember the nt of this word for later
>86a2	46 40				Name0:	.text "F@"	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=34340					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>86a4	02					.byte (("F@"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=0					WordFlags ::= 0	; modifiable copy, remember for later
=8					LinkDisplacement = Nt0-WordListLink
>86a5	00					.byte WordFlags	;wh_Flags
>86a6	03					.byte 3	;wh_CodeLength
>86a7	08					  .byte LinkDisplacement	; offset to previous nt
=$86a8					XtPtr1 ::= *
=34340					WordListLink ::= Nt0 ; remember the nt of this word for later
.86a8					FAt:
.86a8	e0 2f		cpx #$2f		cpx #(DSDim-1)*2+1	; far enough below end of data stack (& not negative)?
.86aa	b0 d1		bcs $867d		bcs Throw_Stack_33
.86ac	b5 26		lda $26,x			lda DStack+0,x		; pop addr faster
.86ae	b4 27		ldy $27,x			ldy DStack+1,x
.86b0	e8		inx				inx
.86b1	e8		inx				inx
.86b2	85 16		sta $16		FAt_YA:		sta tmp2+0		; save addr
.86b4	84 17		sty $17				sty tmp2+1
.86b6	a0 00		ldy #$00			ldy #0			; starting offset from tmp2
.86b8					FAt_Tmp2Y:
.86b8	86 14		stx $14				stx tmp1+0	; save data stack index
.86ba	c6 56		dec $56				dec FIndex	; alloc a FP stack entry
.86bc	30 73		bmi $8731			bmi Throw_FpStack_12	;   if FP stack overflow (or massive underflow)
.86be	a6 56		ldx $56				ldx FIndex	; X= Floating Point stack index
.86c0	b1 16		lda ($16),y			lda (tmp2),y		; copy mantissa
.86c2	95 7f		sta $7f,x			sta FSMant3,x
.86c4	c8		iny				iny
.86c5	b1 16		lda ($16),y			lda (tmp2),y
.86c7	95 75		sta $75,x			sta FSMant2,x
.86c9	c8		iny				iny
.86ca	b1 16		lda ($16),y			lda (tmp2),y
.86cc	95 6b		sta $6b,x			sta FSMant1,x
.86ce	c8		iny				iny
.86cf	b1 16		lda ($16),y			lda (tmp2),y
.86d1	95 61		sta $61,x			sta FSMant0,x
.86d3	c8		iny				iny			; copy exponent
.86d4	b1 16		lda ($16),y			lda (tmp2),y
.86d6	95 57		sta $57,x			sta FSExp,x
.86d8	a6 14		ldx $14				ldx tmp1		; restore data stack index
=50					CodeLen	.var *-XtPtr1
=$86da					Here1 = *	; remember here
>86a6	32					.byte CodeLen	;patch wh_CodeLength
.86da	60		rts				rts
>86db	27 46 21			Name0:	.text "'F!"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=34398					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>86de	23					.byte (("'F!"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=28					WordFlags ::= IM+CO+NN	; modifiable copy, remember for later
=58					LinkDisplacement = Nt0-WordListLink
>86df	1c					.byte WordFlags	;wh_Flags
>86e0	03					.byte 3	;wh_CodeLength
>86e1	3a					  .byte LinkDisplacement	; offset to previous nt
=$86e2					XtPtr1 ::= *
=34398					WordListLink ::= Nt0 ; remember the nt of this word for later
.86e2	20 d4 cd	jsr $cdd4			jsr Tick		; get named FVariable data addr
.86e5	20 2f e0	jsr $e02f			jsr Execute
.86e8	20 15 c9	jsr $c915			jsr ldya_immed_comma	; compile loading addr to YA
.86eb	a9 06		lda #$06			lda #<FStore_YA		; compile jsr FStore_YA
.86ed	a0 87		ldy #$87			ldy #>FStore_YA
.86ef	4c 25 df	jmp $df25			jmp Jsr_Comma_YA
=16					CodeLen	.var *-XtPtr1
=$86f2					Here1 = *	; remember here
>86e0	10					.byte CodeLen	;patch wh_CodeLength
>86f2	46 21 5f 59 41			Name0:	.text "F!_YA"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=34423					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>86f7	25					.byte (("F!_YA"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=25					LinkDisplacement = Nt0-WordListLink
=$12						  WordFlags ::= WordFlags | DB
>86f8	12					.byte WordFlags	;wh_Flags
>86f9	03					.byte 3	;wh_CodeLength
>86fa	19					  .byte LinkDisplacement	; offset to previous nt
>86fb	06 87					  .word FStore_YA		; pointer to xt
=0					XtPtr1 ::= 0
=34423					WordListLink ::= Nt0 ; remember the nt of this word for later
>86fd	46 21				Name0:	.text "F!"	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=34431					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>86ff	22					.byte (("F!"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=0					WordFlags ::= 0	; modifiable copy, remember for later
=8					LinkDisplacement = Nt0-WordListLink
>8700	00					.byte WordFlags	;wh_Flags
>8701	03					.byte 3	;wh_CodeLength
>8702	08					  .byte LinkDisplacement	; offset to previous nt
=$8703					XtPtr1 ::= *
=34431					WordListLink ::= Nt0 ; remember the nt of this word for later
.8703	20 62 c5	jsr $c562	FStore:		jsr PopYA		; pop addr
.8706	85 14		sta $14		FStore_YA:	sta tmp1+0		; save addr
.8708	84 15		sty $15				sty tmp1+1
.870a	a0 00		ldy #$00			ldy #0
.870c	86 16		stx $16				stx tmp2		; save data stack index
.870e	a6 56		ldx $56				ldx FIndex		; X= FP stack index
.8710	e0 0a		cpx #$0a			cpx #FSDim-0		; check FP stack for >=1 entries
.8712	b0 1d		bcs $8731			bcs Throw_FPStack_12
.8714	b5 7f		lda $7f,x			lda FSMant3,x		; copy mantissa
.8716	91 14		sta ($14),y			sta (tmp1),y
.8718	b5 75		lda $75,x			lda FSMant2,x
.871a	c8		iny				iny
.871b	91 14		sta ($14),y			sta (tmp1),y
.871d	b5 6b		lda $6b,x			lda FSMant1,x
.871f	c8		iny				iny
.8720	91 14		sta ($14),y			sta (tmp1),y
.8722	b5 61		lda $61,x			lda FSMant0,x
.8724	c8		iny				iny
.8725	91 14		sta ($14),y			sta (tmp1),y
.8727	b5 57		lda $57,x			lda FSExp,x		; copy exponent
.8729	c8		iny				iny
.872a	91 14		sta ($14),y			sta (tmp1),y
.872c	e6 56		inc $56				inc FIndex		; FDrop
.872e	a6 16		ldx $16				ldx tmp2		; restore data stack index
=45					CodeLen	.var *-XtPtr1
=$8730					Here1 = *	; remember here
>8701	2d					.byte CodeLen	;patch wh_CodeLength
.8730	60		rts				rts
.8731	4c dd 84	jmp $84dd	Throw_FPStack_12: jmp Throw_FPStack
>8734	46 2c				Name0:	.text "F,"	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=34486					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>8736	82					.byte (("F,"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=55					LinkDisplacement = Nt0-WordListLink
>8737	10					.byte WordFlags	;wh_Flags
>8738	03					.byte 3	;wh_CodeLength
>8739	37					  .byte LinkDisplacement	; offset to previous nt
=$873a					XtPtr1 ::= *
=34486					WordListLink ::= Nt0 ; remember the nt of this word for later
.873a	a5 00		lda $00		FComma:		lda cp+0		; store f at Here
.873c	a4 01		ldy $01				ldy cp+1
.873e	20 06 87	jsr $8706			jsr FStore_YA
.8741	a9 05		lda #$05			lda #Float_Size
.8743	4c 45 d2	jmp $d245			jmp Allot_ZA
=12					CodeLen	.var *-XtPtr1
=$8746					Here1 = *	; remember here
>8738	0c					.byte CodeLen	;patch wh_CodeLength
>8746	46 30 21			Name0:	.text "F0!"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=34505					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>8749	23					.byte (("F0!"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=19					LinkDisplacement = Nt0-WordListLink
>874a	10					.byte WordFlags	;wh_Flags
>874b	03					.byte 3	;wh_CodeLength
>874c	13					  .byte LinkDisplacement	; offset to previous nt
=$874d					XtPtr1 ::= *
=34505					WordListLink ::= Nt0 ; remember the nt of this word for later
.874d	20 54 89	jsr $8954	FZStore:	jsr F0
.8750	4c 03 87	jmp $8703			jmp FStore
=6					CodeLen	.var *-XtPtr1
=$8753					Here1 = *	; remember here
>874b	06					.byte CodeLen	;patch wh_CodeLength
>8753	46 30 3d			Name0:	.text "F0="	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=34518					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>8756	a3					.byte (("F0="[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>8757	10					.byte WordFlags	;wh_Flags
>8758	03					.byte 3	;wh_CodeLength
>8759	0d					  .byte LinkDisplacement	; offset to previous nt
=$875a					XtPtr1 ::= *
=34518					WordListLink ::= Nt0 ; remember the nt of this word for later
.875a	a4 56		ldy $56		FZEq:		ldy FIndex
.875c	b9 61 00	lda $0061,y			lda FSMant0,y
.875f	d0 28		bne $8789			bne FFalse1
.8761					FTrue1:
.8761	c0 0a		cpy #$0a			cpy #FSDim-0	; check FP stack for >=1 entries
.8763	b0 cc		bcs $8731			bcs Throw_FPStack_12
.8765	e6 56		inc $56				inc FIndex	; FDrop
.8767	4c 3d c9	jmp $c93d			jmp True	; return true
=16					CodeLen	.var *-XtPtr1
=$876a					Here1 = *	; remember here
>8758	10					.byte CodeLen	;patch wh_CodeLength
>876a	46 30 3c 3e			Name0:	.text "F0<>"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=34542					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>876e	c4					.byte (("F0<>"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=24					LinkDisplacement = Nt0-WordListLink
>876f	10					.byte WordFlags	;wh_Flags
>8770	03					.byte 3	;wh_CodeLength
>8771	18					  .byte LinkDisplacement	; offset to previous nt
=$8772					XtPtr1 ::= *
=34542					WordListLink ::= Nt0 ; remember the nt of this word for later
.8772	a4 56		ldy $56		FZNe:		ldy FIndex
.8774	b9 61 00	lda $0061,y			lda FSMant0,y
.8777	d0 e8		bne $8761			bne FTrue1
.8779	f0 0e		beq $8789			beq FFalse1
=9					CodeLen	.var *-XtPtr1
=$877b					Here1 = *	; remember here
>8770	09					.byte CodeLen	;patch wh_CodeLength
>877b	46 30 3c			Name0:	.text "F0<"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=34558					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>877e	83					.byte (("F0<"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=16					LinkDisplacement = Nt0-WordListLink
>877f	10					.byte WordFlags	;wh_Flags
>8780	03					.byte 3	;wh_CodeLength
>8781	10					  .byte LinkDisplacement	; offset to previous nt
=$8782					XtPtr1 ::= *
=34558					WordListLink ::= Nt0 ; remember the nt of this word for later
.8782	a4 56		ldy $56		FZLt:		ldy FIndex
.8784	b9 61 00	lda $0061,y			lda FSMant0,y
.8787	30 d8		bmi $8761			bmi FTrue1
.8789					FFalse1:
.8789	c0 0a		cpy #$0a			cpy #FSDim-0	; check FP stack for >=1 entries
.878b	b0 a4		bcs $8731			bcs Throw_FPStack_12
.878d	e6 56		inc $56				inc FIndex	; FDrop
.878f	4c 4f c9	jmp $c94f			jmp False	; return false
=16					CodeLen	.var *-XtPtr1
=$8792					Here1 = *	; remember here
>8780	10					.byte CodeLen	;patch wh_CodeLength
>8792	46 30 3e 3d			Name0:	.text "F0>="	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=34582					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>8796	a4					.byte (("F0>="[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=24					LinkDisplacement = Nt0-WordListLink
>8797	10					.byte WordFlags	;wh_Flags
>8798	03					.byte 3	;wh_CodeLength
>8799	18					  .byte LinkDisplacement	; offset to previous nt
=$879a					XtPtr1 ::= *
=34582					WordListLink ::= Nt0 ; remember the nt of this word for later
.879a	a4 56		ldy $56		FZGe:		ldy FIndex
.879c	b9 61 00	lda $0061,y			lda FSMant0,y
.879f	10 c0		bpl $8761			bpl FTrue1
.87a1	30 e6		bmi $8789			bmi FFalse1
=9					CodeLen	.var *-XtPtr1
=$87a3					Here1 = *	; remember here
>8798	09					.byte CodeLen	;patch wh_CodeLength
>87a3	46 30 3e			Name0:	.text "F0>"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=34598					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>87a6	c3					.byte (("F0>"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=16					LinkDisplacement = Nt0-WordListLink
>87a7	10					.byte WordFlags	;wh_Flags
>87a8	03					.byte 3	;wh_CodeLength
>87a9	10					  .byte LinkDisplacement	; offset to previous nt
=$87aa					XtPtr1 ::= *
=34598					WordListLink ::= Nt0 ; remember the nt of this word for later
.87aa	a4 56		ldy $56		FZGt:		ldy FIndex
.87ac	b9 61 00	lda $0061,y			lda FSMant0,y
.87af	30 d8		bmi $8789			bmi FFalse1
.87b1	d0 ae		bne $8761			bne FTrue1
.87b3	f0 d4		beq $8789			beq FFalse1
=11					CodeLen	.var *-XtPtr1
=$87b5					Here1 = *	; remember here
>87a8	0b					.byte CodeLen	;patch wh_CodeLength
>87b5	46 30 3c 3d			Name0:	.text "F0<="	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=34617					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>87b9	a4					.byte (("F0<="[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=19					LinkDisplacement = Nt0-WordListLink
>87ba	10					.byte WordFlags	;wh_Flags
>87bb	03					.byte 3	;wh_CodeLength
>87bc	13					  .byte LinkDisplacement	; offset to previous nt
=$87bd					XtPtr1 ::= *
=34617					WordListLink ::= Nt0 ; remember the nt of this word for later
.87bd	a4 56		ldy $56		FZLe:		ldy FIndex
.87bf	b9 61 00	lda $0061,y			lda FSMant0,y
.87c2	30 9d		bmi $8761			bmi FTrue1
.87c4	d0 c3		bne $8789			bne FFalse1
.87c6	f0 99		beq $8761			beq FTrue1
=11					CodeLen	.var *-XtPtr1
=$87c8					Here1 = *	; remember here
>87bb	0b					.byte CodeLen	;patch wh_CodeLength
>87c8	46 3c				Name0:	.text "F<"	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=34634					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>87ca	82					.byte (("F<"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=17					LinkDisplacement = Nt0-WordListLink
>87cb	10					.byte WordFlags	;wh_Flags
>87cc	03					.byte 3	;wh_CodeLength
>87cd	11					  .byte LinkDisplacement	; offset to previous nt
=$87ce					XtPtr1 ::= *
=34634					WordListLink ::= Nt0 ; remember the nt of this word for later
.87ce	20 72 84	jsr $8472	FLt:		jsr FCmpA
.87d1	30 32		bmi $8805			bmi FTrue2
.87d3					FFalse2:
.87d3	e6 56		inc $56				inc FIndex	; FDrop
.87d5	e6 56		inc $56				inc FIndex	; FDrop
.87d7	4c 4f c9	jmp $c94f			jmp False	; return False
=12					CodeLen	.var *-XtPtr1
=$87da					Here1 = *	; remember here
>87cc	0c					.byte CodeLen	;patch wh_CodeLength
>87da	46 3e 3d			Name0:	.text "F>="	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=34653					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>87dd	a3					.byte (("F>="[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=19					LinkDisplacement = Nt0-WordListLink
>87de	10					.byte WordFlags	;wh_Flags
>87df	03					.byte 3	;wh_CodeLength
>87e0	13					  .byte LinkDisplacement	; offset to previous nt
=$87e1					XtPtr1 ::= *
=34653					WordListLink ::= Nt0 ; remember the nt of this word for later
.87e1	20 72 84	jsr $8472	FGe:		jsr FCmpA
.87e4	10 1f		bpl $8805			bpl FTrue2
.87e6	30 eb		bmi $87d3			bmi FFalse2
=7					CodeLen	.var *-XtPtr1
=$87e8					Here1 = *	; remember here
>87df	07					.byte CodeLen	;patch wh_CodeLength
>87e8	46 3e				Name0:	.text "F>"	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=34666					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>87ea	c2					.byte (("F>"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>87eb	10					.byte WordFlags	;wh_Flags
>87ec	03					.byte 3	;wh_CodeLength
>87ed	0d					  .byte LinkDisplacement	; offset to previous nt
=$87ee					XtPtr1 ::= *
=34666					WordListLink ::= Nt0 ; remember the nt of this word for later
.87ee	20 72 84	jsr $8472	FGt:		jsr FCmpA
.87f1	30 e0		bmi $87d3			bmi FFalse2
.87f3	d0 10		bne $8805			bne FTrue2
.87f5	f0 dc		beq $87d3			beq FFalse2
=9					CodeLen	.var *-XtPtr1
=$87f7					Here1 = *	; remember here
>87ec	09					.byte CodeLen	;patch wh_CodeLength
>87f7	46 3c 3d			Name0:	.text "F<="	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=34682					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>87fa	a3					.byte (("F<="[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=16					LinkDisplacement = Nt0-WordListLink
>87fb	10					.byte WordFlags	;wh_Flags
>87fc	03					.byte 3	;wh_CodeLength
>87fd	10					  .byte LinkDisplacement	; offset to previous nt
=$87fe					XtPtr1 ::= *
=34682					WordListLink ::= Nt0 ; remember the nt of this word for later
.87fe	20 72 84	jsr $8472	FLe:		jsr FCmpA
.8801	30 02		bmi $8805			bmi FTrue2
.8803	d0 ce		bne $87d3			bne FFalse2
.8805					FTrue2:
.8805	e6 56		inc $56				inc FIndex	; FDrop
.8807	e6 56		inc $56				inc FIndex	; FDrop
.8809	4c 3d c9	jmp $c93d			jmp True	; return True
=14					CodeLen	.var *-XtPtr1
=$880c					Here1 = *	; remember here
>87fc	0e					.byte CodeLen	;patch wh_CodeLength
>880c	46 3c 3e			Name0:	.text "F<>"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=34703					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>880f	c3					.byte (("F<>"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=21					LinkDisplacement = Nt0-WordListLink
>8810	10					.byte WordFlags	;wh_Flags
>8811	03					.byte 3	;wh_CodeLength
>8812	15					  .byte LinkDisplacement	; offset to previous nt
=$8813					XtPtr1 ::= *
=34703					WordListLink ::= Nt0 ; remember the nt of this word for later
.8813	20 72 84	jsr $8472	FNe:		jsr FCmpA
.8816	d0 ed		bne $8805			bne FTrue2
.8818	f0 b9		beq $87d3			beq FFalse2
=7					CodeLen	.var *-XtPtr1
=$881a					Here1 = *	; remember here
>8811	07					.byte CodeLen	;patch wh_CodeLength
>881a	46 3d				Name0:	.text "F="	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=34716					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>881c	a2					.byte (("F="[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>881d	10					.byte WordFlags	;wh_Flags
>881e	03					.byte 3	;wh_CodeLength
>881f	0d					  .byte LinkDisplacement	; offset to previous nt
=$8820					XtPtr1 ::= *
=34716					WordListLink ::= Nt0 ; remember the nt of this word for later
.8820	20 72 84	jsr $8472	FEq:		jsr FCmpA
.8823	d0 ae		bne $87d3			bne FFalse2
.8825	f0 de		beq $8805			beq FTrue2
=7					CodeLen	.var *-XtPtr1
=$8827					Here1 = *	; remember here
>881e	07					.byte CodeLen	;patch wh_CodeLength
>8827	46 7e 41 62 73			Name0:	.text "F~Abs"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=34732					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>882c	65					.byte (("F~Abs"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=16					LinkDisplacement = Nt0-WordListLink
>882d	10					.byte WordFlags	;wh_Flags
>882e	03					.byte 3	;wh_CodeLength
>882f	10					  .byte LinkDisplacement	; offset to previous nt
=$8830					XtPtr1 ::= *
=34732					WordListLink ::= Nt0 ; remember the nt of this word for later
.8830	20 77 86	jsr $8677	FTAbs:		jsr FMRot
.8833	20 41 8c	jsr $8c41			jsr FMinus
.8836	20 a3 8c	jsr $8ca3			jsr FAbs
.8839	4c ee 87	jmp $87ee			jmp FGt
=12					CodeLen	.var *-XtPtr1
=$883c					Here1 = *	; remember here
>882e	0c					.byte CodeLen	;patch wh_CodeLength
>883c	46 7e 52 65 6c			Name0:	.text "F~Rel"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=34753					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>8841	85					.byte (("F~Rel"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=21					LinkDisplacement = Nt0-WordListLink
>8842	10					.byte WordFlags	;wh_Flags
>8843	03					.byte 3	;wh_CodeLength
>8844	15					  .byte LinkDisplacement	; offset to previous nt
=$8845					XtPtr1 ::= *
=34753					WordListLink ::= Nt0 ; remember the nt of this word for later
.8845	20 9a 85	jsr $859a	FTRel:		jsr FOver
.8848	a9 03		lda #$03			lda #3
.884a	20 c5 85	jsr $85c5			jsr FPickA
.884d	20 01 8c	jsr $8c01			jsr FPlus
.8850	20 a3 8c	jsr $8ca3			jsr FAbs
.8853	20 da 8c	jsr $8cda			jsr FStar		; r1 r2 r3*|r1+r2|
.8856	20 77 86	jsr $8677			jsr FMRot		; r3*|r1+r2| r1 r2
.8859	20 41 8c	jsr $8c41			jsr FMinus
.885c	20 a3 8c	jsr $8ca3			jsr FAbs
.885f	4c ee 87	jmp $87ee			jmp FGt
=29					CodeLen	.var *-XtPtr1
=$8862					Here1 = *	; remember here
>8843	1d					.byte CodeLen	;patch wh_CodeLength
>8862	46 7e				Name0:	.text "F~"	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=34788					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>8864	c2					.byte (("F~"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=35					LinkDisplacement = Nt0-WordListLink
>8865	10					.byte WordFlags	;wh_Flags
>8866	03					.byte 3	;wh_CodeLength
>8867	23					  .byte LinkDisplacement	; offset to previous nt
=$8868					XtPtr1 ::= *
=34788					WordListLink ::= Nt0 ; remember the nt of this word for later
.8868	a4 56		ldy $56		FTilde:		ldy FIndex
.886a	c0 01		cpy #$01			cpy #FSDim-9		; check FP stack for >=1 entries
.886c	b0 4b		bcs $88b9			bcs Throw_FPStack_12a
.886e	b9 61 00	lda $0061,y			lda FSMant0,y
.8871	30 06		bmi $8879			bmi _10			; r3<0
.8873	d0 bb		bne $8830			bne FTAbs		; r3>0
.8875	e6 56		inc $56				inc FIndex		; r3=0
.8877	d0 a7		bne $8820			bne FEq
.8879	20 79 8c	jsr $8c79	_10:		jsr FNegate
.887c	4c 45 88	jmp $8845			jmp FTRel
=23					CodeLen	.var *-XtPtr1
=$887f					Here1 = *	; remember here
>8866	17					.byte CodeLen	;patch wh_CodeLength
>887f	46 56 61 72 69 61 62 6c		Name0:	.text "FVariable"	;  name of word as a string, ending at wh_NameLastChar
>8887	65
=9					NameLength = *-Name0
=34824					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>8888	a9					.byte (("FVariable"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=24					WordFlags ::= IM+NN	; modifiable copy, remember for later
=36					LinkDisplacement = Nt0-WordListLink
>8889	18					.byte WordFlags	;wh_Flags
>888a	03					.byte 3	;wh_CodeLength
>888b	24					  .byte LinkDisplacement	; offset to previous nt
=$888c					XtPtr1 ::= *
=34824					WordListLink ::= Nt0 ; remember the nt of this word for later
.888c	20 5f d3	jsr $d35f	FVariable:	jsr Create		; compile word header & push PFA adr
.888f	20 6e cd	jsr $cd6e			jsr adjust_z		; fix word code length
.8892	20 54 89	jsr $8954			jsr F0			; alloc & init data
.8895	4c 3a 87	jmp $873a			jmp FComma
=12					CodeLen	.var *-XtPtr1
=$8898					Here1 = *	; remember here
>888a	0c					.byte CodeLen	;patch wh_CodeLength
>8898	46 4c 69 74 65 72 61 6c		Name0:	.text "FLiteral"	;  name of word as a string, ending at wh_NameLastChar
=8					NameLength = *-Name0
=34848					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>88a0	88					.byte (("FLiteral"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=24					WordFlags ::= IM+NN	; modifiable copy, remember for later
=24					LinkDisplacement = Nt0-WordListLink
>88a1	18					.byte WordFlags	;wh_Flags
>88a2	03					.byte 3	;wh_CodeLength
>88a3	18					  .byte LinkDisplacement	; offset to previous nt
=$88a4					XtPtr1 ::= *
=34848					WordListLink ::= Nt0 ; remember the nt of this word for later
.88a4	20 bc 88	jsr $88bc	FLiteral:	jsr FLitTest
.88a7	f0 0a		beq $88b3			beq _Short
.88a9	a9 e9		lda #$e9			lda #<FLitI		; compile JSR FLitI
.88ab	a0 88		ldy #$88			ldy #>FLitI
.88ad	20 25 df	jsr $df25			jsr Jsr_Comma_YA
.88b0	4c 3a 87	jmp $873a			jmp FComma		; compile inline operand, return
.88b3	20 cc 88	jsr $88cc	_Short:		jsr FLitShort
.88b6	4c 25 df	jmp $df25			jmp Jsr_Comma_YA	; compile jsr FLitYA, & return
=21					CodeLen	.var *-XtPtr1
=$88b9					Here1 = *	; remember here
>88a2	15					.byte CodeLen	;patch wh_CodeLength
.88b9	4c dd 84	jmp $84dd	Throw_FPStack_12a: jmp Throw_FPStack
.88bc					FLitTest:
.88bc	a4 56		ldy $56				ldy FIndex
.88be	c0 0a		cpy #$0a			cpy #FSDim-0		; check FP stack for >=1 entries
.88c0	b0 f7		bcs $88b9			bcs Throw_FPStack_12a
.88c2	b9 6b 00	lda $006b,y			lda FSMant1,y		; will short work?
.88c5	19 75 00	ora $0075,y			ora FSMant2,y
.88c8	19 7f 00	ora $007f,y			ora FSMant3,y
.88cb	60		rts				rts
.88cc					FLitShort:
.88cc	a9 a9		lda #$a9			lda #$a9		; compile LDA #mant0
.88ce	20 df de	jsr $dedf			jsr C_Comma_A
.88d1	b9 61 00	lda $0061,y			lda FSMant0,y
.88d4	20 df de	jsr $dedf			jsr C_Comma_A
.88d7	a9 a0		lda #$a0			lda #$a0		; compile LDY #exp
.88d9	20 df de	jsr $dedf			jsr C_Comma_A
.88dc	b9 57 00	lda $0057,y			lda FSExp,y
.88df	20 df de	jsr $dedf			jsr C_Comma_A
.88e2	e6 56		inc $56				inc FIndex		; FDrop
.88e4	a9 36		lda #$36			lda #<FLitYA		; point at FLitYA
.88e6	a0 89		ldy #$89			ldy #>FLitYA
.88e8	60		rts				rts
.88e9					FLitI:
.88e9	68		pla				pla			; tmp2= RTS addr
.88ea	85 16		sta $16				sta tmp2+0
.88ec	18		clc				clc			; bump RTS addr over inline float data
.88ed	69 05		adc #$05			adc #Float_Size
.88ef	a8		tay				tay
.88f0	68		pla				pla
.88f1	85 17		sta $17				sta tmp2+1
.88f3	69 00		adc #$00			adc #0
.88f5	48		pha				pha
.88f6	98		tya				tya
.88f7	48		pha				pha
.88f8	a0 01		ldy #$01			ldy #1			; correct for RTS addr
.88fa	4c b8 86	jmp $86b8			jmp FAt_Tmp2Y		; fetch inline data, & return
>88fd	46 43 6f 6e 73 74 61 6e		Name0:	.text "FConstant"	;  name of word as a string, ending at wh_NameLastChar
>8905	74
=9					NameLength = *-Name0
=34950					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>8906	89					.byte (("FConstant"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=102					LinkDisplacement = Nt0-WordListLink
>8907	10					.byte WordFlags	;wh_Flags
>8908	03					.byte 3	;wh_CodeLength
>8909	66					  .byte LinkDisplacement	; offset to previous nt
=$890a					XtPtr1 ::= *
=34950					WordListLink ::= Nt0 ; remember the nt of this word for later
.890a	20 b2 d2	jsr $d2b2	FConstant:	jsr WordHeader_Comma	; compile word header
.890d	20 bc 88	jsr $88bc			jsr FLitTest		; will short work?
.8910	f0 0d		beq $891f			beq _Short
.8912	a9 28		lda #$28			lda #<FConstantRun	; compile JSR
.8914	a0 89		ldy #$89			ldy #>FConstantRun
.8916	20 25 df	jsr $df25			jsr Jsr_Comma_YA
.8919	20 6e cd	jsr $cd6e			jsr adjust_z
.891c	4c 3a 87	jmp $873a			jmp FComma		; compile inline operand, & return
.891f					_Short:
.891f	20 cc 88	jsr $88cc			jsr FLitShort		; compile load value
.8922	20 3b df	jsr $df3b			jsr Jmp_Comma_YA	; compile JMP
.8925	4c 6e cd	jmp $cd6e			jmp adjust_z
=30					CodeLen	.var *-XtPtr1
=$8928					Here1 = *	; remember here
>8908	1e					.byte CodeLen	;patch wh_CodeLength
.8928					FConstantRun:
.8928	68		pla				pla			; tmp2= pop RTS addr
.8929	85 16		sta $16				sta tmp2+0
.892b	68		pla				pla
.892c	85 17		sta $17				sta tmp2+1
.892e	a0 01		ldy #$01			ldy #1			; correct for RTS addr
.8930	4c b8 86	jmp $86b8			jmp FAt_Tmp2Y		; fetch inline data, & return
.8933	4c dd 84	jmp $84dd	Throw_FPStack_12b: jmp Throw_FPStack
.8936					FLitYA:
.8936	86 14		stx $14				stx tmp1+0	; save data stack index
.8938	c6 56		dec $56				dec FIndex	; alloc a FP stack entry
.893a	30 f7		bmi $8933			bmi Throw_FPStack_12b	;   if FP stack overflow (or massive underflow)
.893c	a6 56		ldx $56				ldx FIndex	; X= Floating Point stack index
.893e	95 61		sta $61,x			sta FSMant0,x		; Mant= A,0,0,0
.8940	94 57		sty $57,x			sty FSExp,x	; sty dir,x exists
.8942	a9 00		lda #$00			lda #0
.8944	95 6b		sta $6b,x			sta FSMant1,x
.8946	95 75		sta $75,x			sta FSMant2,x
.8948	95 7f		sta $7f,x			sta FSMant3,x
.894a	a6 14		ldx $14				ldx tmp1+0		; restore data stack index
.894c	60		rts				rts
>894d	30 2e 65			Name0:	.text "0.e"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=35024					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>8950	a3					.byte (("0.e"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=74					LinkDisplacement = Nt0-WordListLink
>8951	10					.byte WordFlags	;wh_Flags
>8952	03					.byte 3	;wh_CodeLength
>8953	4a					  .byte LinkDisplacement	; offset to previous nt
=$8954					XtPtr1 ::= *
=35024					WordListLink ::= Nt0 ; remember the nt of this word for later
.8954	a9 00		lda #$00	F0:		lda #0			; FSMant0
.8956	a0 80		ldy #$80			ldy #$80		; FSExp
.8958	d0 dc		bne $8936			bne FLitYA
=6					CodeLen	.var *-XtPtr1
=$895a					Here1 = *	; remember here
>8952	06					.byte CodeLen	;patch wh_CodeLength
>895a	31 30 30 30 2e 65		Name0:	.text "1000.e"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=35040					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>8960	a6					.byte (("1000.e"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=16					LinkDisplacement = Nt0-WordListLink
>8961	10					.byte WordFlags	;wh_Flags
>8962	03					.byte 3	;wh_CodeLength
>8963	10					  .byte LinkDisplacement	; offset to previous nt
=$8964					XtPtr1 ::= *
=35040					WordListLink ::= Nt0 ; remember the nt of this word for later
.8964	a9 7d		lda #$7d	F1000:		lda #$7d
.8966	a0 0a		ldy #$0a			ldy #10
.8968	d0 cc		bne $8936			bne FLitYA
=6					CodeLen	.var *-XtPtr1
=$896a					Here1 = *	; remember here
>8962	06					.byte CodeLen	;patch wh_CodeLength
>896a	31 30 2e 65			Name0:	.text "10.e"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=35054					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>896e	a4					.byte (("10.e"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=14					LinkDisplacement = Nt0-WordListLink
>896f	10					.byte WordFlags	;wh_Flags
>8970	03					.byte 3	;wh_CodeLength
>8971	0e					  .byte LinkDisplacement	; offset to previous nt
=$8972					XtPtr1 ::= *
=35054					WordListLink ::= Nt0 ; remember the nt of this word for later
.8972	a9 50		lda #$50	F10:		lda #$50
.8974	a0 04		ldy #$04			ldy #4
.8976	d0 be		bne $8936			bne FLitYA
=6					CodeLen	.var *-XtPtr1
=$8978					Here1 = *	; remember here
>8970	06					.byte CodeLen	;patch wh_CodeLength
>8978	32 2e 65			Name0:	.text "2.e"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=35067					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>897b	a3					.byte (("2.e"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>897c	10					.byte WordFlags	;wh_Flags
>897d	03					.byte 3	;wh_CodeLength
>897e	0d					  .byte LinkDisplacement	; offset to previous nt
=$897f					XtPtr1 ::= *
=35067					WordListLink ::= Nt0 ; remember the nt of this word for later
.897f	a9 40		lda #$40	F2:		lda #$40
.8981	a0 02		ldy #$02			ldy #2
.8983	d0 b1		bne $8936			bne FLitYA
=6					CodeLen	.var *-XtPtr1
=$8985					Here1 = *	; remember here
>897d	06					.byte CodeLen	;patch wh_CodeLength
>8985	31 2e 65			Name0:	.text "1.e"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=35080					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>8988	a3					.byte (("1.e"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>8989	10					.byte WordFlags	;wh_Flags
>898a	03					.byte 3	;wh_CodeLength
>898b	0d					  .byte LinkDisplacement	; offset to previous nt
=$898c					XtPtr1 ::= *
=35080					WordListLink ::= Nt0 ; remember the nt of this word for later
.898c	a9 40		lda #$40	F1:		lda #$40
.898e	a0 01		ldy #$01			ldy #1
.8990	d0 a4		bne $8936			bne FLitYA
=6					CodeLen	.var *-XtPtr1
=$8992					Here1 = *	; remember here
>898a	06					.byte CodeLen	;patch wh_CodeLength
>8992	2e 31 65			Name0:	.text ".1e"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=35093					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>8995	a3					.byte ((".1e"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>8996	10					.byte WordFlags	;wh_Flags
>8997	03					.byte 3	;wh_CodeLength
>8998	0d					  .byte LinkDisplacement	; offset to previous nt
=$8999					XtPtr1 ::= *
=35093					WordListLink ::= Nt0 ; remember the nt of this word for later
.8999	20 28 89	jsr $8928	F10th:		jsr FConstantRun
>899c	67 66 66 66					.dword $66666667	; 32 bit signed binary mantissa.  $40000000 = +0.5
>89a0	fd						.char -3		; 8 bit signed binary exponent.  $00 = 2**0
=8					CodeLen	.var *-XtPtr1
=$89a1					Here1 = *	; remember here
>8997	08					.byte CodeLen	;patch wh_CodeLength
>89a1	50 69				Name0:	.text "Pi"	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=35107					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>89a3	22					.byte (("Pi"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=14					LinkDisplacement = Nt0-WordListLink
>89a4	10					.byte WordFlags	;wh_Flags
>89a5	03					.byte 3	;wh_CodeLength
>89a6	0e					  .byte LinkDisplacement	; offset to previous nt
=$89a7					XtPtr1 ::= *
=35107					WordListLink ::= Nt0 ; remember the nt of this word for later
.89a7	20 28 89	jsr $8928	FPi:		jsr FConstantRun
>89aa	51 ed 87 64					.dword $6487ed51	; 32 bit signed binary mantissa.  $40000000 = +0.5
>89ae	02						.char 2		; 8 bit signed binary exponent.  $00 = 2**0
=8					CodeLen	.var *-XtPtr1
=$89af					Here1 = *	; remember here
>89a5	08					.byte CodeLen	;patch wh_CodeLength
>89af	50 69 2f 32			Name0:	.text "Pi/2"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=35123					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>89b3	44					.byte (("Pi/2"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=16					LinkDisplacement = Nt0-WordListLink
>89b4	10					.byte WordFlags	;wh_Flags
>89b5	03					.byte 3	;wh_CodeLength
>89b6	10					  .byte LinkDisplacement	; offset to previous nt
=$89b7					XtPtr1 ::= *
=35123					WordListLink ::= Nt0 ; remember the nt of this word for later
.89b7	20 28 89	jsr $8928	FPiH:		jsr FConstantRun
>89ba	51 ed 87 64					.dword $6487ed51	; 32 bit signed binary mantissa.  $40000000 = +0.5
>89be	01						.char 1		; 8 bit signed binary exponent.  $00 = 2**0
=8					CodeLen	.var *-XtPtr1
=$89bf					Here1 = *	; remember here
>89b5	08					.byte CodeLen	;patch wh_CodeLength
>89bf	50 69 2f 34			Name0:	.text "Pi/4"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=35139					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>89c3	84					.byte (("Pi/4"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=16					LinkDisplacement = Nt0-WordListLink
>89c4	10					.byte WordFlags	;wh_Flags
>89c5	03					.byte 3	;wh_CodeLength
>89c6	10					  .byte LinkDisplacement	; offset to previous nt
=$89c7					XtPtr1 ::= *
=35139					WordListLink ::= Nt0 ; remember the nt of this word for later
.89c7	20 28 89	jsr $8928	FPiQ:		jsr FConstantRun
>89ca	51 ed 87 64					.dword $6487ed51	; 32 bit signed binary mantissa.  $40000000 = +0.5
>89ce	00						.char 0		; 8 bit signed binary exponent.  $00 = 2**0
=8					CodeLen	.var *-XtPtr1
=$89cf					Here1 = *	; remember here
>89c5	08					.byte CodeLen	;patch wh_CodeLength
>89cf	32 50 69			Name0:	.text "2Pi"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=35154					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>89d2	23					.byte (("2Pi"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=15					LinkDisplacement = Nt0-WordListLink
>89d3	10					.byte WordFlags	;wh_Flags
>89d4	03					.byte 3	;wh_CodeLength
>89d5	0f					  .byte LinkDisplacement	; offset to previous nt
=$89d6					XtPtr1 ::= *
=35154					WordListLink ::= Nt0 ; remember the nt of this word for later
.89d6	20 28 89	jsr $8928	F2Pi:		jsr FConstantRun
>89d9	51 ed 87 64					.dword $6487ed51	; 32 bit signed binary mantissa.  $40000000 = +0.5
>89dd	03						.char 3		; 8 bit signed binary exponent.  $00 = 2**0
=8					CodeLen	.var *-XtPtr1
=$89de					Here1 = *	; remember here
>89d4	08					.byte CodeLen	;patch wh_CodeLength
>89de	46 2e 45			Name0:	.text "F.E"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=35169					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>89e1	a3					.byte (("F.E"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=15					LinkDisplacement = Nt0-WordListLink
>89e2	10					.byte WordFlags	;wh_Flags
>89e3	03					.byte 3	;wh_CodeLength
>89e4	0f					  .byte LinkDisplacement	; offset to previous nt
=$89e5					XtPtr1 ::= *
=35169					WordListLink ::= Nt0 ; remember the nt of this word for later
.89e5	20 28 89	jsr $8928	FE:		jsr FConstantRun
>89e8	2c 2a fc 56					.dword $56fc2a2c	; 32 bit signed binary mantissa.  $40000000 = +0.5
>89ec	02						.char 2		; 8 bit signed binary exponent.  $00 = 2**0
=8					CodeLen	.var *-XtPtr1
=$89ed					Here1 = *	; remember here
>89e3	08					.byte CodeLen	;patch wh_CodeLength
>89ed	46 56 61 6c 75 65		Name0:	.text "FValue"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=35187					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>89f3	a6					.byte (("FValue"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=24					WordFlags ::= IM+NN	; modifiable copy, remember for later
=18					LinkDisplacement = Nt0-WordListLink
>89f4	18					.byte WordFlags	;wh_Flags
>89f5	03					.byte 3	;wh_CodeLength
>89f6	12					  .byte LinkDisplacement	; offset to previous nt
=$89f7					XtPtr1 ::= *
=35187					WordListLink ::= Nt0 ; remember the nt of this word for later
.89f7	20 b2 d2	jsr $d2b2	FValue:		jsr WordHeader_Comma	; compile word header
.89fa	a9 07		lda #$07			lda #<FValue_runtime	; compile JSR FValue_runtime
.89fc	a0 8a		ldy #$8a			ldy #>FValue_runtime
.89fe	20 25 df	jsr $df25			jsr Jsr_Comma_YA
.8a01	20 6e cd	jsr $cd6e			jsr adjust_z		; fix word length
.8a04	4c 3a 87	jmp $873a			jmp FComma		; alloc & init value
=16					CodeLen	.var *-XtPtr1
=$8a07					Here1 = *	; remember here
>89f5	10					.byte CodeLen	;patch wh_CodeLength
.8a07					FValue_runtime:
.8a07	4c 28 89	jmp $8928			jmp FConstantRun
>8a0a	46 53 63 61 6c 65		Name0:	.text "FScale"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=35216					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>8a10	a6					.byte (("FScale"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=29					LinkDisplacement = Nt0-WordListLink
>8a11	10					.byte WordFlags	;wh_Flags
>8a12	03					.byte 3	;wh_CodeLength
>8a13	1d					  .byte LinkDisplacement	; offset to previous nt
=$8a14					XtPtr1 ::= *
=35216					WordListLink ::= Nt0 ; remember the nt of this word for later
.8a14	20 47 c5	jsr $c547	FScale:		jsr PopA		; pop n
.8a17	86 14		stx $14		FScaleA:	stx tmp1		; save data stack index
.8a19	a6 56		ldx $56				ldx FIndex		; X= FP stack index
.8a1b	e0 0a		cpx #$0a			cpx #FSDim-0		; check FP stack for >=1 entries
.8a1d	b0 3f		bcs $8a5e			bcs Throw_FPStack_13a
.8a1f	b4 61		ldy $61,x			ldy FSMant0,x		; mantissa zero?
.8a21	f0 07		beq $8a2a			beq _8
.8a23	18		clc				clc
.8a24	75 57		adc $57,x			adc FSExp,x
.8a26	95 57		sta $57,x			sta FSExp,x
.8a28	70 03		bvs $8a2d			bvs _overflow		; overflow or underflow?
.8a2a	a6 14		ldx $14		_8:		ldx tmp1		; restore data stack index
.8a2c	60		rts				rts
.8a2d					_overflow:
.8a2d	a6 14		ldx $14				ldx tmp1		; restore data stack index
.8a2f	20 e8 84	jsr $84e8			jsr Throw_FpOutOfRange
=30					CodeLen	.var *-XtPtr1
=$8a32					Here1 = *	; remember here
>8a12	1e					.byte CodeLen	;patch wh_CodeLength
>8a32	46 32 2a			Name0:	.text "F2*"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=35253					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>8a35	43					.byte (("F2*"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=37					LinkDisplacement = Nt0-WordListLink
>8a36	10					.byte WordFlags	;wh_Flags
>8a37	03					.byte 3	;wh_CodeLength
>8a38	25					  .byte LinkDisplacement	; offset to previous nt
=$8a39					XtPtr1 ::= *
=35253					WordListLink ::= Nt0 ; remember the nt of this word for later
.8a39	a9 01		lda #$01	F2Star:		lda #1
.8a3b	d0 da		bne $8a17			bne FScaleA
=4					CodeLen	.var *-XtPtr1
=$8a3d					Here1 = *	; remember here
>8a37	04					.byte CodeLen	;patch wh_CodeLength
>8a3d	46 32 2f			Name0:	.text "F2/"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=35264					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>8a40	e3					.byte (("F2/"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=11					LinkDisplacement = Nt0-WordListLink
>8a41	10					.byte WordFlags	;wh_Flags
>8a42	03					.byte 3	;wh_CodeLength
>8a43	0b					  .byte LinkDisplacement	; offset to previous nt
=$8a44					XtPtr1 ::= *
=35264					WordListLink ::= Nt0 ; remember the nt of this word for later
.8a44	a9 ff		lda #$ff	F2Slash:	lda #$ff
.8a46	d0 cf		bne $8a17			bne FScaleA
=4					CodeLen	.var *-XtPtr1
=$8a48					Here1 = *	; remember here
>8a42	04					.byte CodeLen	;patch wh_CodeLength
>8a48	46 31 30 2a			Name0:	.text "F10*"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=35276					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>8a4c	44					.byte (("F10*"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=12					LinkDisplacement = Nt0-WordListLink
>8a4d	10					.byte WordFlags	;wh_Flags
>8a4e	03					.byte 3	;wh_CodeLength
>8a4f	0c					  .byte LinkDisplacement	; offset to previous nt
=$8a50					XtPtr1 ::= *
=35276					WordListLink ::= Nt0 ; remember the nt of this word for later
.8a50	20 39 8a	jsr $8a39	F10Star:	jsr F2Star
.8a53	20 72 85	jsr $8572			jsr FDup
.8a56	a9 02		lda #$02			lda #2
.8a58	20 17 8a	jsr $8a17			jsr FScaleA
.8a5b	4c 01 8c	jmp $8c01			jmp FPlus
=14					CodeLen	.var *-XtPtr1
=$8a5e					Here1 = *	; remember here
>8a4e	0e					.byte CodeLen	;patch wh_CodeLength
.8a5e	4c dd 84	jmp $84dd	Throw_FPStack_13a: jmp Throw_FPStack
.8a61	86 14		stx $14		FShiftA:	stx tmp1+0		; save data stack index
.8a63	a6 56		ldx $56				ldx FIndex		; X= FP stack index
.8a65	e0 0a		cpx #$0a	FShiftAX:	cpx #FSDim-0		; check FP stack for >=1 entries
.8a67	b0 f5		bcs $8a5e			bcs Throw_FPStack_13a
.8a69	85 15		sta $15				sta tmp1+1		; save desired alignment
.8a6b	38		sec				sec			; calc bit shift count
.8a6c	f5 57		sbc $57,x			sbc FSExp,x
.8a6e	f0 32		beq $8aa2			beq _leave
.8a70	70 20		bvs $8a92			bvs _overflow
.8a72	30 2e		bmi $8aa2			bmi _leave
.8a74	c9 20		cmp #$20			cmp #32
.8a76	b0 1c		bcs $8a94			bcs _zero
.8a78	a8		tay				tay
.8a79	a5 15		lda $15				lda tmp1+1
.8a7b	95 57		sta $57,x			sta FSExp,x
.8a7d	b5 61		lda $61,x			lda FSMant0,x
.8a7f	c9 80		cmp #$80	_12:		cmp #$80		; mantissa >>=1
.8a81	6a		ror a				ror a
.8a82	76 6b		ror $6b,x			ror FSMant1,x
.8a84	76 75		ror $75,x			ror FSMant2,x
.8a86	76 7f		ror $7f,x			ror FSMant3,x
.8a88	88		dey				dey
.8a89	d0 f4		bne $8a7f			bne _12
.8a8b	95 61		sta $61,x			sta FSMant0,x
.8a8d	b4 57		ldy $57,x	_30:		ldy FSExp,x
.8a8f	a6 56		ldx $56				ldx FIndex		; restore fp stack index (FShiftAX could have had a funny one)
.8a91	60		rts				rts
.8a92	10 0e		bpl $8aa2	_overflow:	bpl _leave
.8a94	a5 15		lda $15		_zero:		lda tmp1+1
.8a96	95 57		sta $57,x			sta FSExp,x		; return zero
.8a98	a9 00		lda #$00			lda #0
.8a9a	95 61		sta $61,x			sta FSMant0,x
.8a9c	95 6b		sta $6b,x			sta FSMant1,x
.8a9e	95 75		sta $75,x			sta FSMant2,x
.8aa0	95 7f		sta $7f,x			sta FSMant3,x
.8aa2	18		clc		_leave:		clc
.8aa3	90 e8		bcc $8a8d			bcc _30
>8aa5	46 6c 6f 6f 72			Name0:	.text "Floor"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=35370					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>8aaa	45					.byte (("Floor"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=94					LinkDisplacement = Nt0-WordListLink
>8aab	10					.byte WordFlags	;wh_Flags
>8aac	03					.byte 3	;wh_CodeLength
>8aad	5e					  .byte LinkDisplacement	; offset to previous nt
=$8aae					XtPtr1 ::= *
=35370					WordListLink ::= Nt0 ; remember the nt of this word for later
.8aae	a4 56		ldy $56		Floor:		ldy FIndex
.8ab0	c0 0a		cpy #$0a			cpy #FSDim-0		; check FP stack for >=1 entries
.8ab2	b0 aa		bcs $8a5e			bcs Throw_FPStack_13a
.8ab4	b9 61 00	lda $0061,y			lda FSMant0,y		; negative?
.8ab7	10 19		bpl $8ad2			bpl _a
.8ab9	b9 57 00	lda $0057,y			lda FSExp,y		; > -1 ?
.8abc	10 14		bpl $8ad2			bpl _a
.8abe	a9 80		lda #$80			lda #$80		; return -1
.8ac0	99 61 00	sta $0061,y			sta FSMant0,y
.8ac3	a9 00		lda #$00			lda #0
.8ac5	99 57 00	sta $0057,y			sta FSExp,y
.8ac8	99 6b 00	sta $006b,y			sta FSMant1,y
.8acb	99 75 00	sta $0075,y			sta FSMant2,y
.8ace	99 7f 00	sta $007f,y			sta FSMant3,y
.8ad1	60		rts				rts
.8ad2	a9 1f		lda #$1f	_a:		lda #31
.8ad4	20 61 8a	jsr $8a61			jsr FShiftA
.8ad7	4c 6b 8b	jmp $8b6b			jmp FNormX
=44					CodeLen	.var *-XtPtr1
=$8ada					Here1 = *	; remember here
>8aac	2c					.byte CodeLen	;patch wh_CodeLength
>8ada	46 54 72 75 6e 63		Name0:	.text "FTrunc"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=35424					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>8ae0	66					.byte (("FTrunc"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=54					LinkDisplacement = Nt0-WordListLink
>8ae1	10					.byte WordFlags	;wh_Flags
>8ae2	03					.byte 3	;wh_CodeLength
>8ae3	36					  .byte LinkDisplacement	; offset to previous nt
=$8ae4					XtPtr1 ::= *
=35424					WordListLink ::= Nt0 ; remember the nt of this word for later
.8ae4	a4 56		ldy $56		FTrunc:		ldy FIndex
.8ae6	c0 0a		cpy #$0a			cpy #FSDim-0		; check FP stack for >=1 entries
.8ae8	b0 0e		bcs $8af8			bcs Throw_FPStack_13
.8aea	b9 61 00	lda $0061,y			lda FSMant0,y
.8aed	10 bf		bpl $8aae			bpl Floor
.8aef	20 79 8c	jsr $8c79			jsr FNegate
.8af2	20 ae 8a	jsr $8aae			jsr Floor
.8af5	4c 79 8c	jmp $8c79			jmp FNegate
.8af8	4c dd 84	jmp $84dd	Throw_FPStack_13: jmp Throw_FPStack
>8afb	46 52 6f 75 6e 64		Name0:	.text "FRound"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=35457					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>8b01	86					.byte (("FRound"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=33					LinkDisplacement = Nt0-WordListLink
>8b02	10					.byte WordFlags	;wh_Flags
>8b03	03					.byte 3	;wh_CodeLength
>8b04	21					  .byte LinkDisplacement	; offset to previous nt
=$8b05					XtPtr1 ::= *
=35457					WordListLink ::= Nt0 ; remember the nt of this word for later
.8b05	a9 1f		lda #$1f	FRound:		lda #31
.8b07	20 61 8a	jsr $8a61			jsr FShiftA
.8b0a	90 05		bcc $8b11			bcc _15
.8b0c	a6 14		ldx $14				ldx tmp1+0		; restore data stack index
.8b0e	4c 35 8c	jmp $8c35			jmp F1Plus
.8b11	4c 6b 8b	jmp $8b6b	_15:		jmp FNormX
=15					CodeLen	.var *-XtPtr1
=$8b14					Here1 = *	; remember here
>8b03	0f					.byte CodeLen	;patch wh_CodeLength
>8b14	46 49 6e 74 46 72 63		Name0:	.text "FIntFrc"	;  name of word as a string, ending at wh_NameLastChar
=7					NameLength = *-Name0
=35483					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>8b1b	67					.byte (("FIntFrc"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=26					LinkDisplacement = Nt0-WordListLink
>8b1c	10					.byte WordFlags	;wh_Flags
>8b1d	03					.byte 3	;wh_CodeLength
>8b1e	1a					  .byte LinkDisplacement	; offset to previous nt
=$8b1f					XtPtr1 ::= *
=35483					WordListLink ::= Nt0 ; remember the nt of this word for later
.8b1f	20 72 85	jsr $8572	FIntFrc:	jsr FDup	; ( r1 r1 )
.8b22	20 ae 8a	jsr $8aae			jsr Floor	; ( r1 rint )
.8b25	20 3f 86	jsr $863f			jsr FTuck	; ( rint r1 rint )
.8b28	20 41 8c	jsr $8c41			jsr FMinus	; ( rint rfrac )
.8b2b	4c 03 86	jmp $8603			jmp FSwap	; ( rfrac rint )
=15					CodeLen	.var *-XtPtr1
=$8b2e					Here1 = *	; remember here
>8b1d	0f					.byte CodeLen	;patch wh_CodeLength
>8b2e	46 4d 41 6c 69 67 6e 58		Name0:	.text "FMAlignX"	;  name of word as a string, ending at wh_NameLastChar
=8					NameLength = *-Name0
=35510					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>8b36	08					.byte (("FMAlignX"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=27					LinkDisplacement = Nt0-WordListLink
>8b37	10					.byte WordFlags	;wh_Flags
>8b38	03					.byte 3	;wh_CodeLength
>8b39	1b					  .byte LinkDisplacement	; offset to previous nt
=$8b3a					XtPtr1 ::= *
=35510					WordListLink ::= Nt0 ; remember the nt of this word for later
.8b3a	86 14		stx $14		FMAlignX:	stx tmp1+0	; save data stack index
.8b3c	a6 56		ldx $56				ldx FIndex	; load FP stack index
.8b3e	e0 09		cpx #$09			cpx #FSDim-1	; check FP stack for >=2 entries
.8b40	b0 19		bcs $8b5b			bcs Throw_FPStack_3
.8b42	b5 57		lda $57,x			lda FSExp+0,x	; compare exponents
.8b44	38		sec				sec
.8b45	f5 58		sbc $58,x			sbc FSExp+1,x
.8b47	30 03		bmi $8b4c			bmi _1		; r1 smaller?
.8b49	d0 08		bne $8b53			bne _2		; r2 smaller?
.8b4b	60		rts				rts
.8b4c					_1:
.8b4c	70 07		bvs $8b55			bvs _2b		; was this a big positive #?
.8b4e	b5 58		lda $58,x	_1b:		lda FSExp+1,x	; make r1 like r2
.8b50	4c 65 8a	jmp $8a65			jmp FShiftAX
.8b53					_2:
.8b53	70 f7		bvs $8b4c			bvs _1		; was this a big negative #?
.8b55	b5 57		lda $57,x	_2b:		lda FSExp+0,x	; make r2 like r1
.8b57	e8		inx				inx
.8b58	4c 65 8a	jmp $8a65			jmp FShiftAX
=33					CodeLen	.var *-XtPtr1
=$8b5b					Here1 = *	; remember here
>8b38	21					.byte CodeLen	;patch wh_CodeLength
.8b5b	20 dd 84	jsr $84dd	Throw_FPStack_3: jsr Throw_FPStack
>8b5e	46 4e 6f 72 6d			Name0:	.text "FNorm"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=35555					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>8b63	a5					.byte (("FNorm"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=45					LinkDisplacement = Nt0-WordListLink
>8b64	10					.byte WordFlags	;wh_Flags
>8b65	03					.byte 3	;wh_CodeLength
>8b66	2d					  .byte LinkDisplacement	; offset to previous nt
=$8b67					XtPtr1 ::= *
=35555					WordListLink ::= Nt0 ; remember the nt of this word for later
.8b67	86 14		stx $14		FNorm:		stx tmp1+0		; save data stack index
.8b69	a6 56		ldx $56				ldx FIndex		; switch to FP stack
.8b6b	e0 0a		cpx #$0a	FNormX:		cpx #FSDim-0		; check FP stack for >=1 entries
.8b6d	b0 89		bcs $8af8			bcs Throw_FPStack_13
.8b6f	b4 57		ldy $57,x			ldy FSExp,x
.8b71	b5 61		lda $61,x			lda FSMant0,x		; mantissa negative?
.8b73	30 31		bmi $8ba6			bmi _Neg
.8b75	d0 24		bne $8b9b			bne _Pos7		; do byte shift
.8b77	20 e3 8b	jsr $8be3			jsr _ShiftB
.8b7a	d0 0a		bne $8b86			bne _Pos2
.8b7c	20 e3 8b	jsr $8be3			jsr _ShiftB
.8b7f	d0 05		bne $8b86			bne _Pos2
.8b81	20 e3 8b	jsr $8be3			jsr _ShiftB
.8b84	f0 51		beq $8bd7			beq _zero		; no significant bits left?
.8b86	10 13		bpl $8b9b	_Pos2:		bpl _Pos7
.8b88	c8		iny		_RShift:	iny			; right shift 1 bit
.8b89	6a		ror a				ror a
.8b8a	76 6b		ror $6b,x			ror FSMant1,x
.8b8c	76 75		ror $75,x			ror FSMant2,x
.8b8e	76 7f		ror $7f,x			ror FSMant3,x
.8b90	4c 9f 8b	jmp $8b9f			jmp _Finish
.8b93	88		dey		_Pos3:		dey			; do bit shift
.8b94	16 7f		asl $7f,x			asl FSMant3,x
.8b96	36 75		rol $75,x			rol FSMant2,x
.8b98	36 6b		rol $6b,x			rol FSMant1,x
.8b9a	2a		rol a				rol a
.8b9b	c9 40		cmp #$40	_Pos7:		cmp #$40		; normalized?
.8b9d	90 f4		bcc $8b93			bcc _Pos3
.8b9f					_Finish:
.8b9f	95 61		sta $61,x			sta FSMant0,x
.8ba1	94 57		sty $57,x			sty FSExp,x	; sty dir,x exists
.8ba3	a6 14		ldx $14				ldx tmp1+0		; restore data stack index
.8ba5	60		rts				rts
.8ba6					_Neg:
.8ba6	c9 ff		cmp #$ff			cmp #$ff
.8ba8	d0 25		bne $8bcf			bne _Neg7		; do byte shift
.8baa	20 e3 8b	jsr $8be3			jsr _ShiftB
.8bad	10 d9		bpl $8b88			bpl _RShift
.8baf	c9 ff		cmp #$ff			cmp #$ff
.8bb1	d0 1c		bne $8bcf			bne _Neg7
.8bb3	20 e3 8b	jsr $8be3			jsr _ShiftB
.8bb6	10 d0		bpl $8b88			bpl _RShift
.8bb8	c9 ff		cmp #$ff			cmp #$ff
.8bba	d0 13		bne $8bcf			bne _Neg7
.8bbc	20 e3 8b	jsr $8be3			jsr _ShiftB
.8bbf	10 c7		bpl $8b88			bpl _RShift
.8bc1	c9 ff		cmp #$ff			cmp #$ff
.8bc3	d0 0a		bne $8bcf			bne _Neg7
.8bc5	f0 10		beq $8bd7			beq _zero		; no significant bits left?
.8bc7	88		dey		_Neg3:		dey
.8bc8	16 7f		asl $7f,x			asl FSMant3,x
.8bca	36 75		rol $75,x			rol FSMant2,x
.8bcc	36 6b		rol $6b,x			rol FSMant1,x
.8bce	2a		rol a				rol a
.8bcf	c9 c0		cmp #$c0	_Neg7:		cmp #$c0	; normalized?
.8bd1	b0 f4		bcs $8bc7			bcs _Neg3
.8bd3	90 ca		bcc $8b9f			bcc _Finish
.8bd5	68		pla		_Zerop:		pla
.8bd6	68		pla				pla		; pop rts addr from _ShiftB
.8bd7	a9 00		lda #$00	_zero:		lda #0
.8bd9	95 7f		sta $7f,x			sta FSMant3,x
.8bdb	95 75		sta $75,x			sta FSMant2,x
.8bdd	95 6b		sta $6b,x			sta FSMant1,x
.8bdf	a0 80		ldy #$80			ldy #$80
.8be1	d0 bc		bne $8b9f			bne _Finish
.8be3					_ShiftB:
.8be3	98		tya				tya		; exponent -= 8
.8be4	38		sec				sec
.8be5	e9 08		sbc #$08			sbc #8
.8be7	a8		tay				tay
.8be8	70 eb		bvs $8bd5			bvs _zerop	;is this useful? do we need more of them?
.8bea	b5 6b		lda $6b,x			lda FSMant1,x
.8bec	48		pha				pha
.8bed	b5 75		lda $75,x			lda FSMant2,x
.8bef	95 6b		sta $6b,x			sta FSMant1,x
.8bf1	b5 7f		lda $7f,x			lda FSMant3,x
.8bf3	95 75		sta $75,x			sta FSMant2,x
.8bf5	a9 00		lda #$00			lda #0
.8bf7	95 7f		sta $7f,x			sta FSMant3,x
.8bf9	68		pla				pla
.8bfa	60		rts				rts
=148					CodeLen	.var *-XtPtr1
=$8bfb					Here1 = *	; remember here
>8b65	94					.byte CodeLen	;patch wh_CodeLength
>8bfb	46 2b				Name0:	.text "F+"	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=35709					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>8bfd	62					.byte (("F+"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=154					LinkDisplacement = Nt0-WordListLink
>8bfe	10					.byte WordFlags	;wh_Flags
>8bff	03					.byte 3	;wh_CodeLength
>8c00	9a					  .byte LinkDisplacement	; offset to previous nt
=$8c01					XtPtr1 ::= *
=35709					WordListLink ::= Nt0 ; remember the nt of this word for later
.8c01	20 3a 8b	jsr $8b3a	FPlus:		jsr FMAlignX	; align mantissas, X= FP stack index
.8c04	18		clc				clc		; add mantissas
.8c05	b5 80		lda $80,x			lda FSMant3+1,x
.8c07	75 7f		adc $7f,x			adc FSMant3+0,x
.8c09	95 80		sta $80,x			sta FSMant3+1,x
.8c0b	b5 76		lda $76,x			lda FSMant2+1,x
.8c0d	75 75		adc $75,x			adc FSMant2+0,x
.8c0f	95 76		sta $76,x			sta FSMant2+1,x
.8c11	b5 6c		lda $6c,x			lda FSMant1+1,x
.8c13	75 6b		adc $6b,x			adc FSMant1+0,x
.8c15	95 6c		sta $6c,x			sta FSMant1+1,x
.8c17	b5 62		lda $62,x			lda FSMant0+1,x
.8c19	75 61		adc $61,x			adc FSMant0+0,x
.8c1b					FPlusFin:
.8c1b	e8		inx				inx		; FDrop r2
.8c1c	86 56		stx $56				stx FIndex
.8c1e	50 09		bvc $8c29	FPlusFin3:	bvc _19		; if overflow
.8c20	6a		ror a				ror a		;   shift mantissa right 1 bit
.8c21	76 6b		ror $6b,x			ror FSMant1,x
.8c23	76 75		ror $75,x			ror FSMant2,x
.8c25	76 7f		ror $7f,x			ror FSMant3,x
.8c27	f6 57		inc $57,x			inc FSExp,x	;   adjust exponent
.8c29					_19:
.8c29	95 61		sta $61,x			sta FSMant0,x
.8c2b	4c 6b 8b	jmp $8b6b			jmp FNormX	; normalize, return
=45					CodeLen	.var *-XtPtr1
=$8c2e					Here1 = *	; remember here
>8bff	2d					.byte CodeLen	;patch wh_CodeLength
>8c2e	46 31 2b			Name0:	.text "F1+"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=35761					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>8c31	63					.byte (("F1+"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=52					LinkDisplacement = Nt0-WordListLink
>8c32	10					.byte WordFlags	;wh_Flags
>8c33	03					.byte 3	;wh_CodeLength
>8c34	34					  .byte LinkDisplacement	; offset to previous nt
=$8c35					XtPtr1 ::= *
=35761					WordListLink ::= Nt0 ; remember the nt of this word for later
.8c35	20 8c 89	jsr $898c	F1Plus:		jsr F1
.8c38	4c 01 8c	jmp $8c01			jmp FPlus
=6					CodeLen	.var *-XtPtr1
=$8c3b					Here1 = *	; remember here
>8c33	06					.byte CodeLen	;patch wh_CodeLength
>8c3b	46 2d				Name0:	.text "F-"	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=35773					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>8c3d	a2					.byte (("F-"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=12					LinkDisplacement = Nt0-WordListLink
>8c3e	10					.byte WordFlags	;wh_Flags
>8c3f	03					.byte 3	;wh_CodeLength
>8c40	0c					  .byte LinkDisplacement	; offset to previous nt
=$8c41					XtPtr1 ::= *
=35773					WordListLink ::= Nt0 ; remember the nt of this word for later
.8c41	20 3a 8b	jsr $8b3a	FMinus:		jsr FMAlignX	; align mantissas
.8c44	38		sec				sec		; subtract mantissas
.8c45	b5 80		lda $80,x			lda FSMant3+1,x
.8c47	f5 7f		sbc $7f,x			sbc FSMant3+0,x
.8c49	95 80		sta $80,x			sta FSMant3+1,x
.8c4b	b5 76		lda $76,x			lda FSMant2+1,x
.8c4d	f5 75		sbc $75,x			sbc FSMant2+0,x
.8c4f	95 76		sta $76,x			sta FSMant2+1,x
.8c51	b5 6c		lda $6c,x			lda FSMant1+1,x
.8c53	f5 6b		sbc $6b,x			sbc FSMant1+0,x
.8c55	95 6c		sta $6c,x			sta FSMant1+1,x
.8c57	b5 62		lda $62,x			lda FSMant0+1,x
.8c59	f5 61		sbc $61,x			sbc FSMant0+0,x
.8c5b	4c 1b 8c	jmp $8c1b			jmp FPlusFin	; finish
=29					CodeLen	.var *-XtPtr1
=$8c5e					Here1 = *	; remember here
>8c3f	1d					.byte CodeLen	;patch wh_CodeLength
>8c5e	46 31 2d			Name0:	.text "F1-"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=35809					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>8c61	a3					.byte (("F1-"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=36					LinkDisplacement = Nt0-WordListLink
>8c62	10					.byte WordFlags	;wh_Flags
>8c63	03					.byte 3	;wh_CodeLength
>8c64	24					  .byte LinkDisplacement	; offset to previous nt
=$8c65					XtPtr1 ::= *
=35809					WordListLink ::= Nt0 ; remember the nt of this word for later
.8c65	20 8c 89	jsr $898c	F1Minus:	jsr F1
.8c68	4c 41 8c	jmp $8c41			jmp FMinus
=6					CodeLen	.var *-XtPtr1
=$8c6b					Here1 = *	; remember here
>8c63	06					.byte CodeLen	;patch wh_CodeLength
.8c6b	4c dd 84	jmp $84dd	Throw_FPStack_14: jmp Throw_FPStack
>8c6e	46 4e 65 67 61 74 65		Name0:	.text "FNegate"	;  name of word as a string, ending at wh_NameLastChar
=7					NameLength = *-Name0
=35829					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>8c75	a7					.byte (("FNegate"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=20					LinkDisplacement = Nt0-WordListLink
>8c76	10					.byte WordFlags	;wh_Flags
>8c77	03					.byte 3	;wh_CodeLength
>8c78	14					  .byte LinkDisplacement	; offset to previous nt
=$8c79					XtPtr1 ::= *
=35829					WordListLink ::= Nt0 ; remember the nt of this word for later
.8c79	86 14		stx $14		FNegate:	stx tmp1	; save data stack index
.8c7b	a6 56		ldx $56				ldx FIndex	; X= FP stack index
.8c7d	e0 0a		cpx #$0a			cpx #FSDim-0	; check FP stack for >=1 entries
.8c7f	b0 ea		bcs $8c6b			bcs Throw_FPStack_14
.8c81	38		sec				sec		; mantissa = 0 - mantissa
.8c82	a9 00		lda #$00			lda #0
.8c84	f5 7f		sbc $7f,x			sbc FSMant3,x
.8c86	95 7f		sta $7f,x			sta FSMant3,x
.8c88	a9 00		lda #$00			lda #0
.8c8a	f5 75		sbc $75,x			sbc FSMant2,x
.8c8c	95 75		sta $75,x			sta FSMant2,x
.8c8e	a9 00		lda #$00			lda #0
.8c90	f5 6b		sbc $6b,x			sbc FSMant1,x
.8c92	95 6b		sta $6b,x			sta FSMant1,x
.8c94	a9 00		lda #$00			lda #0
.8c96	f5 61		sbc $61,x			sbc FSMant0,x
.8c98	4c 1e 8c	jmp $8c1e			jmp FPlusFin3	; finish up, return
=34					CodeLen	.var *-XtPtr1
=$8c9b					Here1 = *	; remember here
>8c77	22					.byte CodeLen	;patch wh_CodeLength
>8c9b	46 41 62 73			Name0:	.text "FAbs"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=35871					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>8c9f	64					.byte (("FAbs"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=42					LinkDisplacement = Nt0-WordListLink
>8ca0	10					.byte WordFlags	;wh_Flags
>8ca1	03					.byte 3	;wh_CodeLength
>8ca2	2a					  .byte LinkDisplacement	; offset to previous nt
=$8ca3					XtPtr1 ::= *
=35871					WordListLink ::= Nt0 ; remember the nt of this word for later
.8ca3	a4 56		ldy $56		FAbs:		ldy FIndex
.8ca5	c0 0a		cpy #$0a			cpy #FSDim-0	; check FP stack for >=1 entries
.8ca7	b0 c2		bcs $8c6b			bcs Throw_FPStack_14
.8ca9	b9 61 00	lda $0061,y			lda FSMant0,y		; mantissa negative?
.8cac	30 cb		bmi $8c79			bmi FNegate
.8cae	60		rts				rts
=12					CodeLen	.var *-XtPtr1
=$8caf					Here1 = *	; remember here
>8ca1	0c					.byte CodeLen	;patch wh_CodeLength
.8caf	4c dd 84	jmp $84dd	Throw_FPStack_4: jmp Throw_FPStack
.8cb2	a4 56		ldy $56		FPos:		ldy FIndex		; load FP stack index
.8cb4	c0 09		cpy #$09			cpy #FSDim-1		; check FP stack for 2
.8cb6	b0 f7		bcs $8caf			bcs Throw_FPStack_4
.8cb8	b9 61 00	lda $0061,y			lda FSMant0+0,y		; calc result sign
.8cbb	59 62 00	eor $0062,y			eor FSMant0+1,y
.8cbe	08		php				php
.8cbf	b9 62 00	lda $0062,y			lda FSMant0+1,y		; if NOS negative
.8cc2	10 07		bpl $8ccb			bpl +
.8cc4	e6 56		inc $56				inc FIndex		;   point at NOS
.8cc6	20 79 8c	jsr $8c79			jsr FNegate		;   negate NOS
.8cc9	c6 56		dec $56				dec FIndex		;   restore fp
.8ccb					+
.8ccb	20 a3 8c	jsr $8ca3			jsr FAbs		; abs TOS
.8cce	86 14		stx $14				stx tmp1+0		; save data stack index
.8cd0	a6 56		ldx $56				ldx FIndex		; load FP stack index
.8cd2	28		plp				plp			; return sign flag
=48					CodeLen	.var *-XtPtr1
=$8cd3					Here1 = *	; remember here
>8ca1	30					.byte CodeLen	;patch wh_CodeLength
.8cd3	60		rts				rts
>8cd4	46 2a				Name0:	.text "F*"	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=35926					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>8cd6	42					.byte (("F*"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=55					LinkDisplacement = Nt0-WordListLink
>8cd7	10					.byte WordFlags	;wh_Flags
>8cd8	03					.byte 3	;wh_CodeLength
>8cd9	37					  .byte LinkDisplacement	; offset to previous nt
=$8cda					XtPtr1 ::= *
=35926					WordListLink ::= Nt0 ; remember the nt of this word for later
.8cda					FStar:
.8cda	20 b2 8c	jsr $8cb2			jsr FPos		; make r1 & r2 positive,
.8cdd	08		php				php			;   save r3 sign
.8cde	b5 57		lda $57,x			lda FSExp+0,x		; add exponents
.8ce0	18		clc				clc
.8ce1	75 58		adc $58,x			adc FSExp+1,x
.8ce3	95 58		sta $58,x			sta FSExp+1,x
.8ce5	50 12		bvc $8cf9			bvc _49			; IfVs,
.8ce7	b0 06		bcs $8cef			bcs _zero		;   underflow?
.8ce9	a6 14		ldx $14				ldx tmp1+0		;   restore data stack index
.8ceb	28		plp				plp			;   RDrop sign flag
.8cec	20 e8 84	jsr $84e8			jsr Throw_FpOutOfRange
.8cef	e8		inx		_zero:		inx			; F2Drop r1 & r2
.8cf0	e8		inx				inx
.8cf1	86 56		stx $56				stx FIndex
.8cf3	28		plp				plp			; RDrop saved result sign
.8cf4	a6 14		ldx $14				ldx tmp1+0		; restore data stack index
.8cf6	4c 54 89	jmp $8954			jmp F0			; return zero
.8cf9					_49:
.8cf9	a9 00		lda #$00			lda #0			; tmp32= 0
.8cfb	85 16		sta $16				sta tmp2+0
.8cfd	85 17		sta $17				sta tmp2+1
.8cff	85 18		sta $18				sta tmp3+0
.8d01	85 19		sta $19				sta tmp3+1
.8d03	a0 08		ldy #$08			ldy #8			; for each bit in byte
.8d05					_e:
.8d05	46 19		lsr $19				lsr tmp3+1		;   tmp32 >>= 1
.8d07	66 18		ror $18				ror tmp3+0
.8d09	66 17		ror $17				ror tmp2+1
.8d0b	66 16		ror $16				ror tmp2+0
.8d0d	56 7f		lsr $7f,x			lsr FSMant3+0,x		;   if r2.FSMant3 bit set
.8d0f	90 13		bcc $8d24			bcc _a
.8d11	18		clc				clc
.8d12	b5 62		lda $62,x			lda FSMant0+1,x		;     tmp32 += r1>>24
.8d14	65 16		adc $16				adc tmp2+0
.8d16	85 16		sta $16				sta tmp2+0
.8d18	90 0a		bcc $8d24			bcc _a
.8d1a	e6 17		inc $17				inc tmp2+1
.8d1c	d0 06		bne $8d24			bne _a
.8d1e	e6 18		inc $18				inc tmp3+0
.8d20	d0 02		bne $8d24			bne _a
.8d22	e6 19		inc $19				inc tmp3+1
.8d24					_a:
.8d24	56 75		lsr $75,x			lsr FSMant2+0,x		;   if r2.FSMant2 bit set
.8d26	90 15		bcc $8d3d			bcc _b
.8d28	18		clc				clc
.8d29	b5 6c		lda $6c,x			lda FSMant1+1,x		;     tmp32 += r1>>16
.8d2b	65 16		adc $16				adc tmp2+0
.8d2d	85 16		sta $16				sta tmp2+0
.8d2f	b5 62		lda $62,x			lda FSMant0+1,x
.8d31	65 17		adc $17				adc tmp2+1
.8d33	85 17		sta $17				sta tmp2+1
.8d35	90 06		bcc $8d3d			bcc _b
.8d37	e6 18		inc $18				inc tmp3+0
.8d39	d0 02		bne $8d3d			bne _b
.8d3b	e6 19		inc $19				inc tmp3+1
.8d3d					_b:
.8d3d	56 6b		lsr $6b,x			lsr FSMant1+0,x		;   if r2.FSMant1 bit set
.8d3f	90 17		bcc $8d58			bcc _c
.8d41	18		clc				clc
.8d42	b5 76		lda $76,x			lda FSMant2+1,x		;     tmp32 += r1>>8
.8d44	65 16		adc $16				adc tmp2+0
.8d46	85 16		sta $16				sta tmp2+0
.8d48	b5 6c		lda $6c,x			lda FSMant1+1,x
.8d4a	65 17		adc $17				adc tmp2+1
.8d4c	85 17		sta $17				sta tmp2+1
.8d4e	b5 62		lda $62,x			lda FSMant0+1,x
.8d50	65 18		adc $18				adc tmp3+0
.8d52	85 18		sta $18				sta tmp3+0
.8d54	90 02		bcc $8d58			bcc _c
.8d56	e6 19		inc $19				inc tmp3+1
.8d58					_c:
.8d58	56 61		lsr $61,x			lsr FSMant0+0,x		;   if r2.FSMant0 bit set
.8d5a	90 19		bcc $8d75			bcc _d
.8d5c	18		clc				clc
.8d5d	b5 80		lda $80,x			lda FSMant3+1,x		;     tmp32 += r1
.8d5f	65 16		adc $16				adc tmp2+0
.8d61	85 16		sta $16				sta tmp2+0
.8d63	b5 76		lda $76,x			lda FSMant2+1,x
.8d65	65 17		adc $17				adc tmp2+1
.8d67	85 17		sta $17				sta tmp2+1
.8d69	b5 6c		lda $6c,x			lda FSMant1+1,x
.8d6b	65 18		adc $18				adc tmp3+0
.8d6d	85 18		sta $18				sta tmp3+0
.8d6f	b5 62		lda $62,x			lda FSMant0+1,x
.8d71	65 19		adc $19				adc tmp3+1
.8d73	85 19		sta $19				sta tmp3+1
.8d75					_d:
.8d75	88		dey				dey			;  next bit
.8d76	d0 8d		bne $8d05			bne _e
.8d78	a5 16		lda $16				lda tmp2+0		; r1.mant= tmp32
.8d7a	95 80		sta $80,x			sta FSMant3+1,x
.8d7c	a5 17		lda $17				lda tmp2+1
.8d7e	95 76		sta $76,x			sta FSMant2+1,x
.8d80	a5 18		lda $18				lda tmp3+0
.8d82	95 6c		sta $6c,x			sta FSMant1+1,x
.8d84	a5 19		lda $19				lda tmp3+1
.8d86	95 62		sta $62,x			sta FSMant0+1,x
.8d88	e6 56		inc $56				inc FIndex		; FDrop
.8d8a	a6 14		ldx $14				ldx tmp1+0		; restore data stack index
.8d8c	28		plp				plp			; fix result sign
.8d8d	10 03		bpl $8d92			bpl +
.8d8f	4c 79 8c	jmp $8c79			jmp FNegate
.8d92					+
.8d92	4c 67 8b	jmp $8b67			jmp FNorm
=187					CodeLen	.var *-XtPtr1
=$8d95					Here1 = *	; remember here
>8cd8	bb					.byte CodeLen	;patch wh_CodeLength
>8d95	46 53 71 72			Name0:	.text "FSqr"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=36121					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>8d99	44					.byte (("FSqr"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=195					LinkDisplacement = Nt0-WordListLink
>8d9a	10					.byte WordFlags	;wh_Flags
>8d9b	03					.byte 3	;wh_CodeLength
>8d9c	c3					  .byte LinkDisplacement	; offset to previous nt
=$8d9d					XtPtr1 ::= *
=36121					WordListLink ::= Nt0 ; remember the nt of this word for later
.8d9d	20 72 85	jsr $8572	FSqr:		jsr FDup
.8da0	4c da 8c	jmp $8cda			jmp FStar
=6					CodeLen	.var *-XtPtr1
=$8da3					Here1 = *	; remember here
>8d9b	06					.byte CodeLen	;patch wh_CodeLength
>8da3	46 2f				Name0:	.text "F/"	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=36133					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>8da5	e2					.byte (("F/"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=12					LinkDisplacement = Nt0-WordListLink
>8da6	10					.byte WordFlags	;wh_Flags
>8da7	03					.byte 3	;wh_CodeLength
>8da8	0c					  .byte LinkDisplacement	; offset to previous nt
=$8da9					XtPtr1 ::= *
=36133					WordListLink ::= Nt0 ; remember the nt of this word for later
.8da9	20 b2 8c	jsr $8cb2	FSlash:		jsr FPos		; make r1 & r2 positive
.8dac	08		php				php			;   save result sign
.8dad	b5 58		lda $58,x			lda FSExp+1,x		; calc exponent
.8daf	18		clc				clc
.8db0	69 01		adc #$01			adc #1
.8db2	38		sec				sec
.8db3	f5 57		sbc $57,x			sbc FSExp+0,x
.8db5	95 58		sta $58,x			sta FSExp+1,x
.8db7	50 12		bvc $8dcb			bvc _49			;  IfVs
.8db9	b0 06		bcs $8dc1			bcs _Zero		; underflow?
.8dbb	28		plp				plp			; drop saved result sign
.8dbc	a6 15		ldx $15				ldx tmp1+1		; restore data stack index
.8dbe	20 e8 84	jsr $84e8			jsr Throw_FpOutOfRange	; overflow
.8dc1	e8		inx		_Zero:		inx			; F2Drop
.8dc2	e8		inx				inx
.8dc3	86 56		stx $56				stx FIndex
.8dc5	28		plp				plp			; drop saved result sign
.8dc6	a6 14		ldx $14				ldx tmp1+0		; restore data stack index
.8dc8	4c 54 89	jmp $8954			jmp F0			; return 0
.8dcb					_49:
.8dcb	b5 80		lda $80,x			lda FSMant3+1,x		; tmp32 = r1
.8dcd	85 16		sta $16				sta tmp2+0
.8dcf	b5 76		lda $76,x			lda FSMant2+1,x
.8dd1	85 17		sta $17				sta tmp2+1
.8dd3	b5 6c		lda $6c,x			lda FSMant1+1,x
.8dd5	85 18		sta $18				sta tmp3+0
.8dd7	b5 62		lda $62,x			lda FSMant0+1,x
.8dd9	85 19		sta $19				sta tmp3+1
.8ddb	20 04 8e	jsr $8e04			jsr _Byte
.8dde	95 62		sta $62,x			sta FSMant0+1,x
.8de0	20 04 8e	jsr $8e04			jsr _Byte
.8de3	95 6c		sta $6c,x			sta FSMant1+1,x
.8de5	20 04 8e	jsr $8e04			jsr _Byte
.8de8	95 76		sta $76,x			sta FSMant2+1,x
.8dea	20 04 8e	jsr $8e04			jsr _Byte
.8ded	95 80		sta $80,x			sta FSMant3+1,x
.8def	56 62		lsr $62,x			lsr FSMant0+1,x
.8df1	76 6c		ror $6c,x			ror FSMant1+1,x
.8df3	76 76		ror $76,x			ror FSMant2+1,x
.8df5	76 80		ror $80,x			ror FSMant3+1,x
.8df7	e6 56		inc $56				inc FIndex		; FDrop
.8df9	a6 14		ldx $14				ldx tmp1+0		; restore X
.8dfb	28		plp				plp			; fix sign
.8dfc	10 03		bpl $8e01			bpl +
.8dfe	20 79 8c	jsr $8c79			jsr FNegate
.8e01	4c 67 8b	jmp $8b67	+		jmp FNorm
.8e04					_Byte:
.8e04	a0 08		ldy #$08			ldy #8			; for 8 bits
.8e06					_1:
.8e06	a5 19		lda $19				lda tmp3+1		;   if r1>=r2
.8e08	d5 61		cmp $61,x			cmp FSMant0+0,x
.8e0a	d0 10		bne $8e1c			bne _4
.8e0c	a5 18		lda $18				lda tmp3+0
.8e0e	d5 6b		cmp $6b,x			cmp FSMant1+0,x
.8e10	d0 0a		bne $8e1c			bne _4
.8e12	a5 17		lda $17				lda tmp2+1
.8e14	d5 75		cmp $75,x			cmp FSMant2+0,x
.8e16	d0 04		bne $8e1c			bne _4
.8e18	a5 16		lda $16				lda tmp2+0
.8e1a	d5 7f		cmp $7f,x			cmp FSMant3+0,x
.8e1c	90 18		bcc $8e36	_4:		bcc _2
.8e1e	a5 16		lda $16				lda tmp2+0		;     tmp32 -= r2
.8e20	f5 7f		sbc $7f,x			sbc FSMant3+0,x
.8e22	85 16		sta $16				sta tmp2+0
.8e24	a5 17		lda $17				lda tmp2+1
.8e26	f5 75		sbc $75,x			sbc FSMant2+0,x
.8e28	85 17		sta $17				sta tmp2+1
.8e2a	a5 18		lda $18				lda tmp3+0
.8e2c	f5 6b		sbc $6b,x			sbc FSMant1+0,x
.8e2e	85 18		sta $18				sta tmp3+0
.8e30	a5 19		lda $19				lda tmp3+1
.8e32	f5 61		sbc $61,x			sbc FSMant0+0,x
.8e34	85 19		sta $19				sta tmp3+1
.8e36	26 15		rol $15		_2:		rol tmp1+1		;   accum quotient bits
.8e38	06 16		asl $16				asl tmp2+0
.8e3a	26 17		rol $17				rol tmp2+1
.8e3c	26 18		rol $18				rol tmp3+0
.8e3e	26 19		rol $19				rol tmp3+1		;   tmp32<<=1
.8e40	88		dey				dey			;  next
.8e41	d0 c3		bne $8e06			bne _1
.8e43	a5 15		lda $15				lda tmp1+1		; return bits
.8e45	60		rts				rts
=157					CodeLen	.var *-XtPtr1
=$8e46					Here1 = *	; remember here
>8da7	9d					.byte CodeLen	;patch wh_CodeLength
>8e46	46 31 2f			Name0:	.text "F1/"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=36297					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>8e49	e3					.byte (("F1/"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=164					LinkDisplacement = Nt0-WordListLink
>8e4a	10					.byte WordFlags	;wh_Flags
>8e4b	03					.byte 3	;wh_CodeLength
>8e4c	a4					  .byte LinkDisplacement	; offset to previous nt
=$8e4d					XtPtr1 ::= *
=36297					WordListLink ::= Nt0 ; remember the nt of this word for later
.8e4d	20 8c 89	jsr $898c	F1Slash:	jsr F1
.8e50	20 03 86	jsr $8603			jsr FSwap
.8e53	4c a9 8d	jmp $8da9			jmp FSlash
=9					CodeLen	.var *-XtPtr1
=$8e56					Here1 = *	; remember here
>8e4b	09					.byte CodeLen	;patch wh_CodeLength
>8e56	45 2a				Name0:	.text "E*"	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=36312					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>8e58	42					.byte (("E*"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=15					LinkDisplacement = Nt0-WordListLink
>8e59	10					.byte WordFlags	;wh_Flags
>8e5a	03					.byte 3	;wh_CodeLength
>8e5b	0f					  .byte LinkDisplacement	; offset to previous nt
=$8e5c					XtPtr1 ::= *
=36312					WordListLink ::= Nt0 ; remember the nt of this word for later
.8e5c					EStar:
.8e5c	20 b2 8c	jsr $8cb2			jsr FPos		; make r1 & r2 positive
.8e5f	08		php				php			;   remember result sign
.8e60	b5 57		lda $57,x			lda FSExp+0,x		; add exponents
.8e62	18		clc				clc
.8e63	75 58		adc $58,x			adc FSExp+1,x
.8e65	95 58		sta $58,x			sta FSExp+1,x
.8e67	70 3a		bvs $8ea3			bvs _ExpOvfl
.8e69	a9 00		lda #$00			lda #0
.8e6b	85 16		sta $16				sta tmp2+0		; zero result
.8e6d	85 17		sta $17				sta tmp2+1
.8e6f	a0 08		ldy #$08			ldy #8			; for 8 bits in byte
.8e71					_e:
.8e71	46 17		lsr $17				lsr tmp2+1		;   result >>=1
.8e73	66 16		ror $16				ror tmp2+0
.8e75	56 6c		lsr $6c,x			lsr FSMant1+1,x		;   if bit set
.8e77	90 0b		bcc $8e84			bcc _a
.8e79	18		clc				clc
.8e7a	b5 61		lda $61,x			lda FSMant0+0,x		;     result += r2>>8
.8e7c	65 16		adc $16				adc tmp2+0
.8e7e	85 16		sta $16				sta tmp2+0
.8e80	90 02		bcc $8e84			bcc _a
.8e82	e6 17		inc $17				inc tmp2+1
.8e84					_a:
.8e84	56 62		lsr $62,x			lsr FSMant0+1,x		;   if bit set
.8e86	90 0d		bcc $8e95			bcc _b
.8e88	18		clc				clc
.8e89	b5 6b		lda $6b,x			lda FSMant1+0,x		;     result += r2
.8e8b	65 16		adc $16				adc tmp2+0
.8e8d	85 16		sta $16				sta tmp2+0
.8e8f	b5 61		lda $61,x			lda FSMant0+0,x
.8e91	65 17		adc $17				adc tmp2+1
.8e93	85 17		sta $17				sta tmp2+1
.8e95					_b:
.8e95	88		dey				dey			;  next bit
.8e96	d0 d9		bne $8e71			bne _e
.8e98	a5 16		lda $16				lda tmp2+0		; r3 = result
.8e9a	95 6c		sta $6c,x			sta FSMant1+1,x
.8e9c	a5 17		lda $17				lda tmp2+1
.8e9e	95 62		sta $62,x			sta FSMant0+1,x
.8ea0	4c b2 8e	jmp $8eb2			jmp EFix3		; finish
.8ea3					_ExpOvfl:
.8ea3	b0 05		bcs $8eaa			bcs _Zero		;underflow?
.8ea5	a6 14		ldx $14				ldx tmp1+0		; restore X
.8ea7	20 e8 84	jsr $84e8			jsr Throw_FpOutOfRange	;overflow
.8eaa	a9 00		lda #$00	_Zero:		lda #0
.8eac	95 6c		sta $6c,x			sta FSMant1+1,x
.8eae	95 62		sta $62,x			sta FSMant0+1,x
.8eb0	f0 00		beq $8eb2			beq EFix3
=86					CodeLen	.var *-XtPtr1
=$8eb2					Here1 = *	; remember here
>8e5a	56					.byte CodeLen	;patch wh_CodeLength
.8eb2					EFix3:
.8eb2	a9 00		lda #$00			lda #0			; zero unused mantissa
.8eb4	95 76		sta $76,x			sta FSMant2+1,x
.8eb6	95 80		sta $80,x			sta FSMant3+1,x
.8eb8	e6 56		inc $56				inc FIndex		; FDrop
.8eba	a6 14		ldx $14				ldx tmp1+0		; restore X
.8ebc	28		plp				plp			;fix result sign
.8ebd	10 03		bpl $8ec2			bpl +
.8ebf	4c 79 8c	jmp $8c79			jmp FNegate
.8ec2	4c 67 8b	jmp $8b67	+		jmp FNorm
>8ec5	45 53 71 72			Name0:	.text "ESqr"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=36425					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>8ec9	44					.byte (("ESqr"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=113					LinkDisplacement = Nt0-WordListLink
>8eca	10					.byte WordFlags	;wh_Flags
>8ecb	03					.byte 3	;wh_CodeLength
>8ecc	71					  .byte LinkDisplacement	; offset to previous nt
=$8ecd					XtPtr1 ::= *
=36425					WordListLink ::= Nt0 ; remember the nt of this word for later
.8ecd	20 72 85	jsr $8572	ESqr:		jsr FDup
.8ed0	4c 5c 8e	jmp $8e5c			jmp EStar
=6					CodeLen	.var *-XtPtr1
=$8ed3					Here1 = *	; remember here
>8ecb	06					.byte CodeLen	;patch wh_CodeLength
>8ed3	45 2f				Name0:	.text "E/"	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=36437					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>8ed5	e2					.byte (("E/"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=12					LinkDisplacement = Nt0-WordListLink
>8ed6	10					.byte WordFlags	;wh_Flags
>8ed7	03					.byte 3	;wh_CodeLength
>8ed8	0c					  .byte LinkDisplacement	; offset to previous nt
=$8ed9					XtPtr1 ::= *
=36437					WordListLink ::= Nt0 ; remember the nt of this word for later
.8ed9	20 4a a2	jsr $a24a	ESlash:		jsr EPos	; make e1 & e2 positive
.8edc	08		php				php		; remember result sign
.8edd	b5 58		lda $58,x			lda FSExp+1,x		; calc e3 exponent
.8edf	38		sec				sec
.8ee0	f5 57		sbc $57,x			sbc FSExp+0,x
.8ee2	70 17		bvs $8efb			bvs _ExpOvfl
.8ee4	18		clc				clc
.8ee5	69 01		adc #$01			adc #1
.8ee7	95 58		sta $58,x			sta FSExp+1,x
.8ee9	20 0b 8f	jsr $8f0b			jsr _Byte		; gen quotient hi byte
.8eec	48		pha				pha
.8eed	20 0b 8f	jsr $8f0b			jsr _Byte		; gen quotient lo byte
.8ef0	95 6c		sta $6c,x			sta FSMant1+1,x
.8ef2	68		pla				pla
.8ef3	4a		lsr a				lsr a
.8ef4	95 62		sta $62,x			sta FSMant0+1,x
.8ef6	76 6c		ror $6c,x			ror FSMant1+1,x
.8ef8	4c b2 8e	jmp $8eb2			jmp EFix3
.8efb					_ExpOvfl:
.8efb	a6 14		ldx $14				ldx tmp1+0		; restore data stack index
.8efd	b0 04		bcs $8f03			bcs _zero		; underflow?
.8eff	28		plp				plp			; rdrop saved result sign
.8f00	20 e8 84	jsr $84e8			jsr Throw_FpOutOfRange	; overflow
.8f03	28		plp		_zero:		plp			; rdrop saved result sign
.8f04	e6 56		inc $56				inc FIndex		; FDrop e2
.8f06	e6 56		inc $56				inc FIndex		; FDrop e1
.8f08	4c 7a 9f	jmp $9f7a			jmp E0			; return zero
.8f0b					_Byte:
.8f0b	a0 08		ldy #$08			ldy #8			; for 8 bits
.8f0d	b5 6c		lda $6c,x	_b1:		lda FSMant1+1,x		;   if r1 >= r2
.8f0f	d5 6b		cmp $6b,x			cmp FSMant1+0,x
.8f11	b5 62		lda $62,x			lda FSMant0+1,x
.8f13	f5 61		sbc $61,x			sbc FSMant0+0,x
.8f15	90 09		bcc $8f20			bcc _b5
.8f17	95 62		sta $62,x			sta FSMant0+1,x
.8f19	b5 6c		lda $6c,x			lda FSMant1+1,x		;     r1 -= r2
.8f1b	f5 6b		sbc $6b,x			sbc FSMant1+0,x
.8f1d	95 6c		sta $6c,x			sta FSMant1+1,x
.8f1f	38		sec				sec
.8f20					_b5:
.8f20	26 15		rol $15				rol tmp1+1		;   save quotient bit
.8f22	16 6c		asl $6c,x			asl FSMant1+1,x		;   r1 *= 2
.8f24	36 62		rol $62,x			rol FSMant0+1,x
.8f26	88		dey				dey			;  next bit
.8f27	d0 e4		bne $8f0d			bne _b1
.8f29	a5 15		lda $15				lda tmp1+1		; return bits
.8f2b	60		rts				rts
=83					CodeLen	.var *-XtPtr1
=$8f2c					Here1 = *	; remember here
>8ed7	53					.byte CodeLen	;patch wh_CodeLength
>8f2c	45 31 2f			Name0:	.text "E1/"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=36527					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>8f2f	e3					.byte (("E1/"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=90					LinkDisplacement = Nt0-WordListLink
>8f30	10					.byte WordFlags	;wh_Flags
>8f31	03					.byte 3	;wh_CodeLength
>8f32	5a					  .byte LinkDisplacement	; offset to previous nt
=$8f33					XtPtr1 ::= *
=36527					WordListLink ::= Nt0 ; remember the nt of this word for later
.8f33	20 8c 89	jsr $898c	E1Slash:	jsr F1
.8f36	20 03 86	jsr $8603			jsr FSwap
.8f39	4c d9 8e	jmp $8ed9			jmp ESlash
=9					CodeLen	.var *-XtPtr1
=$8f3c					Here1 = *	; remember here
>8f31	09					.byte CodeLen	;patch wh_CodeLength
.8f3c	4c dd 84	jmp $84dd	Throw_FPStack_15b: jmp Throw_FPStack
>8f3f	53 3e 46			Name0:	.text "S>F"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=36546					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>8f42	c3					.byte (("S>F"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=19					LinkDisplacement = Nt0-WordListLink
>8f43	10					.byte WordFlags	;wh_Flags
>8f44	03					.byte 3	;wh_CodeLength
>8f45	13					  .byte LinkDisplacement	; offset to previous nt
=$8f46					XtPtr1 ::= *
=36546					WordListLink ::= Nt0 ; remember the nt of this word for later
.8f46	20 62 c5	jsr $c562	SToF:		jsr PopYA		; pop n
.8f49					SToFYA:
.8f49	86 14		stx $14				stx tmp1+0	; save data stack index
.8f4b	c6 56		dec $56				dec FIndex	; alloc a FP stack entry
.8f4d	30 ed		bmi $8f3c			bmi Throw_FPStack_15b	;   if FP stack overflow (or massive underflow)
.8f4f	a6 56		ldx $56				ldx FIndex	; X= Floating Point stack index
.8f51	95 6b		sta $6b,x			sta FSMant1,x		; copy n to mantissa
.8f53	94 61		sty $61,x			sty FSMant0,x	; sty dir,x exists
.8f55	a9 00		lda #$00			lda #0			; pad mantissa
.8f57	95 75		sta $75,x			sta FSMant2,x
.8f59	95 7f		sta $7f,x			sta FSMant3,x
.8f5b	a9 0f		lda #$0f			lda #15			; set exponent
.8f5d	95 57		sta $57,x			sta FSExp,x
.8f5f	4c 6b 8b	jmp $8b6b			jmp FNormX		; normalize, return
=28					CodeLen	.var *-XtPtr1
=$8f62					Here1 = *	; remember here
>8f44	1c					.byte CodeLen	;patch wh_CodeLength
>8f62	44 3e 46			Name0:	.text "D>F"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=36581					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>8f65	c3					.byte (("D>F"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=35					LinkDisplacement = Nt0-WordListLink
>8f66	10					.byte WordFlags	;wh_Flags
>8f67	03					.byte 3	;wh_CodeLength
>8f68	23					  .byte LinkDisplacement	; offset to previous nt
=$8f69					XtPtr1 ::= *
=36581					WordListLink ::= Nt0 ; remember the nt of this word for later
.8f69					FDToF:
.8f69	86 14		stx $14				stx tmp1+0	; save data stack index
.8f6b	c6 56		dec $56				dec FIndex	; alloc a FP stack entry
.8f6d	30 63		bmi $8fd2			bmi Throw_FPStack_15	;   if FP stack overflow (or massive underflow)
.8f6f	a6 56		ldx $56				ldx FIndex	; X= Floating Point stack index
.8f71	a6 14		ldx $14				ldx tmp1+0		; restore data stack index
.8f73	a4 56		ldy $56				ldy FIndex		; Y= fp stack index
.8f75	b5 28		lda $28,x			lda DStack+2,x		; mantissa= d
.8f77	99 7f 00	sta $007f,y			sta FSMant3,y
.8f7a	b5 29		lda $29,x			lda DStack+3,x
.8f7c	99 75 00	sta $0075,y			sta FSMant2,y
.8f7f	b5 26		lda $26,x			lda DStack+0,x
.8f81	99 6b 00	sta $006b,y			sta FSMant1,y
.8f84	b5 27		lda $27,x			lda DStack+1,x
.8f86	99 61 00	sta $0061,y			sta FSMant0,y
.8f89	a9 1f		lda #$1f			lda #31			; set exponent
.8f8b	99 57 00	sta $0057,y			sta FSExp,y
.8f8e	20 04 d7	jsr $d704			jsr Two_Drop
.8f91	4c 67 8b	jmp $8b67			jmp FNorm		; normalize, return
=43					CodeLen	.var *-XtPtr1
=$8f94					Here1 = *	; remember here
>8f67	2b					.byte CodeLen	;patch wh_CodeLength
>8f94	46 3e 53			Name0:	.text "F>S"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=36631					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>8f97	63					.byte (("F>S"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=50					LinkDisplacement = Nt0-WordListLink
>8f98	10					.byte WordFlags	;wh_Flags
>8f99	03					.byte 3	;wh_CodeLength
>8f9a	32					  .byte LinkDisplacement	; offset to previous nt
=$8f9b					XtPtr1 ::= *
=36631					WordListLink ::= Nt0 ; remember the nt of this word for later
.8f9b	a4 56		ldy $56		FToS:		ldy FIndex
.8f9d	c0 0a		cpy #$0a			cpy #FSDim-0		; check FP stack for >=1 entries
.8f9f	b0 31		bcs $8fd2			bcs Throw_FPStack_15
.8fa1	b9 61 00	lda $0061,y			lda FSMant0,y		; save sign
.8fa4	08		php				php
.8fa5	10 03		bpl $8faa			bpl +
.8fa7	20 79 8c	jsr $8c79			jsr FNegate
.8faa					+
.8faa	a9 0f		lda #$0f			lda #15
.8fac	20 61 8a	jsr $8a61			jsr FShiftA
.8faf	a6 14		ldx $14				ldx tmp1+0		; restore data stack index
.8fb1	c0 10		cpy #$10			cpy #15+1		; always positive, so unsigned compare works
.8fb3	b0 17		bcs $8fcc			bcs _overflow
.8fb5	a4 56		ldy $56				ldy FIndex
.8fb7	ca		dex				dex
.8fb8	ca		dex				dex
.8fb9	b9 61 00	lda $0061,y			lda FSMant0,y
.8fbc	95 27		sta $27,x			sta DStack+1,x
.8fbe	b9 6b 00	lda $006b,y			lda FSMant1,y
.8fc1	95 26		sta $26,x			sta DStack+0,x
.8fc3	e6 56		inc $56				inc FIndex		; FDrop
.8fc5	28		plp				plp			; apply saved sign
.8fc6	30 01		bmi $8fc9			bmi +
.8fc8	60		rts				rts
.8fc9	4c 7b d8	jmp $d87b	+		jmp Negate
.8fcc	28		plp		_overflow:	plp			; RDrop saved sign
.8fcd	a9 f5		lda #$f5			lda #$100+err_OutOfRange
.8fcf	20 dc c5	jsr $c5dc			jsr ThrowA
=55					CodeLen	.var *-XtPtr1
=$8fd2					Here1 = *	; remember here
>8f99	37					.byte CodeLen	;patch wh_CodeLength
.8fd2	4c dd 84	jmp $84dd	Throw_FPStack_15: jmp Throw_FPStack
>8fd5	46 3e 44			Name0:	.text "F>D"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=36696					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>8fd8	83					.byte (("F>D"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=65					LinkDisplacement = Nt0-WordListLink
>8fd9	10					.byte WordFlags	;wh_Flags
>8fda	03					.byte 3	;wh_CodeLength
>8fdb	41					  .byte LinkDisplacement	; offset to previous nt
=$8fdc					XtPtr1 ::= *
=36696					WordListLink ::= Nt0 ; remember the nt of this word for later
.8fdc	a4 56		ldy $56		FToD:		ldy FIndex
.8fde	c0 0a		cpy #$0a			cpy #FSDim-0		; check FP stack for >=1 entries
.8fe0	b0 f0		bcs $8fd2			bcs Throw_FPStack_15
.8fe2	b9 61 00	lda $0061,y			lda FSMant0,y		; save sign
.8fe5	08		php				php
.8fe6	10 03		bpl $8feb			bpl +
.8fe8	20 79 8c	jsr $8c79			jsr FNegate
.8feb					+
.8feb	a9 1f		lda #$1f			lda #31
.8fed	20 61 8a	jsr $8a61			jsr FShiftA
.8ff0	a6 14		ldx $14				ldx tmp1+0		; restore data stack index
.8ff2	c0 20		cpy #$20			cpy #31+1		; always positive, so unsigned compare works
.8ff4	b0 23		bcs $9019			bcs _overflow
.8ff6	a4 56		ldy $56				ldy FIndex
.8ff8	ca		dex				dex			; d= mantissa
.8ff9	ca		dex				dex
.8ffa	ca		dex				dex
.8ffb	ca		dex				dex
.8ffc	b9 61 00	lda $0061,y			lda FSMant0,y
.8fff	95 27		sta $27,x			sta DStack+1,x
.9001	b9 6b 00	lda $006b,y			lda FSMant1,y
.9004	95 26		sta $26,x			sta DStack+0,x
.9006	b9 75 00	lda $0075,y			lda FSMant2,y
.9009	95 29		sta $29,x			sta DStack+3,x
.900b	b9 7f 00	lda $007f,y			lda FSMant3,y
.900e	95 28		sta $28,x			sta DStack+2,x
.9010	e6 56		inc $56				inc FIndex		; FDrop
.9012	28		plp				plp			; apply saved sign
.9013	30 01		bmi $9016			bmi +
.9015	60		rts				rts
.9016	4c ab d8	jmp $d8ab	+		jmp DNegate
.9019	28		plp		_overflow:	plp			; RDrop sign
.901a	a9 f5		lda #$f5			lda #$100+err_OutOfRange
.901c	20 dc c5	jsr $c5dc			jsr ThrowA
=67					CodeLen	.var *-XtPtr1
=$901f					Here1 = *	; remember here
>8fda	43					.byte CodeLen	;patch wh_CodeLength
>901f	46 52 6e 64			Name0:	.text "FRnd"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=36771					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9023	84					.byte (("FRnd"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=75					LinkDisplacement = Nt0-WordListLink
>9024	10					.byte WordFlags	;wh_Flags
>9025	03					.byte 3	;wh_CodeLength
>9026	4b					  .byte LinkDisplacement	; offset to previous nt
=$9027					XtPtr1 ::= *
=36771					WordListLink ::= Nt0 ; remember the nt of this word for later
.9027	20 f7 82	jsr $82f7	FRnd:		jsr Rand		; generate next RndState
.902a	20 d4 84	jsr $84d4			jsr FAllocX		; alloc FP stack entry
.902d	4a		lsr a				lsr a			;   make positive
.902e	95 61		sta $61,x			sta FSMant0,x
.9030	94 6b		sty $6b,x			sty FSMant1,x	; sty dir,x exists
.9032	ad 35 03	lda $0335			lda RndState+0
.9035	95 75		sta $75,x			sta FSMant2,x
.9037	ad 36 03	lda $0336			lda RndState+1
.903a	95 7f		sta $7f,x			sta FSMant3,x
.903c	a9 00		lda #$00			lda #0			; exponent=0
.903e	95 57		sta $57,x			sta FSExp,x
.9040	4c 6b 8b	jmp $8b6b			jmp FNormX		; normalize, return
=28					CodeLen	.var *-XtPtr1
=$9043					Here1 = *	; remember here
>9025	1c					.byte CodeLen	;patch wh_CodeLength
>9043	46 53 71 72 74			Name0:	.text "FSqrt"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=36808					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9048	85					.byte (("FSqrt"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=37					LinkDisplacement = Nt0-WordListLink
>9049	10					.byte WordFlags	;wh_Flags
>904a	03					.byte 3	;wh_CodeLength
>904b	25					  .byte LinkDisplacement	; offset to previous nt
=$904c					XtPtr1 ::= *
=36808					WordListLink ::= Nt0 ; remember the nt of this word for later
.904c	a4 56		ldy $56		FSqrt:		ldy FIndex
.904e	c0 0a		cpy #$0a			cpy #FSDim-0		; check FP stack for >=1 entries
.9050	b0 80		bcs $8fd2			bcs Throw_FPStack_15
.9052	b9 61 00	lda $0061,y			lda FSMant0,y		; zero?
.9055	d0 01		bne $9058			bne +
.9057	60		rts				rts			;   just return the zero
.9058					+
.9058	20 72 85	jsr $8572			jsr FDup		; get trial value
.905b	a4 56		ldy $56				ldy FIndex
.905d	b9 57 00	lda $0057,y			lda FSExp,y		; halve the exponent of trial value
.9060	c9 80		cmp #$80			cmp #$80
.9062	6a		ror a				ror a
.9063	99 57 00	sta $0057,y			sta FSExp,y
.9066	a9 09		lda #$09			lda #9			; for 9 iterations
.9068	48		pha		_3:		pha
.9069	20 f1 85	jsr $85f1			jsr F2Dup		;   calc new trial value
.906c	20 a9 8d	jsr $8da9			jsr FSlash
.906f	20 01 8c	jsr $8c01			jsr FPlus
.9072	20 44 8a	jsr $8a44			jsr F2Slash
.9075	68		pla				pla			;  next
.9076	38		sec				sec
.9077	e9 01		sbc #$01			sbc #1
.9079	d0 ed		bne $9068			bne _3
.907b	4c 49 85	jmp $8549			jmp FNip		; return trial value
=50					CodeLen	.var *-XtPtr1
=$907e					Here1 = *	; remember here
>904a	32					.byte CodeLen	;patch wh_CodeLength
>907e	50 72 65 63 69 73 69 6f		Name0:	.text "Precision"	;  name of word as a string, ending at wh_NameLastChar
>9086	6e
=9					NameLength = *-Name0
=36871					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9087	c9					.byte (("Precision"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=63					LinkDisplacement = Nt0-WordListLink
>9088	10					.byte WordFlags	;wh_Flags
>9089	03					.byte 3	;wh_CodeLength
>908a	3f					  .byte LinkDisplacement	; offset to previous nt
=$908b					XtPtr1 ::= *
=36871					WordListLink ::= Nt0 ; remember the nt of this word for later
.908b	ad ff 02	lda $02ff	Precision:	lda PrecisionV
.908e	4c 5d c9	jmp $c95d			jmp PushZA
=6					CodeLen	.var *-XtPtr1
=$9091					Here1 = *	; remember here
>9089	06					.byte CodeLen	;patch wh_CodeLength
.9091	60		rts				rts
>9092	53 65 74 2d 50 72 65 63		Name0:	.text "Set-Precision"	;  name of word as a string, ending at wh_NameLastChar
>909a	69 73 69 6f 6e
=13					NameLength = *-Name0
=36895					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>909f	cd					.byte (("Set-Precision"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=24					LinkDisplacement = Nt0-WordListLink
>90a0	10					.byte WordFlags	;wh_Flags
>90a1	03					.byte 3	;wh_CodeLength
>90a2	18					  .byte LinkDisplacement	; offset to previous nt
=$90a3					XtPtr1 ::= *
=36895					WordListLink ::= Nt0 ; remember the nt of this word for later
.90a3	20 47 c5	jsr $c547			jsr PopA
.90a6	8d ff 02	sta $02ff			sta PrecisionV
=6					CodeLen	.var *-XtPtr1
=$90a9					Here1 = *	; remember here
>90a1	06					.byte CodeLen	;patch wh_CodeLength
.90a9	60		rts				rts
>90aa	28 46 2e 29			Name0:	.text "(F.)"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=36910					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>90ae	24					.byte (("(F.)"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=15					LinkDisplacement = Nt0-WordListLink
>90af	10					.byte WordFlags	;wh_Flags
>90b0	03					.byte 3	;wh_CodeLength
>90b1	0f					  .byte LinkDisplacement	; offset to previous nt
=$90b2					XtPtr1 ::= *
=36910					WordListLink ::= Nt0 ; remember the nt of this word for later
.90b2	20 36 91	jsr $9136	PFDot:		jsr pfcstart		;start collecting chars, make r positive
.90b5	20 bb 90	jsr $90bb			jsr PFDotSub
.90b8	4c 54 91	jmp $9154			jmp pfcend
.90bb					PFDotSub:
.90bb	20 8b 90	jsr $908b			jsr Precision	;alloc & init work area
.90be	20 74 c9	jsr $c974			jsr One
=$29					_mantNzFound  = DStack+3	; nonzero mantissa digit processed
=$28					_NumSigDigits = DStack+2	; # of significant digits
=$26					_decimalPos   = DStack+0	; decimal point position
.90c1	20 12 91	jsr $9112			jsr FLt10		; scale down to <10, counting exponent
.90c4					_c:
.90c4	b5 26		lda $26,x			lda _decimalPos,x	;  insert decimal point here?
.90c6	d0 05		bne $90cd			bne _c2
.90c8	a9 2e		lda #$2e			lda #'.'
.90ca	20 4b 91	jsr $914b			jsr pfchar
.90cd	d6 26		dec $26,x	_c2:		dec _decimalPos,x
.90cf	20 72 85	jsr $8572			jsr FDup		;  do a digit
.90d2	20 9b 8f	jsr $8f9b			jsr FToS		;  ( work n )
.90d5	b5 26		lda $26,x			lda DStack+0,x
.90d7	15 2b		ora $2b,x			ora _mantNzFound+2,x	;  doing significant digits?
.90d9	95 2b		sta $2b,x			sta _mantNzFound+2,x
.90db	f0 08		beq $90e5			beq _c7
.90dd	d6 2a		dec $2a,x			dec _NumSigDigits+2,x
.90df	10 04		bpl $90e5			bpl _c7
.90e1	e8		inx				inx			;    drop integer
.90e2	e8		inx				inx
.90e3	d0 17		bne $90fc			bne _d
.90e5	b5 26		lda $26,x	_c7:		lda DStack+0,x		;  store the char
.90e7	09 30		ora #$30			ora #'0'
.90e9	20 4b 91	jsr $914b			jsr pfchar
.90ec	20 46 8f	jsr $8f46			jsr SToF		;  ( work )
.90ef	20 41 8c	jsr $8c41			jsr FMinus
.90f2	20 50 8a	jsr $8a50			jsr F10Star
.90f5	a4 56		ldy $56				ldy FIndex		;  until mantissa==0
.90f7	b9 61 00	lda $0061,y			lda FSMant0,y
.90fa	d0 c8		bne $90c4			bne _c
.90fc	d6 26		dec $26,x	_d:		dec _decimalPos,x	;do trailing zeros
.90fe	30 08		bmi $9108			bmi _d9
.9100	a9 30		lda #$30			lda #'0'
.9102	20 4b 91	jsr $914b			jsr pfchar
.9105	4c fc 90	jmp $90fc			jmp _d
.9108					_d9:
.9108	e8		inx				inx			; drop work area
.9109	e8		inx				inx
.910a	e8		inx				inx
.910b	e8		inx				inx
.910c	e6 56		inc $56				inc FIndex		; FDrop
.910e	60		rts				rts
=93					CodeLen	.var *-XtPtr1
=$910f					Here1 = *	; remember here
>90b0	5d					.byte CodeLen	;patch wh_CodeLength
.910f	4c dd 84	jmp $84dd	Throw_FPStack_16a: jmp Throw_FPStack
.9112					FLt10:
.9112	a4 56		ldy $56		_1:		ldy FIndex		; while r >= 10
.9114	c0 0a		cpy #$0a			cpy #FSDim-0		; check FP stack for >=1 entries
.9116	b0 f7		bcs $910f			bcs Throw_FPStack_16a
.9118	b9 57 00	lda $0057,y			lda FSExp,y
.911b	30 18		bmi $9135			bmi _9			;   exponent negative?
.911d	c9 04		cmp #$04			cmp #4
.911f	90 14		bcc $9135			bcc _9			;   < 4 ?
.9121	d0 07		bne $912a			bne _2			;   > 4 ?
.9123	b9 61 00	lda $0061,y			lda FSMant0,y		;   r > 10 ?
.9126	c9 50		cmp #$50			cmp #$50
.9128	90 0b		bcc $9135			bcc _9
.912a	f6 26		inc $26,x	_2:		inc DStack+0,x		;   exp ++
.912c	20 72 89	jsr $8972			jsr F10			;   r /= 10
.912f	20 a9 8d	jsr $8da9			jsr FSlash
.9132	4c 12 91	jmp $9112			jmp _1
.9135	60		rts		_9:		rts
.9136					pfcstart:
.9136	a9 01		lda #$01			lda #1
.9138	8d 34 03	sta $0334			sta ToHold
.913b	a4 56		ldy $56				ldy FIndex		; if r1 negative
.913d	b9 61 00	lda $0061,y			lda FSMant0,y
.9140	10 08		bpl $914a			bpl _19
.9142	a9 2d		lda #$2d			lda #'-'		;   append sign
.9144	20 4b 91	jsr $914b			jsr pfchar
.9147	4c 79 8c	jmp $8c79			jmp FNegate		;   make positive, return
.914a	60		rts		_19:		rts
.914b					pfchar:
.914b	ac 34 03	ldy $0334			ldy ToHold
.914e	91 00		sta ($00),y			sta (cp),y
.9150	ee 34 03	inc $0334			inc ToHold
.9153	60		rts				rts
.9154					pfcend:
.9154	ad 34 03	lda $0334			lda ToHold
.9157	38		sec				sec
.9158	e9 01		sbc #$01			sbc #1
.915a	a0 00		ldy #$00			ldy #0
.915c	91 00		sta ($00),y			sta (cp),y		; fill in length
.915e	4c 04 dc	jmp $dc04			jmp Here		; push start addr
.9161					pfciA:
.9161	a8		tay				tay
.9162	10 09		bpl $916d			bpl _15			; IfMi,
.9164	c8		iny				iny			;   negate
.9165	98		tya				tya
.9166	49 ff		eor #$ff			eor #$ff
.9168	48		pha				pha
.9169	a9 2d		lda #$2d			lda #'-'
.916b	d0 03		bne $9170			bne _19
.916d	48		pha		_15:		pha
.916e	a9 2b		lda #$2b			lda #'+'
.9170					_19:
.9170	20 4b 91	jsr $914b			jsr pfchar
.9173	68		pla				pla
.9174	a0 2f		ldy #$2f			ldy #'0'-1
.9176	c8		iny		_20:		iny
.9177	38		sec				sec
.9178	e9 0a		sbc #$0a			sbc #10
.917a	b0 fa		bcs $9176			bcs _20
.917c	69 0a		adc #$0a			adc #10
.917e	48		pha				pha
.917f	98		tya				tya
.9180	20 4b 91	jsr $914b			jsr pfchar
.9183	68		pla				pla
.9184	09 30		ora #$30			ora #'0'
.9186	d0 c3		bne $914b			bne pfchar
>9188	46 2e				Name0:	.text "F."	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=37130					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>918a	c2					.byte (("F."[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=220					LinkDisplacement = Nt0-WordListLink
>918b	10					.byte WordFlags	;wh_Flags
>918c	03					.byte 3	;wh_CodeLength
>918d	dc					  .byte LinkDisplacement	; offset to previous nt
=$918e					XtPtr1 ::= *
=37130					WordListLink ::= Nt0 ; remember the nt of this word for later
.918e	20 b2 90	jsr $90b2	FDot:		jsr PFDot
.9191	20 5b c3	jsr $c35b	FDot2:		jsr Count
.9194	20 f1 df	jsr $dff1			jsr Type
.9197	4c e5 df	jmp $dfe5			jmp Space
=12					CodeLen	.var *-XtPtr1
=$919a					Here1 = *	; remember here
>918c	0c					.byte CodeLen	;patch wh_CodeLength
.919a	4c dd 84	jmp $84dd	Throw_FPStack_16: jmp Throw_FPStack
>919d	46 2e 53			Name0:	.text "F.S"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=37152					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>91a0	63					.byte (("F.S"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=22					LinkDisplacement = Nt0-WordListLink
>91a1	10					.byte WordFlags	;wh_Flags
>91a2	03					.byte 3	;wh_CodeLength
>91a3	16					  .byte LinkDisplacement	; offset to previous nt
=$91a4					XtPtr1 ::= *
=37152					WordListLink ::= Nt0 ; remember the nt of this word for later
.91a4	a9 09		lda #$09	FDotS:		lda #FSDim-1	; for each FP stack entry
.91a6	d0 0b		bne $91b3			bne _8
.91a8	48		pha		_2:		pha
.91a9	20 c8 85	jsr $85c8			jsr FPick3	;   print it
.91ac	20 8e 91	jsr $918e			jsr FDot
.91af	68		pla				pla		;  next
.91b0	38		sec				sec
.91b1	e9 01		sbc #$01			sbc #1
.91b3	c5 56		cmp $56		_8:		cmp FIndex
.91b5	b0 f1		bcs $91a8			bcs _2
=19					CodeLen	.var *-XtPtr1
=$91b7					Here1 = *	; remember here
>91a2	13					.byte CodeLen	;patch wh_CodeLength
.91b7	60		rts				rts
>91b8	28 46 53 2e 29			Name0:	.text "(FS.)"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=37181					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>91bd	25					.byte (("(FS.)"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=29					LinkDisplacement = Nt0-WordListLink
>91be	10					.byte WordFlags	;wh_Flags
>91bf	03					.byte 3	;wh_CodeLength
>91c0	1d					  .byte LinkDisplacement	; offset to previous nt
=$91c1					XtPtr1 ::= *
=37181					WordListLink ::= Nt0 ; remember the nt of this word for later
.91c1	20 6b c9	jsr $c96b	PFSDot:		jsr Zero		; alloc work area
=$26					_exp    = DStack+0
.91c4	20 36 91	jsr $9136			jsr pfcstart		; start collecting chars, make r positive
.91c7	20 12 91	jsr $9112			jsr FLt10		; scale down to <10
.91ca	a4 56		ldy $56		_c1:		ldy FIndex		; while r < 1
.91cc	b9 61 00	lda $0061,y			lda FSMant0,y		;   mantissa == 0 ?
.91cf	f0 0f		beq $91e0			beq _c9
.91d1	b9 57 00	lda $0057,y			lda FSExp,y		;   exp < 1 ?
.91d4	f0 02		beq $91d8			beq _c2
.91d6	10 08		bpl $91e0			bpl _c9
.91d8	d6 26		dec $26,x	_c2:		dec DStack+0,x		;  exp -= 1
.91da	20 50 8a	jsr $8a50			jsr F10Star		;  r *= 10
.91dd	4c ca 91	jmp $91ca			jmp _c1
.91e0					_c9:
.91e0	20 bb 90	jsr $90bb	PFSDotM:	jsr PFDotSub		; do mantissa
.91e3	a9 45		lda #$45			lda #'E'
.91e5	20 4b 91	jsr $914b			jsr pfchar		; do exponent
.91e8	b5 26		lda $26,x			lda DStack+0,x		;   _exp
.91ea	20 61 91	jsr $9161			jsr pfciA
.91ed	e8		inx				inx			; Drop work area
.91ee	e8		inx				inx
.91ef	4c 54 91	jmp $9154			jmp pfcend		; finish string
=49					CodeLen	.var *-XtPtr1
=$91f2					Here1 = *	; remember here
>91bf	31					.byte CodeLen	;patch wh_CodeLength
>91f2	46 53 2e			Name0:	.text "FS."	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=37237					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>91f5	c3					.byte (("FS."[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=56					LinkDisplacement = Nt0-WordListLink
>91f6	10					.byte WordFlags	;wh_Flags
>91f7	03					.byte 3	;wh_CodeLength
>91f8	38					  .byte LinkDisplacement	; offset to previous nt
=$91f9					XtPtr1 ::= *
=37237					WordListLink ::= Nt0 ; remember the nt of this word for later
.91f9	20 c1 91	jsr $91c1	FSDot:		jsr PFSDot
.91fc	4c 91 91	jmp $9191			jmp FDot2
=6					CodeLen	.var *-XtPtr1
=$91ff					Here1 = *	; remember here
>91f7	06					.byte CodeLen	;patch wh_CodeLength
>91ff	28 46 45 2e 29			Name0:	.text "(FE.)"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=37252					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9204	25					.byte (("(FE.)"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=15					LinkDisplacement = Nt0-WordListLink
>9205	10					.byte WordFlags	;wh_Flags
>9206	03					.byte 3	;wh_CodeLength
>9207	0f					  .byte LinkDisplacement	; offset to previous nt
=$9208					XtPtr1 ::= *
=37252					WordListLink ::= Nt0 ; remember the nt of this word for later
.9208	20 6b c9	jsr $c96b	PFEDot:		jsr Zero		; alloc work area
=$26					_exp    = DStack+0
.920b	20 36 91	jsr $9136			jsr pfcstart		; start collecting chars, make r positive
.920e	a4 56		ldy $56		_30:		ldy FIndex		; while r < 1
.9210	c0 0a		cpy #$0a			cpy #FSDim-0		; check FP stack for >=1 entries
.9212	b0 86		bcs $919a			bcs Throw_FPStack_16
.9214	b9 61 00	lda $0061,y			lda FSMant0,y
.9217	f0 16		beq $922f			beq _39
.9219	b9 57 00	lda $0057,y			lda FSExp,y
.921c	f0 02		beq $9220			beq _31
.921e	10 0f		bpl $922f			bpl _39
.9220	d6 26		dec $26,x	_31:		dec _exp,x		;  exp -= 3
.9222	d6 26		dec $26,x			dec _exp,x
.9224	d6 26		dec $26,x			dec _exp,x
.9226	20 64 89	jsr $8964			jsr F1000		;  r *= 1000
.9229	20 da 8c	jsr $8cda			jsr FStar
.922c	4c 0e 92	jmp $920e			jmp _30
.922f					_39:
.922f	a4 56		ldy $56		_a:		ldy FIndex		; while r >= 1000
.9231	b9 57 00	lda $0057,y			lda FSExp,y
.9234	30 1c		bmi $9252			bmi _a9			; exponent negative?
.9236	c9 0a		cmp #$0a			cmp #10
.9238	90 18		bcc $9252			bcc _a9			;   < 10 ?
.923a	d0 07		bne $9243			bne _a2			;   > 10 ?
.923c	b9 61 00	lda $0061,y			lda FSMant0,y
.923f	c9 7d		cmp #$7d			cmp #$7d
.9241	90 0f		bcc $9252			bcc _a9
.9243	f6 26		inc $26,x	_a2:		inc _exp,x		;   exp += 3
.9245	f6 26		inc $26,x			inc _exp,x
.9247	f6 26		inc $26,x			inc _exp,x
.9249	20 64 89	jsr $8964			jsr F1000		;   r /= 1000
.924c	20 a9 8d	jsr $8da9			jsr FSlash
.924f	4c 2f 92	jmp $922f			jmp _a
.9252					_a9:
.9252	4c e0 91	jmp $91e0			jmp PFSDotM
=77					CodeLen	.var *-XtPtr1
=$9255					Here1 = *	; remember here
>9206	4d					.byte CodeLen	;patch wh_CodeLength
>9255	46 45 2e			Name0:	.text "FE."	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=37336					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9258	c3					.byte (("FE."[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=84					LinkDisplacement = Nt0-WordListLink
>9259	10					.byte WordFlags	;wh_Flags
>925a	03					.byte 3	;wh_CodeLength
>925b	54					  .byte LinkDisplacement	; offset to previous nt
=$925c					XtPtr1 ::= *
=37336					WordListLink ::= Nt0 ; remember the nt of this word for later
.925c	20 08 92	jsr $9208	FEDot:		jsr PFEDot
.925f	4c 91 91	jmp $9191			jmp FDot2
=6					CodeLen	.var *-XtPtr1
=$9262					Here1 = *	; remember here
>925a	06					.byte CodeLen	;patch wh_CodeLength
>9262	46 27				Name0:	.text "F'"	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=37348					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9264	e2					.byte (("F'"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=24					WordFlags ::= IM+NN	; modifiable copy, remember for later
=12					LinkDisplacement = Nt0-WordListLink
>9265	18					.byte WordFlags	;wh_Flags
>9266	03					.byte 3	;wh_CodeLength
>9267	0c					  .byte LinkDisplacement	; offset to previous nt
=$9268					XtPtr1 ::= *
=37348					WordListLink ::= Nt0 ; remember the nt of this word for later
.9268	20 15 cc	jsr $cc15	FQuote:		jsr Parse_Name		; get string
.926b	20 8b 92	jsr $928b			jsr ToFloat		; convert
.926e	b5 26		lda $26,x			lda DStack+0,x		; error?
.9270	f0 0a		beq $927c			beq _Err
.9272	e8		inx				inx
.9273	e8		inx				inx
.9274	a5 0a		lda $0a				lda State		; compiling?
.9276	d0 01		bne $9279			bne _compile
.9278	60		rts				rts
.9279	4c a4 88	jmp $88a4	_compile:	jmp FLiteral		; compile a FP literal
.927c	a9 36		lda #$36	_Err:		lda #100+err_FPInvalidArg
.927e	20 dc c5	jsr $c5dc			jsr ThrowA
=25					CodeLen	.var *-XtPtr1
=$9281					Here1 = *	; remember here
>9266	19					.byte CodeLen	;patch wh_CodeLength
>9281	3e 46 6c 6f 61 74		Name0:	.text ">Float"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=37383					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9287	86					.byte ((">Float"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=35					LinkDisplacement = Nt0-WordListLink
>9288	10					.byte WordFlags	;wh_Flags
>9289	03					.byte 3	;wh_CodeLength
>928a	23					  .byte LinkDisplacement	; offset to previous nt
=$928b					XtPtr1 ::= *
=37383					WordListLink ::= Nt0 ; remember the nt of this word for later
.928b					ToFloat:
.928b	20 6b c9	jsr $c96b			jsr Zero	; alloc & init workspace
.928e	20 6b c9	jsr $c96b			jsr Zero
.9291	20 6b c9	jsr $c96b			jsr Zero
=$2e					_addr		= DStack+8
=$2c					_len		= DStack+6
=$2b					_mantfound 	= DStack+5		;mantissa digits found
=$2a					_exponent 	= DStack+4		;exponent
=$29					_decimalPos 	= DStack+3		;decimal point position
=$28					_DecPointFound1 = DStack+2
=$27					_MantissaNegative1 = DStack+1
=$26					_ExponentNegative1 = DStack+0
.9294	20 54 89	jsr $8954			jsr F0			; init result
.9297	20 69 93	jsr $9369	_11:		jsr _GetChar		; get mantissa prefix
.929a	b0 57		bcs $92f3			bcs _trueb ;_finishb
.929c	c9 20		cmp #$20			cmp #' '
.929e	f0 f7		beq $9297			beq _11
.92a0	c9 2b		cmp #$2b			cmp #'+'
.92a2	f0 06		beq $92aa			beq _20
.92a4	c9 2d		cmp #$2d			cmp #'-'
.92a6	d0 07		bne $92af			bne _21
.92a8	95 27		sta $27,x			sta _MantissaNegative1,x ; remember mantissa is negative
.92aa	20 69 93	jsr $9369	_20:		jsr _GetChar		; do next mantissa digits
.92ad	b0 47		bcs $92f6			bcs _finishb
.92af	c9 2e		cmp #$2e	_21:		cmp #'.'
.92b1	f0 31		beq $92e4			beq _27
.92b3	c9 45		cmp #$45			cmp #'E'
.92b5	f0 42		beq $92f9			beq _30
.92b7	c9 65		cmp #$65			cmp #'e'
.92b9	f0 3e		beq $92f9			beq _30
.92bb	c9 44		cmp #$44			cmp #'D'
.92bd	f0 3a		beq $92f9			beq _30
.92bf	c9 64		cmp #$64			cmp #'d'
.92c1	f0 36		beq $92f9			beq _30
.92c3	38		sec				sec			;   a digit?
.92c4	e9 30		sbc #$30			sbc #'0'
.92c6	90 24		bcc $92ec			bcc _fail
.92c8	c9 0a		cmp #$0a			cmp #9+1
.92ca	b0 20		bcs $92ec			bcs _fail
.92cc	48		pha				pha			; append digit to mantissa
.92cd	20 50 8a	jsr $8a50			jsr F10Star
.92d0	68		pla				pla
.92d1	a0 00		ldy #$00			ldy #0
.92d3	20 49 8f	jsr $8f49			jsr SToFYA
.92d6	20 01 8c	jsr $8c01			jsr FPlus
.92d9	f6 2b		inc $2b,x			inc _mantfound,x	; remember we found a mantissa digit
.92db	b5 28		lda $28,x			lda _DecPointFound1,x	; if mantissa decimal point found
.92dd	f0 02		beq $92e1			beq +
.92df	d6 29		dec $29,x			dec _decimalPos,x	;   increment decimal point position
.92e1					+
.92e1	4c aa 92	jmp $92aa			jmp _20
.92e4					_27:
.92e4	b4 28		ldy $28,x			ldy _DecPointFound1,x	; already have one?
.92e6	d0 04		bne $92ec			bne _fail
.92e8	95 28		sta $28,x			sta _DecPointFound1,x	; we have one now!
.92ea	f0 be		beq $92aa			beq _20
.92ec					_fail:
.92ec	20 26 85	jsr $8526			jsr FDrop
.92ef	a9 00		lda #$00			lda #0			;return false
.92f1	f0 69		beq $935c			beq _return
.92f3	4c 5a 93	jmp $935a	_trueb:		jmp _true
.92f6	4c 27 93	jmp $9327	_finishb:	jmp _finish
.92f9					_30:
.92f9	20 69 93	jsr $9369			jsr _GetChar
.92fc	b0 29		bcs $9327			bcs _finish
.92fe	c9 2b		cmp #$2b			cmp #'+'
.9300	f0 06		beq $9308			beq _40
.9302	c9 2d		cmp #$2d			cmp #'-'
.9304	d0 07		bne $930d			bne _41
.9306	95 26		sta $26,x			sta _ExponentNegative1,x ; remember exponent is negative
.9308	20 69 93	jsr $9369	_40:		jsr _GetChar		;get exponent digits
.930b	b0 1a		bcs $9327			bcs _finish
.930d	38		sec		_41:		sec			;  digit?
.930e	e9 30		sbc #$30			sbc #'0'
.9310	90 da		bcc $92ec			bcc _fail
.9312	c9 0a		cmp #$0a			cmp #9+1
.9314	b0 d6		bcs $92ec			bcs _fail
.9316	85 14		sta $14				sta tmp1
.9318	16 2a		asl $2a,x			asl _exponent,x		;  exponent *= 10
.931a	b5 2a		lda $2a,x			lda _exponent,x
.931c	0a		asl a				asl a
.931d	0a		asl a				asl a
.931e	75 2a		adc $2a,x			adc _exponent,x
.9320	65 14		adc $14				adc tmp1		;  + digit
.9322	95 2a		sta $2a,x			sta _exponent,x
.9324	4c 08 93	jmp $9308			jmp _40
.9327					_finish:
.9327	b5 2b		lda $2b,x			lda _mantfound,x	;some mantissa digits found?
.9329	f0 c1		beq $92ec			beq _fail
.932b	b5 26		lda $26,x			lda _ExponentNegative1,x ;apply exponent sign
.932d	f0 07		beq $9336			beq +
.932f	a9 00		lda #$00			lda #0
.9331	38		sec				sec
.9332	f5 2a		sbc $2a,x			sbc _exponent,x
.9334	95 2a		sta $2a,x			sta _exponent,x
.9336					+
.9336	b5 2a		lda $2a,x			lda _exponent,x		;apply decimal position to exponent
.9338	18		clc				clc
.9339	75 29		adc $29,x			adc _decimalPos,x
.933b	95 2a		sta $2a,x			sta _exponent,x
.933d	4c 45 93	jmp $9345			jmp _93
.9340	20 50 8a	jsr $8a50	_93b:		jsr F10Star		;apply exponent to mantissa
.9343	d6 2a		dec $2a,x			dec _exponent,x
.9345	f0 0a		beq $9351	_93:		beq _94
.9347	10 f7		bpl $9340			bpl _93b
.9349	20 72 89	jsr $8972	_94b:		jsr F10
.934c	20 a9 8d	jsr $8da9			jsr FSlash
.934f	f6 2a		inc $2a,x			inc _exponent,x
.9351	30 f6		bmi $9349	_94:		bmi _94b
.9353					_95:
.9353	b5 27		lda $27,x			lda _MantissaNegative1,x ;apply mantissa sign
.9355	f0 03		beq $935a			beq +
.9357	20 79 8c	jsr $8c79			jsr FNegate
.935a					+
.935a	a9 ff		lda #$ff	_true:		lda #$ff		;return true
.935c					_return:
.935c	95 2e		sta $2e,x			sta _addr+0,x		; replace _addr with flag
.935e	95 2f		sta $2f,x			sta _addr+1,x
.9360	e8		inx				inx			; Drop work
.9361	e8		inx				inx
.9362	e8		inx				inx			; 2Drop work
.9363	e8		inx				inx
.9364	e8		inx				inx
.9365	e8		inx				inx
.9366	e8		inx				inx			; Drop len
.9367	e8		inx				inx
.9368	60		rts				rts
.9369					_GetChar:
.9369	38		sec				sec
.936a	b5 2c		lda $2c,x			lda _len,x
.936c	f0 0b		beq $9379			beq _gc_rts		; if end, return C=1
.936e	d6 2c		dec $2c,x			dec _len,x
.9370	a1 2e		lda ($2e,x)			lda (_addr,x)
.9372	f6 2e		inc $2e,x			inc _addr+0,x
.9374	d0 02		bne $9378			bne +
.9376	f6 2f		inc $2f,x			inc _addr+1,x
.9378					+
.9378	18		clc				clc			; get char, return C=0
.9379	60		rts		_gc_rts:	rts
>937a	46 4b 65 79			Name0:	.text "FKey"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=37630					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>937e	24					.byte (("FKey"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=247					LinkDisplacement = Nt0-WordListLink
>937f	10					.byte WordFlags	;wh_Flags
>9380	03					.byte 3	;wh_CodeLength
>9381	f7					  .byte LinkDisplacement	; offset to previous nt
=$9382					XtPtr1 ::= *
=37630					WordListLink ::= Nt0 ; remember the nt of this word for later
.9382					FKey:
.9382	20 04 dc	jsr $dc04			jsr Here		; ( addr )
.9385	20 04 dc	jsr $dc04			jsr Here		; ( addr addr )
.9388	a9 28		lda #$28			lda #40			; ( addr addr 40 )
.938a	20 5d c9	jsr $c95d			jsr PushZA
.938d	20 70 d4	jsr $d470			jsr Accept		; ( addr len )
.9390	20 8b 92	jsr $928b			jsr ToFloat		; ( true | false)
.9393	e8		inx				inx			; err?
.9394	e8		inx				inx
.9395	b5 24		lda $24,x			lda DStack-2,x
.9397	f0 01		beq $939a			beq _err
.9399	60		rts				rts
.939a	20 4b ca	jsr $ca4b	_err:		jsr SLiteral_runtime
.939d	4c a3 93	jmp $93a3			  jmp +
>93a0	20 3f 20					  .text " ? "
.93a3	20 f1 df	jsr $dff1	+		jsr Type
.93a6	4c 82 93	jmp $9382			jmp FKey
>93a9	53 46 40			Name0:	.text "SF@"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=37676					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>93ac	03					.byte (("SF@"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=46					LinkDisplacement = Nt0-WordListLink
>93ad	10					.byte WordFlags	;wh_Flags
>93ae	03					.byte 3	;wh_CodeLength
>93af	2e					  .byte LinkDisplacement	; offset to previous nt
=$93b0					XtPtr1 ::= *
=37676					WordListLink ::= Nt0 ; remember the nt of this word for later
.93b0	20 62 c5	jsr $c562	SFAt:		jsr PopYA		; pop sf_addr
.93b3	85 16		sta $16		SFAt_YA:	sta tmp2+0		; save sf_addr
.93b5	84 17		sty $17				sty tmp2+1
.93b7	20 d4 84	jsr $84d4			jsr FAllocX		; alloc FP stack entry
.93ba	a0 01		ldy #$01			ldy #1			; copy exponent
.93bc	b1 16		lda ($16),y			lda (tmp2),y
.93be	0a		asl a				asl a
.93bf	88		dey				dey
.93c0	b1 16		lda ($16),y			lda (tmp2),y
.93c2	2a		rol a				rol a
.93c3	38		sec				sec
.93c4	e9 7e		sbc #$7e			sbc #126
.93c6	95 57		sta $57,x			sta FSExp,x
.93c8	a0 01		ldy #$01			ldy #1			; copy mantissa
.93ca	b1 16		lda ($16),y			lda (tmp2),y
.93cc	09 80		ora #$80			ora #$80
.93ce	4a		lsr a				lsr a
.93cf	95 61		sta $61,x			sta FSMant0,x
.93d1	c8		iny				iny
.93d2	b1 16		lda ($16),y			lda (tmp2),y
.93d4	6a		ror a				ror a
.93d5	95 6b		sta $6b,x			sta FSMant1,x
.93d7	c8		iny				iny
.93d8	b1 16		lda ($16),y			lda (tmp2),y
.93da	6a		ror a				ror a
.93db	95 75		sta $75,x			sta FSMant2,x
.93dd	a9 00		lda #$00			lda #0
.93df	6a		ror a				ror a
.93e0	95 7f		sta $7f,x			sta FSMant3,x
.93e2	a6 14		ldx $14				ldx tmp1+0		; restore data stack index
.93e4	a0 00		ldy #$00			ldy #0			; get sign
.93e6	b1 16		lda ($16),y			lda (tmp2),y
.93e8	10 03		bpl $93ed			bpl +
.93ea	20 79 8c	jsr $8c79			jsr FNegate
.93ed					+
=61					CodeLen	.var *-XtPtr1
=$93ed					Here1 = *	; remember here
>93ae	3d					.byte CodeLen	;patch wh_CodeLength
.93ed	60		rts				rts
>93ee	53 46 21			Name0:	.text "SF!"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=37745					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>93f1	23					.byte (("SF!"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=69					LinkDisplacement = Nt0-WordListLink
>93f2	10					.byte WordFlags	;wh_Flags
>93f3	03					.byte 3	;wh_CodeLength
>93f4	45					  .byte LinkDisplacement	; offset to previous nt
=$93f5					XtPtr1 ::= *
=37745					WordListLink ::= Nt0 ; remember the nt of this word for later
.93f5	20 62 c5	jsr $c562	SFStore:	jsr PopYA		; pop sf_addr
.93f8	85 16		sta $16		SFStore_YA:	sta tmp2+0		; save
.93fa	84 17		sty $17				sty tmp2+1
.93fc	a4 56		ldy $56				ldy FIndex		; negative?
.93fe	c0 0a		cpy #$0a			cpy #FSDim-0		; check FP stack for >=1 entries
.9400	b0 5c		bcs $945e			bcs Throw_FPStack_17
.9402	b9 61 00	lda $0061,y			lda FSMant0,y
.9405	29 80		and #$80			and #$80		;  save sign
.9407	85 19		sta $19				sta tmp3+1
.9409	10 03		bpl $940e			bpl +
.940b	20 79 8c	jsr $8c79			jsr FNegate
.940e					+
.940e	86 14		stx $14				stx tmp1+0		; save data stack index
.9410	a6 56		ldx $56				ldx FIndex		; switch to FP stack index
.9412	b5 57		lda $57,x			lda FSExp,x		; +128
.9414	18		clc				clc
.9415	69 7e		adc #$7e			adc #126
.9417	95 57		sta $57,x			sta FSExp,x
.9419	16 7f		asl $7f,x			asl FSMant3,x
.941b	b5 75		lda $75,x			lda FSMant2,x
.941d	2a		rol a				rol a
.941e	a0 03		ldy #$03			ldy #3			; +3 IEEE
.9420	91 16		sta ($16),y			sta (tmp2),y
.9422	b5 6b		lda $6b,x			lda FSMant1,x
.9424	2a		rol a				rol a
.9425	88		dey				dey			; +2 IEEE
.9426	91 16		sta ($16),y			sta (tmp2),y
.9428	b5 61		lda $61,x			lda FSMant0,x
.942a	2a		rol a				rol a
.942b	2a		rol a				rol a
.942c	56 57		lsr $57,x			lsr FSExp,x
.942e	6a		ror a				ror a
.942f	88		dey				dey			; +1 IEEE
.9430	91 16		sta ($16),y			sta (tmp2),y
.9432	b5 57		lda $57,x			lda FSExp,x
.9434	05 19		ora $19				ora tmp3+1		;  insert sign
.9436	88		dey				dey			; +0 IEEE
.9437	91 16		sta ($16),y			sta (tmp2),y
.9439	e6 56		inc $56				inc FIndex		; FDrop
.943b	a6 14		ldx $14				ldx tmp1+0		; restore data stack index
=72					CodeLen	.var *-XtPtr1
=$943d					Here1 = *	; remember here
>93f3	48					.byte CodeLen	;patch wh_CodeLength
.943d	60		rts				rts
>943e	53 46 6c 6f 61 74 2b		Name0:	.text "SFloat+"	;  name of word as a string, ending at wh_NameLastChar
=7					NameLength = *-Name0
=37829					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9445	67					.byte (("SFloat+"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=84					LinkDisplacement = Nt0-WordListLink
>9446	10					.byte WordFlags	;wh_Flags
>9447	03					.byte 3	;wh_CodeLength
>9448	54					  .byte LinkDisplacement	; offset to previous nt
=$9449					XtPtr1 ::= *
=37829					WordListLink ::= Nt0 ; remember the nt of this word for later
.9449	a9 04		lda #$04	SFloatPlus:	lda #4
.944b	4c da db	jmp $dbda			jmp Plus_A
=5					CodeLen	.var *-XtPtr1
=$944e					Here1 = *	; remember here
>9447	05					.byte CodeLen	;patch wh_CodeLength
>944e	53 46 6c 6f 61 74 73		Name0:	.text "SFloats"	;  name of word as a string, ending at wh_NameLastChar
=7					NameLength = *-Name0
=37845					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9455	67					.byte (("SFloats"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=16					LinkDisplacement = Nt0-WordListLink
>9456	10					.byte WordFlags	;wh_Flags
>9457	03					.byte 3	;wh_CodeLength
>9458	10					  .byte LinkDisplacement	; offset to previous nt
=$9459					XtPtr1 ::= *
=37845					WordListLink ::= Nt0 ; remember the nt of this word for later
.9459	a9 02		lda #$02	SFloats:	lda #2
.945b	4c 2d dd	jmp $dd2d			jmp LShift_A
=5					CodeLen	.var *-XtPtr1
=$945e					Here1 = *	; remember here
>9457	05					.byte CodeLen	;patch wh_CodeLength
.945e	4c dd 84	jmp $84dd	Throw_FPStack_17: jmp Throw_FPStack
>9461	44 46 21			Name0:	.text "DF!"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=37860					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9464	23					.byte (("DF!"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=15					LinkDisplacement = Nt0-WordListLink
>9465	10					.byte WordFlags	;wh_Flags
>9466	03					.byte 3	;wh_CodeLength
>9467	0f					  .byte LinkDisplacement	; offset to previous nt
=$9468					XtPtr1 ::= *
=37860					WordListLink ::= Nt0 ; remember the nt of this word for later
.9468	20 62 c5	jsr $c562	DFStore:	jsr PopYA		; pop df_addr
.946b	85 16		sta $16		DFStore_YA:	sta tmp2+0		; save df_addr
.946d	84 17		sty $17				sty tmp2+1
.946f	a4 56		ldy $56				ldy FIndex
.9471	c0 0a		cpy #$0a			cpy #FSDim-0		; check FP stack for >=1 entries
.9473	b0 e9		bcs $945e			bcs Throw_FPStack_17
.9475	b9 61 00	lda $0061,y			lda FSMant0,y		; negative?
.9478	29 80		and #$80			and #$80		; remember sign
.947a	85 19		sta $19				sta tmp3+1
.947c	10 03		bpl $9481			bpl +			; make positive
.947e	20 79 8c	jsr $8c79			jsr FNegate
.9481					+
.9481	86 14		stx $14				stx tmp1+0		; save data stack index
.9483	a6 56		ldx $56				ldx FIndex
.9485	a9 00		lda #$00			lda #0
.9487	a0 07		ldy #$07			ldy #7			; +7 IEEE
.9489	91 16		sta ($16),y			sta (tmp2),y
.948b	88		dey				dey			; +6 IEEE
.948c	91 16		sta ($16),y			sta (tmp2),y
.948e	20 d6 94	jsr $94d6			jsr _shift		; shift mantissa
.9491	20 d6 94	jsr $94d6			jsr _shift
.9494	88		dey				dey			; +5 IEEE
.9495	91 16		sta ($16),y			sta (tmp2),y
.9497	b5 7f		lda $7f,x			lda FSMant3,x
.9499	88		dey				dey			; +4 IEEE
.949a	91 16		sta ($16),y			sta (tmp2),y
.949c	b5 75		lda $75,x			lda FSMant2,x
.949e	88		dey				dey			; +3 IEEE
.949f	91 16		sta ($16),y			sta (tmp2),y
.94a1	b5 6b		lda $6b,x			lda FSMant1,x
.94a3	88		dey				dey			; +2 IEEE
.94a4	91 16		sta ($16),y			sta (tmp2),y
.94a6	b5 61		lda $61,x			lda FSMant0,x		; clear extra bits
.94a8	29 0f		and #$0f			and #$f
.94aa	95 61		sta $61,x			sta FSMant0,x
.94ac	b5 57		lda $57,x			lda FSExp,x
.94ae	38		sec				sec
.94af	e9 02		sbc #$02			sbc #2
.94b1	95 57		sta $57,x			sta FSExp,x
.94b3	0a		asl a				asl a
.94b4	0a		asl a				asl a
.94b5	0a		asl a				asl a
.94b6	0a		asl a				asl a
.94b7	15 61		ora $61,x			ora FSMant0,x
.94b9	88		dey				dey			; +1 IEEE
.94ba	91 16		sta ($16),y			sta (tmp2),y
.94bc	b5 57		lda $57,x			lda FSExp,x
.94be	08		php				php
.94bf	4a		lsr a				lsr a
.94c0	4a		lsr a				lsr a
.94c1	4a		lsr a				lsr a
.94c2	4a		lsr a				lsr a
.94c3	18		clc				clc
.94c4	69 30		adc #$30			adc #$30
.94c6	28		plp				plp
.94c7	30 03		bmi $94cc			bmi +
.94c9	18		clc				clc
.94ca	69 10		adc #$10			adc #$10
.94cc	05 19		ora $19		+		ora tmp3+1		; add sign bit
.94ce	88		dey				dey			; +0 IEEE
.94cf	91 16		sta ($16),y			sta (tmp2),y
.94d1	e6 56		inc $56				inc FIndex		; FDrop
.94d3	a6 14		ldx $14				ldx tmp1+0		; restore data stack index
.94d5	60		rts				rts
.94d6	56 61		lsr $61,x	_shift:		lsr FSMant0,x
.94d8	76 6b		ror $6b,x			ror FSMant1,x
.94da	76 75		ror $75,x			ror FSMant2,x
.94dc	76 7f		ror $7f,x			ror FSMant3,x
.94de	6a		ror a				ror a
=119					CodeLen	.var *-XtPtr1
=$94df					Here1 = *	; remember here
>9466	77					.byte CodeLen	;patch wh_CodeLength
.94df	60		rts				rts
>94e0	44 46 40			Name0:	.text "DF@"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=37987					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>94e3	03					.byte (("DF@"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=127					LinkDisplacement = Nt0-WordListLink
>94e4	10					.byte WordFlags	;wh_Flags
>94e5	03					.byte 3	;wh_CodeLength
>94e6	7f					  .byte LinkDisplacement	; offset to previous nt
=$94e7					XtPtr1 ::= *
=37987					WordListLink ::= Nt0 ; remember the nt of this word for later
.94e7	20 62 c5	jsr $c562	DFAt:		jsr PopYA		; pop df_addr
.94ea	85 16		sta $16		DFAt_YA:	sta tmp2+0		; save df_addr
.94ec	84 17		sty $17				sty tmp2+1
.94ee	20 d4 84	jsr $84d4			jsr FAllocX		; alloc FP stack entry
.94f1	a0 00		ldy #$00			ldy #0			; +0 IEEE byte
.94f3	b1 16		lda ($16),y			lda (tmp2),y
.94f5	95 57		sta $57,x			sta FSExp,x
.94f7	c8		iny				iny			; +1 IEEE byte
.94f8	b1 16		lda ($16),y			lda (tmp2),y
.94fa	95 61		sta $61,x			sta FSMant0,x
.94fc	c8		iny				iny			; +2 IEEE byte
.94fd	b1 16		lda ($16),y			lda (tmp2),y
.94ff	95 6b		sta $6b,x			sta FSMant1,x
.9501	c8		iny				iny			; +3 IEEE byte
.9502	b1 16		lda ($16),y			lda (tmp2),y
.9504	95 75		sta $75,x			sta FSMant2,x
.9506	c8		iny				iny			; +4 IEEE byte
.9507	b1 16		lda ($16),y			lda (tmp2),y
.9509	95 7f		sta $7f,x			sta FSMant3,x
.950b	c8		iny				iny			; +5 IEEE byte
.950c	b1 16		lda ($16),y			lda (tmp2),y
.950e	20 37 95	jsr $9537			jsr _shifta		; shift exponent & mantissa bits into place
.9511	20 37 95	jsr $9537			jsr _shifta
.9514	b5 61		lda $61,x			lda FSMant0,x		; finish shifting exponent bits
.9516	0a		asl a				asl a
.9517	36 57		rol $57,x			rol FSExp,x
.9519	0a		asl a				asl a
.951a	36 57		rol $57,x			rol FSExp,x
.951c	b5 57		lda $57,x			lda FSExp,x		; remove +1023
.951e	18		clc				clc
.951f	69 02		adc #$02			adc #2
.9521	95 57		sta $57,x			sta FSExp,x
.9523	b5 61		lda $61,x			lda FSMant0,x
.9525	29 7f		and #$7f			and #$7f
.9527	09 40		ora #$40			ora #$40		;   insert implied 1
.9529	95 61		sta $61,x			sta FSMant0,x		;   insert sign=0
.952b	a6 14		ldx $14				ldx tmp1		; restore data stack index
.952d	a0 00		ldy #$00			ldy #0			; get sign from +0 IEEE byte
.952f	b1 16		lda ($16),y			lda (tmp2),y
.9531	10 03		bpl $9536			bpl +
.9533	20 79 8c	jsr $8c79			jsr FNegate
.9536					+
.9536	60		rts				rts
.9537	0a		asl a		_shifta:	asl a
.9538	36 7f		rol $7f,x			rol FSMant3,x
.953a	36 75		rol $75,x			rol FSMant2,x
.953c	36 6b		rol $6b,x			rol FSMant1,x
.953e	36 61		rol $61,x			rol FSMant0,x
.9540	36 57		rol $57,x			rol FSExp,x
.9542	60		rts				rts
=92					CodeLen	.var *-XtPtr1
=$9543					Here1 = *	; remember here
>94e5	5c					.byte CodeLen	;patch wh_CodeLength
>9543	44 46 6c 6f 61 74 2b		Name0:	.text "DFloat+"	;  name of word as a string, ending at wh_NameLastChar
=7					NameLength = *-Name0
=38090					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>954a	67					.byte (("DFloat+"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=103					LinkDisplacement = Nt0-WordListLink
>954b	10					.byte WordFlags	;wh_Flags
>954c	03					.byte 3	;wh_CodeLength
>954d	67					  .byte LinkDisplacement	; offset to previous nt
=$954e					XtPtr1 ::= *
=38090					WordListLink ::= Nt0 ; remember the nt of this word for later
.954e	a9 08		lda #$08	DFloatPlus:	lda #8
.9550	4c da db	jmp $dbda			jmp Plus_A
=5					CodeLen	.var *-XtPtr1
=$9553					Here1 = *	; remember here
>954c	05					.byte CodeLen	;patch wh_CodeLength
>9553	44 46 6c 6f 61 74 73		Name0:	.text "DFloats"	;  name of word as a string, ending at wh_NameLastChar
=7					NameLength = *-Name0
=38106					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>955a	67					.byte (("DFloats"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=16					LinkDisplacement = Nt0-WordListLink
>955b	10					.byte WordFlags	;wh_Flags
>955c	03					.byte 3	;wh_CodeLength
>955d	10					  .byte LinkDisplacement	; offset to previous nt
=$955e					XtPtr1 ::= *
=38106					WordListLink ::= Nt0 ; remember the nt of this word for later
.955e	a9 03		lda #$03	DFloats:	lda #3
.9560	4c 2d dd	jmp $dd2d			jmp LShift_A
=5					CodeLen	.var *-XtPtr1
=$9563					Here1 = *	; remember here
>955c	05					.byte CodeLen	;patch wh_CodeLength
>9563	46 4d 50 6f 6c 79		Name0:	.text "FMPoly"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=38121					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9569	26					.byte (("FMPoly"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=15					LinkDisplacement = Nt0-WordListLink
>956a	10					.byte WordFlags	;wh_Flags
>956b	03					.byte 3	;wh_CodeLength
>956c	0f					  .byte LinkDisplacement	; offset to previous nt
=$956d					XtPtr1 ::= *
=38121					WordListLink ::= Nt0 ; remember the nt of this word for later
.956d	20 62 c5	jsr $c562	FMPoly:		jsr PopYA
.9570	20 2e c9	jsr $c92e	FMPolyYA:	jsr PushYA		; push coefficent table addr
.9573	20 b2 86	jsr $86b2			jsr FAt_YA		; fetch 1st coefficent
.9576	4c 89 95	jmp $9589			jmp _4
.9579	20 9a 85	jsr $859a	_2:		jsr FOver
.957c	20 da 8c	jsr $8cda			jsr FStar
.957f	b5 26		lda $26,x			lda DStack+0,x		; fetch next coefficent
.9581	b4 27		ldy $27,x			ldy DStack+1,x
.9583	20 b2 86	jsr $86b2			jsr FAt_YA
.9586	20 01 8c	jsr $8c01			jsr FPlus
.9589	a9 05		lda #$05	_4:		lda #Float_Size		; bump coefficent ptr
.958b	20 da db	jsr $dbda			jsr Plus_A
.958e	a1 26		lda ($26,x)			lda (DStack+0,x)	; end of coefficent list?
.9590	d0 e7		bne $9579			bne _2
.9592	e8		inx				inx			; Drop coefficent ptr
.9593	e8		inx				inx
=39					CodeLen	.var *-XtPtr1
=$9594					Here1 = *	; remember here
>956b	27					.byte CodeLen	;patch wh_CodeLength
.9594	60		rts				rts
>9595	46 4c 6f 67 32 4d 31 4d		Name0:	.text "FLog2M1M"	;  name of word as a string, ending at wh_NameLastChar
=8					NameLength = *-Name0
=38173					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>959d	a8					.byte (("FLog2M1M"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=52					LinkDisplacement = Nt0-WordListLink
>959e	10					.byte WordFlags	;wh_Flags
>959f	03					.byte 3	;wh_CodeLength
>95a0	34					  .byte LinkDisplacement	; offset to previous nt
=$95a1					XtPtr1 ::= *
=38173					WordListLink ::= Nt0 ; remember the nt of this word for later
.95a1	a9 ab		lda #$ab	FLog2M1M:	lda #<_c
.95a3	a0 95		ldy #$95			ldy #>_c
.95a5	20 70 95	jsr $9570			jsr FMPolyYA
.95a8	4c da 8c	jmp $8cda			jmp FStar
=10					CodeLen	.var *-XtPtr1
=$95ab					Here1 = *	; remember here
>959f	0a					.byte CodeLen	;patch wh_CodeLength
.95ab					_c:
>95ab	cc cf 97 7c					.dword $7C97CFCC	; 32 bit signed binary mantissa.  $40000000 = +0.5
>95af	fa						.char -6		; 8 bit signed binary exponent.  $00 = 2**0
>95b0	64 87 94 af					.dword $AF948764	; 32 bit signed binary mantissa.  $40000000 = +0.5
>95b4	fd						.char -3		; 8 bit signed binary exponent.  $00 = 2**0
>95b5	66 c8 d4 62					.dword $62D4C866	; 32 bit signed binary mantissa.  $40000000 = +0.5
>95b9	fe						.char -2		; 8 bit signed binary exponent.  $00 = 2**0
>95ba	e2 9c c3 ac					.dword $ACC39CE2	; 32 bit signed binary mantissa.  $40000000 = +0.5
>95be	ff						.char -1		; 8 bit signed binary exponent.  $00 = 2**0
>95bf	1a c6 2b 79					.dword $792BC61A	; 32 bit signed binary mantissa.  $40000000 = +0.5
>95c3	ff						.char -1		; 8 bit signed binary exponent.  $00 = 2**0
>95c4	07 e1 c4 a3					.dword $A3C4E107	; 32 bit signed binary mantissa.  $40000000 = +0.5
>95c8	00						.char 0		; 8 bit signed binary exponent.  $00 = 2**0
>95c9	91 a5 54 5c					.dword $5C54A591	; 32 bit signed binary mantissa.  $40000000 = +0.5
>95cd	01						.char 1		; 8 bit signed binary exponent.  $00 = 2**0
>95ce	00						.byte 0
>95cf	46 4c 6f 67 32			Name0:	.text "FLog2"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=38228					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>95d4	45					.byte (("FLog2"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=55					LinkDisplacement = Nt0-WordListLink
>95d5	10					.byte WordFlags	;wh_Flags
>95d6	03					.byte 3	;wh_CodeLength
>95d7	37					  .byte LinkDisplacement	; offset to previous nt
=$95d8					XtPtr1 ::= *
=38228					WordListLink ::= Nt0 ; remember the nt of this word for later
.95d8	a4 56		ldy $56		FLog2:		ldy FIndex
.95da	b9 61 00	lda $0061,y			lda FSMant0,y	; bad param?
.95dd	30 20		bmi $95ff			bmi _OutOfRange
.95df	f0 1e		beq $95ff			beq _OutOfRange
.95e1	b9 57 00	lda $0057,y			lda FSExp,y
.95e4	48		pha				pha		; remember orig exponent
.95e5	a9 01		lda #$01			lda #1
.95e7	99 57 00	sta $0057,y			sta FSExp,y	; set to 1
.95ea	20 65 8c	jsr $8c65			jsr F1Minus
.95ed	20 a1 95	jsr $95a1			jsr FLog2M1M
.95f0	a0 00		ldy #$00			ldy #0		; add orig exponent to float
.95f2	68		pla				pla
.95f3	38		sec				sec
.95f4	e9 01		sbc #$01			sbc #1
.95f6	10 01		bpl $95f9			bpl +
.95f8	88		dey				dey
.95f9					+
.95f9	20 49 8f	jsr $8f49			jsr SToFYA
.95fc	4c 01 8c	jmp $8c01			jmp FPlus
.95ff	4c e8 84	jmp $84e8	_OutOfRange:	jmp Throw_FpOutOfRange
=42					CodeLen	.var *-XtPtr1
=$9602					Here1 = *	; remember here
>95d6	2a					.byte CodeLen	;patch wh_CodeLength
>9602	46 4c 6e			Name0:	.text "FLn"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=38277					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9605	c3					.byte (("FLn"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=49					LinkDisplacement = Nt0-WordListLink
>9606	10					.byte WordFlags	;wh_Flags
>9607	03					.byte 3	;wh_CodeLength
>9608	31					  .byte LinkDisplacement	; offset to previous nt
=$9609					XtPtr1 ::= *
=38277					WordListLink ::= Nt0 ; remember the nt of this word for later
.9609	20 d8 95	jsr $95d8	FLn:		jsr FLog2
.960c	20 e9 88	jsr $88e9			jsr FLitI
>960f	f8 0b b9 58					.dword $58b90bf8	; 32 bit signed binary mantissa.  $40000000 = +0.5
>9613	00						.char 0		; 8 bit signed binary exponent.  $00 = 2**0
.9614	4c da 8c	jmp $8cda			jmp FStar
=14					CodeLen	.var *-XtPtr1
=$9617					Here1 = *	; remember here
>9607	0e					.byte CodeLen	;patch wh_CodeLength
>9617	46 4c 6e 50 31			Name0:	.text "FLnP1"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=38300					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>961c	25					.byte (("FLnP1"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=23					LinkDisplacement = Nt0-WordListLink
>961d	10					.byte WordFlags	;wh_Flags
>961e	03					.byte 3	;wh_CodeLength
>961f	17					  .byte LinkDisplacement	; offset to previous nt
=$9620					XtPtr1 ::= *
=38300					WordListLink ::= Nt0 ; remember the nt of this word for later
.9620	20 35 8c	jsr $8c35	FlnP1:		jsr F1Plus
.9623	4c 09 96	jmp $9609			jmp FLn
=6					CodeLen	.var *-XtPtr1
=$9626					Here1 = *	; remember here
>961e	06					.byte CodeLen	;patch wh_CodeLength
>9626	46 4c 6f 67			Name0:	.text "FLog"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=38314					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>962a	e4					.byte (("FLog"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=14					LinkDisplacement = Nt0-WordListLink
>962b	10					.byte WordFlags	;wh_Flags
>962c	03					.byte 3	;wh_CodeLength
>962d	0e					  .byte LinkDisplacement	; offset to previous nt
=$962e					XtPtr1 ::= *
=38314					WordListLink ::= Nt0 ; remember the nt of this word for later
.962e	20 d8 95	jsr $95d8	FLog:		jsr FLog2
.9631	20 e9 88	jsr $88e9			jsr FLitI
>9634	3c 4d 10 4d					.dword $4d104d3c	; 32 bit signed binary mantissa.  $40000000 = +0.5
>9638	ff						.char -1		; 8 bit signed binary exponent.  $00 = 2**0
.9639	4c da 8c	jmp $8cda			jmp FStar
=14					CodeLen	.var *-XtPtr1
=$963c					Here1 = *	; remember here
>962c	0e					.byte CodeLen	;patch wh_CodeLength
>963c	46 45 78 70 32 4d 31 4d		Name0:	.text "FExp2M1M"	;  name of word as a string, ending at wh_NameLastChar
=8					NameLength = *-Name0
=38340					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9644	a8					.byte (("FExp2M1M"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=26					LinkDisplacement = Nt0-WordListLink
>9645	10					.byte WordFlags	;wh_Flags
>9646	03					.byte 3	;wh_CodeLength
>9647	1a					  .byte LinkDisplacement	; offset to previous nt
=$9648					XtPtr1 ::= *
=38340					WordListLink ::= Nt0 ; remember the nt of this word for later
.9648	a9 52		lda #$52	FExp2M1M:	lda #<_c
.964a	a0 96		ldy #$96			ldy #>_c
.964c	20 70 95	jsr $9570			jsr FMPolyYA
.964f	4c da 8c	jmp $8cda			jmp FStar
=10					CodeLen	.var *-XtPtr1
=$9652					Here1 = *	; remember here
>9646	0a					.byte CodeLen	;patch wh_CodeLength
.9652					_c:
>9652	e7 dc 4f 7c					.dword $7C4FDCe7	; 32 bit signed binary mantissa.  $40000000 = +0.5
>9656	f7						.char -9		; 8 bit signed binary exponent.  $00 = 2**0
>9657	de ca 4c 49					.dword $494CCADe	; 32 bit signed binary mantissa.  $40000000 = +0.5
>965b	fa						.char -6		; 8 bit signed binary exponent.  $00 = 2**0
>965c	fb 42 64 72					.dword $726442fb	; 32 bit signed binary mantissa.  $40000000 = +0.5
>9660	fc						.char -4		; 8 bit signed binary exponent.  $00 = 2**0
>9661	50 90 f4 7a					.dword $7AF49050	; 32 bit signed binary mantissa.  $40000000 = +0.5
>9665	fe						.char -2		; 8 bit signed binary exponent.  $00 = 2**0
>9666	a2 3c b9 58					.dword $58B93Ca2	; 32 bit signed binary mantissa.  $40000000 = +0.5
>966a	00						.char 0		; 8 bit signed binary exponent.  $00 = 2**0
>966b	00						.byte 0
>966c	46 45 78 70 32			Name0:	.text "FExp2"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=38385					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9671	45					.byte (("FExp2"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=45					LinkDisplacement = Nt0-WordListLink
>9672	10					.byte WordFlags	;wh_Flags
>9673	03					.byte 3	;wh_CodeLength
>9674	2d					  .byte LinkDisplacement	; offset to previous nt
=$9675					XtPtr1 ::= *
=38385					WordListLink ::= Nt0 ; remember the nt of this word for later
.9675	20 1f 8b	jsr $8b1f	FExp2:		jsr FIntFrc	; ( f: r_rem r_int )
.9678	20 9b 8f	jsr $8f9b			jsr FToS
.967b	20 48 96	jsr $9648			jsr FExp2M1M
.967e	20 35 8c	jsr $8c35			jsr F1Plus
.9681	20 47 c5	jsr $c547			jsr PopA
.9684	a4 56		ldy $56				ldy FIndex
.9686	18		clc				clc
.9687	79 57 00	adc $0057,y			adc FSExp,y
.968a	99 57 00	sta $0057,y			sta FSExp,y
=24					CodeLen	.var *-XtPtr1
=$968d					Here1 = *	; remember here
>9673	18					.byte CodeLen	;patch wh_CodeLength
.968d	60		rts				rts
>968e	46 45 78 70			Name0:	.text "FExp"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=38418					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9692	04					.byte (("FExp"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=33					LinkDisplacement = Nt0-WordListLink
>9693	10					.byte WordFlags	;wh_Flags
>9694	03					.byte 3	;wh_CodeLength
>9695	21					  .byte LinkDisplacement	; offset to previous nt
=$9696					XtPtr1 ::= *
=38418					WordListLink ::= Nt0 ; remember the nt of this word for later
.9696					FExp:
.9696	20 e9 88	jsr $88e9			jsr FLitI
>9699	94 1d 55 5c					.dword $5c551d94	; 32 bit signed binary mantissa.  $40000000 = +0.5
>969d	01						.char 1		; 8 bit signed binary exponent.  $00 = 2**0
.969e	20 da 8c	jsr $8cda			jsr FStar
.96a1	4c 75 96	jmp $9675			jmp FExp2
=14					CodeLen	.var *-XtPtr1
=$96a4					Here1 = *	; remember here
>9694	0e					.byte CodeLen	;patch wh_CodeLength
>96a4	46 45 78 70 4d 31		Name0:	.text "FExpM1"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=38442					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>96aa	26					.byte (("FExpM1"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=24					LinkDisplacement = Nt0-WordListLink
>96ab	10					.byte WordFlags	;wh_Flags
>96ac	03					.byte 3	;wh_CodeLength
>96ad	18					  .byte LinkDisplacement	; offset to previous nt
=$96ae					XtPtr1 ::= *
=38442					WordListLink ::= Nt0 ; remember the nt of this word for later
.96ae	20 96 96	jsr $9696	FExpM1:		jsr FExp
.96b1	4c 65 8c	jmp $8c65			jmp F1Minus
=6					CodeLen	.var *-XtPtr1
=$96b4					Here1 = *	; remember here
>96ac	06					.byte CodeLen	;patch wh_CodeLength
>96b4	46 41 4c 6f 67			Name0:	.text "FALog"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=38457					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>96b9	e5					.byte (("FALog"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=15					LinkDisplacement = Nt0-WordListLink
>96ba	10					.byte WordFlags	;wh_Flags
>96bb	03					.byte 3	;wh_CodeLength
>96bc	0f					  .byte LinkDisplacement	; offset to previous nt
=$96bd					XtPtr1 ::= *
=38457					WordListLink ::= Nt0 ; remember the nt of this word for later
.96bd					FALog:
.96bd	20 e9 88	jsr $88e9			jsr FLitI
>96c0	25 3c 4d 6a					.dword $6a4d3c25	; 32 bit signed binary mantissa.  $40000000 = +0.5
>96c4	02						.char 2		; 8 bit signed binary exponent.  $00 = 2**0
.96c5	20 da 8c	jsr $8cda			jsr FStar
.96c8	4c 75 96	jmp $9675			jmp FExp2
=14					CodeLen	.var *-XtPtr1
=$96cb					Here1 = *	; remember here
>96bb	0e					.byte CodeLen	;patch wh_CodeLength
>96cb	46 2a 2a			Name0:	.text "F**"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=38478					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>96ce	43					.byte (("F**"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=21					LinkDisplacement = Nt0-WordListLink
>96cf	10					.byte WordFlags	;wh_Flags
>96d0	03					.byte 3	;wh_CodeLength
>96d1	15					  .byte LinkDisplacement	; offset to previous nt
=$96d2					XtPtr1 ::= *
=38478					WordListLink ::= Nt0 ; remember the nt of this word for later
.96d2	20 03 86	jsr $8603	FPower:		jsr FSwap
.96d5	20 d8 95	jsr $95d8			jsr FLog2
.96d8	20 da 8c	jsr $8cda			jsr FStar
.96db	4c 75 96	jmp $9675			jmp FExp2
=12					CodeLen	.var *-XtPtr1
=$96de					Here1 = *	; remember here
>96d0	0c					.byte CodeLen	;patch wh_CodeLength
>96de	44 65 67 32 52 61 64		Name0:	.text "Deg2Rad"	;  name of word as a string, ending at wh_NameLastChar
=7					NameLength = *-Name0
=38501					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>96e5	87					.byte (("Deg2Rad"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=23					LinkDisplacement = Nt0-WordListLink
>96e6	10					.byte WordFlags	;wh_Flags
>96e7	03					.byte 3	;wh_CodeLength
>96e8	17					  .byte LinkDisplacement	; offset to previous nt
=$96e9					XtPtr1 ::= *
=38501					WordListLink ::= Nt0 ; remember the nt of this word for later
.96e9					Deg2Rad:
.96e9	20 e9 88	jsr $88e9			jsr FLitI
>96ec	8a 1a 7d 47					.dword $477d1A8A	; 32 bit signed binary mantissa.  $40000000 = +0.5
>96f0	fb						.char -5		; 8 bit signed binary exponent.  $00 = 2**0
.96f1	4c da 8c	jmp $8cda			jmp FStar
=11					CodeLen	.var *-XtPtr1
=$96f4					Here1 = *	; remember here
>96e7	0b					.byte CodeLen	;patch wh_CodeLength
>96f4	52 61 64 32 44 65 67		Name0:	.text "Rad2Deg"	;  name of word as a string, ending at wh_NameLastChar
=7					NameLength = *-Name0
=38523					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>96fb	e7					.byte (("Rad2Deg"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=22					LinkDisplacement = Nt0-WordListLink
>96fc	10					.byte WordFlags	;wh_Flags
>96fd	03					.byte 3	;wh_CodeLength
>96fe	16					  .byte LinkDisplacement	; offset to previous nt
=$96ff					XtPtr1 ::= *
=38523					WordListLink ::= Nt0 ; remember the nt of this word for later
.96ff					Rad2Deg:
.96ff	20 e9 88	jsr $88e9			jsr FLitI
>9702	68 70 97 72					.dword $72977068	; 32 bit signed binary mantissa.  $40000000 = +0.5
>9706	06						.char 6		; 8 bit signed binary exponent.  $00 = 2**0
.9707	4c da 8c	jmp $8cda			jmp FStar
=11					CodeLen	.var *-XtPtr1
=$970a					Here1 = *	; remember here
>96fd	0b					.byte CodeLen	;patch wh_CodeLength
.970a	4c dd 84	jmp $84dd	Throw_FPStack_18: jmp Throw_FPStack
>970d	46 41 52 65 64 75 63 65		Name0:	.text "FAReduce"	;  name of word as a string, ending at wh_NameLastChar
=8					NameLength = *-Name0
=38549					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9715	a8					.byte (("FAReduce"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=26					LinkDisplacement = Nt0-WordListLink
>9716	10					.byte WordFlags	;wh_Flags
>9717	03					.byte 3	;wh_CodeLength
>9718	1a					  .byte LinkDisplacement	; offset to previous nt
=$9719					XtPtr1 ::= *
=38549					WordListLink ::= Nt0 ; remember the nt of this word for later
.9719	a4 56		ldy $56		FAReduce:	ldy FIndex
.971b	c0 0a		cpy #$0a			cpy #FSDim-0		; check for >=1 FP stack entry
.971d	b0 eb		bcs $970a			bcs Throw_FPStack_18
.971f	b9 61 00	lda $0061,y			lda FSMant0,y		; zero?
.9722	f0 2f		beq $9753			beq _ok
.9724	b9 57 00	lda $0057,y			lda FSExp,y		; get exponent
.9727	30 2a		bmi $9753			bmi _ok			; small?
.9729	c9 01		cmp #$01			cmp #1			; maybe need mirror?
.972b	30 26		bmi $9753			bmi _ok			;if exponent <=0
.972d	f0 24		beq $9753			beq _ok
.972f	c9 02		cmp #$02			cmp #2			; maybe need rotation?
.9731	b0 22		bcs $9755			bcs _exp2
.9733	b9 61 00	lda $0061,y			lda FSMant0,y
.9736	c9 65		cmp #$65			cmp #$65		;in -pi/2..pi/2 ?
.9738	90 19		bcc $9753			bcc _ok
.973a	c9 9b		cmp #$9b			cmp #$100-$65
.973c	b0 15		bcs $9753			bcs _ok
.973e					_mir:
.973e	20 a7 89	jsr $89a7			jsr FPi
.9741	a4 56		ldy $56				ldy FIndex
.9743	b9 62 00	lda $0062,y			lda FSMant0+1,y
.9746	10 03		bpl $974b			bpl _3
.9748	20 79 8c	jsr $8c79			jsr FNegate
.974b	20 03 86	jsr $8603	_3:		jsr FSwap
.974e	20 41 8c	jsr $8c41			jsr FMinus
.9751	38		sec				sec		; mirrored
.9752	60		rts				rts
.9753	18		clc		_ok:		clc		; not mirrored
.9754	60		rts				rts
.9755	d0 0b		bne $9762	_exp2:		bne _rot	;if exp>2 then fix
.9757	b9 61 00	lda $0061,y			lda FSMant0,y
.975a	c9 65		cmp #$65			cmp #$65	;if mant>pi or mant<-pi then fix
.975c	90 e0		bcc $973e			bcc _mir
.975e	c9 9b		cmp #$9b			cmp #$100-$65
.9760	b0 dc		bcs $973e			bcs _mir
.9762	20 d6 89	jsr $89d6	_rot:		jsr F2Pi
.9765	20 a9 8d	jsr $8da9			jsr FSlash
.9768	20 1f 8b	jsr $8b1f			jsr FIntFrc
.976b	e6 56		inc $56				inc FIndex	; FDrop integer part
.976d	a4 56		ldy $56				ldy FIndex	;if >=.5
.976f	b9 57 00	lda $0057,y			lda FSExp,y
.9772	a8		tay				tay
.9773	30 03		bmi $9778			bmi _rot4
.9775	20 65 8c	jsr $8c65			jsr F1Minus	;  subtract 1
.9778	20 d6 89	jsr $89d6	_rot4:		jsr F2Pi
.977b	20 da 8c	jsr $8cda			jsr FStar
.977e	4c 19 97	jmp $9719			jmp FAReduce	; rotate done, look again
=104					CodeLen	.var *-XtPtr1
=$9781					Here1 = *	; remember here
>9717	68					.byte CodeLen	;patch wh_CodeLength
>9781	46 53 69 6e			Name0:	.text "FSin"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=38661					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9785	c4					.byte (("FSin"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=112					LinkDisplacement = Nt0-WordListLink
>9786	10					.byte WordFlags	;wh_Flags
>9787	03					.byte 3	;wh_CodeLength
>9788	70					  .byte LinkDisplacement	; offset to previous nt
=$9789					XtPtr1 ::= *
=38661					WordListLink ::= Nt0 ; remember the nt of this word for later
.9789	20 19 97	jsr $9719	FSin:		jsr FAReduce
.978c	20 72 85	jsr $8572	FSinM:		jsr FDup
.978f	20 9d 8d	jsr $8d9d			jsr FSqr	; x x^2
.9792	a9 a2		lda #$a2			lda #<_c
.9794	a0 97		ldy #$97			ldy #>_c
.9796	20 70 95	jsr $9570			jsr FMPolyYA
.9799	20 da 8c	jsr $8cda			jsr FStar
.979c	20 35 8c	jsr $8c35			jsr F1Plus	; C0 +1.0
.979f	4c da 8c	jmp $8cda			jmp FStar
=25					CodeLen	.var *-XtPtr1
=$97a2					Here1 = *	; remember here
>9787	19					.byte CodeLen	;patch wh_CodeLength
.97a2					_c:
>97a2	ba a7 21 57					.dword $5721a7ba	; 32 bit signed binary mantissa.  $40000000 = +0.5
>97a6	ee						.char -18		; 8 bit signed binary exponent.  $00 = 2**0
>97a7	3a 0b 2a 98					.dword $982a0b3a	; 32 bit signed binary mantissa.  $40000000 = +0.5
>97ab	f4						.char -12		; 8 bit signed binary exponent.  $00 = 2**0
>97ac	4c 8f 43 44					.dword $44438f4c	; 32 bit signed binary mantissa.  $40000000 = +0.5
>97b0	fa						.char -6		; 8 bit signed binary exponent.  $00 = 2**0
>97b1	2b ae aa aa					.dword $aaaaae2b	; 32 bit signed binary mantissa.  $40000000 = +0.5
>97b5	fe						.char -2		; 8 bit signed binary exponent.  $00 = 2**0
>97b6	00						.byte 0
>97b7	46 43 73 63			Name0:	.text "FCsc"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=38715					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>97bb	64					.byte (("FCsc"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=54					LinkDisplacement = Nt0-WordListLink
>97bc	10					.byte WordFlags	;wh_Flags
>97bd	03					.byte 3	;wh_CodeLength
>97be	36					  .byte LinkDisplacement	; offset to previous nt
=$97bf					XtPtr1 ::= *
=38715					WordListLink ::= Nt0 ; remember the nt of this word for later
.97bf	20 89 97	jsr $9789	FCsc:		jsr FSin
.97c2	4c 4d 8e	jmp $8e4d			jmp F1Slash		; 1/SIN(r1)
=6					CodeLen	.var *-XtPtr1
=$97c5					Here1 = *	; remember here
>97bd	06					.byte CodeLen	;patch wh_CodeLength
>97c5	46 43 6f 73			Name0:	.text "FCos"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=38729					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>97c9	64					.byte (("FCos"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=14					LinkDisplacement = Nt0-WordListLink
>97ca	10					.byte WordFlags	;wh_Flags
>97cb	03					.byte 3	;wh_CodeLength
>97cc	0e					  .byte LinkDisplacement	; offset to previous nt
=$97cd					XtPtr1 ::= *
=38729					WordListLink ::= Nt0 ; remember the nt of this word for later
.97cd	20 b7 89	jsr $89b7	FCos:		jsr FPiH
.97d0	20 01 8c	jsr $8c01			jsr FPlus
.97d3	4c 89 97	jmp $9789			jmp FSin
=9					CodeLen	.var *-XtPtr1
=$97d6					Here1 = *	; remember here
>97cb	09					.byte CodeLen	;patch wh_CodeLength
>97d6	46 53 65 63			Name0:	.text "FSec"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=38746					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>97da	64					.byte (("FSec"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=17					LinkDisplacement = Nt0-WordListLink
>97db	10					.byte WordFlags	;wh_Flags
>97dc	03					.byte 3	;wh_CodeLength
>97dd	11					  .byte LinkDisplacement	; offset to previous nt
=$97de					XtPtr1 ::= *
=38746					WordListLink ::= Nt0 ; remember the nt of this word for later
.97de	20 cd 97	jsr $97cd	FSec:		jsr FCos
.97e1	4c 4d 8e	jmp $8e4d			jmp F1Slash		; 1/COS(r1)
=6					CodeLen	.var *-XtPtr1
=$97e4					Here1 = *	; remember here
>97dc	06					.byte CodeLen	;patch wh_CodeLength
>97e4	46 53 69 6e 43 6f 73		Name0:	.text "FSinCos"	;  name of word as a string, ending at wh_NameLastChar
=7					NameLength = *-Name0
=38763					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>97eb	67					.byte (("FSinCos"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=17					LinkDisplacement = Nt0-WordListLink
>97ec	10					.byte WordFlags	;wh_Flags
>97ed	03					.byte 3	;wh_CodeLength
>97ee	11					  .byte LinkDisplacement	; offset to previous nt
=$97ef					XtPtr1 ::= *
=38763					WordListLink ::= Nt0 ; remember the nt of this word for later
.97ef	20 72 85	jsr $8572	FSinCos:	jsr FDup
.97f2	20 89 97	jsr $9789			jsr FSin
.97f5	20 03 86	jsr $8603			jsr FSwap
.97f8	4c cd 97	jmp $97cd			jmp FCos
=12					CodeLen	.var *-XtPtr1
=$97fb					Here1 = *	; remember here
>97ed	0c					.byte CodeLen	;patch wh_CodeLength
>97fb	46 54 61 6e			Name0:	.text "FTan"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=38783					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>97ff	c4					.byte (("FTan"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=20					LinkDisplacement = Nt0-WordListLink
>9800	10					.byte WordFlags	;wh_Flags
>9801	03					.byte 3	;wh_CodeLength
>9802	14					  .byte LinkDisplacement	; offset to previous nt
=$9803					XtPtr1 ::= *
=38783					WordListLink ::= Nt0 ; remember the nt of this word for later
.9803	20 19 97	jsr $9719	FTan:		jsr FAReduce
.9806	90 06		bcc $980e			bcc _30
.9808	20 0e 98	jsr $980e			jsr _30
.980b	4c 79 8c	jmp $8c79			jmp FNegate
.980e					_30:
.980e	20 72 85	jsr $8572			jsr FDup
.9811	20 a3 8c	jsr $8ca3			jsr FAbs
.9814	20 c7 89	jsr $89c7			jsr FPiQ
.9817	20 fe 87	jsr $87fe			jsr FLe
.981a	e8		inx				inx			; pop f
.981b	e8		inx				inx
.981c	b5 26		lda $26,x			lda DStack+0,x
.981e	d0 19		bne $9839			bne FTanM
.9820	20 b7 89	jsr $89b7			jsr FPiH
.9823	a4 56		ldy $56				ldy FIndex		; get sign
.9825	b9 61 00	lda $0061,y			lda FSMant0,y
.9828	10 03		bpl $982d			bpl +
.982a	20 79 8c	jsr $8c79			jsr FNegate
.982d					+
.982d	20 03 86	jsr $8603			jsr FSwap
.9830	20 41 8c	jsr $8c41			jsr FMinus
.9833	20 39 98	jsr $9839			jsr FTanM
.9836	4c 4d 8e	jmp $8e4d			jmp F1Slash
=54					CodeLen	.var *-XtPtr1
=$9839					Here1 = *	; remember here
>9801	36					.byte CodeLen	;patch wh_CodeLength
.9839	20 72 85	jsr $8572	FTanM:		jsr FDup
.983c	20 9d 8d	jsr $8d9d			jsr FSqr		; x x^2
.983f	a9 4f		lda #$4f			lda #<_c
.9841	a0 98		ldy #$98			ldy #>_c
.9843	20 70 95	jsr $9570			jsr FMPolyYA
.9846	20 da 8c	jsr $8cda			jsr FStar
.9849	20 35 8c	jsr $8c35			jsr F1Plus		; c0 1.0
.984c	4c da 8c	jmp $8cda			jmp FStar
.984f					_c:
>984f	1e ae 4d 58					.dword $584DAE1E	; 32 bit signed binary mantissa.  $40000000 = +0.5
>9853	fb						.char -5		; 8 bit signed binary exponent.  $00 = 2**0
>9854	51 0a eb 57					.dword $57EB0A51	; 32 bit signed binary mantissa.  $40000000 = +0.5
>9858	fa						.char -6		; 8 bit signed binary exponent.  $00 = 2**0
>9859	98 d9 14 77					.dword $7714D998	; 32 bit signed binary mantissa.  $40000000 = +0.5
>985d	fc						.char -4		; 8 bit signed binary exponent.  $00 = 2**0
>985e	f9 10 ea 43					.dword $43EA10F9	; 32 bit signed binary mantissa.  $40000000 = +0.5
>9862	fe						.char -2		; 8 bit signed binary exponent.  $00 = 2**0
>9863	1b e2 57 55					.dword $5557E21B	; 32 bit signed binary mantissa.  $40000000 = +0.5
>9867	ff						.char -1		; 8 bit signed binary exponent.  $00 = 2**0
>9868	00						.byte 0
>9869	46 43 6f 74			Name0:	.text "FCot"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=38893					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>986d	84					.byte (("FCot"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=110					LinkDisplacement = Nt0-WordListLink
>986e	10					.byte WordFlags	;wh_Flags
>986f	03					.byte 3	;wh_CodeLength
>9870	6e					  .byte LinkDisplacement	; offset to previous nt
=$9871					XtPtr1 ::= *
=38893					WordListLink ::= Nt0 ; remember the nt of this word for later
.9871	20 03 98	jsr $9803	FCot:		jsr FTan
.9874	4c 4d 8e	jmp $8e4d			jmp F1Slash	; =1/TAN(r1)
=6					CodeLen	.var *-XtPtr1
=$9877					Here1 = *	; remember here
>986f	06					.byte CodeLen	;patch wh_CodeLength
>9877	46 41 43 6f 73			Name0:	.text "FACos"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=38908					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>987c	65					.byte (("FACos"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=15					LinkDisplacement = Nt0-WordListLink
>987d	10					.byte WordFlags	;wh_Flags
>987e	03					.byte 3	;wh_CodeLength
>987f	0f					  .byte LinkDisplacement	; offset to previous nt
=$9880					XtPtr1 ::= *
=38908					WordListLink ::= Nt0 ; remember the nt of this word for later
.9880	a4 56		ldy $56		FACos:		ldy FIndex
.9882	b9 61 00	lda $0061,y			lda FSMant0,y
.9885	08		php				php			; save sign
.9886	20 a3 8c	jsr $8ca3			jsr FAbs
.9889	a9 ac		lda #$ac			lda #<_c
.988b	a0 98		ldy #$98			ldy #>_c
.988d	20 70 95	jsr $9570			jsr FMPolyYA
.9890	20 03 86	jsr $8603			jsr FSwap
.9893	20 79 8c	jsr $8c79			jsr FNegate
.9896	20 35 8c	jsr $8c35			jsr F1Plus
.9899	20 4c 90	jsr $904c			jsr FSqrt
.989c	20 da 8c	jsr $8cda			jsr FStar
.989f	28		plp				plp			; was r1 negative?
.98a0	10 09		bpl $98ab			bpl +
.98a2	20 a7 89	jsr $89a7			jsr FPi
.98a5	20 03 86	jsr $8603			jsr FSwap
.98a8	20 41 8c	jsr $8c41			jsr FMinus
.98ab					+
=43					CodeLen	.var *-XtPtr1
=$98ab					Here1 = *	; remember here
>987e	2b					.byte CodeLen	;patch wh_CodeLength
.98ab	60		rts				rts
.98ac					_c:
>98ac	8b 5e 9f 4b					.dword $4B9F5E8B	; 32 bit signed binary mantissa.  $40000000 = +0.5
>98b0	f8						.char -8		; 8 bit signed binary exponent.  $00 = 2**0
>98b1	ad cc 29 a4					.dword $A429CCAD	; 32 bit signed binary mantissa.  $40000000 = +0.5
>98b5	fa						.char -6		; 8 bit signed binary exponent.  $00 = 2**0
>98b6	98 a1 a3 6e					.dword $6EA3A198	; 32 bit signed binary mantissa.  $40000000 = +0.5
>98ba	fb						.char -5		; 8 bit signed binary exponent.  $00 = 2**0
>98bb	5a 10 e1 9b					.dword $9BE1105A	; 32 bit signed binary mantissa.  $40000000 = +0.5
>98bf	fc						.char -4		; 8 bit signed binary exponent.  $00 = 2**0
>98c0	c6 71 ea 5a					.dword $5AEA71C6	; 32 bit signed binary mantissa.  $40000000 = +0.5
>98c4	fd						.char -3		; 8 bit signed binary exponent.  $00 = 2**0
>98c5	e0 56 21 92					.dword $922156E0	; 32 bit signed binary mantissa.  $40000000 = +0.5
>98c9	fe						.char -2		; 8 bit signed binary exponent.  $00 = 2**0
>98ca	41 ed 87 64					.dword $6487ED41	; 32 bit signed binary mantissa.  $40000000 = +0.5
>98ce	01						.char 1		; 8 bit signed binary exponent.  $00 = 2**0
>98cf	00						.byte 0
>98d0	46 41 53 65 63			Name0:	.text "FASec"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=38997					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>98d5	65					.byte (("FASec"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=89					LinkDisplacement = Nt0-WordListLink
>98d6	10					.byte WordFlags	;wh_Flags
>98d7	03					.byte 3	;wh_CodeLength
>98d8	59					  .byte LinkDisplacement	; offset to previous nt
=$98d9					XtPtr1 ::= *
=38997					WordListLink ::= Nt0 ; remember the nt of this word for later
.98d9	20 4d 8e	jsr $8e4d	FASec:		jsr F1Slash
.98dc	4c 80 98	jmp $9880			jmp FACos
=6					CodeLen	.var *-XtPtr1
=$98df					Here1 = *	; remember here
>98d7	06					.byte CodeLen	;patch wh_CodeLength
>98df	46 41 53 69 6e			Name0:	.text "FASin"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=39012					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>98e4	c5					.byte (("FASin"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=15					LinkDisplacement = Nt0-WordListLink
>98e5	10					.byte WordFlags	;wh_Flags
>98e6	03					.byte 3	;wh_CodeLength
>98e7	0f					  .byte LinkDisplacement	; offset to previous nt
=$98e8					XtPtr1 ::= *
=39012					WordListLink ::= Nt0 ; remember the nt of this word for later
.98e8	20 80 98	jsr $9880	FASin:		jsr FACos
.98eb	20 79 8c	jsr $8c79			jsr FNegate
.98ee	20 b7 89	jsr $89b7			jsr FPiH
.98f1	4c 01 8c	jmp $8c01			jmp FPlus
=12					CodeLen	.var *-XtPtr1
=$98f4					Here1 = *	; remember here
>98e6	0c					.byte CodeLen	;patch wh_CodeLength
>98f4	46 41 43 73 63			Name0:	.text "FACsc"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=39033					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>98f9	65					.byte (("FACsc"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=21					LinkDisplacement = Nt0-WordListLink
>98fa	10					.byte WordFlags	;wh_Flags
>98fb	03					.byte 3	;wh_CodeLength
>98fc	15					  .byte LinkDisplacement	; offset to previous nt
=$98fd					XtPtr1 ::= *
=39033					WordListLink ::= Nt0 ; remember the nt of this word for later
.98fd	20 4d 8e	jsr $8e4d	FACsc:		jsr F1Slash
.9900	4c e8 98	jmp $98e8			jmp FASin
=6					CodeLen	.var *-XtPtr1
=$9903					Here1 = *	; remember here
>98fb	06					.byte CodeLen	;patch wh_CodeLength
>9903	46 41 54 61 6e			Name0:	.text "FATan"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=39048					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9908	c5					.byte (("FATan"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=15					LinkDisplacement = Nt0-WordListLink
>9909	10					.byte WordFlags	;wh_Flags
>990a	03					.byte 3	;wh_CodeLength
>990b	0f					  .byte LinkDisplacement	; offset to previous nt
=$990c					XtPtr1 ::= *
=39048					WordListLink ::= Nt0 ; remember the nt of this word for later
.990c					FATan:
.990c	a4 56		ldy $56				ldy FIndex
.990e	b9 57 00	lda $0057,y			lda FSExp,y		; Abs(r1)<1 ?
.9911	30 1b		bmi $992e			bmi FATanM
.9913	f0 19		beq $992e			beq FATanM
.9915	b9 61 00	lda $0061,y			lda FSMant0,y		; save sign
.9918	08		php				php
.9919	20 4d 8e	jsr $8e4d			jsr F1Slash
.991c	20 2e 99	jsr $992e			jsr FATanM
.991f	20 79 8c	jsr $8c79			jsr FNegate
.9922	20 b7 89	jsr $89b7			jsr FPiH
.9925	28		plp				plp
.9926	10 03		bpl $992b			bpl _18
.9928	20 79 8c	jsr $8c79			jsr FNegate
.992b	4c 01 8c	jmp $8c01	_18:		jmp FPlus
.992e	20 72 85	jsr $8572	FATanM:		jsr FDup		; x x
.9931	20 9d 8d	jsr $8d9d			jsr FSqr		; x xsqr
.9934	a9 44		lda #$44			lda #<_c
.9936	a0 99		ldy #$99			ldy #>_c
.9938	20 70 95	jsr $9570			jsr FMPolyYA
.993b	20 da 8c	jsr $8cda			jsr FStar		; x poly
.993e	20 35 8c	jsr $8c35			jsr F1Plus		; x poly
.9941	4c da 8c	jmp $8cda			jmp FStar
.9944					_c:
>9944	98 08 2d 76					.dword $762D0898	; 32 bit signed binary mantissa.  $40000000 = +0.5
>9948	f9						.char -7		; 8 bit signed binary exponent.  $00 = 2**0
>9949	55 a1 32 b8					.dword $B832A155	; 32 bit signed binary mantissa.  $40000000 = +0.5
>994d	fc						.char -4		; 8 bit signed binary exponent.  $00 = 2**0
>994e	a8 d7 a2 53					.dword $53A2D7A8	; 32 bit signed binary mantissa.  $40000000 = +0.5
>9952	fd						.char -3		; 8 bit signed binary exponent.  $00 = 2**0
>9953	be 91 85 bb					.dword $BB8591BE	; 32 bit signed binary mantissa.  $40000000 = +0.5
>9957	fe						.char -2		; 8 bit signed binary exponent.  $00 = 2**0
>9958	06 65 aa 65					.dword $65AA6506	; 32 bit signed binary mantissa.  $40000000 = +0.5
>995c	fe						.char -2		; 8 bit signed binary exponent.  $00 = 2**0
>995d	12 21 b0 aa					.dword $AAB02112	; 32 bit signed binary mantissa.  $40000000 = +0.5
>9961	ff						.char -1		; 8 bit signed binary exponent.  $00 = 2**0
>9962	00						.byte 0
>9963	46 41 43 6f 74			Name0:	.text "FACot"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=39144					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9968	85					.byte (("FACot"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=96					LinkDisplacement = Nt0-WordListLink
>9969	10					.byte WordFlags	;wh_Flags
>996a	03					.byte 3	;wh_CodeLength
>996b	60					  .byte LinkDisplacement	; offset to previous nt
=$996c					XtPtr1 ::= *
=39144					WordListLink ::= Nt0 ; remember the nt of this word for later
.996c	20 4d 8e	jsr $8e4d	FACot:		jsr F1Slash
.996f	4c 0c 99	jmp $990c			jmp FATan
=6					CodeLen	.var *-XtPtr1
=$9972					Here1 = *	; remember here
>996a	06					.byte CodeLen	;patch wh_CodeLength
>9972	46 41 54 61 6e 32		Name0:	.text "FATan2"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=39160					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9978	46					.byte (("FATan2"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=16					LinkDisplacement = Nt0-WordListLink
>9979	10					.byte WordFlags	;wh_Flags
>997a	03					.byte 3	;wh_CodeLength
>997b	10					  .byte LinkDisplacement	; offset to previous nt
=$997c					XtPtr1 ::= *
=39160					WordListLink ::= Nt0 ; remember the nt of this word for later
.997c	a4 56		ldy $56		FATan2:		ldy FIndex
.997e	b9 61 00	lda $0061,y			lda FSMant0+0,y	; get rx sign
.9981	f0 1c		beq $999f			beq _rxzero
.9983	0a		asl a				asl a		;   C=rx sign
.9984	b9 62 00	lda $0062,y			lda FSMant0+1,y	;   N=ry sign
.9987	08		php				php		; save signs
.9988	20 a9 8d	jsr $8da9			jsr FSlash
.998b	20 0c 99	jsr $990c			jsr FATan
.998e	28		plp				plp		; pop signs
.998f	b0 01		bcs $9992			bcs _rxneg
.9991	60		rts		_rts:		rts
.9992	08		php		_rxneg:		php
.9993	20 a7 89	jsr $89a7			jsr FPi
.9996	28		plp				plp
.9997	10 03		bpl $999c			bpl +
.9999	20 79 8c	jsr $8c79			jsr FNegate
.999c	4c 01 8c	jmp $8c01	+		jmp FPlus
.999f	e6 56		inc $56		_rxzero:	inc FIndex	; FDrop rx
.99a1	b9 61 00	lda $0061,y			lda FSMant0,y
.99a4	08		php				php
.99a5	e6 56		inc $56				inc FIndex	; FDrop ry
.99a7	20 b7 89	jsr $89b7			jsr FPiH
.99aa	28		plp				plp
.99ab	10 e4		bpl $9991			bpl _rts
.99ad	4c 79 8c	jmp $8c79			jmp FNegate
=52					CodeLen	.var *-XtPtr1
=$99b0					Here1 = *	; remember here
>997a	34					.byte CodeLen	;patch wh_CodeLength
>99b0	46 53 67 6e			Name0:	.text "FSgn"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=39220					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>99b4	c4					.byte (("FSgn"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=60					LinkDisplacement = Nt0-WordListLink
>99b5	10					.byte WordFlags	;wh_Flags
>99b6	03					.byte 3	;wh_CodeLength
>99b7	3c					  .byte LinkDisplacement	; offset to previous nt
=$99b8					XtPtr1 ::= *
=39220					WordListLink ::= Nt0 ; remember the nt of this word for later
.99b8	a4 56		ldy $56		FSgn:		ldy FIndex
.99ba	c0 0a		cpy #$0a			cpy #FSDim-0	; check for >=1 FP stack entry
.99bc	b0 10		bcs $99ce			bcs Throw_FPStack_19
.99be	b9 61 00	lda $0061,y			lda FSMant0,y
.99c1	f0 0a		beq $99cd			beq _zero
.99c3	e6 56		inc $56				inc FIndex
.99c5	b9 61 00	lda $0061,y			lda FSMant0,y
.99c8	30 07		bmi $99d1			bmi FM1
.99ca	4c 8c 89	jmp $898c			jmp F1
.99cd	60		rts		_zero:		rts
=22					CodeLen	.var *-XtPtr1
=$99ce					Here1 = *	; remember here
>99b6	16					.byte CodeLen	;patch wh_CodeLength
.99ce	4c dd 84	jmp $84dd	Throw_FPStack_19: jmp Throw_FPStack
.99d1	a9 80		lda #$80	FM1:		lda #$80
.99d3	a0 00		ldy #$00			ldy #0
.99d5	4c 36 89	jmp $8936			jmp FLitYA
=32					CodeLen	.var *-XtPtr1
=$99d8					Here1 = *	; remember here
>99b6	20					.byte CodeLen	;patch wh_CodeLength
>99d8	46 53 69 6e 48			Name0:	.text "FSinH"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=39261					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>99dd	05					.byte (("FSinH"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=41					LinkDisplacement = Nt0-WordListLink
>99de	10					.byte WordFlags	;wh_Flags
>99df	03					.byte 3	;wh_CodeLength
>99e0	29					  .byte LinkDisplacement	; offset to previous nt
=$99e1					XtPtr1 ::= *
=39261					WordListLink ::= Nt0 ; remember the nt of this word for later
.99e1	20 72 85	jsr $8572	FSinH:		jsr FDup
.99e4	20 96 96	jsr $9696			jsr FExp
.99e7	20 03 86	jsr $8603			jsr FSwap
.99ea	20 79 8c	jsr $8c79			jsr FNegate
.99ed	20 96 96	jsr $9696			jsr FExp
.99f0	20 41 8c	jsr $8c41			jsr FMinus
.99f3	4c 44 8a	jmp $8a44			jmp F2Slash
=21					CodeLen	.var *-XtPtr1
=$99f6					Here1 = *	; remember here
>99df	15					.byte CodeLen	;patch wh_CodeLength
>99f6	46 43 73 63 48			Name0:	.text "FCscH"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=39291					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>99fb	05					.byte (("FCscH"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=30					LinkDisplacement = Nt0-WordListLink
>99fc	10					.byte WordFlags	;wh_Flags
>99fd	03					.byte 3	;wh_CodeLength
>99fe	1e					  .byte LinkDisplacement	; offset to previous nt
=$99ff					XtPtr1 ::= *
=39291					WordListLink ::= Nt0 ; remember the nt of this word for later
.99ff	20 e1 99	jsr $99e1	FCscH:		jsr FSinH
.9a02	4c 4d 8e	jmp $8e4d			jmp F1Slash
=6					CodeLen	.var *-XtPtr1
=$9a05					Here1 = *	; remember here
>99fd	06					.byte CodeLen	;patch wh_CodeLength
>9a05	46 43 6f 73 48			Name0:	.text "FCosH"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=39306					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9a0a	05					.byte (("FCosH"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=15					LinkDisplacement = Nt0-WordListLink
>9a0b	10					.byte WordFlags	;wh_Flags
>9a0c	03					.byte 3	;wh_CodeLength
>9a0d	0f					  .byte LinkDisplacement	; offset to previous nt
=$9a0e					XtPtr1 ::= *
=39306					WordListLink ::= Nt0 ; remember the nt of this word for later
.9a0e	20 72 85	jsr $8572	FCosH:		jsr FDup
.9a11	20 96 96	jsr $9696			jsr FExp
.9a14	20 03 86	jsr $8603			jsr FSwap
.9a17	20 79 8c	jsr $8c79			jsr FNegate
.9a1a	20 96 96	jsr $9696			jsr FExp
.9a1d	20 01 8c	jsr $8c01			jsr FPlus
.9a20	4c 44 8a	jmp $8a44			jmp F2Slash
=21					CodeLen	.var *-XtPtr1
=$9a23					Here1 = *	; remember here
>9a0c	15					.byte CodeLen	;patch wh_CodeLength
>9a23	46 53 65 63 48			Name0:	.text "FSecH"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=39336					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9a28	05					.byte (("FSecH"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=30					LinkDisplacement = Nt0-WordListLink
>9a29	10					.byte WordFlags	;wh_Flags
>9a2a	03					.byte 3	;wh_CodeLength
>9a2b	1e					  .byte LinkDisplacement	; offset to previous nt
=$9a2c					XtPtr1 ::= *
=39336					WordListLink ::= Nt0 ; remember the nt of this word for later
.9a2c	20 0e 9a	jsr $9a0e	FSecH:		jsr FCosH
.9a2f	4c 4d 8e	jmp $8e4d			jmp F1Slash
=6					CodeLen	.var *-XtPtr1
=$9a32					Here1 = *	; remember here
>9a2a	06					.byte CodeLen	;patch wh_CodeLength
>9a32	46 54 61 6e 48			Name0:	.text "FTanH"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=39351					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9a37	05					.byte (("FTanH"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=15					LinkDisplacement = Nt0-WordListLink
>9a38	10					.byte WordFlags	;wh_Flags
>9a39	03					.byte 3	;wh_CodeLength
>9a3a	0f					  .byte LinkDisplacement	; offset to previous nt
=$9a3b					XtPtr1 ::= *
=39351					WordListLink ::= Nt0 ; remember the nt of this word for later
.9a3b	20 72 85	jsr $8572	FTanH:		jsr FDup
.9a3e	20 79 8c	jsr $8c79			jsr FNegate	; X -X
.9a41	20 96 96	jsr $9696			jsr FExp	; X Exp(-X)
.9a44	20 03 86	jsr $8603			jsr FSwap	; Exp(-X) X
.9a47	20 96 96	jsr $9696			jsr FExp	; Exp(-X) Exp(X)
.9a4a	20 9a 85	jsr $859a			jsr FOver	; Exp(-X) Exp(X) Exp(-X)
.9a4d	20 01 8c	jsr $8c01			jsr FPlus	; Exp(-X) Exp(X)+Exp(-X)
.9a50	20 a9 8d	jsr $8da9			jsr FSlash	; Exp(-X)/(Exp(X)+Exp(-X))
.9a53	20 39 8a	jsr $8a39			jsr F2Star	; Exp(-X)/(Exp(X)+Exp(-X))*2
.9a56	20 79 8c	jsr $8c79			jsr FNegate
.9a59	4c 35 8c	jmp $8c35			jmp F1Plus
=33					CodeLen	.var *-XtPtr1
=$9a5c					Here1 = *	; remember here
>9a39	21					.byte CodeLen	;patch wh_CodeLength
>9a5c	46 43 6f 74 48			Name0:	.text "FCotH"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=39393					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9a61	05					.byte (("FCotH"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=42					LinkDisplacement = Nt0-WordListLink
>9a62	10					.byte WordFlags	;wh_Flags
>9a63	03					.byte 3	;wh_CodeLength
>9a64	2a					  .byte LinkDisplacement	; offset to previous nt
=$9a65					XtPtr1 ::= *
=39393					WordListLink ::= Nt0 ; remember the nt of this word for later
.9a65	20 3b 9a	jsr $9a3b	FCotH:		jsr FTanH
.9a68	4c 4d 8e	jmp $8e4d			jmp F1Slash
=6					CodeLen	.var *-XtPtr1
=$9a6b					Here1 = *	; remember here
>9a63	06					.byte CodeLen	;patch wh_CodeLength
>9a6b	46 41 53 69 6e 48		Name0:	.text "FASinH"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=39409					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9a71	06					.byte (("FASinH"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=16					LinkDisplacement = Nt0-WordListLink
>9a72	10					.byte WordFlags	;wh_Flags
>9a73	03					.byte 3	;wh_CodeLength
>9a74	10					  .byte LinkDisplacement	; offset to previous nt
=$9a75					XtPtr1 ::= *
=39409					WordListLink ::= Nt0 ; remember the nt of this word for later
.9a75	20 72 85	jsr $8572	FASinH:		jsr FDup	; X X
.9a78	20 9d 8d	jsr $8d9d			jsr FSqr	; X X*X
.9a7b	20 35 8c	jsr $8c35			jsr F1Plus	; X X*X+1
.9a7e	20 4c 90	jsr $904c			jsr FSqrt	; X sqrt(X*X+1)
.9a81	20 01 8c	jsr $8c01			jsr FPlus	;
.9a84	4c 09 96	jmp $9609			jmp FLn
=18					CodeLen	.var *-XtPtr1
=$9a87					Here1 = *	; remember here
>9a73	12					.byte CodeLen	;patch wh_CodeLength
>9a87	46 41 43 73 63 48		Name0:	.text "FACscH"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=39437					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9a8d	06					.byte (("FACscH"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=28					LinkDisplacement = Nt0-WordListLink
>9a8e	10					.byte WordFlags	;wh_Flags
>9a8f	03					.byte 3	;wh_CodeLength
>9a90	1c					  .byte LinkDisplacement	; offset to previous nt
=$9a91					XtPtr1 ::= *
=39437					WordListLink ::= Nt0 ; remember the nt of this word for later
.9a91	20 4d 8e	jsr $8e4d	FACscH:		jsr F1Slash
.9a94	4c 75 9a	jmp $9a75			jmp FASinH
=6					CodeLen	.var *-XtPtr1
=$9a97					Here1 = *	; remember here
>9a8f	06					.byte CodeLen	;patch wh_CodeLength
>9a97	46 41 43 6f 73 48		Name0:	.text "FACosH"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=39453					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9a9d	06					.byte (("FACosH"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=16					LinkDisplacement = Nt0-WordListLink
>9a9e	10					.byte WordFlags	;wh_Flags
>9a9f	03					.byte 3	;wh_CodeLength
>9aa0	10					  .byte LinkDisplacement	; offset to previous nt
=$9aa1					XtPtr1 ::= *
=39453					WordListLink ::= Nt0 ; remember the nt of this word for later
.9aa1	20 72 85	jsr $8572	FACosH:		jsr FDup
.9aa4	20 9d 8d	jsr $8d9d			jsr FSqr
.9aa7	20 65 8c	jsr $8c65			jsr F1Minus
.9aaa	20 4c 90	jsr $904c			jsr FSqrt
.9aad	20 01 8c	jsr $8c01			jsr FPlus
.9ab0	4c 09 96	jmp $9609			jmp FLn
=18					CodeLen	.var *-XtPtr1
=$9ab3					Here1 = *	; remember here
>9a9f	12					.byte CodeLen	;patch wh_CodeLength
>9ab3	46 41 53 65 63 48		Name0:	.text "FASecH"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=39481					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9ab9	06					.byte (("FASecH"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=28					LinkDisplacement = Nt0-WordListLink
>9aba	10					.byte WordFlags	;wh_Flags
>9abb	03					.byte 3	;wh_CodeLength
>9abc	1c					  .byte LinkDisplacement	; offset to previous nt
=$9abd					XtPtr1 ::= *
=39481					WordListLink ::= Nt0 ; remember the nt of this word for later
.9abd	20 4d 8e	jsr $8e4d	FASecH:		jsr F1Slash
.9ac0	4c a1 9a	jmp $9aa1			jmp FACosH
=6					CodeLen	.var *-XtPtr1
=$9ac3					Here1 = *	; remember here
>9abb	06					.byte CodeLen	;patch wh_CodeLength
>9ac3	46 41 54 61 6e 48		Name0:	.text "FATanH"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=39497					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9ac9	06					.byte (("FATanH"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=16					LinkDisplacement = Nt0-WordListLink
>9aca	10					.byte WordFlags	;wh_Flags
>9acb	03					.byte 3	;wh_CodeLength
>9acc	10					  .byte LinkDisplacement	; offset to previous nt
=$9acd					XtPtr1 ::= *
=39497					WordListLink ::= Nt0 ; remember the nt of this word for later
.9acd	20 72 85	jsr $8572	FAtanH:		jsr FDup	; x x
.9ad0	20 35 8c	jsr $8c35			jsr F1Plus	; x x+1
.9ad3	20 03 86	jsr $8603			jsr FSwap	; 1+x x
.9ad6	20 8c 89	jsr $898c			jsr F1
.9ad9	20 03 86	jsr $8603			jsr FSwap
.9adc	20 41 8c	jsr $8c41			jsr FMinus	; 1+x 1-x
.9adf	20 a9 8d	jsr $8da9			jsr FSlash	; (1+x)/(1-x)
.9ae2	20 09 96	jsr $9609			jsr FLn
.9ae5	4c 44 8a	jmp $8a44			jmp F2Slash
=27					CodeLen	.var *-XtPtr1
=$9ae8					Here1 = *	; remember here
>9acb	1b					.byte CodeLen	;patch wh_CodeLength
>9ae8	46 41 43 6f 74 48		Name0:	.text "FACotH"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=39534					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9aee	06					.byte (("FACotH"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=37					LinkDisplacement = Nt0-WordListLink
>9aef	10					.byte WordFlags	;wh_Flags
>9af0	03					.byte 3	;wh_CodeLength
>9af1	25					  .byte LinkDisplacement	; offset to previous nt
=$9af2					XtPtr1 ::= *
=39534					WordListLink ::= Nt0 ; remember the nt of this word for later
.9af2	20 4d 8e	jsr $8e4d	FACotH: 	jsr F1Slash
.9af5	4c cd 9a	jmp $9acd			jmp FATanH
=6					CodeLen	.var *-XtPtr1
=$9af8					Here1 = *	; remember here
>9af0	06					.byte CodeLen	;patch wh_CodeLength
=3					EFloat_Size = 3	; # of in memory byte for an E Float
>9af8	45 46 6c 6f 61 74		Name0:	.text "EFloat"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=39550					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9afe	86					.byte (("EFloat"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=16					LinkDisplacement = Nt0-WordListLink
>9aff	10					.byte WordFlags	;wh_Flags
>9b00	03					.byte 3	;wh_CodeLength
>9b01	10					  .byte LinkDisplacement	; offset to previous nt
=$9b02					XtPtr1 ::= *
=39550					WordListLink ::= Nt0 ; remember the nt of this word for later
.9b02	a9 03		lda #$03	EFloat:		lda #EFloat_Size
.9b04	4c 5d c9	jmp $c95d			jmp PushZA
=5					CodeLen	.var *-XtPtr1
=$9b07					Here1 = *	; remember here
>9b00	05					.byte CodeLen	;patch wh_CodeLength
>9b07	45 46 6c 6f 61 74 2b		Name0:	.text "EFloat+"	;  name of word as a string, ending at wh_NameLastChar
=7					NameLength = *-Name0
=39566					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9b0e	67					.byte (("EFloat+"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=16					LinkDisplacement = Nt0-WordListLink
>9b0f	10					.byte WordFlags	;wh_Flags
>9b10	03					.byte 3	;wh_CodeLength
>9b11	10					  .byte LinkDisplacement	; offset to previous nt
=$9b12					XtPtr1 ::= *
=39566					WordListLink ::= Nt0 ; remember the nt of this word for later
.9b12	a9 03		lda #$03	EFloatPlus:	lda #EFloat_Size
.9b14	4c da db	jmp $dbda			jmp Plus_A
=5					CodeLen	.var *-XtPtr1
=$9b17					Here1 = *	; remember here
>9b10	05					.byte CodeLen	;patch wh_CodeLength
>9b17	45 46 6c 6f 61 74 73		Name0:	.text "EFloats"	;  name of word as a string, ending at wh_NameLastChar
=7					NameLength = *-Name0
=39582					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9b1e	67					.byte (("EFloats"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=16					LinkDisplacement = Nt0-WordListLink
>9b1f	10					.byte WordFlags	;wh_Flags
>9b20	03					.byte 3	;wh_CodeLength
>9b21	10					  .byte LinkDisplacement	; offset to previous nt
=$9b22					XtPtr1 ::= *
=39582					WordListLink ::= Nt0 ; remember the nt of this word for later
.9b22	20 02 9b	jsr $9b02	EFloats:	jsr EFloat
.9b25	4c f3 bf	jmp $bff3			jmp Star
=6					CodeLen	.var *-XtPtr1
=$9b28					Here1 = *	; remember here
>9b20	06					.byte CodeLen	;patch wh_CodeLength
>9b28	45 41 6c 69 67 6e		Name0:	.text "EAlign"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=39598					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9b2e	c6					.byte (("EAlign"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=0					WordFlags ::= 0	; modifiable copy, remember for later
=16					LinkDisplacement = Nt0-WordListLink
>9b2f	00					.byte WordFlags	;wh_Flags
>9b30	03					.byte 3	;wh_CodeLength
>9b31	10					  .byte LinkDisplacement	; offset to previous nt
=$9b32					XtPtr1 ::= *
=39598					WordListLink ::= Nt0 ; remember the nt of this word for later
.9b32					EAlign:
=0					CodeLen	.var *-XtPtr1
=$9b32					Here1 = *	; remember here
>9b30	00					.byte CodeLen	;patch wh_CodeLength
.9b32	60		rts				rts
>9b33	45 41 6c 69 67 6e 65 64		Name0:	.text "EAligned"	;  name of word as a string, ending at wh_NameLastChar
=8					NameLength = *-Name0
=39611					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9b3b	88					.byte (("EAligned"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=0					WordFlags ::= 0	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>9b3c	00					.byte WordFlags	;wh_Flags
>9b3d	03					.byte 3	;wh_CodeLength
>9b3e	0d					  .byte LinkDisplacement	; offset to previous nt
=$9b3f					XtPtr1 ::= *
=39611					WordListLink ::= Nt0 ; remember the nt of this word for later
.9b3f					EAligned:
=0					CodeLen	.var *-XtPtr1
=$9b3f					Here1 = *	; remember here
>9b3d	00					.byte CodeLen	;patch wh_CodeLength
.9b3f	60		rts				rts
>9b40	48 65 78 3e 45			Name0:	.text "Hex>E"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=39621					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9b45	a5					.byte (("Hex>E"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=10					LinkDisplacement = Nt0-WordListLink
>9b46	10					.byte WordFlags	;wh_Flags
>9b47	03					.byte 3	;wh_CodeLength
>9b48	0a					  .byte LinkDisplacement	; offset to previous nt
=$9b49					XtPtr1 ::= *
=39621					WordListLink ::= Nt0 ; remember the nt of this word for later
.9b49	20 d4 84	jsr $84d4	PartsToE:	jsr FAllocX		; alloc FP stack entry, X= FP stack index
.9b4c	a6 14		ldx $14				ldx tmp1+0		; restore data stack index
.9b4e	a4 56		ldy $56				ldy FIndex		; Y= FP stack index
.9b50	20 47 c5	jsr $c547			jsr PopA		; pop n_exp
.9b53	99 57 00	sta $0057,y			sta FSExp,y
.9b56	b5 27		lda $27,x			lda DStack+1,x
.9b58	99 61 00	sta $0061,y			sta FSMant0,y
.9b5b	b5 26		lda $26,x			lda DStack+0,x
.9b5d	99 6b 00	sta $006b,y			sta FSMant1,y
.9b60	e8		inx				inx			; Drop
.9b61	e8		inx				inx
=25					CodeLen	.var *-XtPtr1
=$9b62					Here1 = *	; remember here
>9b47	19					.byte CodeLen	;patch wh_CodeLength
.9b62	60		rts				rts
>9b63	45 3e 48 65 78			Name0:	.text "E>Hex"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=39656					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9b68	05					.byte (("E>Hex"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=35					LinkDisplacement = Nt0-WordListLink
>9b69	10					.byte WordFlags	;wh_Flags
>9b6a	03					.byte 3	;wh_CodeLength
>9b6b	23					  .byte LinkDisplacement	; offset to previous nt
=$9b6c					XtPtr1 ::= *
=39656					WordListLink ::= Nt0 ; remember the nt of this word for later
.9b6c	a4 56		ldy $56		EToParts:	ldy FIndex	; Y= FP stack index
.9b6e	ca		dex				dex		; alloc n_mantissa
.9b6f	ca		dex				dex
.9b70	ca		dex				dex		; alloc n_exponent
.9b71	ca		dex				dex
.9b72	b9 61 00	lda $0061,y			lda FSMant0,y	; copy mantissa
.9b75	95 29		sta $29,x			sta DStack+3,x
.9b77	b9 6b 00	lda $006b,y			lda FSMant1,y
.9b7a	95 28		sta $28,x			sta DStack+2,x
.9b7c	b9 57 00	lda $0057,y			lda FSExp,y	; copy exponent
.9b7f	95 26		sta $26,x			sta DStack+0,x
.9b81	29 80		and #$80			and #$80	;   sign extend
.9b83	f0 02		beq $9b87			beq +
.9b85	a9 ff		lda #$ff			lda #$ff
.9b87	95 27		sta $27,x	+		sta DStack+1,x
.9b89	e6 56		inc $56				inc FIndex	; FDrop r
=31					CodeLen	.var *-XtPtr1
=$9b8b					Here1 = *	; remember here
>9b6a	1f					.byte CodeLen	;patch wh_CodeLength
.9b8b	60		rts				rts
>9b8c	45 2e 48 65 78			Name0:	.text "E.Hex"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=39697					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9b91	05					.byte (("E.Hex"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=41					LinkDisplacement = Nt0-WordListLink
>9b92	10					.byte WordFlags	;wh_Flags
>9b93	03					.byte 3	;wh_CodeLength
>9b94	29					  .byte LinkDisplacement	; offset to previous nt
=$9b95					XtPtr1 ::= *
=39697					WordListLink ::= Nt0 ; remember the nt of this word for later
.9b95	20 6c 9b	jsr $9b6c	EDotHex:	jsr EToParts	; get parts of r
.9b98	20 ad e1	jsr $e1ad			jsr Swap
.9b9b	20 57 ba	jsr $ba57			jsr Dot_Hex	; do mantissa
.9b9e	a9 3a		lda #$3a			lda #':'
.9ba0	20 cd df	jsr $dfcd			jsr Emit_A
.9ba3	4c 36 ba	jmp $ba36			jmp C_Dot_Hex	; do exponent
=17					CodeLen	.var *-XtPtr1
=$9ba6					Here1 = *	; remember here
>9b93	11					.byte CodeLen	;patch wh_CodeLength
>9ba6	45 43 6d 70 41			Name0:	.text "ECmpA"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=39723					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9bab	25					.byte (("ECmpA"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=26					LinkDisplacement = Nt0-WordListLink
>9bac	10					.byte WordFlags	;wh_Flags
>9bad	03					.byte 3	;wh_CodeLength
>9bae	1a					  .byte LinkDisplacement	; offset to previous nt
=$9baf					XtPtr1 ::= *
=39723					WordListLink ::= Nt0 ; remember the nt of this word for later
.9baf	86 14		stx $14		ECmpA:		stx tmp1		; save data stack index
.9bb1	a6 56		ldx $56				ldx FIndex		; X= FP stack index
.9bb3	b5 61		lda $61,x			lda FSMant0+0,x		; r2 mantissa == 0 ?
.9bb5	f0 29		beq $9be0			beq _r2Zero
.9bb7	b4 62		ldy $62,x			ldy FSMant0+1,x		; r1 mantissa == 0 ?
.9bb9	f0 1f		beq $9bda			beq _r1Zero
.9bbb	55 62		eor $62,x			eor FSMant0+1,x		; compare mantissa sign
.9bbd	30 31		bmi $9bf0			bmi _MantissaSignDifferent
.9bbf	38		sec				sec			; compare exponent
.9bc0	b5 58		lda $58,x			lda FSExp+1,x
.9bc2	f5 57		sbc $57,x			sbc FSExp+0,x
.9bc4	d0 1f		bne $9be5			bne _ExponentDifferent
.9bc6	98		tya				tya			; compare mantissa MSB
.9bc7	f5 61		sbc $61,x			sbc FSMant0+0,x		;   always same sign so can't overflow
.9bc9	d0 0b		bne $9bd6			bne _13
.9bcb	b5 6c		lda $6c,x			lda FSMant1+1,x		; compare mantissa 1
.9bcd	f5 6b		sbc $6b,x			sbc FSMant1+0,x
.9bcf	f0 05		beq $9bd6			beq _13
.9bd1	6a		ror a		_12:		ror a
.9bd2	49 80		eor #$80	_14:		eor #$80
.9bd4	09 01		ora #$01			ora #1
.9bd6	a6 14		ldx $14		_13:		ldx tmp1		; restore data stack index
.9bd8	a8		tay				tay			; set CPU flags
.9bd9	60		rts				rts
.9bda	b5 61		lda $61,x	_r1Zero:	lda FSMant0+0,x		; return 0-r2
.9bdc	d0 f4		bne $9bd2			bne _14
.9bde	f0 f6		beq $9bd6			beq _13
.9be0	b5 62		lda $62,x	_r2Zero:	lda FSMant0+1,x		; return r1
.9be2	4c d6 9b	jmp $9bd6			jmp _13
.9be5					_ExponentDifferent:
.9be5	50 02		bvc $9be9			bvc +
.9be7	49 80		eor #$80			eor #$80
.9be9					+
.9be9	55 61		eor $61,x			eor FSMant0+0,x
.9beb	a6 14		ldx $14				ldx tmp1		; restore data stack index
.9bed	09 01		ora #$01			ora #1			; set CPU flags
.9bef	60		rts				rts
.9bf0					_MantissaSignDifferent:
.9bf0	98		tya				tya
.9bf1	a6 14		ldx $14				ldx tmp1		; restore data stack index
.9bf3	09 01		ora #$01			ora #1
.9bf5	60		rts				rts
=71					CodeLen	.var *-XtPtr1
=$9bf6					Here1 = *	; remember here
>9bad	47					.byte CodeLen	;patch wh_CodeLength
>9bf6	45 4d 61 78			Name0:	.text "EMax"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=39802					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9bfa	04					.byte (("EMax"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=79					LinkDisplacement = Nt0-WordListLink
>9bfb	10					.byte WordFlags	;wh_Flags
>9bfc	03					.byte 3	;wh_CodeLength
>9bfd	4f					  .byte LinkDisplacement	; offset to previous nt
=$9bfe					XtPtr1 ::= *
=39802					WordListLink ::= Nt0 ; remember the nt of this word for later
.9bfe	20 af 9b	jsr $9baf	EMax:		jsr ECmpA
.9c01	10 2c		bpl $9c2f			bpl EDrop
.9c03	30 44		bmi $9c49			bmi ENip
=7					CodeLen	.var *-XtPtr1
=$9c05					Here1 = *	; remember here
>9bfc	07					.byte CodeLen	;patch wh_CodeLength
>9c05	45 4d 69 6e			Name0:	.text "EMin"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=39817					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9c09	c4					.byte (("EMin"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=15					LinkDisplacement = Nt0-WordListLink
>9c0a	10					.byte WordFlags	;wh_Flags
>9c0b	03					.byte 3	;wh_CodeLength
>9c0c	0f					  .byte LinkDisplacement	; offset to previous nt
=$9c0d					XtPtr1 ::= *
=39817					WordListLink ::= Nt0 ; remember the nt of this word for later
.9c0d	20 af 9b	jsr $9baf	EMin:		jsr ECmpA
.9c10	30 1d		bmi $9c2f			bmi EDrop
.9c12	10 35		bpl $9c49			bpl ENip
=7					CodeLen	.var *-XtPtr1
=$9c14					Here1 = *	; remember here
>9c0b	07					.byte CodeLen	;patch wh_CodeLength
>9c14	45 44 65 70 74 68		Name0:	.text "EDepth"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=39834					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9c1a	06					.byte (("EDepth"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=17					LinkDisplacement = Nt0-WordListLink
>9c1b	10					.byte WordFlags	;wh_Flags
>9c1c	03					.byte 3	;wh_CodeLength
>9c1d	11					  .byte LinkDisplacement	; offset to previous nt
=$9c1e					XtPtr1 ::= *
=39834					WordListLink ::= Nt0 ; remember the nt of this word for later
.9c1e	a9 0a		lda #$0a	EDepth:		lda #FSDim
.9c20	38		sec				sec
.9c21	e5 56		sbc $56				sbc FIndex
.9c23	4c 5d c9	jmp $c95d			jmp PushZA
=8					CodeLen	.var *-XtPtr1
=$9c26					Here1 = *	; remember here
>9c1c	08					.byte CodeLen	;patch wh_CodeLength
>9c26	45 44 72 6f 70			Name0:	.text "EDrop"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=39851					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9c2b	05					.byte (("EDrop"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=0					WordFlags ::= 0	; modifiable copy, remember for later
=17					LinkDisplacement = Nt0-WordListLink
>9c2c	00					.byte WordFlags	;wh_Flags
>9c2d	03					.byte 3	;wh_CodeLength
>9c2e	11					  .byte LinkDisplacement	; offset to previous nt
=$9c2f					XtPtr1 ::= *
=39851					WordListLink ::= Nt0 ; remember the nt of this word for later
.9c2f	e6 56		inc $56		EDrop:		inc FIndex
=2					CodeLen	.var *-XtPtr1
=$9c31					Here1 = *	; remember here
>9c2d	02					.byte CodeLen	;patch wh_CodeLength
.9c31	60		rts				rts
>9c32	45 32 44 72 6f 70		Name0:	.text "E2Drop"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=39864					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9c38	06					.byte (("E2Drop"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=0					WordFlags ::= 0	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>9c39	00					.byte WordFlags	;wh_Flags
>9c3a	03					.byte 3	;wh_CodeLength
>9c3b	0d					  .byte LinkDisplacement	; offset to previous nt
=$9c3c					XtPtr1 ::= *
=39864					WordListLink ::= Nt0 ; remember the nt of this word for later
.9c3c	e6 56		inc $56		E2Drop:		inc FIndex
.9c3e	e6 56		inc $56				inc FIndex
=4					CodeLen	.var *-XtPtr1
=$9c40					Here1 = *	; remember here
>9c3a	04					.byte CodeLen	;patch wh_CodeLength
.9c40	60		rts				rts
>9c41	45 4e 69 70			Name0:	.text "ENip"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=39877					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9c45	04					.byte (("ENip"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=0					WordFlags ::= 0	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>9c46	00					.byte WordFlags	;wh_Flags
>9c47	03					.byte 3	;wh_CodeLength
>9c48	0d					  .byte LinkDisplacement	; offset to previous nt
=$9c49					XtPtr1 ::= *
=39877					WordListLink ::= Nt0 ; remember the nt of this word for later
.9c49	86 14		stx $14		ENip:		stx tmp1		; save data stack index
.9c4b	a6 56		ldx $56				ldx FIndex		; X= FP stack index
.9c4d	b5 57		lda $57,x			lda FSExp+0,x		; copy exponent
.9c4f	95 58		sta $58,x			sta FSExp+1,x
.9c51	b5 61		lda $61,x			lda FSMant0+0,x		; copy mantissa
.9c53	95 62		sta $62,x			sta FSMant0+1,x
.9c55	b5 6b		lda $6b,x			lda FSMant1+0,x
.9c57	95 6c		sta $6c,x			sta FSMant1+1,x
.9c59	e6 56		inc $56				inc FIndex		; EDrop
.9c5b	a6 14		ldx $14				ldx tmp1		; restore data stack index
=20					CodeLen	.var *-XtPtr1
=$9c5d					Here1 = *	; remember here
>9c47	14					.byte CodeLen	;patch wh_CodeLength
.9c5d	60		rts				rts
>9c5e	45 44 75 70			Name0:	.text "EDup"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=39906					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9c62	04					.byte (("EDup"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=0					WordFlags ::= 0	; modifiable copy, remember for later
=29					LinkDisplacement = Nt0-WordListLink
>9c63	00					.byte WordFlags	;wh_Flags
>9c64	03					.byte 3	;wh_CodeLength
>9c65	1d					  .byte LinkDisplacement	; offset to previous nt
=$9c66					XtPtr1 ::= *
=39906					WordListLink ::= Nt0 ; remember the nt of this word for later
.9c66	20 d4 84	jsr $84d4	EDup:		jsr FAllocX		; alloc FP stack entry, X=fp stack index
.9c69	b5 58		lda $58,x			lda FSExp+1,x		; copy exponent
.9c6b	95 57		sta $57,x			sta FSExp+0,x
.9c6d	b5 62		lda $62,x			lda FSMant0+1,x		; copy mantissa
.9c6f	95 61		sta $61,x			sta FSMant0+0,x
.9c71	b5 6c		lda $6c,x			lda FSMant1+1,x
.9c73	95 6b		sta $6b,x			sta FSMant1+0,x
.9c75	a6 14		ldx $14				ldx tmp1+0		; restore data stack index
=17					CodeLen	.var *-XtPtr1
=$9c77					Here1 = *	; remember here
>9c64	11					.byte CodeLen	;patch wh_CodeLength
.9c77	60		rts				rts
>9c78	45 4f 76 65 72			Name0:	.text "EOver"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=39933					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9c7d	45					.byte (("EOver"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=0					WordFlags ::= 0	; modifiable copy, remember for later
=27					LinkDisplacement = Nt0-WordListLink
>9c7e	00					.byte WordFlags	;wh_Flags
>9c7f	03					.byte 3	;wh_CodeLength
>9c80	1b					  .byte LinkDisplacement	; offset to previous nt
=$9c81					XtPtr1 ::= *
=39933					WordListLink ::= Nt0 ; remember the nt of this word for later
.9c81	20 d4 84	jsr $84d4	EOver:		jsr FAllocX		; alloc FP stack entry, X=fp stack index
.9c84	b5 59		lda $59,x			lda FSExp+2,x		; copy exponent
.9c86	95 57		sta $57,x			sta FSExp+0,x
.9c88	b5 63		lda $63,x			lda FSMant0+2,x		; copy mantissa
.9c8a	95 61		sta $61,x			sta FSMant0+0,x
.9c8c	b5 6d		lda $6d,x			lda FSMant1+2,x
.9c8e	95 6b		sta $6b,x			sta FSMant1+0,x
.9c90	a6 14		ldx $14				ldx tmp1+0		; restore data stack index
=17					CodeLen	.var *-XtPtr1
=$9c92					Here1 = *	; remember here
>9c7f	11					.byte CodeLen	;patch wh_CodeLength
.9c92	60		rts				rts
>9c93	45 50 69 63 6b			Name0:	.text "EPick"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=39960					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9c98	65					.byte (("EPick"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=0					WordFlags ::= 0	; modifiable copy, remember for later
=27					LinkDisplacement = Nt0-WordListLink
>9c99	00					.byte WordFlags	;wh_Flags
>9c9a	03					.byte 3	;wh_CodeLength
>9c9b	1b					  .byte LinkDisplacement	; offset to previous nt
=$9c9c					XtPtr1 ::= *
=39960					WordListLink ::= Nt0 ; remember the nt of this word for later
.9c9c	20 47 c5	jsr $c547	EPick:		jsr PopA		; pop u (desired entry #)
.9c9f	18		clc		EPickA:		clc			; Y= fp stack index of [u]
.9ca0	65 56		adc $56				adc FIndex
.9ca2	a8		tay		EPick3:		tay
.9ca3	20 d4 84	jsr $84d4			jsr FAllocX		; alloc FP stack entry, X=fp stack index
.9ca6	b9 57 00	lda $0057,y			lda FSExp,y		; copy exponent
.9ca9	95 57		sta $57,x			sta FSExp,x
.9cab	b9 61 00	lda $0061,y			lda FSMant0,y		; copy mantissa
.9cae	95 61		sta $61,x			sta FSMant0,x
.9cb0	b9 6b 00	lda $006b,y			lda FSMant1,y
.9cb3	95 6b		sta $6b,x			sta FSMant1,x
.9cb5	a6 14		ldx $14				ldx tmp1+0		; restore data stack index
=27					CodeLen	.var *-XtPtr1
=$9cb7					Here1 = *	; remember here
>9c9a	1b					.byte CodeLen	;patch wh_CodeLength
.9cb7	60		rts				rts
>9cb8	45 32 44 75 70			Name0:	.text "E2Dup"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=39997					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9cbd	05					.byte (("E2Dup"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=37					LinkDisplacement = Nt0-WordListLink
>9cbe	10					.byte WordFlags	;wh_Flags
>9cbf	03					.byte 3	;wh_CodeLength
>9cc0	25					  .byte LinkDisplacement	; offset to previous nt
=$9cc1					XtPtr1 ::= *
=39997					WordListLink ::= Nt0 ; remember the nt of this word for later
.9cc1	20 81 9c	jsr $9c81	E2Dup:		jsr EOver
.9cc4	4c 81 9c	jmp $9c81			jmp EOver
=6					CodeLen	.var *-XtPtr1
=$9cc7					Here1 = *	; remember here
>9cbf	06					.byte CodeLen	;patch wh_CodeLength
>9cc7	45 53 77 61 70			Name0:	.text "ESwap"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=40012					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9ccc	05					.byte (("ESwap"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=0					WordFlags ::= 0	; modifiable copy, remember for later
=15					LinkDisplacement = Nt0-WordListLink
>9ccd	00					.byte WordFlags	;wh_Flags
>9cce	03					.byte 3	;wh_CodeLength
>9ccf	0f					  .byte LinkDisplacement	; offset to previous nt
=$9cd0					XtPtr1 ::= *
=40012					WordListLink ::= Nt0 ; remember the nt of this word for later
.9cd0	86 14		stx $14		ESwap:		stx tmp1+0		; save data stack index
.9cd2	a6 56		ldx $56				ldx FIndex		; X=FP stack index
.9cd4	b5 57		lda $57,x			lda FSExp+0,x		; do FSExp
.9cd6	b4 58		ldy $58,x			ldy FSExp+1,x
.9cd8	95 58		sta $58,x			sta FSExp+1,x
.9cda	94 57		sty $57,x			sty FSExp+0,x	; sty dir,x exists
.9cdc	b5 61		lda $61,x			lda FSMant0+0,x		; do FSMant0
.9cde	b4 62		ldy $62,x			ldy FSMant0+1,x
.9ce0	95 62		sta $62,x			sta FSMant0+1,x
.9ce2	94 61		sty $61,x			sty FSMant0+0,x	; sty dir,x exists
.9ce4	b5 6b		lda $6b,x			lda FSMant1+0,x		; do FSMant1
.9ce6	b4 6c		ldy $6c,x			ldy FSMant1+1,x
.9ce8	95 6c		sta $6c,x			sta FSMant1+1,x
.9cea	94 6b		sty $6b,x			sty FSMant1+0,x	; sty dir,x exists
.9cec	a6 14		ldx $14				ldx tmp1+0		; restore data stack index
=30					CodeLen	.var *-XtPtr1
=$9cee					Here1 = *	; remember here
>9cce	1e					.byte CodeLen	;patch wh_CodeLength
.9cee	60		rts				rts
>9cef	45 54 75 63 6b			Name0:	.text "ETuck"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=40052					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9cf4	65					.byte (("ETuck"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=40					LinkDisplacement = Nt0-WordListLink
>9cf5	10					.byte WordFlags	;wh_Flags
>9cf6	03					.byte 3	;wh_CodeLength
>9cf7	28					  .byte LinkDisplacement	; offset to previous nt
=$9cf8					XtPtr1 ::= *
=40052					WordListLink ::= Nt0 ; remember the nt of this word for later
.9cf8	20 d0 9c	jsr $9cd0	ETuck:		jsr ESwap
.9cfb	4c 81 9c	jmp $9c81			jmp EOver
=6					CodeLen	.var *-XtPtr1
=$9cfe					Here1 = *	; remember here
>9cf6	06					.byte CodeLen	;patch wh_CodeLength
>9cfe	45 52 6f 74			Name0:	.text "ERot"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=40066					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9d02	84					.byte (("ERot"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=0					WordFlags ::= 0	; modifiable copy, remember for later
=14					LinkDisplacement = Nt0-WordListLink
>9d03	00					.byte WordFlags	;wh_Flags
>9d04	03					.byte 3	;wh_CodeLength
>9d05	0e					  .byte LinkDisplacement	; offset to previous nt
=$9d06					XtPtr1 ::= *
=40066					WordListLink ::= Nt0 ; remember the nt of this word for later
.9d06	86 14		stx $14		ERot:		stx tmp1		; save data stack index
.9d08	a5 56		lda $56				lda FIndex		; for FSMant3, FSMant2, FSMant1, FSMant0, FSExp
.9d0a	18		clc				clc
.9d0b	69 14		adc #$14			adc #2*FSDim
.9d0d	d0 03		bne $9d12			bne _3
.9d0f	8a		txa		_2:		txa			;    next byte
.9d10	e9 0a		sbc #$0a			sbc #FSDim
.9d12	aa		tax		_3:		tax
.9d13	b4 59		ldy $59,x			ldy FSExp+2,x		;   do a byte
.9d15	b5 58		lda $58,x			lda FSExp+1,x
.9d17	95 59		sta $59,x			sta FSExp+2,x
.9d19	b5 57		lda $57,x			lda FSExp+0,x
.9d1b	95 58		sta $58,x			sta FSExp+1,x
.9d1d	94 57		sty $57,x			sty FSExp+0,x	; sty dir,x exists
.9d1f	e4 56		cpx $56				cpx FIndex		; done?
.9d21	d0 ec		bne $9d0f			bne _2
.9d23	a6 14		ldx $14				ldx tmp1		; restore param stack index
=31					CodeLen	.var *-XtPtr1
=$9d25					Here1 = *	; remember here
>9d04	1f					.byte CodeLen	;patch wh_CodeLength
.9d25	60		rts				rts
>9d26	45 2d 52 6f 74			Name0:	.text "E-Rot"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=40107					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9d2b	85					.byte (("E-Rot"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=41					LinkDisplacement = Nt0-WordListLink
>9d2c	10					.byte WordFlags	;wh_Flags
>9d2d	03					.byte 3	;wh_CodeLength
>9d2e	29					  .byte LinkDisplacement	; offset to previous nt
=$9d2f					XtPtr1 ::= *
=40107					WordListLink ::= Nt0 ; remember the nt of this word for later
.9d2f	20 06 9d	jsr $9d06	EMRot:		jsr ERot
.9d32	4c 06 9d	jmp $9d06			jmp ERot
=6					CodeLen	.var *-XtPtr1
=$9d35					Here1 = *	; remember here
>9d2d	06					.byte CodeLen	;patch wh_CodeLength
>9d35	45 40				Name0:	.text "E@"	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=40119					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9d37	02					.byte (("E@"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=0					WordFlags ::= 0	; modifiable copy, remember for later
=12					LinkDisplacement = Nt0-WordListLink
>9d38	00					.byte WordFlags	;wh_Flags
>9d39	03					.byte 3	;wh_CodeLength
>9d3a	0c					  .byte LinkDisplacement	; offset to previous nt
=$9d3b					XtPtr1 ::= *
=40119					WordListLink ::= Nt0 ; remember the nt of this word for later
.9d3b	20 62 c5	jsr $c562	EAt:		jsr PopYA		; pop addr
.9d3e	85 16		sta $16		EAt_YA:		sta tmp2+0		; save addr
.9d40	84 17		sty $17				sty tmp2+1
.9d42	a0 00		ldy #$00			ldy #0			; starting offset from tmp2
.9d44	20 d4 84	jsr $84d4	EAt_Tmp2Y:	jsr FAllocX		; alloc FP stack entry, X= fp stack index
.9d47	b1 16		lda ($16),y			lda (tmp2),y		; copy mantissa
.9d49	95 6b		sta $6b,x			sta FSMant1,x
.9d4b	c8		iny				iny
.9d4c	b1 16		lda ($16),y			lda (tmp2),y
.9d4e	95 61		sta $61,x			sta FSMant0,x
.9d50	c8		iny				iny			; copy exponent
.9d51	b1 16		lda ($16),y			lda (tmp2),y
.9d53	95 57		sta $57,x			sta FSExp,x
.9d55	a6 14		ldx $14				ldx tmp1		; restore data stack index
=28					CodeLen	.var *-XtPtr1
=$9d57					Here1 = *	; remember here
>9d39	1c					.byte CodeLen	;patch wh_CodeLength
.9d57	60		rts				rts
>9d58	45 21				Name0:	.text "E!"	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=40154					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9d5a	22					.byte (("E!"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=0					WordFlags ::= 0	; modifiable copy, remember for later
=35					LinkDisplacement = Nt0-WordListLink
>9d5b	00					.byte WordFlags	;wh_Flags
>9d5c	03					.byte 3	;wh_CodeLength
>9d5d	23					  .byte LinkDisplacement	; offset to previous nt
=$9d5e					XtPtr1 ::= *
=40154					WordListLink ::= Nt0 ; remember the nt of this word for later
.9d5e	20 62 c5	jsr $c562	EStore:		jsr PopYA		; pop addr
.9d61	85 14		sta $14		EStore_YA:	sta tmp1+0		; save addr
.9d63	84 15		sty $15				sty tmp1+1
.9d65	a0 00		ldy #$00			ldy #0
.9d67	86 16		stx $16				stx tmp2		; save data stack index
.9d69	a6 56		ldx $56				ldx FIndex		; X= FP stack index
.9d6b	b5 6b		lda $6b,x			lda FSMant1,x		; copy mantissa
.9d6d	91 14		sta ($14),y			sta (tmp1),y
.9d6f	b5 61		lda $61,x			lda FSMant0,x
.9d71	c8		iny				iny
.9d72	91 14		sta ($14),y			sta (tmp1),y
.9d74	b5 57		lda $57,x			lda FSExp,x		; copy exponent
.9d76	c8		iny				iny
.9d77	91 14		sta ($14),y			sta (tmp1),y
.9d79	e6 56		inc $56				inc FIndex		; FDrop
.9d7b	a6 16		ldx $16				ldx tmp2		; restore data stack index
=31					CodeLen	.var *-XtPtr1
=$9d7d					Here1 = *	; remember here
>9d5c	1f					.byte CodeLen	;patch wh_CodeLength
.9d7d	60		rts				rts
>9d7e	45 2c				Name0:	.text "E,"	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=40192					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9d80	82					.byte (("E,"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=38					LinkDisplacement = Nt0-WordListLink
>9d81	10					.byte WordFlags	;wh_Flags
>9d82	03					.byte 3	;wh_CodeLength
>9d83	26					  .byte LinkDisplacement	; offset to previous nt
=$9d84					XtPtr1 ::= *
=40192					WordListLink ::= Nt0 ; remember the nt of this word for later
.9d84	a5 00		lda $00		EComma:		lda cp+0		; store f at Here
.9d86	a4 01		ldy $01				ldy cp+1
.9d88	20 61 9d	jsr $9d61			jsr EStore_YA
.9d8b	a9 03		lda #$03			lda #EFloat_Size
.9d8d	4c 45 d2	jmp $d245			jmp Allot_ZA
=12					CodeLen	.var *-XtPtr1
=$9d90					Here1 = *	; remember here
>9d82	0c					.byte CodeLen	;patch wh_CodeLength
>9d90	45 30 21			Name0:	.text "E0!"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=40211					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9d93	23					.byte (("E0!"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=19					LinkDisplacement = Nt0-WordListLink
>9d94	10					.byte WordFlags	;wh_Flags
>9d95	03					.byte 3	;wh_CodeLength
>9d96	13					  .byte LinkDisplacement	; offset to previous nt
=$9d97					XtPtr1 ::= *
=40211					WordListLink ::= Nt0 ; remember the nt of this word for later
.9d97	20 7a 9f	jsr $9f7a	EZStore:	jsr E0
.9d9a	4c 5e 9d	jmp $9d5e			jmp EStore
=6					CodeLen	.var *-XtPtr1
=$9d9d					Here1 = *	; remember here
>9d95	06					.byte CodeLen	;patch wh_CodeLength
>9d9d	45 30 3d			Name0:	.text "E0="	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=40224					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9da0	a3					.byte (("E0="[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>9da1	10					.byte WordFlags	;wh_Flags
>9da2	03					.byte 3	;wh_CodeLength
>9da3	0d					  .byte LinkDisplacement	; offset to previous nt
=$9da4					XtPtr1 ::= *
=40224					WordListLink ::= Nt0 ; remember the nt of this word for later
.9da4	a4 56		ldy $56		EZEq:		ldy FIndex
.9da6	b9 61 00	lda $0061,y			lda FSMant0,y
.9da9	d0 24		bne $9dcf			bne EFalse1
.9dab					ETrue1:
.9dab	e6 56		inc $56				inc FIndex	; EDrop
.9dad	4c 3d c9	jmp $c93d			jmp True	; return true
=12					CodeLen	.var *-XtPtr1
=$9db0					Here1 = *	; remember here
>9da2	0c					.byte CodeLen	;patch wh_CodeLength
>9db0	45 30 3c 3e			Name0:	.text "E0<>"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=40244					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9db4	c4					.byte (("E0<>"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=20					LinkDisplacement = Nt0-WordListLink
>9db5	10					.byte WordFlags	;wh_Flags
>9db6	03					.byte 3	;wh_CodeLength
>9db7	14					  .byte LinkDisplacement	; offset to previous nt
=$9db8					XtPtr1 ::= *
=40244					WordListLink ::= Nt0 ; remember the nt of this word for later
.9db8	a4 56		ldy $56		EZNe:		ldy FIndex
.9dba	b9 61 00	lda $0061,y			lda FSMant0,y
.9dbd	d0 ec		bne $9dab			bne ETrue1
.9dbf	f0 0e		beq $9dcf			beq EFalse1
=9					CodeLen	.var *-XtPtr1
=$9dc1					Here1 = *	; remember here
>9db6	09					.byte CodeLen	;patch wh_CodeLength
>9dc1	45 30 3c			Name0:	.text "E0<"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=40260					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9dc4	83					.byte (("E0<"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=16					LinkDisplacement = Nt0-WordListLink
>9dc5	10					.byte WordFlags	;wh_Flags
>9dc6	03					.byte 3	;wh_CodeLength
>9dc7	10					  .byte LinkDisplacement	; offset to previous nt
=$9dc8					XtPtr1 ::= *
=40260					WordListLink ::= Nt0 ; remember the nt of this word for later
.9dc8	a4 56		ldy $56		EZLt:		ldy FIndex
.9dca	b9 61 00	lda $0061,y			lda FSMant0,y
.9dcd	30 dc		bmi $9dab			bmi ETrue1
.9dcf					EFalse1:
.9dcf	e6 56		inc $56				inc FIndex	; EDrop
.9dd1	4c 4f c9	jmp $c94f			jmp False	; return false
=12					CodeLen	.var *-XtPtr1
=$9dd4					Here1 = *	; remember here
>9dc6	0c					.byte CodeLen	;patch wh_CodeLength
>9dd4	45 30 3e 3d			Name0:	.text "E0>="	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=40280					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9dd8	a4					.byte (("E0>="[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=20					LinkDisplacement = Nt0-WordListLink
>9dd9	10					.byte WordFlags	;wh_Flags
>9dda	03					.byte 3	;wh_CodeLength
>9ddb	14					  .byte LinkDisplacement	; offset to previous nt
=$9ddc					XtPtr1 ::= *
=40280					WordListLink ::= Nt0 ; remember the nt of this word for later
.9ddc	a4 56		ldy $56		EZGe:		ldy FIndex
.9dde	b9 61 00	lda $0061,y			lda FSMant0,y
.9de1	10 c8		bpl $9dab			bpl ETrue1
.9de3	30 ea		bmi $9dcf			bmi EFalse1
=9					CodeLen	.var *-XtPtr1
=$9de5					Here1 = *	; remember here
>9dda	09					.byte CodeLen	;patch wh_CodeLength
>9de5	45 30 3e			Name0:	.text "E0>"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=40296					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9de8	c3					.byte (("E0>"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=16					LinkDisplacement = Nt0-WordListLink
>9de9	10					.byte WordFlags	;wh_Flags
>9dea	03					.byte 3	;wh_CodeLength
>9deb	10					  .byte LinkDisplacement	; offset to previous nt
=$9dec					XtPtr1 ::= *
=40296					WordListLink ::= Nt0 ; remember the nt of this word for later
.9dec	a4 56		ldy $56		EZGt:		ldy FIndex
.9dee	b9 61 00	lda $0061,y			lda FSMant0,y
.9df1	30 dc		bmi $9dcf			bmi EFalse1
.9df3	d0 b6		bne $9dab			bne ETrue1
.9df5	f0 d8		beq $9dcf			beq EFalse1
=11					CodeLen	.var *-XtPtr1
=$9df7					Here1 = *	; remember here
>9dea	0b					.byte CodeLen	;patch wh_CodeLength
>9df7	45 30 3c 3d			Name0:	.text "E0<="	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=40315					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9dfb	a4					.byte (("E0<="[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=19					LinkDisplacement = Nt0-WordListLink
>9dfc	10					.byte WordFlags	;wh_Flags
>9dfd	03					.byte 3	;wh_CodeLength
>9dfe	13					  .byte LinkDisplacement	; offset to previous nt
=$9dff					XtPtr1 ::= *
=40315					WordListLink ::= Nt0 ; remember the nt of this word for later
.9dff	a4 56		ldy $56		EZLe:		ldy FIndex
.9e01	b9 61 00	lda $0061,y			lda FSMant0,y
.9e04	30 a5		bmi $9dab			bmi ETrue1
.9e06	d0 c7		bne $9dcf			bne EFalse1
.9e08	f0 a1		beq $9dab			beq ETrue1
=11					CodeLen	.var *-XtPtr1
=$9e0a					Here1 = *	; remember here
>9dfd	0b					.byte CodeLen	;patch wh_CodeLength
>9e0a	45 3c				Name0:	.text "E<"	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=40332					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9e0c	82					.byte (("E<"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=17					LinkDisplacement = Nt0-WordListLink
>9e0d	10					.byte WordFlags	;wh_Flags
>9e0e	03					.byte 3	;wh_CodeLength
>9e0f	11					  .byte LinkDisplacement	; offset to previous nt
=$9e10					XtPtr1 ::= *
=40332					WordListLink ::= Nt0 ; remember the nt of this word for later
.9e10	20 af 9b	jsr $9baf	ELt:		jsr ECmpA
.9e13	30 32		bmi $9e47			bmi ETrue2
.9e15					EFalse2:
.9e15	e6 56		inc $56				inc FIndex	; EDrop
.9e17	e6 56		inc $56				inc FIndex	; EDrop
.9e19	4c 4f c9	jmp $c94f			jmp False	; return False
=12					CodeLen	.var *-XtPtr1
=$9e1c					Here1 = *	; remember here
>9e0e	0c					.byte CodeLen	;patch wh_CodeLength
>9e1c	45 3e 3d			Name0:	.text "E>="	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=40351					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9e1f	a3					.byte (("E>="[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=19					LinkDisplacement = Nt0-WordListLink
>9e20	10					.byte WordFlags	;wh_Flags
>9e21	03					.byte 3	;wh_CodeLength
>9e22	13					  .byte LinkDisplacement	; offset to previous nt
=$9e23					XtPtr1 ::= *
=40351					WordListLink ::= Nt0 ; remember the nt of this word for later
.9e23	20 af 9b	jsr $9baf	EGe:		jsr ECmpA
.9e26	10 1f		bpl $9e47			bpl ETrue2
.9e28	30 eb		bmi $9e15			bmi EFalse2
=7					CodeLen	.var *-XtPtr1
=$9e2a					Here1 = *	; remember here
>9e21	07					.byte CodeLen	;patch wh_CodeLength
>9e2a	45 3e				Name0:	.text "E>"	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=40364					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9e2c	c2					.byte (("E>"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>9e2d	10					.byte WordFlags	;wh_Flags
>9e2e	03					.byte 3	;wh_CodeLength
>9e2f	0d					  .byte LinkDisplacement	; offset to previous nt
=$9e30					XtPtr1 ::= *
=40364					WordListLink ::= Nt0 ; remember the nt of this word for later
.9e30	20 af 9b	jsr $9baf	EGt:		jsr ECmpA
.9e33	30 e0		bmi $9e15			bmi EFalse2
.9e35	d0 10		bne $9e47			bne ETrue2
.9e37	f0 dc		beq $9e15			beq EFalse2
=9					CodeLen	.var *-XtPtr1
=$9e39					Here1 = *	; remember here
>9e2e	09					.byte CodeLen	;patch wh_CodeLength
>9e39	45 3c 3d			Name0:	.text "E<="	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=40380					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9e3c	a3					.byte (("E<="[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=16					LinkDisplacement = Nt0-WordListLink
>9e3d	10					.byte WordFlags	;wh_Flags
>9e3e	03					.byte 3	;wh_CodeLength
>9e3f	10					  .byte LinkDisplacement	; offset to previous nt
=$9e40					XtPtr1 ::= *
=40380					WordListLink ::= Nt0 ; remember the nt of this word for later
.9e40	20 af 9b	jsr $9baf	ELe:		jsr ECmpA
.9e43	30 02		bmi $9e47			bmi ETrue2
.9e45	d0 ce		bne $9e15			bne EFalse2
.9e47					ETrue2:
.9e47	e6 56		inc $56				inc FIndex	; EDrop
.9e49	e6 56		inc $56				inc FIndex	; EDrop
.9e4b	4c 3d c9	jmp $c93d			jmp True	; return True
=14					CodeLen	.var *-XtPtr1
=$9e4e					Here1 = *	; remember here
>9e3e	0e					.byte CodeLen	;patch wh_CodeLength
>9e4e	45 3c 3e			Name0:	.text "E<>"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=40401					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9e51	c3					.byte (("E<>"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=21					LinkDisplacement = Nt0-WordListLink
>9e52	10					.byte WordFlags	;wh_Flags
>9e53	03					.byte 3	;wh_CodeLength
>9e54	15					  .byte LinkDisplacement	; offset to previous nt
=$9e55					XtPtr1 ::= *
=40401					WordListLink ::= Nt0 ; remember the nt of this word for later
.9e55	20 af 9b	jsr $9baf	ENe:		jsr ECmpA
.9e58	d0 ed		bne $9e47			bne ETrue2
.9e5a	f0 b9		beq $9e15			beq EFalse2
=7					CodeLen	.var *-XtPtr1
=$9e5c					Here1 = *	; remember here
>9e53	07					.byte CodeLen	;patch wh_CodeLength
>9e5c	45 3d				Name0:	.text "E="	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=40414					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9e5e	a2					.byte (("E="[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>9e5f	10					.byte WordFlags	;wh_Flags
>9e60	03					.byte 3	;wh_CodeLength
>9e61	0d					  .byte LinkDisplacement	; offset to previous nt
=$9e62					XtPtr1 ::= *
=40414					WordListLink ::= Nt0 ; remember the nt of this word for later
.9e62	20 af 9b	jsr $9baf	EEq:		jsr ECmpA
.9e65	d0 ae		bne $9e15			bne EFalse2
.9e67	f0 de		beq $9e47			beq ETrue2
=7					CodeLen	.var *-XtPtr1
=$9e69					Here1 = *	; remember here
>9e60	07					.byte CodeLen	;patch wh_CodeLength
>9e69	45 7e 41 62 73			Name0:	.text "E~Abs"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=40430					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9e6e	65					.byte (("E~Abs"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=16					LinkDisplacement = Nt0-WordListLink
>9e6f	10					.byte WordFlags	;wh_Flags
>9e70	03					.byte 3	;wh_CodeLength
>9e71	10					  .byte LinkDisplacement	; offset to previous nt
=$9e72					XtPtr1 ::= *
=40430					WordListLink ::= Nt0 ; remember the nt of this word for later
.9e72	20 2f 9d	jsr $9d2f	ETAbs:		jsr EMRot
.9e75	20 fc a1	jsr $a1fc			jsr EMinus
.9e78	20 3f a2	jsr $a23f			jsr EAbs
.9e7b	4c 30 9e	jmp $9e30			jmp EGt
=12					CodeLen	.var *-XtPtr1
=$9e7e					Here1 = *	; remember here
>9e70	0c					.byte CodeLen	;patch wh_CodeLength
>9e7e	45 7e 52 65 6c			Name0:	.text "E~Rel"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=40451					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9e83	85					.byte (("E~Rel"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=21					LinkDisplacement = Nt0-WordListLink
>9e84	10					.byte WordFlags	;wh_Flags
>9e85	03					.byte 3	;wh_CodeLength
>9e86	15					  .byte LinkDisplacement	; offset to previous nt
=$9e87					XtPtr1 ::= *
=40451					WordListLink ::= Nt0 ; remember the nt of this word for later
.9e87	20 81 9c	jsr $9c81	ETRel:		jsr EOver
.9e8a	a9 03		lda #$03			lda #3
.9e8c	20 9f 9c	jsr $9c9f			jsr EPickA
.9e8f	20 cc a1	jsr $a1cc			jsr EPlus
.9e92	20 3f a2	jsr $a23f			jsr EAbs
.9e95	20 5c 8e	jsr $8e5c			jsr EStar		; r1 r2 r3*|r1+r2|
.9e98	20 2f 9d	jsr $9d2f			jsr EMRot		; r3*|r1+r2| r1 r2
.9e9b	20 fc a1	jsr $a1fc			jsr EMinus
.9e9e	20 3f a2	jsr $a23f			jsr EAbs
.9ea1	4c 30 9e	jmp $9e30			jmp EGt
=29					CodeLen	.var *-XtPtr1
=$9ea4					Here1 = *	; remember here
>9e85	1d					.byte CodeLen	;patch wh_CodeLength
>9ea4	45 7e				Name0:	.text "E~"	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=40486					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9ea6	c2					.byte (("E~"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=35					LinkDisplacement = Nt0-WordListLink
>9ea7	10					.byte WordFlags	;wh_Flags
>9ea8	03					.byte 3	;wh_CodeLength
>9ea9	23					  .byte LinkDisplacement	; offset to previous nt
=$9eaa					XtPtr1 ::= *
=40486					WordListLink ::= Nt0 ; remember the nt of this word for later
.9eaa	a4 56		ldy $56		ETilde:		ldy FIndex
.9eac	b9 61 00	lda $0061,y			lda FSMant0,y
.9eaf	30 06		bmi $9eb7			bmi _10			; e3<0
.9eb1	d0 bf		bne $9e72			bne ETAbs		; e3>0
.9eb3	e6 56		inc $56				inc FIndex		; e3=0
.9eb5	d0 ab		bne $9e62			bne EEq
.9eb7	20 25 a2	jsr $a225	_10:		jsr ENegate
.9eba	4c 87 9e	jmp $9e87			jmp ETRel
=19					CodeLen	.var *-XtPtr1
=$9ebd					Here1 = *	; remember here
>9ea8	13					.byte CodeLen	;patch wh_CodeLength
>9ebd	45 56 61 72 69 61 62 6c		Name0:	.text "EVariable"	;  name of word as a string, ending at wh_NameLastChar
>9ec5	65
=9					NameLength = *-Name0
=40518					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9ec6	a9					.byte (("EVariable"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=24					WordFlags ::= IM+NN	; modifiable copy, remember for later
=32					LinkDisplacement = Nt0-WordListLink
>9ec7	18					.byte WordFlags	;wh_Flags
>9ec8	03					.byte 3	;wh_CodeLength
>9ec9	20					  .byte LinkDisplacement	; offset to previous nt
=$9eca					XtPtr1 ::= *
=40518					WordListLink ::= Nt0 ; remember the nt of this word for later
.9eca	20 5f d3	jsr $d35f	EVariable:	jsr Create		; compile word header & push PFA adr
.9ecd	20 6e cd	jsr $cd6e			jsr adjust_z		; fix word code length
.9ed0	20 7a 9f	jsr $9f7a			jsr E0			; alloc & init data
.9ed3	4c 84 9d	jmp $9d84			jmp EComma
=12					CodeLen	.var *-XtPtr1
=$9ed6					Here1 = *	; remember here
>9ec8	0c					.byte CodeLen	;patch wh_CodeLength
>9ed6	45 4c 69 74 65 72 61 6c		Name0:	.text "ELiteral"	;  name of word as a string, ending at wh_NameLastChar
=8					NameLength = *-Name0
=40542					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9ede	88					.byte (("ELiteral"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=24					WordFlags ::= IM+NN	; modifiable copy, remember for later
=24					LinkDisplacement = Nt0-WordListLink
>9edf	18					.byte WordFlags	;wh_Flags
>9ee0	03					.byte 3	;wh_CodeLength
>9ee1	18					  .byte LinkDisplacement	; offset to previous nt
=$9ee2					XtPtr1 ::= *
=40542					WordListLink ::= Nt0 ; remember the nt of this word for later
.9ee2	20 f7 9e	jsr $9ef7	ELiteral:	jsr ELitTest
.9ee5	f0 0a		beq $9ef1			beq _Short
.9ee7	a9 1a		lda #$1a			lda #<ELitI		; compile JSR FLitI
.9ee9	a0 9f		ldy #$9f			ldy #>ELitI
.9eeb	20 25 df	jsr $df25			jsr Jsr_Comma_YA
.9eee	4c 84 9d	jmp $9d84			jmp EComma		; compile inline operand, return
.9ef1	20 fd 9e	jsr $9efd	_Short:		jsr ELitShort
.9ef4	4c 25 df	jmp $df25			jmp Jsr_Comma_YA	; compile jsr ELitYA, & return
=21					CodeLen	.var *-XtPtr1
=$9ef7					Here1 = *	; remember here
>9ee0	15					.byte CodeLen	;patch wh_CodeLength
.9ef7					ELitTest:
.9ef7	a4 56		ldy $56				ldy FIndex
.9ef9	b9 6b 00	lda $006b,y			lda FSMant1,y		; will short work?
.9efc	60		rts				rts
.9efd					ELitShort:
.9efd	a9 a9		lda #$a9			lda #$a9		; compile LDA #mant0
.9eff	20 df de	jsr $dedf			jsr C_Comma_A
.9f02	b9 61 00	lda $0061,y			lda FSMant0,y
.9f05	20 df de	jsr $dedf			jsr C_Comma_A
.9f08	a9 a0		lda #$a0			lda #$a0		; compile LDY #exp
.9f0a	20 df de	jsr $dedf			jsr C_Comma_A
.9f0d	b9 57 00	lda $0057,y			lda FSExp,y
.9f10	20 df de	jsr $dedf			jsr C_Comma_A
.9f13	e6 56		inc $56				inc FIndex		; FDrop
.9f15	a9 64		lda #$64			lda #<ELitYA		; point at FLitYA
.9f17	a0 9f		ldy #$9f			ldy #>ELitYA
.9f19	60		rts				rts
.9f1a					ELitI:
.9f1a	68		pla				pla			; tmp2= RTS addr
.9f1b	85 16		sta $16				sta tmp2+0
.9f1d	18		clc				clc			; bump RTS addr over inline float data
.9f1e	69 03		adc #$03			adc #EFloat_Size
.9f20	a8		tay				tay
.9f21	68		pla				pla
.9f22	85 17		sta $17				sta tmp2+1
.9f24	69 00		adc #$00			adc #0
.9f26	48		pha				pha
.9f27	98		tya				tya
.9f28	48		pha				pha
.9f29	a0 01		ldy #$01			ldy #1			; correct for RTS addr
.9f2b	4c 44 9d	jmp $9d44			jmp EAt_Tmp2Y		; fetch inline data, & return
>9f2e	45 43 6f 6e 73 74 61 6e		Name0:	.text "EConstant"	;  name of word as a string, ending at wh_NameLastChar
>9f36	74
=9					NameLength = *-Name0
=40631					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9f37	89					.byte (("EConstant"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=89					LinkDisplacement = Nt0-WordListLink
>9f38	10					.byte WordFlags	;wh_Flags
>9f39	03					.byte 3	;wh_CodeLength
>9f3a	59					  .byte LinkDisplacement	; offset to previous nt
=$9f3b					XtPtr1 ::= *
=40631					WordListLink ::= Nt0 ; remember the nt of this word for later
.9f3b	20 b2 d2	jsr $d2b2	EConstant:	jsr WordHeader_Comma	; compile word header
.9f3e	20 f7 9e	jsr $9ef7			jsr ELitTest		; will short work?
.9f41	f0 0d		beq $9f50			beq _Short
.9f43	a9 59		lda #$59			lda #<EConstantRun	; compile call
.9f45	a0 9f		ldy #$9f			ldy #>EConstantRun
.9f47	20 25 df	jsr $df25			jsr Jsr_Comma_YA
.9f4a	20 6e cd	jsr $cd6e			jsr adjust_z
.9f4d	4c 84 9d	jmp $9d84			jmp EComma		; inline operand, & return
.9f50					_Short:
.9f50	20 fd 9e	jsr $9efd			jsr ELitShort		; compile load value
.9f53	20 3b df	jsr $df3b			jsr Jmp_Comma_YA	; compile JMP
.9f56	4c 6e cd	jmp $cd6e			jmp adjust_z
=30					CodeLen	.var *-XtPtr1
=$9f59					Here1 = *	; remember here
>9f39	1e					.byte CodeLen	;patch wh_CodeLength
.9f59					EConstantRun:
.9f59	68		pla				pla			; tmp2= pop RTS addr
.9f5a	85 16		sta $16				sta tmp2+0
.9f5c	68		pla				pla
.9f5d	85 17		sta $17				sta tmp2+1
.9f5f	a0 01		ldy #$01			ldy #1			; correct for RTS addr
.9f61	4c 44 9d	jmp $9d44			jmp EAt_Tmp2Y		; fetch inline data, & return
.9f64					ELitYA:
.9f64	20 d4 84	jsr $84d4			jsr FAllocX		; alloc FP stack entry, X=FP stack index
.9f67	95 61		sta $61,x			sta FSMant0,x		; Mant= A,0
.9f69	94 57		sty $57,x			sty FSExp,x	; sty dir,x exists
.9f6b	a9 00		lda #$00			lda #0
.9f6d	95 6b		sta $6b,x			sta FSMant1,x
.9f6f	a6 14		ldx $14				ldx tmp1+0		; restore data stack index
.9f71	60		rts				rts
>9f72	45 30 2e 65			Name0:	.text "E0.e"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=40694					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9f76	a4					.byte (("E0.e"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=63					LinkDisplacement = Nt0-WordListLink
>9f77	10					.byte WordFlags	;wh_Flags
>9f78	03					.byte 3	;wh_CodeLength
>9f79	3f					  .byte LinkDisplacement	; offset to previous nt
=$9f7a					XtPtr1 ::= *
=40694					WordListLink ::= Nt0 ; remember the nt of this word for later
.9f7a	a9 00		lda #$00	E0:		lda #0			; FSMant0
.9f7c	a0 80		ldy #$80			ldy #$80		; FSExp
.9f7e	d0 e4		bne $9f64			bne ELitYA
=6					CodeLen	.var *-XtPtr1
=$9f80					Here1 = *	; remember here
>9f78	06					.byte CodeLen	;patch wh_CodeLength
>9f80	45 31 30 30 30 2e 65		Name0:	.text "E1000.e"	;  name of word as a string, ending at wh_NameLastChar
=7					NameLength = *-Name0
=40711					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9f87	a7					.byte (("E1000.e"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=17					LinkDisplacement = Nt0-WordListLink
>9f88	10					.byte WordFlags	;wh_Flags
>9f89	03					.byte 3	;wh_CodeLength
>9f8a	11					  .byte LinkDisplacement	; offset to previous nt
=$9f8b					XtPtr1 ::= *
=40711					WordListLink ::= Nt0 ; remember the nt of this word for later
.9f8b	a9 7d		lda #$7d	E1000:		lda #$7d
.9f8d	a0 0a		ldy #$0a			ldy #10
.9f8f	d0 d3		bne $9f64			bne ELitYA
=6					CodeLen	.var *-XtPtr1
=$9f91					Here1 = *	; remember here
>9f89	06					.byte CodeLen	;patch wh_CodeLength
>9f91	45 31 30 2e 65			Name0:	.text "E10.e"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=40726					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9f96	a5					.byte (("E10.e"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=15					LinkDisplacement = Nt0-WordListLink
>9f97	10					.byte WordFlags	;wh_Flags
>9f98	03					.byte 3	;wh_CodeLength
>9f99	0f					  .byte LinkDisplacement	; offset to previous nt
=$9f9a					XtPtr1 ::= *
=40726					WordListLink ::= Nt0 ; remember the nt of this word for later
.9f9a	a9 50		lda #$50	E10:		lda #$50
.9f9c	a0 04		ldy #$04			ldy #4
.9f9e	d0 c4		bne $9f64			bne ELitYA
=6					CodeLen	.var *-XtPtr1
=$9fa0					Here1 = *	; remember here
>9f98	06					.byte CodeLen	;patch wh_CodeLength
>9fa0	45 32 2e 65			Name0:	.text "E2.e"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=40740					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9fa4	a4					.byte (("E2.e"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=14					LinkDisplacement = Nt0-WordListLink
>9fa5	10					.byte WordFlags	;wh_Flags
>9fa6	03					.byte 3	;wh_CodeLength
>9fa7	0e					  .byte LinkDisplacement	; offset to previous nt
=$9fa8					XtPtr1 ::= *
=40740					WordListLink ::= Nt0 ; remember the nt of this word for later
.9fa8	a9 40		lda #$40	E2:		lda #$40
.9faa	a0 02		ldy #$02			ldy #2
.9fac	d0 b6		bne $9f64			bne ELitYA
=6					CodeLen	.var *-XtPtr1
=$9fae					Here1 = *	; remember here
>9fa6	06					.byte CodeLen	;patch wh_CodeLength
>9fae	45 31 2e 65			Name0:	.text "E1.e"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=40754					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9fb2	a4					.byte (("E1.e"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=14					LinkDisplacement = Nt0-WordListLink
>9fb3	10					.byte WordFlags	;wh_Flags
>9fb4	03					.byte 3	;wh_CodeLength
>9fb5	0e					  .byte LinkDisplacement	; offset to previous nt
=$9fb6					XtPtr1 ::= *
=40754					WordListLink ::= Nt0 ; remember the nt of this word for later
.9fb6	a9 40		lda #$40	E1:		lda #$40
.9fb8	a0 01		ldy #$01			ldy #1
.9fba	d0 a8		bne $9f64			bne ELitYA
=6					CodeLen	.var *-XtPtr1
=$9fbc					Here1 = *	; remember here
>9fb4	06					.byte CodeLen	;patch wh_CodeLength
>9fbc	45 2e 31 65			Name0:	.text "E.1e"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=40768					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9fc0	a4					.byte (("E.1e"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=14					LinkDisplacement = Nt0-WordListLink
>9fc1	10					.byte WordFlags	;wh_Flags
>9fc2	03					.byte 3	;wh_CodeLength
>9fc3	0e					  .byte LinkDisplacement	; offset to previous nt
=$9fc4					XtPtr1 ::= *
=40768					WordListLink ::= Nt0 ; remember the nt of this word for later
.9fc4	20 59 9f	jsr $9f59	E10th:		jsr eConstantRun
>9fc7	67 66						.word $6667		; 16 bit signed binary mantissa.  $4000 = +0.5
>9fc9	fd						.char -3		; 8 bit signed exponent.  $00 = 2**0
=6					CodeLen	.var *-XtPtr1
=$9fca					Here1 = *	; remember here
>9fc2	06					.byte CodeLen	;patch wh_CodeLength
>9fca	45 50 69			Name0:	.text "EPi"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=40781					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9fcd	23					.byte (("EPi"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>9fce	10					.byte WordFlags	;wh_Flags
>9fcf	03					.byte 3	;wh_CodeLength
>9fd0	0d					  .byte LinkDisplacement	; offset to previous nt
=$9fd1					XtPtr1 ::= *
=40781					WordListLink ::= Nt0 ; remember the nt of this word for later
.9fd1	20 59 9f	jsr $9f59	EPi:		jsr EConstantRun
>9fd4	88 64						.word $6488		; 16 bit signed binary mantissa.  $4000 = +0.5
>9fd6	02						.char 2		; 8 bit signed exponent.  $00 = 2**0
=6					CodeLen	.var *-XtPtr1
=$9fd7					Here1 = *	; remember here
>9fcf	06					.byte CodeLen	;patch wh_CodeLength
>9fd7	45 50 69 2f 32			Name0:	.text "EPi/2"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=40796					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9fdc	45					.byte (("EPi/2"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=15					LinkDisplacement = Nt0-WordListLink
>9fdd	10					.byte WordFlags	;wh_Flags
>9fde	03					.byte 3	;wh_CodeLength
>9fdf	0f					  .byte LinkDisplacement	; offset to previous nt
=$9fe0					XtPtr1 ::= *
=40796					WordListLink ::= Nt0 ; remember the nt of this word for later
.9fe0	20 59 9f	jsr $9f59	EPiH:		jsr EConstantRun
>9fe3	88 64						.word $6488		; 16 bit signed binary mantissa.  $4000 = +0.5
>9fe5	01						.char 1		; 8 bit signed exponent.  $00 = 2**0
=6					CodeLen	.var *-XtPtr1
=$9fe6					Here1 = *	; remember here
>9fde	06					.byte CodeLen	;patch wh_CodeLength
>9fe6	45 50 69 2f 34			Name0:	.text "EPi/4"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=40811					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9feb	85					.byte (("EPi/4"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=15					LinkDisplacement = Nt0-WordListLink
>9fec	10					.byte WordFlags	;wh_Flags
>9fed	03					.byte 3	;wh_CodeLength
>9fee	0f					  .byte LinkDisplacement	; offset to previous nt
=$9fef					XtPtr1 ::= *
=40811					WordListLink ::= Nt0 ; remember the nt of this word for later
.9fef	20 59 9f	jsr $9f59	EPiQ:		jsr EConstantRun
>9ff2	88 64						.word $6488		; 16 bit signed binary mantissa.  $4000 = +0.5
>9ff4	00						.char 0		; 8 bit signed exponent.  $00 = 2**0
=6					CodeLen	.var *-XtPtr1
=$9ff5					Here1 = *	; remember here
>9fed	06					.byte CodeLen	;patch wh_CodeLength
>9ff5	45 32 50 69			Name0:	.text "E2Pi"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=40825					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9ff9	24					.byte (("E2Pi"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=14					LinkDisplacement = Nt0-WordListLink
>9ffa	10					.byte WordFlags	;wh_Flags
>9ffb	03					.byte 3	;wh_CodeLength
>9ffc	0e					  .byte LinkDisplacement	; offset to previous nt
=$9ffd					XtPtr1 ::= *
=40825					WordListLink ::= Nt0 ; remember the nt of this word for later
.9ffd	20 59 9f	jsr $9f59	E2Pi:		jsr EConstantRun
>a000	88 64						.word $6488		; 16 bit signed binary mantissa.  $4000 = +0.5
>a002	03						.char 3		; 8 bit signed exponent.  $00 = 2**0
=6					CodeLen	.var *-XtPtr1
=$a003					Here1 = *	; remember here
>9ffb	06					.byte CodeLen	;patch wh_CodeLength
>a003	45 2e 45			Name0:	.text "E.E"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=40838					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>a006	a3					.byte (("E.E"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>a007	10					.byte WordFlags	;wh_Flags
>a008	03					.byte 3	;wh_CodeLength
>a009	0d					  .byte LinkDisplacement	; offset to previous nt
=$a00a					XtPtr1 ::= *
=40838					WordListLink ::= Nt0 ; remember the nt of this word for later
.a00a	20 59 9f	jsr $9f59	EE:		jsr EConstantRun
>a00d	fc 56						.word $56fc		; 16 bit signed binary mantissa.  $4000 = +0.5
>a00f	02						.char 2		; 8 bit signed exponent.  $00 = 2**0
=6					CodeLen	.var *-XtPtr1
=$a010					Here1 = *	; remember here
>a008	06					.byte CodeLen	;patch wh_CodeLength
>a010	45 56 61 6c 75 65		Name0:	.text "EValue"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=40854					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>a016	a6					.byte (("EValue"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=24					WordFlags ::= IM+NN	; modifiable copy, remember for later
=16					LinkDisplacement = Nt0-WordListLink
>a017	18					.byte WordFlags	;wh_Flags
>a018	03					.byte 3	;wh_CodeLength
>a019	10					  .byte LinkDisplacement	; offset to previous nt
=$a01a					XtPtr1 ::= *
=40854					WordListLink ::= Nt0 ; remember the nt of this word for later
.a01a	20 b2 d2	jsr $d2b2	EValue:		jsr WordHeader_Comma	; compile word header
.a01d	a9 2a		lda #$2a			lda #<EValue_runtime	; compile JSR EValue_runtime
.a01f	a0 a0		ldy #$a0			ldy #>EValue_runtime
.a021	20 25 df	jsr $df25			jsr Jsr_Comma_YA
.a024	20 6e cd	jsr $cd6e			jsr adjust_z		; fix word length
.a027	4c 84 9d	jmp $9d84			jmp EComma		; alloc & init value
=16					CodeLen	.var *-XtPtr1
=$a02a					Here1 = *	; remember here
>a018	10					.byte CodeLen	;patch wh_CodeLength
.a02a					EValue_runtime:
.a02a	4c 59 9f	jmp $9f59			jmp EConstantRun
>a02d	45 53 63 61 6c 65		Name0:	.text "EScale"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=40883					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>a033	a6					.byte (("EScale"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=29					LinkDisplacement = Nt0-WordListLink
>a034	10					.byte WordFlags	;wh_Flags
>a035	03					.byte 3	;wh_CodeLength
>a036	1d					  .byte LinkDisplacement	; offset to previous nt
=$a037					XtPtr1 ::= *
=40883					WordListLink ::= Nt0 ; remember the nt of this word for later
.a037	20 47 c5	jsr $c547	EScale:		jsr PopA		; pop n
.a03a	86 14		stx $14		EScaleA:	stx tmp1		; save data stack index
.a03c	a6 56		ldx $56				ldx FIndex		; X= FP stack index
.a03e	b4 61		ldy $61,x			ldy FSMant0,x		; mantissa zero?
.a040	f0 07		beq $a049			beq _8
.a042	18		clc				clc
.a043	75 57		adc $57,x			adc FSExp,x
.a045	95 57		sta $57,x			sta FSExp,x
.a047	70 03		bvs $a04c			bvs _overflow		; overflow or underflow?
.a049	a6 14		ldx $14		_8:		ldx tmp1		; restore data stack index
.a04b	60		rts				rts
.a04c					_overflow:
.a04c	a6 14		ldx $14				ldx tmp1		; restore data stack index
.a04e	20 e8 84	jsr $84e8			jsr Throw_FpOutOfRange
=26					CodeLen	.var *-XtPtr1
=$a051					Here1 = *	; remember here
>a035	1a					.byte CodeLen	;patch wh_CodeLength
>a051	45 32 2a			Name0:	.text "E2*"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=40916					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>a054	43					.byte (("E2*"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=33					LinkDisplacement = Nt0-WordListLink
>a055	10					.byte WordFlags	;wh_Flags
>a056	03					.byte 3	;wh_CodeLength
>a057	21					  .byte LinkDisplacement	; offset to previous nt
=$a058					XtPtr1 ::= *
=40916					WordListLink ::= Nt0 ; remember the nt of this word for later
.a058	a9 01		lda #$01	E2Star:		lda #1
.a05a	d0 de		bne $a03a			bne EScaleA
=4					CodeLen	.var *-XtPtr1
=$a05c					Here1 = *	; remember here
>a056	04					.byte CodeLen	;patch wh_CodeLength
>a05c	45 32 2f			Name0:	.text "E2/"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=40927					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>a05f	e3					.byte (("E2/"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=11					LinkDisplacement = Nt0-WordListLink
>a060	10					.byte WordFlags	;wh_Flags
>a061	03					.byte 3	;wh_CodeLength
>a062	0b					  .byte LinkDisplacement	; offset to previous nt
=$a063					XtPtr1 ::= *
=40927					WordListLink ::= Nt0 ; remember the nt of this word for later
.a063	a9 ff		lda #$ff	E2Slash:	lda #$ff
.a065	d0 d3		bne $a03a			bne EScaleA
=4					CodeLen	.var *-XtPtr1
=$a067					Here1 = *	; remember here
>a061	04					.byte CodeLen	;patch wh_CodeLength
>a067	45 31 30 2a			Name0:	.text "E10*"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=40939					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>a06b	44					.byte (("E10*"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=12					LinkDisplacement = Nt0-WordListLink
>a06c	10					.byte WordFlags	;wh_Flags
>a06d	03					.byte 3	;wh_CodeLength
>a06e	0c					  .byte LinkDisplacement	; offset to previous nt
=$a06f					XtPtr1 ::= *
=40939					WordListLink ::= Nt0 ; remember the nt of this word for later
.a06f	20 58 a0	jsr $a058	E10Star:	jsr E2Star
.a072	20 66 9c	jsr $9c66			jsr EDup
.a075	a9 02		lda #$02			lda #2
.a077	20 3a a0	jsr $a03a			jsr EScaleA
.a07a	4c cc a1	jmp $a1cc			jmp EPlus
=14					CodeLen	.var *-XtPtr1
=$a07d					Here1 = *	; remember here
>a06d	0e					.byte CodeLen	;patch wh_CodeLength
>a07d	45 46 6c 6f 6f 72		Name0:	.text "EFloor"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=40963					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>a083	46					.byte (("EFloor"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=24					LinkDisplacement = Nt0-WordListLink
>a084	10					.byte WordFlags	;wh_Flags
>a085	03					.byte 3	;wh_CodeLength
>a086	18					  .byte LinkDisplacement	; offset to previous nt
=$a087					XtPtr1 ::= *
=40963					WordListLink ::= Nt0 ; remember the nt of this word for later
.a087	a4 56		ldy $56		EFloor:		ldy FIndex
.a089	b9 61 00	lda $0061,y			lda FSMant0,y		; negative?
.a08c	10 13		bpl $a0a1			bpl _a
.a08e	b9 57 00	lda $0057,y			lda FSExp,y		; > -1 ?
.a091	10 0e		bpl $a0a1			bpl _a
.a093	a9 80		lda #$80			lda #$80		; return -1
.a095	99 61 00	sta $0061,y			sta FSMant0,y
.a098	a9 00		lda #$00			lda #0
.a09a	99 57 00	sta $0057,y			sta FSExp,y
.a09d	99 6b 00	sta $006b,y			sta FSMant1,y
.a0a0	60		rts				rts
.a0a1	a9 0f		lda #$0f	_a:		lda #16-1
.a0a3	20 b6 a0	jsr $a0b6			jsr EShiftA
.a0a6	4c 76 a1	jmp $a176			jmp ENormX
=34					CodeLen	.var *-XtPtr1
=$a0a9					Here1 = *	; remember here
>a085	22					.byte CodeLen	;patch wh_CodeLength
>a0a9	45 53 68 69 66 74		Name0:	.text "EShift"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=41007					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>a0af	86					.byte (("EShift"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=44					LinkDisplacement = Nt0-WordListLink
>a0b0	10					.byte WordFlags	;wh_Flags
>a0b1	03					.byte 3	;wh_CodeLength
>a0b2	2c					  .byte LinkDisplacement	; offset to previous nt
=$a0b3					XtPtr1 ::= *
=41007					WordListLink ::= Nt0 ; remember the nt of this word for later
.a0b3	20 47 c5	jsr $c547	EShift:		jsr PopA
.a0b6	86 14		stx $14		EShiftA:	stx tmp1+0		; save data stack index
.a0b8	a6 56		ldx $56				ldx FIndex		; X= FP stack index
.a0ba	85 15		sta $15		EShiftAX:	sta tmp1+1		; save desired alignment
.a0bc	38		sec				sec			; calc bit shift count
.a0bd	f5 57		sbc $57,x			sbc FSExp,x
.a0bf	f0 2a		beq $a0eb			beq _leave
.a0c1	70 1c		bvs $a0df			bvs _overflow
.a0c3	30 26		bmi $a0eb			bmi _leave
.a0c5	c9 10		cmp #$10			cmp #16
.a0c7	b0 18		bcs $a0e1			bcs _zero
.a0c9	a8		tay				tay
.a0ca	a5 15		lda $15				lda tmp1+1
.a0cc	95 57		sta $57,x			sta FSExp,x
.a0ce	b5 61		lda $61,x			lda FSMant0,x
.a0d0	c9 80		cmp #$80	_12:		cmp #$80		; mantissa >>=1
.a0d2	6a		ror a				ror a
.a0d3	76 6b		ror $6b,x			ror FSMant1,x
.a0d5	88		dey				dey
.a0d6	d0 f8		bne $a0d0			bne _12
.a0d8	95 61		sta $61,x			sta FSMant0,x
.a0da	b4 57		ldy $57,x	_30:		ldy FSExp,x
.a0dc	a6 56		ldx $56				ldx FIndex		; restore fp stack index (EShiftAX could have had a funny one)
.a0de	60		rts				rts
.a0df	10 0a		bpl $a0eb	_overflow:	bpl _leave
.a0e1	a5 15		lda $15		_zero:		lda tmp1+1		; return zero
.a0e3	95 57		sta $57,x			sta FSExp,x
.a0e5	a9 00		lda #$00			lda #0
.a0e7	95 61		sta $61,x			sta FSMant0,x
.a0e9	95 6b		sta $6b,x			sta FSMant1,x
.a0eb	18		clc		_leave:		clc
.a0ec	90 ec		bcc $a0da			bcc _30
>a0ee	45 54 72 75 6e 63		Name0:	.text "ETrunc"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=41076					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>a0f4	66					.byte (("ETrunc"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=69					LinkDisplacement = Nt0-WordListLink
>a0f5	10					.byte WordFlags	;wh_Flags
>a0f6	03					.byte 3	;wh_CodeLength
>a0f7	45					  .byte LinkDisplacement	; offset to previous nt
=$a0f8					XtPtr1 ::= *
=41076					WordListLink ::= Nt0 ; remember the nt of this word for later
.a0f8	a4 56		ldy $56		ETrunc:		ldy FIndex
.a0fa	b9 61 00	lda $0061,y			lda FSMant0,y
.a0fd	10 88		bpl $a087			bpl EFloor
.a0ff	20 25 a2	jsr $a225			jsr ENegate
.a102	20 87 a0	jsr $a087			jsr EFloor
.a105	4c 25 a2	jmp $a225			jmp ENegate
>a108	45 52 6f 75 6e 64		Name0:	.text "ERound"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=41102					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>a10e	86					.byte (("ERound"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=26					LinkDisplacement = Nt0-WordListLink
>a10f	10					.byte WordFlags	;wh_Flags
>a110	03					.byte 3	;wh_CodeLength
>a111	1a					  .byte LinkDisplacement	; offset to previous nt
=$a112					XtPtr1 ::= *
=41102					WordListLink ::= Nt0 ; remember the nt of this word for later
.a112	a9 0f		lda #$0f	ERound:		lda #15
.a114	20 b6 a0	jsr $a0b6			jsr EShiftA
.a117	90 05		bcc $a11e			bcc _15
.a119	a6 14		ldx $14				ldx tmp1+0		; restore data stack index
.a11b	4c f0 a1	jmp $a1f0			jmp E1Plus
.a11e	4c 76 a1	jmp $a176	_15:		jmp ENormX
=15					CodeLen	.var *-XtPtr1
=$a121					Here1 = *	; remember here
>a110	0f					.byte CodeLen	;patch wh_CodeLength
>a121	45 49 6e 74 46 72 63		Name0:	.text "EIntFrc"	;  name of word as a string, ending at wh_NameLastChar
=7					NameLength = *-Name0
=41128					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>a128	67					.byte (("EIntFrc"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=26					LinkDisplacement = Nt0-WordListLink
>a129	10					.byte WordFlags	;wh_Flags
>a12a	03					.byte 3	;wh_CodeLength
>a12b	1a					  .byte LinkDisplacement	; offset to previous nt
=$a12c					XtPtr1 ::= *
=41128					WordListLink ::= Nt0 ; remember the nt of this word for later
.a12c	20 66 9c	jsr $9c66	EIntFrc:	jsr EDup	; ( e1 e1 )
.a12f	20 87 a0	jsr $a087			jsr EFloor	; ( e1 eint )
.a132	20 f8 9c	jsr $9cf8			jsr ETuck	; ( eint e1 eint )
.a135	20 fc a1	jsr $a1fc			jsr EMinus	; ( eint efrac )
.a138	4c d0 9c	jmp $9cd0			jmp ESwap	; ( efrac eint )
=15					CodeLen	.var *-XtPtr1
=$a13b					Here1 = *	; remember here
>a12a	0f					.byte CodeLen	;patch wh_CodeLength
>a13b	45 4d 41 6c 69 67 6e 58		Name0:	.text "EMAlignX"	;  name of word as a string, ending at wh_NameLastChar
=8					NameLength = *-Name0
=41155					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>a143	08					.byte (("EMAlignX"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=27					LinkDisplacement = Nt0-WordListLink
>a144	10					.byte WordFlags	;wh_Flags
>a145	03					.byte 3	;wh_CodeLength
>a146	1b					  .byte LinkDisplacement	; offset to previous nt
=$a147					XtPtr1 ::= *
=41155					WordListLink ::= Nt0 ; remember the nt of this word for later
.a147	86 14		stx $14		EMAlignX:	stx tmp1+0	; save data stack index
.a149	a6 56		ldx $56				ldx FIndex	; load FP stack index
.a14b	e0 09		cpx #$09			cpx #FSDim-1	; check FP stack for >=2 entries
.a14d	b0 19		bcs $a168			bcs Throw_FPStack_e3
.a14f	b5 57		lda $57,x			lda FSExp+0,x	; compare exponents
.a151	38		sec				sec
.a152	f5 58		sbc $58,x			sbc FSExp+1,x
.a154	30 03		bmi $a159			bmi _1		; r1 smaller?
.a156	d0 08		bne $a160			bne _2		; r2 smaller?
.a158	60		rts				rts
.a159					_1:
.a159	70 07		bvs $a162			bvs _2b		; was this a big positive #?
.a15b	b5 58		lda $58,x	_1b:		lda FSExp+1,x	; make r1 like r2
.a15d	4c ba a0	jmp $a0ba			jmp EShiftAX
.a160					_2:
.a160	70 f7		bvs $a159			bvs _1		; was this a big negative #?
.a162	b5 57		lda $57,x	_2b:		lda FSExp+0,x	; make r2 like r1
.a164	e8		inx				inx
.a165	4c ba a0	jmp $a0ba			jmp EShiftAX
=33					CodeLen	.var *-XtPtr1
=$a168					Here1 = *	; remember here
>a145	21					.byte CodeLen	;patch wh_CodeLength
.a168	20 dd 84	jsr $84dd	Throw_FPStack_e3: jsr Throw_FPStack
>a16b	45 4e 6f 72 6d			Name0:	.text "ENorm"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=41200					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>a170	a5					.byte (("ENorm"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=45					LinkDisplacement = Nt0-WordListLink
>a171	10					.byte WordFlags	;wh_Flags
>a172	03					.byte 3	;wh_CodeLength
>a173	2d					  .byte LinkDisplacement	; offset to previous nt
=$a174					XtPtr1 ::= *
=41200					WordListLink ::= Nt0 ; remember the nt of this word for later
.a174	86 14		stx $14		ENorm:		stx tmp1+0		; save data stack index
.a176	a6 56		ldx $56		ENormX:		ldx FIndex		; switch to FP stack
.a178	b4 57		ldy $57,x			ldy FSExp,x
.a17a	b5 61		lda $61,x			lda FSMant0,x		; mantissa negative?
.a17c	30 1b		bmi $a199			bmi _Neg
.a17e	d0 05		bne $a185			bne _Pos2		; do byte shift
.a180	20 b6 a1	jsr $a1b6			jsr _ShiftB
.a183	f0 29		beq $a1ae			beq _zero		; no significant bits left?
.a185	18		clc		_Pos2:		clc
.a186	30 06		bmi $a18e			bmi _RShft
.a188	88		dey		_Pos3:		dey			; do bit shift
.a189	16 6b		asl $6b,x			asl FSMant1,x
.a18b	2a		rol a				rol a
.a18c	10 fa		bpl $a188			bpl _Pos3
.a18e					_RShft:
.a18e	c8		iny				iny
.a18f	6a		ror a				ror a
.a190	76 6b		ror $6b,x			ror FSMant1,x
.a192					_28:
.a192	95 61		sta $61,x			sta FSMant0,x
.a194	94 57		sty $57,x			sty FSExp,x	; sty dir,x exists
.a196	a6 14		ldx $14				ldx tmp1+0	; restore data stack index
.a198	60		rts				rts
.a199					_Neg:
.a199	c9 ff		cmp #$ff			cmp #$ff
.a19b	d0 03		bne $a1a0			bne _Neg2	; do byte shift
.a19d	20 b6 a1	jsr $a1b6			jsr _ShiftB
.a1a0	c9 00		cmp #$00	_Neg2:		cmp #0
.a1a2	10 ea		bpl $a18e			bpl _RShft
.a1a4	88		dey		_Neg3:		dey
.a1a5	16 6b		asl $6b,x			asl FSMant1,x
.a1a7	2a		rol a				rol a
.a1a8	30 fa		bmi $a1a4			bmi _Neg3
.a1aa	10 e2		bpl $a18e			bpl _RShft
.a1ac	68		pla		_Zerop:		pla
.a1ad	68		pla				pla		; pop rts addr from _ShiftB
.a1ae	a9 00		lda #$00	_zero:		lda #0
.a1b0	95 6b		sta $6b,x			sta FSMant1,x
.a1b2	a0 80		ldy #$80			ldy #$80
.a1b4	d0 dc		bne $a192			bne _28
.a1b6					_ShiftB:
.a1b6	98		tya				tya		; exponent -= 8
.a1b7	38		sec				sec
.a1b8	e9 08		sbc #$08			sbc #8
.a1ba	a8		tay				tay
.a1bb	70 ef		bvs $a1ac			bvs _zerop	;is this useful? do we need more of them?
.a1bd	b5 6b		lda $6b,x			lda FSMant1,x
.a1bf	48		pha				pha
.a1c0	a9 00		lda #$00			lda #0
.a1c2	95 6b		sta $6b,x			sta FSMant1,x
.a1c4	68		pla				pla
.a1c5	60		rts				rts
=82					CodeLen	.var *-XtPtr1
=$a1c6					Here1 = *	; remember here
>a172	52					.byte CodeLen	;patch wh_CodeLength
>a1c6	45 2b				Name0:	.text "E+"	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=41288					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>a1c8	62					.byte (("E+"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=88					LinkDisplacement = Nt0-WordListLink
>a1c9	10					.byte WordFlags	;wh_Flags
>a1ca	03					.byte 3	;wh_CodeLength
>a1cb	58					  .byte LinkDisplacement	; offset to previous nt
=$a1cc					XtPtr1 ::= *
=41288					WordListLink ::= Nt0 ; remember the nt of this word for later
.a1cc	20 3a 8b	jsr $8b3a	EPlus:		jsr FMAlignX	; align mantissas, X= FP stack index
.a1cf	18		clc				clc		; add mantissas
.a1d0	b5 6c		lda $6c,x			lda FSMant1+1,x
.a1d2	75 6b		adc $6b,x			adc FSMant1+0,x
.a1d4	95 6c		sta $6c,x			sta FSMant1+1,x
.a1d6	b5 62		lda $62,x			lda FSMant0+1,x
.a1d8	75 61		adc $61,x			adc FSMant0+0,x
.a1da					EPlusFin:
.a1da	e8		inx				inx		; FDrop r2
.a1db	86 56		stx $56				stx FIndex
.a1dd	50 05		bvc $a1e4	EPlusFin3:	bvc _19		; if overflow
.a1df	6a		ror a				ror a		;   shift mantissa right 1 bit
.a1e0	76 6b		ror $6b,x			ror FSMant1,x
.a1e2	f6 57		inc $57,x			inc FSExp,x	;   adjust exponent
.a1e4					_19:
.a1e4	95 61		sta $61,x			sta FSMant0,x
.a1e6	4c 76 a1	jmp $a176			jmp ENormX	; normalize, return
=29					CodeLen	.var *-XtPtr1
=$a1e9					Here1 = *	; remember here
>a1ca	1d					.byte CodeLen	;patch wh_CodeLength
>a1e9	45 31 2b			Name0:	.text "E1+"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=41324					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>a1ec	63					.byte (("E1+"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=36					LinkDisplacement = Nt0-WordListLink
>a1ed	10					.byte WordFlags	;wh_Flags
>a1ee	03					.byte 3	;wh_CodeLength
>a1ef	24					  .byte LinkDisplacement	; offset to previous nt
=$a1f0					XtPtr1 ::= *
=41324					WordListLink ::= Nt0 ; remember the nt of this word for later
.a1f0	20 b6 9f	jsr $9fb6	E1Plus:		jsr E1
.a1f3	4c cc a1	jmp $a1cc			jmp EPlus
=6					CodeLen	.var *-XtPtr1
=$a1f6					Here1 = *	; remember here
>a1ee	06					.byte CodeLen	;patch wh_CodeLength
>a1f6	45 2d				Name0:	.text "E-"	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=41336					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>a1f8	a2					.byte (("E-"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=12					LinkDisplacement = Nt0-WordListLink
>a1f9	10					.byte WordFlags	;wh_Flags
>a1fa	03					.byte 3	;wh_CodeLength
>a1fb	0c					  .byte LinkDisplacement	; offset to previous nt
=$a1fc					XtPtr1 ::= *
=41336					WordListLink ::= Nt0 ; remember the nt of this word for later
.a1fc	20 3a 8b	jsr $8b3a	EMinus:		jsr FMAlignX	; align mantissas
.a1ff	38		sec				sec		; subtract mantissas
.a200	b5 6c		lda $6c,x			lda FSMant1+1,x
.a202	f5 6b		sbc $6b,x			sbc FSMant1+0,x
.a204	95 6c		sta $6c,x			sta FSMant1+1,x
.a206	b5 62		lda $62,x			lda FSMant0+1,x
.a208	f5 61		sbc $61,x			sbc FSMant0+0,x
.a20a	4c da a1	jmp $a1da			jmp EPlusFin	; finish
=17					CodeLen	.var *-XtPtr1
=$a20d					Here1 = *	; remember here
>a1fa	11					.byte CodeLen	;patch wh_CodeLength
>a20d	45 31 2d			Name0:	.text "E1-"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=41360					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>a210	a3					.byte (("E1-"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=24					LinkDisplacement = Nt0-WordListLink
>a211	10					.byte WordFlags	;wh_Flags
>a212	03					.byte 3	;wh_CodeLength
>a213	18					  .byte LinkDisplacement	; offset to previous nt
=$a214					XtPtr1 ::= *
=41360					WordListLink ::= Nt0 ; remember the nt of this word for later
.a214	20 b6 9f	jsr $9fb6	E1Minus:	jsr E1
.a217	4c fc a1	jmp $a1fc			jmp EMinus
=6					CodeLen	.var *-XtPtr1
=$a21a					Here1 = *	; remember here
>a212	06					.byte CodeLen	;patch wh_CodeLength
>a21a	45 4e 65 67 61 74 65		Name0:	.text "ENegate"	;  name of word as a string, ending at wh_NameLastChar
=7					NameLength = *-Name0
=41377					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>a221	a7					.byte (("ENegate"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=17					LinkDisplacement = Nt0-WordListLink
>a222	10					.byte WordFlags	;wh_Flags
>a223	03					.byte 3	;wh_CodeLength
>a224	11					  .byte LinkDisplacement	; offset to previous nt
=$a225					XtPtr1 ::= *
=41377					WordListLink ::= Nt0 ; remember the nt of this word for later
.a225	86 14		stx $14		ENegate:	stx tmp1	; save data stack index
.a227	a6 56		ldx $56				ldx FIndex	; X= FP stack index
.a229	38		sec				sec		; mantissa = 0 - mantissa
.a22a	a9 00		lda #$00			lda #0
.a22c	f5 6b		sbc $6b,x			sbc FSMant1,x
.a22e	95 6b		sta $6b,x			sta FSMant1,x
.a230	a9 00		lda #$00			lda #0
.a232	f5 61		sbc $61,x			sbc FSMant0,x
.a234	4c dd a1	jmp $a1dd			jmp EPlusFin3	; finish up, return
=18					CodeLen	.var *-XtPtr1
=$a237					Here1 = *	; remember here
>a223	12					.byte CodeLen	;patch wh_CodeLength
>a237	45 41 62 73			Name0:	.text "EAbs"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=41403					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>a23b	64					.byte (("EAbs"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=26					LinkDisplacement = Nt0-WordListLink
>a23c	10					.byte WordFlags	;wh_Flags
>a23d	03					.byte 3	;wh_CodeLength
>a23e	1a					  .byte LinkDisplacement	; offset to previous nt
=$a23f					XtPtr1 ::= *
=41403					WordListLink ::= Nt0 ; remember the nt of this word for later
.a23f	a4 56		ldy $56		EAbs:		ldy FIndex
.a241	b9 61 00	lda $0061,y			lda FSMant0,y		; mantissa negative?
.a244	30 df		bmi $a225			bmi ENegate
.a246	60		rts				rts
=8					CodeLen	.var *-XtPtr1
=$a247					Here1 = *	; remember here
>a23d	08					.byte CodeLen	;patch wh_CodeLength
.a247	4c dd 84	jmp $84dd	Throw_FPStack_e4: jmp Throw_FPStack
.a24a	a4 56		ldy $56		EPos:		ldy FIndex		; load FP stack index
.a24c	c0 09		cpy #$09			cpy #FSDim-1		; check FP stack for 2
.a24e	b0 f7		bcs $a247			bcs Throw_FPStack_e4
.a250	b9 61 00	lda $0061,y			lda FSMant0+0,y		; calc result sign
.a253	59 62 00	eor $0062,y			eor FSMant0+1,y
.a256	08		php				php
.a257	b9 62 00	lda $0062,y			lda FSMant0+1,y		; if NOS negative
.a25a	10 07		bpl $a263			bpl +
.a25c	e6 56		inc $56				inc FIndex		;   point at NOS
.a25e	20 25 a2	jsr $a225			jsr ENegate		;   negate NOS
.a261	c6 56		dec $56				dec FIndex		;   restore fp
.a263					+
.a263	20 3f a2	jsr $a23f			jsr EAbs		; abs TOS
.a266	86 14		stx $14				stx tmp1+0		; save data stack index
.a268	a6 56		ldx $56				ldx FIndex		; load FP stack index
.a26a	28		plp				plp			; restore sign flag
.a26b	60		rts				rts
>a26c	46 3e 45			Name0:	.text "F>E"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=41455					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>a26f	a3					.byte (("F>E"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=0					WordFlags ::= 0	; modifiable copy, remember for later
=52					LinkDisplacement = Nt0-WordListLink
>a270	00					.byte WordFlags	;wh_Flags
>a271	03					.byte 3	;wh_CodeLength
>a272	34					  .byte LinkDisplacement	; offset to previous nt
=$a273					XtPtr1 ::= *
=41455					WordListLink ::= Nt0 ; remember the nt of this word for later
.a273					FToE:
=0					CodeLen	.var *-XtPtr1
=$a273					Here1 = *	; remember here
>a271	00					.byte CodeLen	;patch wh_CodeLength
.a273	60		rts				rts
>a274	45 3e 46			Name0:	.text "E>F"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=41463					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>a277	c3					.byte (("E>F"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=0					WordFlags ::= 0	; modifiable copy, remember for later
=8					LinkDisplacement = Nt0-WordListLink
>a278	00					.byte WordFlags	;wh_Flags
>a279	03					.byte 3	;wh_CodeLength
>a27a	08					  .byte LinkDisplacement	; offset to previous nt
=$a27b					XtPtr1 ::= *
=41463					WordListLink ::= Nt0 ; remember the nt of this word for later
.a27b	a4 56		ldy $56		EToF:		ldy FIndex
.a27d	a9 00		lda #$00			lda #0			; zero 2nd 16 bits of mantissa
.a27f	99 75 00	sta $0075,y			sta FSMant2,y
.a282	99 7f 00	sta $007f,y			sta FSMant3,y
=10					CodeLen	.var *-XtPtr1
=$a285					Here1 = *	; remember here
>a279	0a					.byte CodeLen	;patch wh_CodeLength
.a285	60		rts				rts
>a286	53 3e 45			Name0:	.text "S>E"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=41481					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>a289	a3					.byte (("S>E"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=18					LinkDisplacement = Nt0-WordListLink
>a28a	10					.byte WordFlags	;wh_Flags
>a28b	03					.byte 3	;wh_CodeLength
>a28c	12					  .byte LinkDisplacement	; offset to previous nt
=$a28d					XtPtr1 ::= *
=41481					WordListLink ::= Nt0 ; remember the nt of this word for later
.a28d	20 62 c5	jsr $c562	SToE:		jsr PopYA		; pop n
.a290	20 d4 84	jsr $84d4	SToEYA:		jsr FAllocX		; alloc FP stack entry
.a293	95 6b		sta $6b,x			sta FSMant1,x		; copy n to mantissa
.a295	94 61		sty $61,x			sty FSMant0,x	; sty dir,x exists
.a297	a9 0f		lda #$0f			lda #15			; set exponent
.a299	95 57		sta $57,x			sta FSExp,x
.a29b	4c 76 a1	jmp $a176			jmp ENormX		; normalize, return
=17					CodeLen	.var *-XtPtr1
=$a29e					Here1 = *	; remember here
>a28b	11					.byte CodeLen	;patch wh_CodeLength
>a29e	45 3e 53			Name0:	.text "E>S"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=41505					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>a2a1	63					.byte (("E>S"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=24					LinkDisplacement = Nt0-WordListLink
>a2a2	10					.byte WordFlags	;wh_Flags
>a2a3	03					.byte 3	;wh_CodeLength
>a2a4	18					  .byte LinkDisplacement	; offset to previous nt
=$a2a5					XtPtr1 ::= *
=41505					WordListLink ::= Nt0 ; remember the nt of this word for later
.a2a5	a4 56		ldy $56		EToS:		ldy FIndex
.a2a7	b9 61 00	lda $0061,y			lda FSMant0,y		; save sign
.a2aa	08		php				php
.a2ab	10 03		bpl $a2b0			bpl +
.a2ad	20 25 a2	jsr $a225			jsr ENegate
.a2b0					+
.a2b0	a9 0f		lda #$0f			lda #15
.a2b2	20 b6 a0	jsr $a0b6			jsr EShiftA
.a2b5	a6 14		ldx $14				ldx tmp1+0		; restore data stack index
.a2b7	c0 10		cpy #$10			cpy #15+1		; always positive, so unsigned compare works
.a2b9	b0 17		bcs $a2d2			bcs _overflow
.a2bb	a4 56		ldy $56				ldy FIndex
.a2bd	ca		dex				dex
.a2be	ca		dex				dex
.a2bf	b9 61 00	lda $0061,y			lda FSMant0,y
.a2c2	95 27		sta $27,x			sta DStack+1,x
.a2c4	b9 6b 00	lda $006b,y			lda FSMant1,y
.a2c7	95 26		sta $26,x			sta DStack+0,x
.a2c9	e6 56		inc $56				inc FIndex		; EDrop
.a2cb	28		plp				plp			; apply saved sign
.a2cc	30 01		bmi $a2cf			bmi +
.a2ce	60		rts				rts
.a2cf	4c 7b d8	jmp $d87b	+		jmp Negate
.a2d2	28		plp		_overflow:	plp			; RDrop saved sign
.a2d3	a9 f5		lda #$f5			lda #$100+err_OutOfRange
.a2d5	20 dc c5	jsr $c5dc			jsr ThrowA
=51					CodeLen	.var *-XtPtr1
=$a2d8					Here1 = *	; remember here
>a2a3	33					.byte CodeLen	;patch wh_CodeLength
>a2d8	45 52 6e 64			Name0:	.text "ERnd"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=41564					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>a2dc	84					.byte (("ERnd"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=59					LinkDisplacement = Nt0-WordListLink
>a2dd	10					.byte WordFlags	;wh_Flags
>a2de	03					.byte 3	;wh_CodeLength
>a2df	3b					  .byte LinkDisplacement	; offset to previous nt
=$a2e0					XtPtr1 ::= *
=41564					WordListLink ::= Nt0 ; remember the nt of this word for later
.a2e0	20 f7 82	jsr $82f7	ERnd:		jsr Rand		; generate next RndState
.a2e3	20 d4 84	jsr $84d4			jsr FAllocX		; alloc FP stack entry
.a2e6	4a		lsr a				lsr a			;   make positive
.a2e7	95 61		sta $61,x			sta FSMant0,x
.a2e9	94 6b		sty $6b,x			sty FSMant1,x	; sty dir,x exists
.a2eb	a9 00		lda #$00			lda #0			; exponent=0
.a2ed	95 57		sta $57,x			sta FSExp,x
.a2ef	4c 76 a1	jmp $a176			jmp ENormX		; normalize, return
=18					CodeLen	.var *-XtPtr1
=$a2f2					Here1 = *	; remember here
>a2de	12					.byte CodeLen	;patch wh_CodeLength
>a2f2	45 53 71 72 74			Name0:	.text "ESqrt"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=41591					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>a2f7	85					.byte (("ESqrt"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=27					LinkDisplacement = Nt0-WordListLink
>a2f8	10					.byte WordFlags	;wh_Flags
>a2f9	03					.byte 3	;wh_CodeLength
>a2fa	1b					  .byte LinkDisplacement	; offset to previous nt
=$a2fb					XtPtr1 ::= *
=41591					WordListLink ::= Nt0 ; remember the nt of this word for later
.a2fb	a4 56		ldy $56		ESqrt:		ldy FIndex
.a2fd	b9 61 00	lda $0061,y			lda FSMant0,y		; zero?
.a300	d0 01		bne $a303			bne +
.a302	60		rts				rts			;   just return the zero
.a303					+
.a303	20 66 9c	jsr $9c66			jsr EDup		; get trial value
.a306	a4 56		ldy $56				ldy FIndex
.a308	b9 57 00	lda $0057,y			lda FSExp,y		; halve the exponent of trial value
.a30b	c9 80		cmp #$80			cmp #$80
.a30d	6a		ror a				ror a
.a30e	99 57 00	sta $0057,y			sta FSExp,y
.a311	a9 09		lda #$09			lda #9			; for 9 iterations
.a313	48		pha		_3:		pha
.a314	20 c1 9c	jsr $9cc1			jsr E2Dup		;   calc new trial value
.a317	20 d9 8e	jsr $8ed9			jsr ESlash
.a31a	20 cc a1	jsr $a1cc			jsr EPlus
.a31d	20 63 a0	jsr $a063			jsr E2Slash
.a320	68		pla				pla			;  next
.a321	38		sec				sec
.a322	e9 01		sbc #$01			sbc #1
.a324	d0 ed		bne $a313			bne _3
.a326	4c 49 9c	jmp $9c49			jmp ENip		; return trial value
=46					CodeLen	.var *-XtPtr1
=$a329					Here1 = *	; remember here
>a2f9	2e					.byte CodeLen	;patch wh_CodeLength
>a329	28 45 2e 29			Name0:	.text "(E.)"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=41645					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>a32d	24					.byte (("(E.)"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=54					LinkDisplacement = Nt0-WordListLink
>a32e	10					.byte WordFlags	;wh_Flags
>a32f	03					.byte 3	;wh_CodeLength
>a330	36					  .byte LinkDisplacement	; offset to previous nt
=$a331					XtPtr1 ::= *
=41645					WordListLink ::= Nt0 ; remember the nt of this word for later
.a331	20 ae a3	jsr $a3ae	PEDot:		jsr pecstart		;start collecting chars, make r positive
.a334	20 3a a3	jsr $a33a			jsr PEDotSub
.a337	4c 54 91	jmp $9154			jmp pfcend
.a33a					PEDotSub:
.a33a	20 8b 90	jsr $908b			jsr Precision	;alloc & init work area
.a33d	20 74 c9	jsr $c974			jsr One
=$29					_mantNzFound  = DStack+3	; nonzero mantissa digit processed
=$28					_NumSigDigits = DStack+2	; # of significant digits
=$26					_decimalPos   = DStack+0	; decimal point position
.a340	20 8e a3	jsr $a38e			jsr ELt10		; scale down to <10, counting exponent
.a343					_c:
.a343	b5 26		lda $26,x			lda _decimalPos,x	;  insert decimal point here?
.a345	d0 05		bne $a34c			bne _c2
.a347	a9 2e		lda #$2e			lda #'.'
.a349	20 4b 91	jsr $914b			jsr pfchar
.a34c	d6 26		dec $26,x	_c2:		dec _decimalPos,x
.a34e	20 66 9c	jsr $9c66			jsr EDup		;  do a digit
.a351	20 a5 a2	jsr $a2a5			jsr EToS		; ( work n )
.a354	b5 26		lda $26,x			lda DStack+0,x
.a356	15 2b		ora $2b,x			ora _mantNzFound+2,x	;  doing significant digits?
.a358	95 2b		sta $2b,x			sta _mantNzFound+2,x
.a35a	f0 08		beq $a364			beq _c7
.a35c	d6 2a		dec $2a,x			dec _NumSigDigits+2,x
.a35e	10 04		bpl $a364			bpl _c7
.a360	e8		inx				inx			;    drop integer
.a361	e8		inx				inx
.a362	d0 17		bne $a37b			bne _d
.a364	b5 26		lda $26,x	_c7:		lda DStack+0,x		;  store the char
.a366	09 30		ora #$30			ora #'0'
.a368	20 4b 91	jsr $914b			jsr pfchar
.a36b	20 8d a2	jsr $a28d			jsr SToE		; ( work )
.a36e	20 fc a1	jsr $a1fc			jsr EMinus
.a371	20 6f a0	jsr $a06f			jsr E10Star
.a374	a4 56		ldy $56				ldy FIndex		;  until mantissa==0
.a376	b9 61 00	lda $0061,y			lda FSMant0,y
.a379	d0 c8		bne $a343			bne _c
.a37b	d6 26		dec $26,x	_d:		dec _decimalPos,x	;do trailing zeros
.a37d	30 08		bmi $a387			bmi _d9
.a37f	a9 30		lda #$30			lda #'0'
.a381	20 4b 91	jsr $914b			jsr pfchar
.a384	4c 7b a3	jmp $a37b			jmp _d
.a387	e8		inx		_d9:		inx			; drop work area
.a388	e8		inx				inx
.a389	e8		inx				inx
.a38a	e8		inx				inx
.a38b	e6 56		inc $56				inc FIndex		; FDrop
.a38d	60		rts				rts
=93					CodeLen	.var *-XtPtr1
=$a38e					Here1 = *	; remember here
>a32f	5d					.byte CodeLen	;patch wh_CodeLength
.a38e					ELt10:
.a38e	a4 56		ldy $56		_1:		ldy FIndex		; while e1 >= 10
.a390	b9 57 00	lda $0057,y			lda FSExp,y
.a393	30 18		bmi $a3ad			bmi _9			;   exponent negative?
.a395	c9 04		cmp #$04			cmp #4
.a397	90 14		bcc $a3ad			bcc _9			;   < 4 ?
.a399	d0 07		bne $a3a2			bne _2			;   > 4 ?
.a39b	b9 61 00	lda $0061,y			lda FSMant0,y		;   mantissa >= 10 ?
.a39e	c9 50		cmp #$50			cmp #$50
.a3a0	90 0b		bcc $a3ad			bcc _9
.a3a2	f6 26		inc $26,x	_2:		inc DStack+0,x		;   exp ++
.a3a4	20 9a 9f	jsr $9f9a			jsr E10			;   e /= 10
.a3a7	20 d9 8e	jsr $8ed9			jsr ESlash
.a3aa	4c 8e a3	jmp $a38e			jmp _1
.a3ad	60		rts		_9:		rts
.a3ae					pecstart:
.a3ae	a9 01		lda #$01			lda #1
.a3b0	8d 34 03	sta $0334			sta ToHold
.a3b3	a4 56		ldy $56				ldy FIndex		; if e1 negative
.a3b5	b9 61 00	lda $0061,y			lda FSMant0,y
.a3b8	10 08		bpl $a3c2			bpl _19
.a3ba	a9 2d		lda #$2d			lda #'-'		;   append sign
.a3bc	20 4b 91	jsr $914b			jsr pfchar
.a3bf	4c 25 a2	jmp $a225			jmp ENegate		;   make positive, return
.a3c2	60		rts		_19:		rts
>a3c3	45 2e				Name0:	.text "E."	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=41797					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>a3c5	c2					.byte (("E."[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=152					LinkDisplacement = Nt0-WordListLink
>a3c6	10					.byte WordFlags	;wh_Flags
>a3c7	03					.byte 3	;wh_CodeLength
>a3c8	98					  .byte LinkDisplacement	; offset to previous nt
=$a3c9					XtPtr1 ::= *
=41797					WordListLink ::= Nt0 ; remember the nt of this word for later
.a3c9	20 31 a3	jsr $a331	EDot:		jsr PEDot
.a3cc	20 5b c3	jsr $c35b	EDot2:		jsr Count
.a3cf	20 f1 df	jsr $dff1			jsr Type
.a3d2	4c e5 df	jmp $dfe5			jmp Space
=12					CodeLen	.var *-XtPtr1
=$a3d5					Here1 = *	; remember here
>a3c7	0c					.byte CodeLen	;patch wh_CodeLength
>a3d5	45 2e 53			Name0:	.text "E.S"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=41816					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>a3d8	63					.byte (("E.S"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=19					LinkDisplacement = Nt0-WordListLink
>a3d9	10					.byte WordFlags	;wh_Flags
>a3da	03					.byte 3	;wh_CodeLength
>a3db	13					  .byte LinkDisplacement	; offset to previous nt
=$a3dc					XtPtr1 ::= *
=41816					WordListLink ::= Nt0 ; remember the nt of this word for later
.a3dc	a9 09		lda #$09	EDotS:		lda #FSDim-1	; for each FP stack entry
.a3de	d0 0b		bne $a3eb			bne _8
.a3e0	48		pha		_2:		pha
.a3e1	20 a2 9c	jsr $9ca2			jsr EPick3	;   print it
.a3e4	20 c9 a3	jsr $a3c9			jsr EDot
.a3e7	68		pla				pla		;  next
.a3e8	38		sec				sec
.a3e9	e9 01		sbc #$01			sbc #1
.a3eb	c5 56		cmp $56		_8:		cmp FIndex
.a3ed	b0 f1		bcs $a3e0			bcs _2
=19					CodeLen	.var *-XtPtr1
=$a3ef					Here1 = *	; remember here
>a3da	13					.byte CodeLen	;patch wh_CodeLength
.a3ef	60		rts				rts
>a3f0	28 45 53 2e 29			Name0:	.text "(ES.)"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=41845					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>a3f5	25					.byte (("(ES.)"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=29					LinkDisplacement = Nt0-WordListLink
>a3f6	10					.byte WordFlags	;wh_Flags
>a3f7	03					.byte 3	;wh_CodeLength
>a3f8	1d					  .byte LinkDisplacement	; offset to previous nt
=$a3f9					XtPtr1 ::= *
=41845					WordListLink ::= Nt0 ; remember the nt of this word for later
.a3f9	20 6b c9	jsr $c96b	PESDot:		jsr Zero		; alloc work area
=$26					_exp    = DStack+0
.a3fc	20 ae a3	jsr $a3ae			jsr pecstart		; start collecting chars, make r positive
.a3ff	20 8e a3	jsr $a38e			jsr ELt10		; scale down to <10
.a402	a4 56		ldy $56		_c1:		ldy FIndex		; while r < 1
.a404	b9 61 00	lda $0061,y			lda FSMant0,y		;   mantissa == 0 ?
.a407	f0 0f		beq $a418			beq _c9
.a409	b9 57 00	lda $0057,y			lda FSExp,y		;   exp < 1 ?
.a40c	f0 02		beq $a410			beq _c2
.a40e	10 08		bpl $a418			bpl _c9
.a410	d6 26		dec $26,x	_c2:		dec DStack+0,x		;  exp -= 1
.a412	20 6f a0	jsr $a06f			jsr E10Star		;  r *= 10
.a415	4c 02 a4	jmp $a402			jmp _c1
.a418					_c9:
.a418	20 3a a3	jsr $a33a	PESDotM:	jsr PEDotSub		; do mantissa
.a41b	a9 45		lda #$45			lda #'E'
.a41d	20 4b 91	jsr $914b			jsr pfchar		; do exponent
.a420	b5 26		lda $26,x			lda DStack+0,x		;   _exp
.a422	20 61 91	jsr $9161			jsr pfciA
.a425	e8		inx				inx			; Drop work area
.a426	e8		inx				inx
.a427	4c 54 91	jmp $9154			jmp pfcend		; finish string
=49					CodeLen	.var *-XtPtr1
=$a42a					Here1 = *	; remember here
>a3f7	31					.byte CodeLen	;patch wh_CodeLength
>a42a	45 53 2e			Name0:	.text "ES."	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=41901					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>a42d	c3					.byte (("ES."[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=56					LinkDisplacement = Nt0-WordListLink
>a42e	10					.byte WordFlags	;wh_Flags
>a42f	03					.byte 3	;wh_CodeLength
>a430	38					  .byte LinkDisplacement	; offset to previous nt
=$a431					XtPtr1 ::= *
=41901					WordListLink ::= Nt0 ; remember the nt of this word for later
.a431	20 f9 a3	jsr $a3f9	ESDot:		jsr PESDot
.a434	4c cc a3	jmp $a3cc			jmp EDot2
=6					CodeLen	.var *-XtPtr1
=$a437					Here1 = *	; remember here
>a42f	06					.byte CodeLen	;patch wh_CodeLength
>a437	28 45 45 2e 29			Name0:	.text "(EE.)"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=41916					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>a43c	25					.byte (("(EE.)"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=15					LinkDisplacement = Nt0-WordListLink
>a43d	10					.byte WordFlags	;wh_Flags
>a43e	03					.byte 3	;wh_CodeLength
>a43f	0f					  .byte LinkDisplacement	; offset to previous nt
=$a440					XtPtr1 ::= *
=41916					WordListLink ::= Nt0 ; remember the nt of this word for later
.a440	20 6b c9	jsr $c96b	PEEDot:		jsr Zero		; alloc work area
=$26					_exp    = DStack+0
.a443	20 ae a3	jsr $a3ae			jsr pecstart		; start collecting chars, make r positive
.a446	a4 56		ldy $56		_30:		ldy FIndex		; while r < 1
.a448	b9 61 00	lda $0061,y			lda FSMant0,y
.a44b	f0 16		beq $a463			beq _39
.a44d	b9 57 00	lda $0057,y			lda FSExp,y
.a450	f0 02		beq $a454			beq _31
.a452	10 0f		bpl $a463			bpl _39
.a454	d6 26		dec $26,x	_31:		dec _exp,x		;  exp -= 3
.a456	d6 26		dec $26,x			dec _exp,x
.a458	d6 26		dec $26,x			dec _exp,x
.a45a	20 8b 9f	jsr $9f8b			jsr E1000		;  r *= 1000
.a45d	20 5c 8e	jsr $8e5c			jsr EStar
.a460	4c 46 a4	jmp $a446			jmp _30
.a463					_39:
.a463	a4 56		ldy $56		_a:		ldy FIndex		; while r >= 1000
.a465	b9 57 00	lda $0057,y			lda FSExp,y
.a468	30 1c		bmi $a486			bmi _a9			; exponent negative?
.a46a	c9 0a		cmp #$0a			cmp #10
.a46c	90 18		bcc $a486			bcc _a9			;   < 10 ?
.a46e	d0 07		bne $a477			bne _a2			;   > 10 ?
.a470	b9 61 00	lda $0061,y			lda FSMant0,y
.a473	c9 7d		cmp #$7d			cmp #$7d
.a475	90 0f		bcc $a486			bcc _a9
.a477	f6 26		inc $26,x	_a2:		inc _exp,x		;   exp += 3
.a479	f6 26		inc $26,x			inc _exp,x
.a47b	f6 26		inc $26,x			inc _exp,x
.a47d	20 8b 9f	jsr $9f8b			jsr E1000		;   r /= 1000
.a480	20 d9 8e	jsr $8ed9			jsr ESlash
.a483	4c 63 a4	jmp $a463			jmp _a
.a486					_a9:
.a486	4c 18 a4	jmp $a418			jmp PESDotM
=73					CodeLen	.var *-XtPtr1
=$a489					Here1 = *	; remember here
>a43e	49					.byte CodeLen	;patch wh_CodeLength
>a489	45 45 2e			Name0:	.text "EE."	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=41996					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>a48c	c3					.byte (("EE."[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=80					LinkDisplacement = Nt0-WordListLink
>a48d	10					.byte WordFlags	;wh_Flags
>a48e	03					.byte 3	;wh_CodeLength
>a48f	50					  .byte LinkDisplacement	; offset to previous nt
=$a490					XtPtr1 ::= *
=41996					WordListLink ::= Nt0 ; remember the nt of this word for later
.a490	20 40 a4	jsr $a440	EEDot:		jsr PEEDot
.a493	4c cc a3	jmp $a3cc			jmp EDot2
=6					CodeLen	.var *-XtPtr1
=$a496					Here1 = *	; remember here
>a48e	06					.byte CodeLen	;patch wh_CodeLength
>a496	45 27				Name0:	.text "E'"	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=42008					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>a498	e2					.byte (("E'"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=24					WordFlags ::= IM+NN	; modifiable copy, remember for later
=12					LinkDisplacement = Nt0-WordListLink
>a499	18					.byte WordFlags	;wh_Flags
>a49a	03					.byte 3	;wh_CodeLength
>a49b	0c					  .byte LinkDisplacement	; offset to previous nt
=$a49c					XtPtr1 ::= *
=42008					WordListLink ::= Nt0 ; remember the nt of this word for later
.a49c	20 15 cc	jsr $cc15	EQuote:		jsr Parse_Name		; get string
.a49f	20 c0 a4	jsr $a4c0			jsr ToEFloat		; convert
.a4a2	b5 26		lda $26,x			lda DStack+0,x		; error?
.a4a4	f0 0a		beq $a4b0			beq _Err
.a4a6	e8		inx				inx
.a4a7	e8		inx				inx
.a4a8	a5 0a		lda $0a				lda State		; compiling?
.a4aa	d0 01		bne $a4ad			bne _compile
.a4ac	60		rts				rts
.a4ad	4c e2 9e	jmp $9ee2	_compile:	jmp ELiteral		; compile a FP literal
.a4b0	a9 36		lda #$36	_Err:		lda #100+err_FPInvalidArg
.a4b2	20 dc c5	jsr $c5dc			jsr ThrowA
=25					CodeLen	.var *-XtPtr1
=$a4b5					Here1 = *	; remember here
>a49a	19					.byte CodeLen	;patch wh_CodeLength
>a4b5	3e 45 46 6c 6f 61 74		Name0:	.text ">EFloat"	;  name of word as a string, ending at wh_NameLastChar
=7					NameLength = *-Name0
=42044					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>a4bc	87					.byte ((">EFloat"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=36					LinkDisplacement = Nt0-WordListLink
>a4bd	10					.byte WordFlags	;wh_Flags
>a4be	03					.byte 3	;wh_CodeLength
>a4bf	24					  .byte LinkDisplacement	; offset to previous nt
=$a4c0					XtPtr1 ::= *
=42044					WordListLink ::= Nt0 ; remember the nt of this word for later
.a4c0					ToEFloat:
.a4c0	20 6b c9	jsr $c96b			jsr Zero	; alloc & init workspace
.a4c3	20 6b c9	jsr $c96b			jsr Zero
.a4c6	20 6b c9	jsr $c96b			jsr Zero
=$2e					_addr		= DStack+8
=$2c					_len		= DStack+6
=$2b					_mantfound 	= DStack+5		;mantissa digits found
=$2a					_exponent 	= DStack+4		;exponent
=$29					_decimalPos 	= DStack+3		;decimal point position
=$28					_DecPointFound1 = DStack+2
=$27					_MantissaNegative1 = DStack+1
=$26					_ExponentNegative1 = DStack+0
.a4c9	20 7a 9f	jsr $9f7a			jsr E0			; init result
.a4cc	20 9d a5	jsr $a59d	_11:		jsr _GetChar		; get mantissa prefix
.a4cf	b0 56		bcs $a527			bcs _trueb ;_finishb
.a4d1	c9 20		cmp #$20			cmp #' '
.a4d3	f0 f7		beq $a4cc			beq _11
.a4d5	c9 2b		cmp #$2b			cmp #'+'
.a4d7	f0 06		beq $a4df			beq _20
.a4d9	c9 2d		cmp #$2d			cmp #'-'
.a4db	d0 07		bne $a4e4			bne _21
.a4dd	95 27		sta $27,x			sta _MantissaNegative1,x ; remember mantissa is negative
.a4df	20 9d a5	jsr $a59d	_20:		jsr _GetChar		; do next mantissa digits
.a4e2	b0 46		bcs $a52a			bcs _finishb
.a4e4	c9 2e		cmp #$2e	_21:		cmp #'.'
.a4e6	f0 31		beq $a519			beq _27
.a4e8	c9 45		cmp #$45			cmp #'E'
.a4ea	f0 41		beq $a52d			beq _30
.a4ec	c9 65		cmp #$65			cmp #'e'
.a4ee	f0 3d		beq $a52d			beq _30
.a4f0	c9 44		cmp #$44			cmp #'D'
.a4f2	f0 39		beq $a52d			beq _30
.a4f4	c9 64		cmp #$64			cmp #'d'
.a4f6	f0 35		beq $a52d			beq _30
.a4f8	38		sec				sec			;   a digit?
.a4f9	e9 30		sbc #$30			sbc #'0'
.a4fb	90 24		bcc $a521			bcc _fail
.a4fd	c9 0a		cmp #$0a			cmp #9+1
.a4ff	b0 20		bcs $a521			bcs _fail
.a501	48		pha				pha			; append digit to mantissa
.a502	20 6f a0	jsr $a06f			jsr E10Star
.a505	68		pla				pla
.a506	a0 00		ldy #$00			ldy #0
.a508	20 90 a2	jsr $a290			jsr SToEYA
.a50b	20 cc a1	jsr $a1cc			jsr EPlus
.a50e	f6 2b		inc $2b,x			inc _mantfound,x	; remember we found a mantissa digit
.a510	b5 28		lda $28,x			lda _DecPointFound1,x	; if mantissa decimal point found
.a512	f0 02		beq $a516			beq +
.a514	d6 29		dec $29,x			dec _decimalPos,x	;   increment decimal point position
.a516					+
.a516	4c df a4	jmp $a4df			jmp _20
.a519					_27:
.a519	b4 28		ldy $28,x			ldy _DecPointFound1,x	; already have one?
.a51b	d0 04		bne $a521			bne _fail
.a51d	95 28		sta $28,x			sta _DecPointFound1,x	; we have one now!
.a51f	f0 be		beq $a4df			beq _20
.a521					_fail:
.a521	e6 56		inc $56				inc FIndex		; EDrop
.a523	a9 00		lda #$00			lda #0			;return false
.a525	f0 69		beq $a590			beq _return
.a527	4c 8e a5	jmp $a58e	_trueb:		jmp _true
.a52a	4c 5b a5	jmp $a55b	_finishb:	jmp _finish
.a52d					_30:
.a52d	20 9d a5	jsr $a59d			jsr _GetChar
.a530	b0 29		bcs $a55b			bcs _finish
.a532	c9 2b		cmp #$2b			cmp #'+'
.a534	f0 06		beq $a53c			beq _40
.a536	c9 2d		cmp #$2d			cmp #'-'
.a538	d0 07		bne $a541			bne _41
.a53a	95 26		sta $26,x			sta _ExponentNegative1,x ; remember exponent is negative
.a53c	20 9d a5	jsr $a59d	_40:		jsr _GetChar		;get exponent digits
.a53f	b0 1a		bcs $a55b			bcs _finish
.a541	38		sec		_41:		sec			;  digit?
.a542	e9 30		sbc #$30			sbc #'0'
.a544	90 db		bcc $a521			bcc _fail
.a546	c9 0a		cmp #$0a			cmp #9+1
.a548	b0 d7		bcs $a521			bcs _fail
.a54a	85 14		sta $14				sta tmp1
.a54c	16 2a		asl $2a,x			asl _exponent,x		;  exponent *= 10
.a54e	b5 2a		lda $2a,x			lda _exponent,x
.a550	0a		asl a				asl a
.a551	0a		asl a				asl a
.a552	75 2a		adc $2a,x			adc _exponent,x
.a554	65 14		adc $14				adc tmp1		;  + digit
.a556	95 2a		sta $2a,x			sta _exponent,x
.a558	4c 3c a5	jmp $a53c			jmp _40
.a55b					_finish:
.a55b	b5 2b		lda $2b,x			lda _mantfound,x	;some mantissa digits found?
.a55d	f0 c2		beq $a521			beq _fail
.a55f	b5 26		lda $26,x			lda _ExponentNegative1,x ;apply exponent sign
.a561	f0 07		beq $a56a			beq +
.a563	a9 00		lda #$00			lda #0
.a565	38		sec				sec
.a566	f5 2a		sbc $2a,x			sbc _exponent,x
.a568	95 2a		sta $2a,x			sta _exponent,x
.a56a					+
.a56a	b5 2a		lda $2a,x			lda _exponent,x		;apply decimal position to exponent
.a56c	18		clc				clc
.a56d	75 29		adc $29,x			adc _decimalPos,x
.a56f	95 2a		sta $2a,x			sta _exponent,x
.a571	4c 79 a5	jmp $a579			jmp _93
.a574	20 6f a0	jsr $a06f	_93b:		jsr E10Star		;apply exponent to mantissa
.a577	d6 2a		dec $2a,x			dec _exponent,x
.a579	f0 0a		beq $a585	_93:		beq _94
.a57b	10 f7		bpl $a574			bpl _93b
.a57d	20 9a 9f	jsr $9f9a	_94b:		jsr E10
.a580	20 d9 8e	jsr $8ed9			jsr ESlash
.a583	f6 2a		inc $2a,x			inc _exponent,x
.a585	30 f6		bmi $a57d	_94:		bmi _94b
.a587					_95:
.a587	b5 27		lda $27,x			lda _MantissaNegative1,x ;apply mantissa sign
.a589	f0 03		beq $a58e			beq +
.a58b	20 25 a2	jsr $a225			jsr ENegate
.a58e					+
.a58e	a9 ff		lda #$ff	_true:		lda #$ff		;return true
.a590					_return:
.a590	95 2e		sta $2e,x			sta _addr+0,x		; replace _addr with flag
.a592	95 2f		sta $2f,x			sta _addr+1,x
.a594	e8		inx				inx			; Drop work
.a595	e8		inx				inx
.a596	e8		inx				inx			; 2Drop work
.a597	e8		inx				inx
.a598	e8		inx				inx
.a599	e8		inx				inx
.a59a	e8		inx				inx			; Drop len
.a59b	e8		inx				inx
.a59c	60		rts				rts
.a59d					_GetChar:
.a59d	38		sec				sec
.a59e	b5 2c		lda $2c,x			lda _len,x
.a5a0	f0 0b		beq $a5ad			beq _gc_rts		; if end, return C=1
.a5a2	d6 2c		dec $2c,x			dec _len,x
.a5a4	a1 2e		lda ($2e,x)			lda (_addr,x)
.a5a6	f6 2e		inc $2e,x			inc _addr+0,x
.a5a8	d0 02		bne $a5ac			bne +
.a5aa	f6 2f		inc $2f,x			inc _addr+1,x
.a5ac					+
.a5ac	18		clc				clc			; get char, return C=0
.a5ad	60		rts		_gc_rts:	rts
>a5ae	45 4b 65 79			Name0:	.text "EKey"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=42290					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>a5b2	24					.byte (("EKey"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=246					LinkDisplacement = Nt0-WordListLink
>a5b3	10					.byte WordFlags	;wh_Flags
>a5b4	03					.byte 3	;wh_CodeLength
>a5b5	f6					  .byte LinkDisplacement	; offset to previous nt
=$a5b6					XtPtr1 ::= *
=42290					WordListLink ::= Nt0 ; remember the nt of this word for later
.a5b6					EKey:
.a5b6	20 04 dc	jsr $dc04			jsr Here		; ( addr )
.a5b9	20 04 dc	jsr $dc04			jsr Here		; ( addr addr )
.a5bc	a9 28		lda #$28			lda #40			; ( addr addr 40 )
.a5be	20 5d c9	jsr $c95d			jsr PushZA
.a5c1	20 70 d4	jsr $d470			jsr Accept		; ( addr len )
.a5c4	20 c0 a4	jsr $a4c0			jsr ToEFloat		; ( true | false)
.a5c7	e8		inx				inx			; err?
.a5c8	e8		inx				inx
.a5c9	b5 24		lda $24,x			lda DStack-2,x
.a5cb	f0 01		beq $a5ce			beq _err
.a5cd	60		rts				rts
.a5ce	20 4b ca	jsr $ca4b	_err:		jsr SLiteral_runtime
.a5d1	4c d7 a5	jmp $a5d7			  jmp +
>a5d4	20 3f 20					  .text " ? "
.a5d7	20 f1 df	jsr $dff1	+		jsr Type
.a5da	4c b6 a5	jmp $a5b6			jmp EKey
>a5dd	45 4d 50 6f 6c 79		Name0:	.text "EMPoly"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=42339					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>a5e3	26					.byte (("EMPoly"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=49					LinkDisplacement = Nt0-WordListLink
>a5e4	10					.byte WordFlags	;wh_Flags
>a5e5	03					.byte 3	;wh_CodeLength
>a5e6	31					  .byte LinkDisplacement	; offset to previous nt
=$a5e7					XtPtr1 ::= *
=42339					WordListLink ::= Nt0 ; remember the nt of this word for later
.a5e7	20 62 c5	jsr $c562	EMPoly:		jsr PopYA
.a5ea	20 2e c9	jsr $c92e	EMPolyYA:	jsr PushYA		; push coefficent addr
.a5ed	20 3e 9d	jsr $9d3e			jsr EAt_YA		; fetch 1st coefficent
.a5f0	4c 03 a6	jmp $a603			jmp _4
.a5f3	20 81 9c	jsr $9c81	_2:		jsr EOver
.a5f6	20 5c 8e	jsr $8e5c			jsr EStar
.a5f9	b5 26		lda $26,x			lda DStack+0,x		; fetch next coefficent
.a5fb	b4 27		ldy $27,x			ldy DStack+1,x
.a5fd	20 3e 9d	jsr $9d3e			jsr EAt_YA
.a600	20 cc a1	jsr $a1cc			jsr EPlus
.a603	a9 03		lda #$03	_4:		lda #EFloat_Size	; bump coefficent ptr
.a605	20 da db	jsr $dbda			jsr Plus_A
.a608	a1 26		lda ($26,x)			lda (DStack+0,x)	; end of coefficent list?
.a60a	d0 e7		bne $a5f3			bne _2
.a60c	e8		inx				inx			; Drop coefficent ptr
.a60d	e8		inx				inx
=39					CodeLen	.var *-XtPtr1
=$a60e					Here1 = *	; remember here
>a5e5	27					.byte CodeLen	;patch wh_CodeLength
.a60e	60		rts				rts
>a60f	45 4c 6f 67 32 4d 31 4d		Name0:	.text "ELog2M1M"	;  name of word as a string, ending at wh_NameLastChar
=8					NameLength = *-Name0
=42391					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>a617	a8					.byte (("ELog2M1M"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=52					LinkDisplacement = Nt0-WordListLink
>a618	10					.byte WordFlags	;wh_Flags
>a619	03					.byte 3	;wh_CodeLength
>a61a	34					  .byte LinkDisplacement	; offset to previous nt
=$a61b					XtPtr1 ::= *
=42391					WordListLink ::= Nt0 ; remember the nt of this word for later
.a61b	a9 25		lda #$25	ELog2M1M:	lda #<_c
.a61d	a0 a6		ldy #$a6			ldy #>_c
.a61f	20 ea a5	jsr $a5ea			jsr EMPolyYA
.a622	4c 5c 8e	jmp $8e5c			jmp EStar
=10					CodeLen	.var *-XtPtr1
=$a625					Here1 = *	; remember here
>a619	0a					.byte CodeLen	;patch wh_CodeLength
.a625					_c:
>a625	e6 ab						.word $abe6		; 16 bit signed binary mantissa.  $4000 = +0.5
>a627	fd						.char -3		; 8 bit signed exponent.  $00 = 2**0
>a628	39 52						.word $5239		; 16 bit signed binary mantissa.  $4000 = +0.5
>a62a	ff						.char -1		; 8 bit signed exponent.  $00 = 2**0
>a62b	3e a9						.word $a93e		; 16 bit signed binary mantissa.  $4000 = +0.5
>a62d	00						.char 0		; 8 bit signed exponent.  $00 = 2**0
>a62e	14 5c						.word $5c14		; 16 bit signed binary mantissa.  $4000 = +0.5
>a630	01						.char 1		; 8 bit signed exponent.  $00 = 2**0
>a631	00					.byte 0
>a632	45 4c 6f 67 32			Name0:	.text "ELog2"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=42423					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>a637	45					.byte (("ELog2"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=32					LinkDisplacement = Nt0-WordListLink
>a638	10					.byte WordFlags	;wh_Flags
>a639	03					.byte 3	;wh_CodeLength
>a63a	20					  .byte LinkDisplacement	; offset to previous nt
=$a63b					XtPtr1 ::= *
=42423					WordListLink ::= Nt0 ; remember the nt of this word for later
.a63b	a4 56		ldy $56		ELog2:		ldy FIndex
.a63d	b9 61 00	lda $0061,y			lda FSMant0,y	; bad param?
.a640	30 20		bmi $a662			bmi _OutOfRange
.a642	f0 1e		beq $a662			beq _OutOfRange
.a644	b9 57 00	lda $0057,y			lda FSExp,y
.a647	48		pha				pha		; remember orig exponent
.a648	a9 01		lda #$01			lda #1
.a64a	99 57 00	sta $0057,y			sta FSExp,y	; set to 1
.a64d	20 14 a2	jsr $a214			jsr E1Minus
.a650	20 1b a6	jsr $a61b			jsr ELog2M1M
.a653	a0 00		ldy #$00			ldy #0		; add orig exponent to float
.a655	68		pla				pla
.a656	38		sec				sec
.a657	e9 01		sbc #$01			sbc #1
.a659	10 01		bpl $a65c			bpl +
.a65b	88		dey				dey
.a65c					+
.a65c	20 90 a2	jsr $a290			jsr SToEYA
.a65f	4c cc a1	jmp $a1cc			jmp EPlus
.a662	4c e8 84	jmp $84e8	_OutOfRange:	jmp Throw_FpOutOfRange
=42					CodeLen	.var *-XtPtr1
=$a665					Here1 = *	; remember here
>a639	2a					.byte CodeLen	;patch wh_CodeLength
>a665	45 4c 6e			Name0:	.text "ELn"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=42472					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>a668	c3					.byte (("ELn"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=49					LinkDisplacement = Nt0-WordListLink
>a669	10					.byte WordFlags	;wh_Flags
>a66a	03					.byte 3	;wh_CodeLength
>a66b	31					  .byte LinkDisplacement	; offset to previous nt
=$a66c					XtPtr1 ::= *
=42472					WordListLink ::= Nt0 ; remember the nt of this word for later
.a66c	20 3b a6	jsr $a63b	ELn:		jsr ELog2
.a66f	20 1a 9f	jsr $9f1a			jsr ELitI
>a672	b9 58						.word $58b9		; 16 bit signed binary mantissa.  $4000 = +0.5
>a674	00						.char 0		; 8 bit signed exponent.  $00 = 2**0
.a675	4c 5c 8e	jmp $8e5c			jmp EStar
=12					CodeLen	.var *-XtPtr1
=$a678					Here1 = *	; remember here
>a66a	0c					.byte CodeLen	;patch wh_CodeLength
>a678	45 4c 6e 50 31			Name0:	.text "ELnP1"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=42493					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>a67d	25					.byte (("ELnP1"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=21					LinkDisplacement = Nt0-WordListLink
>a67e	10					.byte WordFlags	;wh_Flags
>a67f	03					.byte 3	;wh_CodeLength
>a680	15					  .byte LinkDisplacement	; offset to previous nt
=$a681					XtPtr1 ::= *
=42493					WordListLink ::= Nt0 ; remember the nt of this word for later
.a681	20 f0 a1	jsr $a1f0	ElnP1:		jsr E1Plus
.a684	4c 6c a6	jmp $a66c			jmp ELn
=6					CodeLen	.var *-XtPtr1
=$a687					Here1 = *	; remember here
>a67f	06					.byte CodeLen	;patch wh_CodeLength
>a687	45 4c 6f 67			Name0:	.text "ELog"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=42507					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>a68b	e4					.byte (("ELog"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=14					LinkDisplacement = Nt0-WordListLink
>a68c	10					.byte WordFlags	;wh_Flags
>a68d	03					.byte 3	;wh_CodeLength
>a68e	0e					  .byte LinkDisplacement	; offset to previous nt
=$a68f					XtPtr1 ::= *
=42507					WordListLink ::= Nt0 ; remember the nt of this word for later
.a68f	20 3b a6	jsr $a63b	ELog:		jsr ELog2
.a692	20 1a 9f	jsr $9f1a			jsr ELitI
>a695	10 4d						.word $4d10		; 16 bit signed binary mantissa.  $4000 = +0.5
>a697	ff						.char -1		; 8 bit signed exponent.  $00 = 2**0
.a698	4c 5c 8e	jmp $8e5c			jmp EStar
=12					CodeLen	.var *-XtPtr1
=$a69b					Here1 = *	; remember here
>a68d	0c					.byte CodeLen	;patch wh_CodeLength
>a69b	45 45 78 70 32 4d 31 4d		Name0:	.text "EExp2M1M"	;  name of word as a string, ending at wh_NameLastChar
=8					NameLength = *-Name0
=42531					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>a6a3	a8					.byte (("EExp2M1M"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=24					LinkDisplacement = Nt0-WordListLink
>a6a4	10					.byte WordFlags	;wh_Flags
>a6a5	03					.byte 3	;wh_CodeLength
>a6a6	18					  .byte LinkDisplacement	; offset to previous nt
=$a6a7					XtPtr1 ::= *
=42531					WordListLink ::= Nt0 ; remember the nt of this word for later
.a6a7	a9 b1		lda #$b1	EExp2M1M:	lda #<_c
.a6a9	a0 a6		ldy #$a6			ldy #>_c
.a6ab	20 ea a5	jsr $a5ea			jsr EMPolyYA
.a6ae	4c 5c 8e	jmp $8e5c			jmp EStar
=10					CodeLen	.var *-XtPtr1
=$a6b1					Here1 = *	; remember here
>a6a5	0a					.byte CodeLen	;patch wh_CodeLength
.a6b1					_c:
>a6b1	26 51						.word $5126		; 16 bit signed binary mantissa.  $4000 = +0.5
>a6b3	fd						.char -3		; 8 bit signed exponent.  $00 = 2**0
>a6b4	21 73						.word $7321		; 16 bit signed binary mantissa.  $4000 = +0.5
>a6b6	fe						.char -2		; 8 bit signed exponent.  $00 = 2**0
>a6b7	13 59						.word $5913		; 16 bit signed binary mantissa.  $4000 = +0.5
>a6b9	00						.char 0		; 8 bit signed exponent.  $00 = 2**0
>a6ba	00					.byte 0
>a6bb	45 45 78 70 32			Name0:	.text "EExp2"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=42560					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>a6c0	45					.byte (("EExp2"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=29					LinkDisplacement = Nt0-WordListLink
>a6c1	10					.byte WordFlags	;wh_Flags
>a6c2	03					.byte 3	;wh_CodeLength
>a6c3	1d					  .byte LinkDisplacement	; offset to previous nt
=$a6c4					XtPtr1 ::= *
=42560					WordListLink ::= Nt0 ; remember the nt of this word for later
.a6c4	20 2c a1	jsr $a12c	EExp2:		jsr EIntFrc	; ( f: r_rem r_int )
.a6c7	20 a5 a2	jsr $a2a5			jsr EToS
.a6ca	20 a7 a6	jsr $a6a7			jsr EExp2M1M
.a6cd	20 f0 a1	jsr $a1f0			jsr E1Plus
.a6d0	20 47 c5	jsr $c547			jsr PopA
.a6d3	a4 56		ldy $56				ldy FIndex
.a6d5	18		clc				clc
.a6d6	79 57 00	adc $0057,y			adc FSExp,y
.a6d9	99 57 00	sta $0057,y			sta FSExp,y
=24					CodeLen	.var *-XtPtr1
=$a6dc					Here1 = *	; remember here
>a6c2	18					.byte CodeLen	;patch wh_CodeLength
.a6dc	60		rts				rts
>a6dd	45 45 78 70			Name0:	.text "EExp"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=42593					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>a6e1	04					.byte (("EExp"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=33					LinkDisplacement = Nt0-WordListLink
>a6e2	10					.byte WordFlags	;wh_Flags
>a6e3	03					.byte 3	;wh_CodeLength
>a6e4	21					  .byte LinkDisplacement	; offset to previous nt
=$a6e5					XtPtr1 ::= *
=42593					WordListLink ::= Nt0 ; remember the nt of this word for later
.a6e5					EExp:
.a6e5	20 1a 9f	jsr $9f1a			jsr ELitI
>a6e8	55 5c						.word $5c55		; 16 bit signed binary mantissa.  $4000 = +0.5
>a6ea	01						.char 1		; 8 bit signed exponent.  $00 = 2**0
.a6eb	20 5c 8e	jsr $8e5c			jsr EStar
.a6ee	4c c4 a6	jmp $a6c4			jmp EExp2
=12					CodeLen	.var *-XtPtr1
=$a6f1					Here1 = *	; remember here
>a6e3	0c					.byte CodeLen	;patch wh_CodeLength
>a6f1	45 45 78 70 4d 31		Name0:	.text "EExpM1"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=42615					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>a6f7	26					.byte (("EExpM1"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=22					LinkDisplacement = Nt0-WordListLink
>a6f8	10					.byte WordFlags	;wh_Flags
>a6f9	03					.byte 3	;wh_CodeLength
>a6fa	16					  .byte LinkDisplacement	; offset to previous nt
=$a6fb					XtPtr1 ::= *
=42615					WordListLink ::= Nt0 ; remember the nt of this word for later
.a6fb	20 e5 a6	jsr $a6e5	EExpM1:		jsr EExp
.a6fe	4c 14 a2	jmp $a214			jmp E1Minus
=6					CodeLen	.var *-XtPtr1
=$a701					Here1 = *	; remember here
>a6f9	06					.byte CodeLen	;patch wh_CodeLength
>a701	45 41 4c 6f 67			Name0:	.text "EALog"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=42630					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>a706	e5					.byte (("EALog"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=15					LinkDisplacement = Nt0-WordListLink
>a707	10					.byte WordFlags	;wh_Flags
>a708	03					.byte 3	;wh_CodeLength
>a709	0f					  .byte LinkDisplacement	; offset to previous nt
=$a70a					XtPtr1 ::= *
=42630					WordListLink ::= Nt0 ; remember the nt of this word for later
.a70a					EALog:
.a70a	20 1a 9f	jsr $9f1a			jsr ELitI
>a70d	4d 6a						.word $6a4d		; 16 bit signed binary mantissa.  $4000 = +0.5
>a70f	02						.char 2		; 8 bit signed exponent.  $00 = 2**0
.a710	20 5c 8e	jsr $8e5c			jsr EStar
.a713	4c c4 a6	jmp $a6c4			jmp EExp2
=12					CodeLen	.var *-XtPtr1
=$a716					Here1 = *	; remember here
>a708	0c					.byte CodeLen	;patch wh_CodeLength
>a716	45 2a 2a			Name0:	.text "E**"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=42649					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>a719	43					.byte (("E**"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=19					LinkDisplacement = Nt0-WordListLink
>a71a	10					.byte WordFlags	;wh_Flags
>a71b	03					.byte 3	;wh_CodeLength
>a71c	13					  .byte LinkDisplacement	; offset to previous nt
=$a71d					XtPtr1 ::= *
=42649					WordListLink ::= Nt0 ; remember the nt of this word for later
.a71d	20 d0 9c	jsr $9cd0	EPower:		jsr ESwap
.a720	20 3b a6	jsr $a63b			jsr ELog2
.a723	20 5c 8e	jsr $8e5c			jsr EStar
.a726	4c c4 a6	jmp $a6c4			jmp EExp2
=12					CodeLen	.var *-XtPtr1
=$a729					Here1 = *	; remember here
>a71b	0c					.byte CodeLen	;patch wh_CodeLength
>a729	45 44 65 67 32 52 61 64		Name0:	.text "EDeg2Rad"	;  name of word as a string, ending at wh_NameLastChar
=8					NameLength = *-Name0
=42673					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>a731	88					.byte (("EDeg2Rad"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=24					LinkDisplacement = Nt0-WordListLink
>a732	10					.byte WordFlags	;wh_Flags
>a733	03					.byte 3	;wh_CodeLength
>a734	18					  .byte LinkDisplacement	; offset to previous nt
=$a735					XtPtr1 ::= *
=42673					WordListLink ::= Nt0 ; remember the nt of this word for later
.a735					EDeg2Rad:
.a735	20 1a 9f	jsr $9f1a			jsr ELitI
>a738	7d 47						.word $477d		; 16 bit signed binary mantissa.  $4000 = +0.5
>a73a	fb						.char -5		; 8 bit signed exponent.  $00 = 2**0
.a73b	4c 5c 8e	jmp $8e5c			jmp EStar
=9					CodeLen	.var *-XtPtr1
=$a73e					Here1 = *	; remember here
>a733	09					.byte CodeLen	;patch wh_CodeLength
>a73e	45 52 61 64 32 44 65 67		Name0:	.text "ERad2Deg"	;  name of word as a string, ending at wh_NameLastChar
=8					NameLength = *-Name0
=42694					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>a746	e8					.byte (("ERad2Deg"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=21					LinkDisplacement = Nt0-WordListLink
>a747	10					.byte WordFlags	;wh_Flags
>a748	03					.byte 3	;wh_CodeLength
>a749	15					  .byte LinkDisplacement	; offset to previous nt
=$a74a					XtPtr1 ::= *
=42694					WordListLink ::= Nt0 ; remember the nt of this word for later
.a74a					ERad2Deg:
.a74a	20 1a 9f	jsr $9f1a			jsr ELitI
>a74d	97 72						.word $7297		; 16 bit signed binary mantissa.  $4000 = +0.5
>a74f	06						.char 6		; 8 bit signed exponent.  $00 = 2**0
.a750	4c 5c 8e	jmp $8e5c			jmp EStar
=9					CodeLen	.var *-XtPtr1
=$a753					Here1 = *	; remember here
>a748	09					.byte CodeLen	;patch wh_CodeLength
>a753	45 41 52 65 64 75 63 65		Name0:	.text "EAReduce"	;  name of word as a string, ending at wh_NameLastChar
=8					NameLength = *-Name0
=42715					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>a75b	a8					.byte (("EAReduce"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=21					LinkDisplacement = Nt0-WordListLink
>a75c	10					.byte WordFlags	;wh_Flags
>a75d	03					.byte 3	;wh_CodeLength
>a75e	15					  .byte LinkDisplacement	; offset to previous nt
=$a75f					XtPtr1 ::= *
=42715					WordListLink ::= Nt0 ; remember the nt of this word for later
.a75f	a4 56		ldy $56		EAReduce:	ldy FIndex
.a761	b9 61 00	lda $0061,y			lda FSMant0,y		; zero?
.a764	f0 2f		beq $a795			beq _ok
.a766	b9 57 00	lda $0057,y			lda FSExp,y		; get exponent
.a769	30 2a		bmi $a795			bmi _ok			; small?
.a76b	c9 01		cmp #$01			cmp #1			; maybe need mirror?
.a76d	30 26		bmi $a795			bmi _ok			;if exponent <=0
.a76f	f0 24		beq $a795			beq _ok
.a771	c9 02		cmp #$02			cmp #2			; maybe need rotation?
.a773	b0 22		bcs $a797			bcs _exp2
.a775	b9 61 00	lda $0061,y			lda FSMant0,y
.a778	c9 65		cmp #$65			cmp #$65		;in -pi/2..pi/2 ?
.a77a	90 19		bcc $a795			bcc _ok
.a77c	c9 9b		cmp #$9b			cmp #$100-$65
.a77e	b0 15		bcs $a795			bcs _ok
.a780					_mir:
.a780	20 d1 9f	jsr $9fd1			jsr EPi
.a783	a4 56		ldy $56				ldy FIndex
.a785	b9 62 00	lda $0062,y			lda FSMant0+1,y
.a788	10 03		bpl $a78d			bpl _3
.a78a	20 25 a2	jsr $a225			jsr ENegate
.a78d	20 d0 9c	jsr $9cd0	_3:		jsr ESwap
.a790	20 fc a1	jsr $a1fc			jsr EMinus
.a793	38		sec				sec		; mirrored
.a794	60		rts				rts
.a795	18		clc		_ok:		clc		; not mirrored
.a796	60		rts				rts
.a797	d0 0b		bne $a7a4	_exp2:		bne _rot	;if exp>2 then fix
.a799	b9 61 00	lda $0061,y			lda FSMant0,y
.a79c	c9 65		cmp #$65			cmp #$65	;if mant>pi or mant<-pi then fix
.a79e	90 e0		bcc $a780			bcc _mir
.a7a0	c9 9b		cmp #$9b			cmp #$100-$65
.a7a2	b0 dc		bcs $a780			bcs _mir
.a7a4	20 fd 9f	jsr $9ffd	_rot:		jsr E2Pi
.a7a7	20 d9 8e	jsr $8ed9			jsr ESlash
.a7aa	20 2c a1	jsr $a12c			jsr EIntFrc
.a7ad	e6 56		inc $56				inc FIndex	; FDrop integer part
.a7af	a4 56		ldy $56				ldy FIndex	;if >=.5
.a7b1	b9 57 00	lda $0057,y			lda FSExp,y
.a7b4	a8		tay				tay
.a7b5	30 03		bmi $a7ba			bmi _rot4
.a7b7	20 14 a2	jsr $a214			jsr E1Minus	;  subtract 1
.a7ba	20 fd 9f	jsr $9ffd	_rot4:		jsr E2Pi
.a7bd	20 5c 8e	jsr $8e5c			jsr EStar
.a7c0	4c 5f a7	jmp $a75f			jmp EAReduce	; rotate done, look again
=100					CodeLen	.var *-XtPtr1
=$a7c3					Here1 = *	; remember here
>a75d	64					.byte CodeLen	;patch wh_CodeLength
>a7c3	45 53 69 6e			Name0:	.text "ESin"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=42823					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>a7c7	c4					.byte (("ESin"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=108					LinkDisplacement = Nt0-WordListLink
>a7c8	10					.byte WordFlags	;wh_Flags
>a7c9	03					.byte 3	;wh_CodeLength
>a7ca	6c					  .byte LinkDisplacement	; offset to previous nt
=$a7cb					XtPtr1 ::= *
=42823					WordListLink ::= Nt0 ; remember the nt of this word for later
.a7cb	20 5f a7	jsr $a75f	ESin:		jsr EAReduce
.a7ce	20 66 9c	jsr $9c66	ESinM:		jsr EDup
.a7d1	20 cd 8e	jsr $8ecd			jsr ESqr	; x x^2
.a7d4	a9 e4		lda #$e4			lda #<_c
.a7d6	a0 a7		ldy #$a7			ldy #>_c
.a7d8	20 ea a5	jsr $a5ea			jsr EMPolyYA
.a7db	20 5c 8e	jsr $8e5c			jsr EStar
.a7de	20 f0 a1	jsr $a1f0			jsr E1Plus	; C0 +1.0
.a7e1	4c 5c 8e	jmp $8e5c			jmp EStar
=25					CodeLen	.var *-XtPtr1
=$a7e4					Here1 = *	; remember here
>a7c9	19					.byte CodeLen	;patch wh_CodeLength
.a7e4					_c:
>a7e4	65 7c						.word $7c65		; 16 bit signed binary mantissa.  $4000 = +0.5
>a7e6	f9						.char -7		; 8 bit signed exponent.  $00 = 2**0
>a7e7	01 ab						.word $ab01		; 16 bit signed binary mantissa.  $4000 = +0.5
>a7e9	fe						.char -2		; 8 bit signed exponent.  $00 = 2**0
>a7ea	00					.byte 0			; end
>a7eb	45 43 73 63			Name0:	.text "ECsc"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=42863					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>a7ef	64					.byte (("ECsc"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=40					LinkDisplacement = Nt0-WordListLink
>a7f0	10					.byte WordFlags	;wh_Flags
>a7f1	03					.byte 3	;wh_CodeLength
>a7f2	28					  .byte LinkDisplacement	; offset to previous nt
=$a7f3					XtPtr1 ::= *
=42863					WordListLink ::= Nt0 ; remember the nt of this word for later
.a7f3	20 cb a7	jsr $a7cb	ECsc:		jsr ESin
.a7f6	4c 33 8f	jmp $8f33			jmp E1Slash		; 1/SIN(r1)
=6					CodeLen	.var *-XtPtr1
=$a7f9					Here1 = *	; remember here
>a7f1	06					.byte CodeLen	;patch wh_CodeLength
>a7f9	45 43 6f 73			Name0:	.text "ECos"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=42877					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>a7fd	64					.byte (("ECos"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=14					LinkDisplacement = Nt0-WordListLink
>a7fe	10					.byte WordFlags	;wh_Flags
>a7ff	03					.byte 3	;wh_CodeLength
>a800	0e					  .byte LinkDisplacement	; offset to previous nt
=$a801					XtPtr1 ::= *
=42877					WordListLink ::= Nt0 ; remember the nt of this word for later
.a801	20 e0 9f	jsr $9fe0	ECos:		jsr EPiH
.a804	20 cc a1	jsr $a1cc			jsr EPlus
.a807	4c cb a7	jmp $a7cb			jmp ESin
=9					CodeLen	.var *-XtPtr1
=$a80a					Here1 = *	; remember here
>a7ff	09					.byte CodeLen	;patch wh_CodeLength
>a80a	45 53 65 63			Name0:	.text "ESec"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=42894					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>a80e	64					.byte (("ESec"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=17					LinkDisplacement = Nt0-WordListLink
>a80f	10					.byte WordFlags	;wh_Flags
>a810	03					.byte 3	;wh_CodeLength
>a811	11					  .byte LinkDisplacement	; offset to previous nt
=$a812					XtPtr1 ::= *
=42894					WordListLink ::= Nt0 ; remember the nt of this word for later
.a812	20 01 a8	jsr $a801	ESec:		jsr ECos
.a815	4c 33 8f	jmp $8f33			jmp E1Slash		; 1/COS(r1)
=6					CodeLen	.var *-XtPtr1
=$a818					Here1 = *	; remember here
>a810	06					.byte CodeLen	;patch wh_CodeLength
>a818	45 53 69 6e 43 6f 73		Name0:	.text "ESinCos"	;  name of word as a string, ending at wh_NameLastChar
=7					NameLength = *-Name0
=42911					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>a81f	67					.byte (("ESinCos"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=17					LinkDisplacement = Nt0-WordListLink
>a820	10					.byte WordFlags	;wh_Flags
>a821	03					.byte 3	;wh_CodeLength
>a822	11					  .byte LinkDisplacement	; offset to previous nt
=$a823					XtPtr1 ::= *
=42911					WordListLink ::= Nt0 ; remember the nt of this word for later
.a823	20 72 85	jsr $8572	ESinCos:	jsr FDup
.a826	20 89 97	jsr $9789			jsr FSin
.a829	20 03 86	jsr $8603			jsr FSwap
.a82c	4c cd 97	jmp $97cd			jmp FCos
=12					CodeLen	.var *-XtPtr1
=$a82f					Here1 = *	; remember here
>a821	0c					.byte CodeLen	;patch wh_CodeLength
>a82f	45 54 61 6e			Name0:	.text "ETan"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=42931					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>a833	c4					.byte (("ETan"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=20					LinkDisplacement = Nt0-WordListLink
>a834	10					.byte WordFlags	;wh_Flags
>a835	03					.byte 3	;wh_CodeLength
>a836	14					  .byte LinkDisplacement	; offset to previous nt
=$a837					XtPtr1 ::= *
=42931					WordListLink ::= Nt0 ; remember the nt of this word for later
.a837	20 5f a7	jsr $a75f	ETan:		jsr EAReduce
.a83a	90 06		bcc $a842			bcc _30
.a83c	20 42 a8	jsr $a842			jsr _30
.a83f	4c 25 a2	jmp $a225			jmp ENegate
.a842					_30:
.a842	20 66 9c	jsr $9c66			jsr EDup
.a845	20 3f a2	jsr $a23f			jsr EAbs
.a848	20 ef 9f	jsr $9fef			jsr EPiQ
.a84b	20 40 9e	jsr $9e40			jsr ELe
.a84e	e8		inx				inx			; pop f
.a84f	e8		inx				inx
.a850	b5 26		lda $26,x			lda DStack+0,x
.a852	d0 19		bne $a86d			bne ETanM
.a854	20 e0 9f	jsr $9fe0			jsr EPiH
.a857	a4 56		ldy $56				ldy FIndex		; get sign
.a859	b9 61 00	lda $0061,y			lda FSMant0,y
.a85c	10 03		bpl $a861			bpl +
.a85e	20 25 a2	jsr $a225			jsr ENegate
.a861					+
.a861	20 d0 9c	jsr $9cd0			jsr ESwap
.a864	20 fc a1	jsr $a1fc			jsr EMinus
.a867	20 6d a8	jsr $a86d			jsr ETanM
.a86a	4c 33 8f	jmp $8f33			jmp E1Slash
=54					CodeLen	.var *-XtPtr1
=$a86d					Here1 = *	; remember here
>a835	36					.byte CodeLen	;patch wh_CodeLength
.a86d	20 66 9c	jsr $9c66	ETanM:		jsr EDup
.a870	20 cd 8e	jsr $8ecd			jsr ESqr		; x x^2
.a873	a9 83		lda #$83			lda #<_c
.a875	a0 a8		ldy #$a8			ldy #>_c
.a877	20 ea a5	jsr $a5ea			jsr EMPolyYA
.a87a	20 5c 8e	jsr $8e5c			jsr EStar
.a87d	20 f0 a1	jsr $a1f0			jsr E1Plus		; c0 1.0
.a880	4c 5c 8e	jmp $8e5c			jmp EStar
=76					CodeLen	.var *-XtPtr1
=$a883					Here1 = *	; remember here
>a835	4c					.byte CodeLen	;patch wh_CodeLength
.a883					_c:
>a883	b6 64						.word $64b6		; 16 bit signed binary mantissa.  $4000 = +0.5
>a885	fd						.char -3		; 8 bit signed exponent.  $00 = 2**0
>a886	50 73						.word $7350		; 16 bit signed binary mantissa.  $4000 = +0.5
>a888	fd						.char -3		; 8 bit signed exponent.  $00 = 2**0
>a889	09 56						.word $5609		; 16 bit signed binary mantissa.  $4000 = +0.5
>a88b	ff						.char -1		; 8 bit signed exponent.  $00 = 2**0
>a88c	00					.byte 0			; end
>a88d	45 43 6f 74			Name0:	.text "ECot"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=43025					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>a891	84					.byte (("ECot"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=94					LinkDisplacement = Nt0-WordListLink
>a892	10					.byte WordFlags	;wh_Flags
>a893	03					.byte 3	;wh_CodeLength
>a894	5e					  .byte LinkDisplacement	; offset to previous nt
=$a895					XtPtr1 ::= *
=43025					WordListLink ::= Nt0 ; remember the nt of this word for later
.a895	20 37 a8	jsr $a837	ECot:		jsr ETan
.a898	4c 33 8f	jmp $8f33			jmp E1Slash	; =1/TAN(r1)
=6					CodeLen	.var *-XtPtr1
=$a89b					Here1 = *	; remember here
>a893	06					.byte CodeLen	;patch wh_CodeLength
>a89b	45 41 43 6f 73			Name0:	.text "EACos"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=43040					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>a8a0	65					.byte (("EACos"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=15					LinkDisplacement = Nt0-WordListLink
>a8a1	10					.byte WordFlags	;wh_Flags
>a8a2	03					.byte 3	;wh_CodeLength
>a8a3	0f					  .byte LinkDisplacement	; offset to previous nt
=$a8a4					XtPtr1 ::= *
=43040					WordListLink ::= Nt0 ; remember the nt of this word for later
.a8a4	a4 56		ldy $56		EACos:		ldy FIndex
.a8a6	b9 61 00	lda $0061,y			lda FSMant0,y
.a8a9	08		php				php			; save sign
.a8aa	20 3f a2	jsr $a23f			jsr EAbs
.a8ad	a9 d0		lda #$d0			lda #<_c
.a8af	a0 a8		ldy #$a8			ldy #>_c
.a8b1	20 ea a5	jsr $a5ea			jsr EMPolyYA
.a8b4	20 d0 9c	jsr $9cd0			jsr ESwap
.a8b7	20 25 a2	jsr $a225			jsr ENegate
.a8ba	20 f0 a1	jsr $a1f0			jsr E1Plus
.a8bd	20 fb a2	jsr $a2fb			jsr ESqrt
.a8c0	20 5c 8e	jsr $8e5c			jsr EStar
.a8c3	28		plp				plp			; was r1 negative?
.a8c4	10 09		bpl $a8cf			bpl +
.a8c6	20 d1 9f	jsr $9fd1			jsr EPi
.a8c9	20 d0 9c	jsr $9cd0			jsr ESwap
.a8cc	20 fc a1	jsr $a1fc			jsr EMinus
.a8cf					+
=43					CodeLen	.var *-XtPtr1
=$a8cf					Here1 = *	; remember here
>a8a2	2b					.byte CodeLen	;patch wh_CodeLength
.a8cf	60		rts				rts
.a8d0					_c:
>a8d0	e6 b2						.word $b2e6		; 16 bit signed binary mantissa.  $4000 = +0.5
>a8d2	fb						.char -5		; 8 bit signed exponent.  $00 = 2**0
>a8d3	92 4c						.word $4c92		; 16 bit signed binary mantissa.  $4000 = +0.5
>a8d5	fd						.char -3		; 8 bit signed exponent.  $00 = 2**0
>a8d6	2f 93						.word $932f		; 16 bit signed binary mantissa.  $4000 = +0.5
>a8d8	fe						.char -2		; 8 bit signed exponent.  $00 = 2**0
>a8d9	88 64						.word $6488		; 16 bit signed binary mantissa.  $4000 = +0.5
>a8db	01						.char 1		; 8 bit signed exponent.  $00 = 2**0
>a8dc	00					.byte 0			; end
>a8dd	45 41 53 65 63			Name0:	.text "EASec"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=43106					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>a8e2	65					.byte (("EASec"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=66					LinkDisplacement = Nt0-WordListLink
>a8e3	10					.byte WordFlags	;wh_Flags
>a8e4	03					.byte 3	;wh_CodeLength
>a8e5	42					  .byte LinkDisplacement	; offset to previous nt
=$a8e6					XtPtr1 ::= *
=43106					WordListLink ::= Nt0 ; remember the nt of this word for later
.a8e6	20 33 8f	jsr $8f33	EASec:		jsr E1Slash
.a8e9	4c a4 a8	jmp $a8a4			jmp EACos
=6					CodeLen	.var *-XtPtr1
=$a8ec					Here1 = *	; remember here
>a8e4	06					.byte CodeLen	;patch wh_CodeLength
>a8ec	45 41 53 69 6e			Name0:	.text "EASin"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=43121					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>a8f1	c5					.byte (("EASin"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=15					LinkDisplacement = Nt0-WordListLink
>a8f2	10					.byte WordFlags	;wh_Flags
>a8f3	03					.byte 3	;wh_CodeLength
>a8f4	0f					  .byte LinkDisplacement	; offset to previous nt
=$a8f5					XtPtr1 ::= *
=43121					WordListLink ::= Nt0 ; remember the nt of this word for later
.a8f5	20 a4 a8	jsr $a8a4	EASin:		jsr EACos
.a8f8	20 25 a2	jsr $a225			jsr ENegate
.a8fb	20 e0 9f	jsr $9fe0			jsr EPiH
.a8fe	4c cc a1	jmp $a1cc			jmp EPlus
=12					CodeLen	.var *-XtPtr1
=$a901					Here1 = *	; remember here
>a8f3	0c					.byte CodeLen	;patch wh_CodeLength
>a901	45 41 43 73 63			Name0:	.text "EACsc"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=43142					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>a906	65					.byte (("EACsc"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=21					LinkDisplacement = Nt0-WordListLink
>a907	10					.byte WordFlags	;wh_Flags
>a908	03					.byte 3	;wh_CodeLength
>a909	15					  .byte LinkDisplacement	; offset to previous nt
=$a90a					XtPtr1 ::= *
=43142					WordListLink ::= Nt0 ; remember the nt of this word for later
.a90a	20 33 8f	jsr $8f33	EACsc:		jsr E1Slash
.a90d	4c f5 a8	jmp $a8f5			jmp EASin
=6					CodeLen	.var *-XtPtr1
=$a910					Here1 = *	; remember here
>a908	06					.byte CodeLen	;patch wh_CodeLength
>a910	45 41 54 61 6e			Name0:	.text "EATan"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=43157					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>a915	c5					.byte (("EATan"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=15					LinkDisplacement = Nt0-WordListLink
>a916	10					.byte WordFlags	;wh_Flags
>a917	03					.byte 3	;wh_CodeLength
>a918	0f					  .byte LinkDisplacement	; offset to previous nt
=$a919					XtPtr1 ::= *
=43157					WordListLink ::= Nt0 ; remember the nt of this word for later
.a919					EATan:
.a919	a4 56		ldy $56				ldy FIndex
.a91b	b9 57 00	lda $0057,y			lda FSExp,y		; Abs(r1)<1 ?
.a91e	30 1b		bmi $a93b			bmi EATanM
.a920	f0 19		beq $a93b			beq EATanM
.a922	b9 61 00	lda $0061,y			lda FSMant0,y		; save sign
.a925	08		php				php
.a926	20 33 8f	jsr $8f33			jsr E1Slash
.a929	20 3b a9	jsr $a93b			jsr EATanM
.a92c	20 25 a2	jsr $a225			jsr ENegate
.a92f	20 e0 9f	jsr $9fe0			jsr EPiH
.a932	28		plp				plp
.a933	10 03		bpl $a938			bpl _18
.a935	20 25 a2	jsr $a225			jsr ENegate
.a938	4c cc a1	jmp $a1cc	_18:		jmp EPlus
.a93b	20 66 9c	jsr $9c66	EATanM:		jsr EDup		; x x
.a93e	20 cd 8e	jsr $8ecd			jsr ESqr		; x xsqr
.a941	a9 51		lda #$51			lda #<_c
.a943	a0 a9		ldy #$a9			ldy #>_c
.a945	20 ea a5	jsr $a5ea			jsr EMPolyYA
.a948	20 5c 8e	jsr $8e5c			jsr EStar		; x poly
.a94b	20 f0 a1	jsr $a1f0			jsr E1Plus		; x poly
.a94e	4c 5c 8e	jmp $8e5c			jmp EStar
.a951					_c:
>a951	4f a9						.word $a94f		; 16 bit signed binary mantissa.  $4000 = +0.5
>a953	fc						.char -4		; 8 bit signed exponent.  $00 = 2**0
>a954	8e 4e						.word $4e8e		; 16 bit signed binary mantissa.  $4000 = +0.5
>a956	fe						.char -2		; 8 bit signed exponent.  $00 = 2**0
>a957	9f ac						.word $ac9f		; 16 bit signed binary mantissa.  $4000 = +0.5
>a959	ff						.char -1		; 8 bit signed exponent.  $00 = 2**0
>a95a	00					.byte 0			; end
>a95b	45 41 43 6f 74			Name0:	.text "EACot"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=43232					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>a960	85					.byte (("EACot"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=75					LinkDisplacement = Nt0-WordListLink
>a961	10					.byte WordFlags	;wh_Flags
>a962	03					.byte 3	;wh_CodeLength
>a963	4b					  .byte LinkDisplacement	; offset to previous nt
=$a964					XtPtr1 ::= *
=43232					WordListLink ::= Nt0 ; remember the nt of this word for later
.a964	20 33 8f	jsr $8f33	EACot:		jsr E1Slash
.a967	4c 19 a9	jmp $a919			jmp EATan
=6					CodeLen	.var *-XtPtr1
=$a96a					Here1 = *	; remember here
>a962	06					.byte CodeLen	;patch wh_CodeLength
>a96a	45 41 54 61 6e 32		Name0:	.text "EATan2"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=43248					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>a970	46					.byte (("EATan2"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=16					LinkDisplacement = Nt0-WordListLink
>a971	10					.byte WordFlags	;wh_Flags
>a972	03					.byte 3	;wh_CodeLength
>a973	10					  .byte LinkDisplacement	; offset to previous nt
=$a974					XtPtr1 ::= *
=43248					WordListLink ::= Nt0 ; remember the nt of this word for later
.a974	a4 56		ldy $56		EATan2:		ldy FIndex
.a976	b9 61 00	lda $0061,y			lda FSMant0+0,y	; get rx sign
.a979	f0 1c		beq $a997			beq _rxzero
.a97b	0a		asl a				asl a		;   C=rx sign
.a97c	b9 62 00	lda $0062,y			lda FSMant0+1,y	;   N=ry sign
.a97f	08		php				php		; save signs
.a980	20 d9 8e	jsr $8ed9			jsr ESlash
.a983	20 19 a9	jsr $a919			jsr EATan
.a986	28		plp				plp		; pop signs
.a987	b0 01		bcs $a98a			bcs _rxneg
.a989	60		rts		_rts:		rts
.a98a	08		php		_rxneg:		php
.a98b	20 a7 89	jsr $89a7			jsr FPi
.a98e	28		plp				plp
.a98f	10 03		bpl $a994			bpl +
.a991	20 25 a2	jsr $a225			jsr ENegate
.a994	4c cc a1	jmp $a1cc	+		jmp EPlus
.a997	e6 56		inc $56		_rxzero:	inc FIndex	; FDrop rx
.a999	b9 61 00	lda $0061,y			lda FSMant0,y
.a99c	08		php				php
.a99d	e6 56		inc $56				inc FIndex	; FDrop ry
.a99f	20 e0 9f	jsr $9fe0			jsr EPiH
.a9a2	28		plp				plp
.a9a3	10 e4		bpl $a989			bpl _rts
.a9a5	4c 25 a2	jmp $a225			jmp ENegate
=52					CodeLen	.var *-XtPtr1
=$a9a8					Here1 = *	; remember here
>a972	34					.byte CodeLen	;patch wh_CodeLength
>a9a8	45 53 67 6e			Name0:	.text "ESgn"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=43308					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>a9ac	c4					.byte (("ESgn"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=60					LinkDisplacement = Nt0-WordListLink
>a9ad	10					.byte WordFlags	;wh_Flags
>a9ae	03					.byte 3	;wh_CodeLength
>a9af	3c					  .byte LinkDisplacement	; offset to previous nt
=$a9b0					XtPtr1 ::= *
=43308					WordListLink ::= Nt0 ; remember the nt of this word for later
.a9b0	a4 56		ldy $56		ESgn:		ldy FIndex
.a9b2	b9 61 00	lda $0061,y			lda FSMant0,y
.a9b5	f0 0a		beq $a9c1			beq _zero
.a9b7	e6 56		inc $56				inc FIndex
.a9b9	b9 61 00	lda $0061,y			lda FSMant0,y
.a9bc	30 04		bmi $a9c2			bmi EM1
.a9be	4c b6 9f	jmp $9fb6			jmp E1
.a9c1	60		rts		_zero:		rts
=18					CodeLen	.var *-XtPtr1
=$a9c2					Here1 = *	; remember here
>a9ae	12					.byte CodeLen	;patch wh_CodeLength
.a9c2	a9 80		lda #$80	EM1:		lda #$80
.a9c4	a0 00		ldy #$00			ldy #0
.a9c6	4c 64 9f	jmp $9f64			jmp ELitYA
>a9c9	45 53 69 6e 48			Name0:	.text "ESinH"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=43342					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>a9ce	05					.byte (("ESinH"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=34					LinkDisplacement = Nt0-WordListLink
>a9cf	10					.byte WordFlags	;wh_Flags
>a9d0	03					.byte 3	;wh_CodeLength
>a9d1	22					  .byte LinkDisplacement	; offset to previous nt
=$a9d2					XtPtr1 ::= *
=43342					WordListLink ::= Nt0 ; remember the nt of this word for later
.a9d2	20 66 9c	jsr $9c66	ESinH:		jsr EDup
.a9d5	20 e5 a6	jsr $a6e5			jsr EExp
.a9d8	20 d0 9c	jsr $9cd0			jsr ESwap
.a9db	20 25 a2	jsr $a225			jsr ENegate
.a9de	20 e5 a6	jsr $a6e5			jsr EExp
.a9e1	20 fc a1	jsr $a1fc			jsr EMinus
.a9e4	4c 63 a0	jmp $a063			jmp E2Slash
=21					CodeLen	.var *-XtPtr1
=$a9e7					Here1 = *	; remember here
>a9d0	15					.byte CodeLen	;patch wh_CodeLength
>a9e7	45 43 73 63 48			Name0:	.text "ECscH"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=43372					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>a9ec	05					.byte (("ECscH"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=30					LinkDisplacement = Nt0-WordListLink
>a9ed	10					.byte WordFlags	;wh_Flags
>a9ee	03					.byte 3	;wh_CodeLength
>a9ef	1e					  .byte LinkDisplacement	; offset to previous nt
=$a9f0					XtPtr1 ::= *
=43372					WordListLink ::= Nt0 ; remember the nt of this word for later
.a9f0	20 d2 a9	jsr $a9d2	ECscH:		jsr ESinH
.a9f3	4c 33 8f	jmp $8f33			jmp E1Slash
=6					CodeLen	.var *-XtPtr1
=$a9f6					Here1 = *	; remember here
>a9ee	06					.byte CodeLen	;patch wh_CodeLength
>a9f6	45 43 6f 73 48			Name0:	.text "ECosH"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=43387					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>a9fb	05					.byte (("ECosH"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=15					LinkDisplacement = Nt0-WordListLink
>a9fc	10					.byte WordFlags	;wh_Flags
>a9fd	03					.byte 3	;wh_CodeLength
>a9fe	0f					  .byte LinkDisplacement	; offset to previous nt
=$a9ff					XtPtr1 ::= *
=43387					WordListLink ::= Nt0 ; remember the nt of this word for later
.a9ff	20 66 9c	jsr $9c66	ECosH:		jsr EDup
.aa02	20 e5 a6	jsr $a6e5			jsr EExp
.aa05	20 d0 9c	jsr $9cd0			jsr ESwap
.aa08	20 25 a2	jsr $a225			jsr ENegate
.aa0b	20 e5 a6	jsr $a6e5			jsr EExp
.aa0e	20 cc a1	jsr $a1cc			jsr EPlus
.aa11	4c 63 a0	jmp $a063			jmp E2Slash
=21					CodeLen	.var *-XtPtr1
=$aa14					Here1 = *	; remember here
>a9fd	15					.byte CodeLen	;patch wh_CodeLength
>aa14	45 53 65 63 48			Name0:	.text "ESecH"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=43417					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>aa19	05					.byte (("ESecH"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=30					LinkDisplacement = Nt0-WordListLink
>aa1a	10					.byte WordFlags	;wh_Flags
>aa1b	03					.byte 3	;wh_CodeLength
>aa1c	1e					  .byte LinkDisplacement	; offset to previous nt
=$aa1d					XtPtr1 ::= *
=43417					WordListLink ::= Nt0 ; remember the nt of this word for later
.aa1d	20 ff a9	jsr $a9ff	ESecH:		jsr ECosH
.aa20	4c 33 8f	jmp $8f33			jmp E1Slash
=6					CodeLen	.var *-XtPtr1
=$aa23					Here1 = *	; remember here
>aa1b	06					.byte CodeLen	;patch wh_CodeLength
>aa23	45 54 61 6e 48			Name0:	.text "ETanH"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=43432					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>aa28	05					.byte (("ETanH"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=15					LinkDisplacement = Nt0-WordListLink
>aa29	10					.byte WordFlags	;wh_Flags
>aa2a	03					.byte 3	;wh_CodeLength
>aa2b	0f					  .byte LinkDisplacement	; offset to previous nt
=$aa2c					XtPtr1 ::= *
=43432					WordListLink ::= Nt0 ; remember the nt of this word for later
.aa2c	20 66 9c	jsr $9c66	ETanH:		jsr EDup
.aa2f	20 25 a2	jsr $a225			jsr ENegate	; X -X
.aa32	20 e5 a6	jsr $a6e5			jsr EExp	; X Exp(-X)
.aa35	20 d0 9c	jsr $9cd0			jsr ESwap	; Exp(-X) X
.aa38	20 e5 a6	jsr $a6e5			jsr EExp	; Exp(-X) Exp(X)
.aa3b	20 81 9c	jsr $9c81			jsr EOver	; Exp(-X) Exp(X) Exp(-X)
.aa3e	20 cc a1	jsr $a1cc			jsr EPlus	; Exp(-X) Exp(X)+Exp(-X)
.aa41	20 d9 8e	jsr $8ed9			jsr ESlash	; Exp(-X)/(Exp(X)+Exp(-X))
.aa44	20 58 a0	jsr $a058			jsr E2Star	; Exp(-X)/(Exp(X)+Exp(-X))*2
.aa47	20 25 a2	jsr $a225			jsr ENegate
.aa4a	4c f0 a1	jmp $a1f0			jmp E1Plus
=33					CodeLen	.var *-XtPtr1
=$aa4d					Here1 = *	; remember here
>aa2a	21					.byte CodeLen	;patch wh_CodeLength
>aa4d	45 43 6f 74 48			Name0:	.text "ECotH"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=43474					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>aa52	05					.byte (("ECotH"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=42					LinkDisplacement = Nt0-WordListLink
>aa53	10					.byte WordFlags	;wh_Flags
>aa54	03					.byte 3	;wh_CodeLength
>aa55	2a					  .byte LinkDisplacement	; offset to previous nt
=$aa56					XtPtr1 ::= *
=43474					WordListLink ::= Nt0 ; remember the nt of this word for later
.aa56	20 2c aa	jsr $aa2c	ECotH:		jsr ETanH
.aa59	4c 33 8f	jmp $8f33			jmp E1Slash
=6					CodeLen	.var *-XtPtr1
=$aa5c					Here1 = *	; remember here
>aa54	06					.byte CodeLen	;patch wh_CodeLength
>aa5c	45 41 53 69 6e 48		Name0:	.text "EASinH"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=43490					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>aa62	06					.byte (("EASinH"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=16					LinkDisplacement = Nt0-WordListLink
>aa63	10					.byte WordFlags	;wh_Flags
>aa64	03					.byte 3	;wh_CodeLength
>aa65	10					  .byte LinkDisplacement	; offset to previous nt
=$aa66					XtPtr1 ::= *
=43490					WordListLink ::= Nt0 ; remember the nt of this word for later
.aa66	20 66 9c	jsr $9c66	EASinH:		jsr EDup	; X X
.aa69	20 cd 8e	jsr $8ecd			jsr ESqr	; X X*X
.aa6c	20 f0 a1	jsr $a1f0			jsr E1Plus	; X X*X+1
.aa6f	20 fb a2	jsr $a2fb			jsr ESqrt	; X sqrt(X*X+1)
.aa72	20 cc a1	jsr $a1cc			jsr EPlus	;
.aa75	4c 6c a6	jmp $a66c			jmp ELn
=18					CodeLen	.var *-XtPtr1
=$aa78					Here1 = *	; remember here
>aa64	12					.byte CodeLen	;patch wh_CodeLength
>aa78	45 41 43 73 63 48		Name0:	.text "EACscH"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=43518					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>aa7e	06					.byte (("EACscH"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=28					LinkDisplacement = Nt0-WordListLink
>aa7f	10					.byte WordFlags	;wh_Flags
>aa80	03					.byte 3	;wh_CodeLength
>aa81	1c					  .byte LinkDisplacement	; offset to previous nt
=$aa82					XtPtr1 ::= *
=43518					WordListLink ::= Nt0 ; remember the nt of this word for later
.aa82	20 33 8f	jsr $8f33	EACscH:		jsr E1Slash
.aa85	4c 66 aa	jmp $aa66			jmp EASinH
=6					CodeLen	.var *-XtPtr1
=$aa88					Here1 = *	; remember here
>aa80	06					.byte CodeLen	;patch wh_CodeLength
>aa88	45 41 43 6f 73 48		Name0:	.text "EACosH"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=43534					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>aa8e	06					.byte (("EACosH"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=16					LinkDisplacement = Nt0-WordListLink
>aa8f	10					.byte WordFlags	;wh_Flags
>aa90	03					.byte 3	;wh_CodeLength
>aa91	10					  .byte LinkDisplacement	; offset to previous nt
=$aa92					XtPtr1 ::= *
=43534					WordListLink ::= Nt0 ; remember the nt of this word for later
.aa92	20 66 9c	jsr $9c66	EACosH:		jsr EDup
.aa95	20 cd 8e	jsr $8ecd			jsr ESqr
.aa98	20 14 a2	jsr $a214			jsr E1Minus
.aa9b	20 fb a2	jsr $a2fb			jsr ESqrt
.aa9e	20 cc a1	jsr $a1cc			jsr EPlus
.aaa1	4c 6c a6	jmp $a66c			jmp ELn
=18					CodeLen	.var *-XtPtr1
=$aaa4					Here1 = *	; remember here
>aa90	12					.byte CodeLen	;patch wh_CodeLength
>aaa4	45 41 53 65 63 48		Name0:	.text "EASecH"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=43562					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>aaaa	06					.byte (("EASecH"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=28					LinkDisplacement = Nt0-WordListLink
>aaab	10					.byte WordFlags	;wh_Flags
>aaac	03					.byte 3	;wh_CodeLength
>aaad	1c					  .byte LinkDisplacement	; offset to previous nt
=$aaae					XtPtr1 ::= *
=43562					WordListLink ::= Nt0 ; remember the nt of this word for later
.aaae	20 33 8f	jsr $8f33	EASecH:		jsr E1Slash
.aab1	4c 92 aa	jmp $aa92			jmp EACosH
=6					CodeLen	.var *-XtPtr1
=$aab4					Here1 = *	; remember here
>aaac	06					.byte CodeLen	;patch wh_CodeLength
>aab4	45 41 54 61 6e 48		Name0:	.text "EATanH"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=43578					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>aaba	06					.byte (("EATanH"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=16					LinkDisplacement = Nt0-WordListLink
>aabb	10					.byte WordFlags	;wh_Flags
>aabc	03					.byte 3	;wh_CodeLength
>aabd	10					  .byte LinkDisplacement	; offset to previous nt
=$aabe					XtPtr1 ::= *
=43578					WordListLink ::= Nt0 ; remember the nt of this word for later
.aabe	20 66 9c	jsr $9c66	EAtanH:		jsr EDup	; x x
.aac1	20 f0 a1	jsr $a1f0			jsr E1Plus	; x x+1
.aac4	20 d0 9c	jsr $9cd0			jsr ESwap	; 1+x x
.aac7	20 b6 9f	jsr $9fb6			jsr E1
.aaca	20 d0 9c	jsr $9cd0			jsr ESwap
.aacd	20 fc a1	jsr $a1fc			jsr EMinus	; 1+x 1-x
.aad0	20 d9 8e	jsr $8ed9			jsr ESlash	; (1+x)/(1-x)
.aad3	20 6c a6	jsr $a66c			jsr ELn
.aad6	4c 63 a0	jmp $a063			jmp E2Slash
=27					CodeLen	.var *-XtPtr1
=$aad9					Here1 = *	; remember here
>aabc	1b					.byte CodeLen	;patch wh_CodeLength
>aad9	45 41 43 6f 74 48		Name0:	.text "EACotH"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=43615					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>aadf	06					.byte (("EACotH"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=37					LinkDisplacement = Nt0-WordListLink
>aae0	10					.byte WordFlags	;wh_Flags
>aae1	03					.byte 3	;wh_CodeLength
>aae2	25					  .byte LinkDisplacement	; offset to previous nt
=$aae3					XtPtr1 ::= *
=43615					WordListLink ::= Nt0 ; remember the nt of this word for later
.aae3	20 33 8f	jsr $8f33	EACotH: 	jsr E1Slash
.aae6	4c be aa	jmp $aabe			jmp EATanH
=6					CodeLen	.var *-XtPtr1
=$aae9					Here1 = *	; remember here
>aae1	06					.byte CodeLen	;patch wh_CodeLength
>aae9	45 64				Name0:	.text "Ed"	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=43627					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>aaeb	82					.byte (("Ed"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=12					LinkDisplacement = Nt0-WordListLink
>aaec	10					.byte WordFlags	;wh_Flags
>aaed	03					.byte 3	;wh_CodeLength
>aaee	0c					  .byte LinkDisplacement	; offset to previous nt
=$aaef					XtPtr1 ::= *
=43627					WordListLink ::= Nt0 ; remember the nt of this word for later
.aaef	4c f2 aa	jmp $aaf2	Ed:		jmp ed6502
=3					CodeLen	.var *-XtPtr1
=$aaf2					Here1 = *	; remember here
>aaed	03					.byte CodeLen	;patch wh_CodeLength
=$20					ed_head	 = editor1  ; pointer to first list element (addr) (2 bytes)
=$22					ed_cur	 = editor2  ; current line number (1 is first line) (2 bytes)
=$24					ed_flags = editor3  ; Flags used by ed, where
.aaf2					ed6502:
.aaf2	ad 00 03	lda $0300			lda base
.aaf5	85 25		sta $25				sta editor3+1
.aaf7	20 35 c3	jsr $c335			jsr Decimal
.aafa	a9 00		lda #$00			lda #0
.aafc	85 20		sta $20				sta ed_head
.aafe	85 21		sta $21				sta ed_head+1
.ab00	85 22		sta $22				sta ed_cur
.ab02	85 23		sta $23				sta ed_cur+1
.ab04	85 24		sta $24				sta ed_flags
.ab06	20 6b c9	jsr $c96b			jsr Zero
.ab09	20 6b c9	jsr $c96b			jsr Zero		; ( addr-t u-t )
.ab0c	20 b7 bc	jsr $bcb7			jsr CR
.ab0f					ed_input_loop:
.ab0f	a9 7e		lda #$7e			lda #$ff-%10000001
.ab11	25 24		and $24				and ed_flags
.ab13	85 24		sta $24				sta ed_flags
.ab15	20 b4 af	jsr $afb4			jsr ed_get_input
.ab18	a5 06		lda $06				lda ciblen+0
.ab1a	d0 1e		bne $ab3a			bne _command_mode
.ab1c	a5 22		lda $22				lda ed_cur+0
.ab1e	a4 23		ldy $23				ldy ed_cur+1
.ab20	20 2e c9	jsr $c92e			jsr PushYA		; ( addr-t u-t u )
.ab23	a9 80		lda #$80			lda #%10000000
.ab25	05 24		ora $24				ora ed_flags
.ab27	85 24		sta $24				sta ed_flags
.ab29	20 37 dc	jsr $dc37			jsr One_Plus		; ( addr-t u-t u+1 )
.ab2c	20 cf af	jsr $afcf			jsr ed_is_valid_line
.ab2f	b0 03		bcs $ab34			bcs +
.ab31	4c a4 af	jmp $afa4			jmp ed_error_1drop	; New line number is not legal, abort
.ab34					+
.ab34	20 6b c9	jsr $c96b			jsr Zero		; ( addr-t u-t u+1 0 )
.ab37	4c f9 ab	jmp $abf9			jmp _line_number_only_from_external
.ab3a					_command_mode:
.ab3a	20 6b c9	jsr $c96b			jsr Zero		; parameter 1 is NOS ( addr-t u-t 0 )
.ab3d	20 6b c9	jsr $c96b			jsr Zero		; parameter 2 is TOS ( addr-t u-t 0 0 )
.ab40	a0 00		ldy #$00			ldy #0			; get char
.ab42	b1 04		lda ($04),y			lda (cib),y
.ab44	c9 2e		cmp #$2e			cmp #'.'
.ab46	d0 31		bne $ab79			bne _prefix_dollar
.ab48	20 c3 af	jsr $afc3			jsr ed_have_text
.ab4b	a5 22		lda $22				lda ed_cur
.ab4d	95 28		sta $28,x			sta DStack+2,x
.ab4f	a5 23		lda $23				lda ed_cur+1
.ab51	95 29		sta $29,x			sta DStack+3,x		; ( addr-t u-t cur 0 )
.ab53	a9 80		lda #$80			lda #%10000000
.ab55	05 24		ora $24				ora ed_flags
.ab57	85 24		sta $24				sta ed_flags
.ab59	a5 06		lda $06				lda ciblen
.ab5b	c9 01		cmp #$01			cmp #1			; sets Z if A was 1
.ab5d	d0 03		bne $ab62			bne +
.ab5f	4c f9 ab	jmp $abf9			jmp _line_number_only_from_external
.ab62					+
.ab62	a5 04		lda $04				lda cib+0
.ab64	a4 05		ldy $05				ldy cib+1
.ab66	20 2e c9	jsr $c92e			jsr PushYA
.ab69	a5 06		lda $06				lda ciblen+0
.ab6b	a4 07		ldy $07				ldy ciblen+1
.ab6d	20 2e c9	jsr $c92e			jsr PushYA
.ab70	20 11 dc	jsr $dc11			jsr One_Minus		; ( addr-t u-t para1 0 addr u-1 )
.ab73	20 42 dc	jsr $dc42			jsr NOS_One_Plus	; ( addr-t u-t para1 0 addr+1 u-1 )
.ab76	4c 4b ac	jmp $ac4b			jmp _check_for_para2
.ab79					_prefix_dollar:
.ab79	c9 24		cmp #$24			cmp #'$'
.ab7b	d0 1f		bne $ab9c			bne _prefix_percent
.ab7d	20 c3 af	jsr $afc3			jsr ed_have_text
.ab80	e8		inx				inx
.ab81	e8		inx				inx			; ( addr-t u-t 0 )
.ab82	20 f0 af	jsr $aff0			jsr ed_last_line	; ( addr-t u-t 0 para1 )
.ab85	20 ad e1	jsr $e1ad			jsr Swap		; ( addr-t u-t para1 0 )
.ab88	a9 80		lda #$80			lda #%10000000
.ab8a	05 24		ora $24				ora ed_flags
.ab8c	85 24		sta $24				sta ed_flags
.ab8e	a5 06		lda $06				lda ciblen
.ab90	c9 01		cmp #$01			cmp #1			; sets Z if A was 1
.ab92	d0 03		bne $ab97			bne +
.ab94	4c f9 ab	jmp $abf9			jmp _line_number_only_from_external
.ab97					+
.ab97	a0 01		ldy #$01			ldy #1
.ab99	4c c1 ac	jmp $acc1			jmp _check_command
.ab9c					_prefix_percent:
.ab9c	c9 25		cmp #$25			cmp #'%'
.ab9e	f0 04		beq $aba4			beq _whole_text
.aba0	c9 2c		cmp #$2c			cmp #','
.aba2	d0 1b		bne $abbf			bne _prefix_semicolon
.aba4					_whole_text:
.aba4	20 c3 af	jsr $afc3			jsr ed_have_text
.aba7	a9 01		lda #$01			lda #1
.aba9	95 28		sta $28,x			sta DStack+2,x		; LSB of NOS is para 1
.abab	a9 00		lda #$00			lda #0
.abad	95 29		sta $29,x			sta DStack+3,x		; ( addr-t u-t para1 0 )
.abaf					_semicolon_entry:
.abaf	e8		inx				inx
.abb0	e8		inx				inx			; DROP ( addr-t u-t para1 )
.abb1	20 f0 af	jsr $aff0			jsr ed_last_line	  ; ( addr-t u-t para1 para2 )
.abb4	a9 80		lda #$80			lda #%10000000
.abb6	05 24		ora $24				ora ed_flags
.abb8	85 24		sta $24				sta ed_flags
.abba	a0 01		ldy #$01			ldy #1
.abbc	4c c1 ac	jmp $acc1			jmp _check_command
.abbf					_prefix_semicolon:
.abbf	c9 3b		cmp #$3b			cmp #';'
.abc1	d0 0e		bne $abd1			bne _prefix_number
.abc3	20 c3 af	jsr $afc3			jsr ed_have_text
.abc6	a5 22		lda $22				lda ed_cur
.abc8	95 28		sta $28,x			sta DStack+2,x
.abca	a5 23		lda $23				lda ed_cur+1
.abcc	95 29		sta $29,x			sta DStack+3,x		; ( addr-t u-t cur 0 )
.abce	4c af ab	jmp $abaf			jmp _semicolon_entry
.abd1					_prefix_number:
.abd1	20 6b c9	jsr $c96b			jsr Zero
.abd4	20 6b c9	jsr $c96b			jsr Zero		; ( addr-t u-t 0 0 0 0 )
.abd7	a5 04		lda $04				lda cib+0
.abd9	a4 05		ldy $05				ldy cib+1
.abdb	20 2e c9	jsr $c92e			jsr PushYA
.abde	a5 06		lda $06				lda ciblen+0
.abe0	a4 07		ldy $07				ldy ciblen+1
.abe2	20 2e c9	jsr $c92e			jsr PushYA		; ( addr-t u-t 0 0 0 0 cib ciblen )
.abe5	20 b4 c1	jsr $c1b4			jsr To_Number		; ( addr-t u-t 0 0 ud addr2 u2 )
.abe8	b5 26		lda $26,x			lda DStack+0,x
.abea	15 27		ora $27,x			ora DStack+1,x
.abec	d0 25		bne $ac13			bne _have_unconverted_chars
.abee	20 04 d7	jsr $d704			jsr Two_Drop		; ( addr-t u-t 0 0 ud )
.abf1	20 b2 d1	jsr $d1b2			jsr D_To_S		; ( addr-t u-t 0 0 u )
.abf4	20 90 e0	jsr $e090			jsr Not_Rot		; ( addr-t u-t u 0 0 )
.abf7	e8		inx				inx
.abf8	e8		inx				inx			; ( addr-t u-t u 0 ) drop through
.abf9					_line_number_only_from_external:
.abf9	20 ad e1	jsr $e1ad			jsr Swap		; ( addr-t u-t 0 u )
.abfc	20 cf af	jsr $afcf			jsr ed_is_valid_line
.abff	b0 03		bcs $ac04			bcs +
.ac01	4c a2 af	jmp $afa2			jmp ed_error_2drop
.ac04					+
.ac04	20 ad e1	jsr $e1ad			jsr Swap		; ( addr-t u-t u 0 )
.ac07	20 2f b0	jsr $b02f			jsr ed_para1_to_cur
.ac0a	a9 80		lda #$80			lda #%10000000
.ac0c	05 24		ora $24				ora ed_flags
.ac0e	85 24		sta $24				sta ed_flags
.ac10	4c 8d ae	jmp $ae8d			jmp ed_cmd_p_from_external
.ac13					_have_unconverted_chars:
.ac13	a5 06		lda $06				lda ciblen+0
.ac15	d5 26		cmp $26,x			cmp DStack+0,x
.ac17	d0 16		bne $ac2f			bne _no_command_yet
.ac19	a5 07		lda $07				lda ciblen+1
.ac1b	d5 27		cmp $27,x			cmp DStack+1,x
.ac1d	d0 10		bne $ac2f			bne _no_command_yet
.ac1f	8a		txa				txa
.ac20	18		clc				clc
.ac21	69 08		adc #$08			adc #8
.ac23	aa		tax				tax			; ( addr-t u-t 0 0 )
.ac24	a9 7f		lda #$7f			lda #$ff-%10000000
.ac26	25 24		and $24				and ed_flags
.ac28	85 24		sta $24				sta ed_flags
.ac2a	a0 00		ldy #$00			ldy #0
.ac2c	4c c1 ac	jmp $acc1			jmp _check_command
.ac2f					_no_command_yet:
.ac2f	20 fa e0	jsr $e0fa			jsr To_R		; >R ( ... 0 0 ud addr2 ) (R: u2)
.ac32	20 90 e0	jsr $e090			jsr Not_Rot		; -ROT ( ... 0 0 addr2 ud ) (R: u2)
.ac35	20 b2 d1	jsr $d1b2			jsr D_To_S		; D>S  ( ... 0 0 addr2 para1 ) (R: u2)
.ac38	b5 26		lda $26,x			lda DStack+0,x		; LSB
.ac3a	95 2c		sta $2c,x			sta DStack+6,x
.ac3c	b5 27		lda $27,x			lda DStack+1,x		; MSB
.ac3e	95 2d		sta $2d,x			sta DStack+7,x		; ( ... para1 0 addr2 para1 ) (R: u2)
.ac40	e8		inx				inx
.ac41	e8		inx				inx			; ( addr-t u-t para1 0 addr2 ) (R: u2)
.ac42	20 18 e1	jsr $e118			jsr R_From		; R> ( addr-t u-t para1 0 addr2 u2 ) fall through
.ac45	a9 80		lda #$80			lda #%10000000
.ac47	05 24		ora $24				ora ed_flags
.ac49	85 24		sta $24				sta ed_flags
.ac4b					_check_for_para2:
.ac4b	a1 28		lda ($28,x)			lda (DStack+2,x)
.ac4d	c9 2c		cmp #$2c			cmp #','
.ac4f	f0 0c		beq $ac5d			beq _got_comma
.ac51	38		sec				sec
.ac52	a5 06		lda $06				lda ciblen
.ac54	f5 26		sbc $26,x			sbc DStack+0,x
.ac56	a8		tay				tay
.ac57	20 04 d7	jsr $d704			jsr Two_Drop		; Remove the leftover stuff from >NUMBER
.ac5a	4c c1 ac	jmp $acc1			jmp _check_command
.ac5d					_got_comma:
.ac5d	20 42 dc	jsr $dc42			jsr NOS_One_Plus	; ( addr-t u-t para1 0 addr2+1 u2 )
.ac60	20 11 dc	jsr $dc11			jsr One_Minus		; ( addr-t u-t para1 0 addr2+1 u2-1 )
.ac63	a1 28		lda ($28,x)			lda (DStack+2,x)
.ac65	c9 24		cmp #$24			cmp #'$'
.ac67	d0 16		bne $ac7f			bne _para2_not_dollar
.ac69	38		sec				sec
.ac6a	a5 06		lda $06				lda ciblen
.ac6c	f5 28		sbc $28,x			sbc DStack+2,x
.ac6e	a8		tay				tay
.ac6f	c8		iny				iny
.ac70	98		tya				tya
.ac71	48		pha				pha
.ac72	8a		txa				txa
.ac73	18		clc				clc
.ac74	69 06		adc #$06			adc #6
.ac76	aa		tax				tax			; ( addr-t u-t para1 )
.ac77	20 f0 af	jsr $aff0			jsr ed_last_line	  ; ( addr-t u-t para1 para2 )
.ac7a	68		pla				pla
.ac7b	a8		tay				tay
.ac7c	4c c1 ac	jmp $acc1			jmp _check_command
.ac7f					_para2_not_dollar:
.ac7f	20 fa e0	jsr $e0fa			jsr To_R		; >R ( ... para1 0 addr2+1 ) (R: u2-1)
.ac82	20 6b c9	jsr $c96b			jsr Zero		; 0 ( ... para1 0 addr2+1 0 ) (R: u2-1)
.ac85	20 6b c9	jsr $c96b			jsr Zero		; 0 ( ... para1 0 addr2+1 0 0 ) (R: u2-1)
.ac88	20 6b e0	jsr $e06b			jsr Rot		; ROT ( ... para1 0 0 0 addr2+1 ) (R: u2-1)
.ac8b	20 18 e1	jsr $e118			jsr R_From		; R> ( ... para1 0 0 0 addr2+1 u2-1)
.ac8e	20 8a e1	jsr $e18a			jsr Dup		; DUP ( ... para1 0 0 0 addr2+1 u2-1 u2-1)
.ac91	20 fa e0	jsr $e0fa			jsr To_R		; >R ( ... para1 0 0 0 addr2+1 u2-1 ) (R: u2-1)
.ac94	20 b4 c1	jsr $c1b4			jsr To_Number	; >NUMBER ( ... para1 0 ud addr3 u3 ) (R: u2-1)
.ac97	20 8a e1	jsr $e18a			jsr Dup		; DUP ( ... para1 0 ud addr3 u3 u3 ) (R: u2-1)
.ac9a	20 18 e1	jsr $e118			jsr R_From		; R> ( ... para1 0 ud addr3 u3 u3 u2-1 )
.ac9d	20 10 da	jsr $da10			jsr Equal		; = ( ... para1 0 ud addr3 u3 f )
.aca0	b5 26		lda $26,x			lda DStack+0,x
.aca2	15 27		ora $27,x			ora DStack+1,x
.aca4	f0 08		beq $acae			beq _second_number
.aca6	8a		txa				txa
.aca7	18		clc				clc
.aca8	69 0c		adc #$0c			adc #12
.acaa	aa		tax				tax			; back to ( addr-t u-t )
.acab	4c a6 af	jmp $afa6			jmp ed_error
.acae					_second_number:
.acae	e8		inx				inx
.acaf	e8		inx				inx			; ( addr-t u-t para1 0 ud addr3 u3 )
.acb0	38		sec				sec
.acb1	a5 06		lda $06				lda ciblen
.acb3	f5 26		sbc $26,x			sbc DStack+0,x
.acb5	48		pha				pha
.acb6	20 04 d7	jsr $d704			jsr Two_drop		; 2DROP ( addr-t u-t para1 0 ud )
.acb9	20 b2 d1	jsr $d1b2			jsr D_To_S		; D>S  ( addr-t u-t para1 0 para2 )
.acbc	20 5f db	jsr $db5f			jsr Nip			; NIP ( addr-t u-t para1 para2 )
.acbf	68		pla				pla
.acc0	a8		tay				tay
.acc1					_check_command:
.acc1	24 24		bit $24				bit ed_flags
.acc3	30 08		bmi $accd			bmi _check_command_have_arg
.acc5	a5 22		lda $22				lda ed_cur+0
.acc7	95 28		sta $28,x			sta DStack+2,x
.acc9	a5 23		lda $23				lda ed_cur+1
.accb	95 29		sta $29,x			sta DStack+3,x
.accd					_check_command_have_arg:
.accd	b1 04		lda ($04),y			lda (cib),y		; get mystery char from input
.accf	85 14		sta $14				sta tmp1+0
.acd1	85 15		sta $15				sta tmp1+1		; We need X for awhile, so it has to
.acd3	a2 ff		ldx #$ff			ldx #$ff		; for each char
.acd5	e8		inx		_cmd_loop:	inx			;   next char
.acd6	bd 53 b0	lda $b053,x			lda ed_cmd_list,x
.acd9	f0 13		beq $acee			beq _illegal_command	;   end of list?
.acdb	c5 14		cmp $14				cmp tmp1+0
.acdd	d0 f6		bne $acd5			bne _cmd_loop		;   not found?
.acdf	8a		txa				txa
.ace0	0a		asl a				asl
.ace1	aa		tax				tax			; X * 2 for table
.ace2	bd 5f b0	lda $b05f,x			lda ed_cmd_table+1,x
.ace5	48		pha				pha
.ace6	bd 5e b0	lda $b05e,x			lda ed_Cmd_table+0,x
.ace9	48		pha				pha
.acea	a6 15		ldx $15				ldx tmp1+1		; restore X
.acec	08		php				php
.aced	40		rti				rti			; jump to command routine
.acee					_illegal_command:
.acee	4c a2 af	jmp $afa2			jmp ed_error_2drop
.acf1					ed_next_command:
.acf1	20 04 d7	jsr $d704			jsr Two_Drop		; ( addr-t u-t ) Fall through
.acf4					_next_command_empty:
.acf4	4c 0f ab	jmp $ab0f			jmp ed_input_loop
.acf7					ed_all_done:
.acf7	a9 00		lda #$00			lda #0
.acf9	85 06		sta $06				sta ciblen
.acfb	85 07		sta $07				sta ciblen+1
.acfd	20 04 d7	jsr $d704			jsr Two_drop			; ( addr-t u-t )
.ad00	a5 25		lda $25				lda editor3+1
.ad02	8d 00 03	sta $0300			sta base
.ad05	60		rts				rts
.ad06					ed_cmd_a:
.ad06	e8		inx				inx
.ad07	e8		inx				inx			;  DROP ( addr-t u-t para1 )
.ad08					ed_entry_cmd_i:
.ad08					ed_cmd_a_have_para:
.ad08	20 14 b0	jsr $b014			jsr ed_num_to_addr	  ;  ( addr-t u-t addr1 )
.ad0b	20 b7 bc	jsr $bcb7			jsr CR
.ad0e					_next_string_loop:
.ad0e	20 b4 af	jsr $afb4			jsr ed_get_input
.ad11	a0 00		ldy #$00			ldy #0
.ad13	b1 04		lda ($04),y			lda (cib),y
.ad15	c9 2e		cmp #$2e			cmp #'.'
.ad17	d0 18		bne $ad31			bne _add_line
.ad19	a4 06		ldy $06				ldy ciblen
.ad1b	c0 01		cpy #$01			cpy #1
.ad1d	d0 12		bne $ad31			bne _add_line
.ad1f	a4 07		ldy $07				ldy ciblen+1
.ad21	d0 0e		bne $ad31			bne _add_line
.ad23	e8		inx				inx
.ad24	e8		inx				inx
.ad25	a9 40		lda #$40			lda #%01000000
.ad27	05 24		ora $24				ora ed_flags
.ad29	85 24		sta $24				sta ed_flags
.ad2b	20 b7 bc	jsr $bcb7			jsr CR
.ad2e	4c 0f ab	jmp $ab0f			jmp ed_input_loop
.ad31					_add_line:
.ad31	20 8a e1	jsr $e18a			jsr Dup			; ( addr-t u-t addr1 addr1 )
.ad34	20 04 dc	jsr $dc04			jsr Here		; ( addr-t u-t addr1 addr1 here )
.ad37	20 ad e1	jsr $e1ad			jsr Swap		; ( addr-t u-t addr1 here addr1 )
.ad3a	20 b2 e0	jsr $e0b2			jsr Fetch		; ( addr-t u-t addr1 here addr2 )
.ad3d	20 f3 de	jsr $def3			jsr Comma		; ( addr-t u-t addr1 here )
.ad40	20 bb de	jsr $debb			jsr Tuck		; TUCK ( addr-t u-t here addr1 here )
.ad43	20 ad e1	jsr $e1ad			jsr Swap		; ( addr-t u-t here here addr1 )
.ad46	20 cb e0	jsr $e0cb			jsr Store		; ( addr-t u-t here )
.ad49	20 04 dc	jsr $dc04			jsr Here		; HERE ( addr-t u-t here here2)
.ad4c	a9 04		lda #$04			lda #4
.ad4e	20 45 d2	jsr $d245			jsr Allot_ZA
.ad51	e6 22		inc $22				inc ed_cur
.ad53	d0 02		bne $ad57			bne +
.ad55	e6 23		inc $23				inc ed_cur+1
.ad57					+
.ad57	20 04 dc	jsr $dc04			jsr Here	; ( addr-t u-t here here2 here3 )
.ad5a	a5 04		lda $04				lda cib+0
.ad5c	a4 05		ldy $05				ldy cib+1
.ad5e	20 2e c9	jsr $c92e			jsr PushYA	; ( addr-t u-t here here2 here3 cib )
.ad61	20 61 e1	jsr $e161			jsr Over	; ( addr-t u-t here here2 here3 cib here3 )
.ad64	a5 06		lda $06				lda ciblen+0
.ad66	a4 07		ldy $07				ldy ciblen+1
.ad68	20 2e c9	jsr $c92e			jsr PushYA	; ( addr-t u-t here here2 here3 cib here3 ciblen )
.ad6b	20 df be	jsr $bedf			jsr Move	; ( addr-t u-t here here2 here3 )
.ad6e	18		clc				clc
.ad6f	a5 00		lda $00				lda cp
.ad71	65 06		adc $06				adc ciblen
.ad73	85 00		sta $00				sta cp
.ad75	90 06		bcc $ad7d			bcc +
.ad77	a5 01		lda $01				lda cp+1
.ad79	65 07		adc $07				adc ciblen+1
.ad7b	85 01		sta $01				sta cp+1
.ad7d					+
.ad7d	20 61 e1	jsr $e161			jsr Over		; ( addr-t u-t here here2 here3 here2 )
.ad80	20 cb e0	jsr $e0cb			jsr Store		; ( addr-t u-t here here2 )
.ad83	20 d8 db	jsr $dbd8			jsr Cell_Plus		; ( addr-t u-t here here2+2 )
.ad86	20 8a e1	jsr $e18a			jsr Dup			; ( addr-t u-t here here2+2 here2+2 )
.ad89	a5 06		lda $06				lda ciblen
.ad8b	95 28		sta $28,x			sta DStack+2,x
.ad8d	a5 07		lda $07				lda ciblen+1
.ad8f	95 29		sta $29,x			sta DStack+3,x		; ( addr-t u-t here ciblen here2+2 )
.ad91	20 cb e0	jsr $e0cb			jsr Store		; ( addr-t u-t here )
.ad94	20 b7 bc	jsr $bcb7			jsr CR			; Add a line feed for visuals
.ad97	4c 0e ad	jmp $ad0e			jmp _next_string_loop
.ad9a					ed_cmd_d:
.ad9a	20 c3 af	jsr $afc3			jsr ed_have_text
.ad9d	20 06 b0	jsr $b006			jsr ed_no_line_zero
.ada0	b5 26		lda $26,x			lda DStack+0,x
.ada2	15 27		ora $27,x			ora DStack+1,x
.ada4	d0 09		bne $adaf			bne +
.ada6	20 61 e1	jsr $e161			jsr Over		; ( addr-t u-t para1 0 para1 )
.ada9	20 e4 ad	jsr $ade4			jsr _cmd_d_common	; ( addr-t u-t para1 0 )
.adac	4c d8 ad	jmp $add8			jmp _cmd_d_done
.adaf					+
.adaf	20 cf af	jsr $afcf			jsr ed_is_valid_line	  ; result is in C flag
.adb2	b0 03		bcs $adb7			bcs _cmd_d_loop
.adb4	4c a2 af	jmp $afa2			jmp ed_error_2drop
.adb7					_cmd_d_loop:
.adb7	b5 26		lda $26,x			lda DStack+0,x		; para1 > para2 ?
.adb9	d5 28		cmp $28,x			cmp DStack+2,x
.adbb	b5 27		lda $27,x			lda DStack+1,x
.adbd	f5 29		sbc $29,x			sbc DStack+3,x
.adbf	90 0c		bcc $adcd			bcc _cmd_d_done_with_flag
.adc1	20 8a e1	jsr $e18a			jsr Dup		; DUP ( addr-t u-t para1 para2 para2 )
.adc4	20 e4 ad	jsr $ade4			jsr _cmd_d_common	; ( addr-t u-t para1 para2 )
.adc7	20 11 dc	jsr $dc11			jsr One_minus	; 1- ( addr-t u-t para1 para2-1 )
.adca	4c b7 ad	jmp $adb7			jmp _cmd_d_loop
.adcd					_cmd_d_done_with_flag:
.adcd	20 1e dc	jsr $dc1e			jsr NOS_One_Minus
.add0	b5 28		lda $28,x			lda DStack+2,x
.add2	85 22		sta $22				sta ed_cur
.add4	b5 29		lda $29,x			lda DStack+3,x
.add6	85 23		sta $23				sta ed_cur+1		; drop through to _cmd_d_done
.add8					_cmd_d_done:
.add8	a9 40		lda #$40			lda #%01000000
.adda	05 24		ora $24				ora ed_flags
.addc	85 24		sta $24				sta ed_flags
.adde	20 b7 bc	jsr $bcb7			jsr CR
.ade1	4c f1 ac	jmp $acf1			jmp ed_next_command
.ade4					_cmd_d_common:
.ade4	20 8a e1	jsr $e18a			jsr Dup			; ( addr-t u-t u u )
.ade7	20 14 b0	jsr $b014			jsr ed_num_to_addr	; ( addr-t u-t u addr )
.adea	20 b2 e0	jsr $e0b2			jsr Fetch		; ( addr-t u-t u addr1 )
.aded	20 ad e1	jsr $e1ad			jsr Swap		; ( addr-t u-t addr1 u )
.adf0	20 11 dc	jsr $dc11			jsr One_minus		; ( addr-t u-t addr1 u-1 )
.adf3	20 14 b0	jsr $b014			jsr ed_num_to_addr	; ( addr-t u-t addr1 addr-1 )
.adf6	4c cb e0	jmp $e0cb			jmp Store		; ( addr-t u-t )
.adf9					ed_cmd_equ:
.adf9	a5 20		lda $20				lda ed_head
.adfb	05 21		ora $21				ora ed_head+1
.adfd	d0 06		bne $ae05			bne _cmd_equ_have_text
.adff	20 6b c9	jsr $c96b			jsr Zero		; ( addr-t u-t para1 para2 0 )
.ae02	4c 25 ae	jmp $ae25			jmp _cmd_equ_done
.ae05					_cmd_equ_have_text:
.ae05	20 06 b0	jsr $b006			jsr ed_no_line_zero
.ae08	24 24		bit $24				bit ed_flags
.ae0a	30 0a		bmi $ae16			bmi _cmd_equ_have_para
.ae0c	a5 22		lda $22				lda ed_cur+0		; ( addr-t u-t para1 para2 ? )
.ae0e	a4 23		ldy $23				ldy ed_cur+1
.ae10	20 2e c9	jsr $c92e			jsr PushYA
.ae13	4c 25 ae	jmp $ae25			jmp _cmd_equ_done	; ( addr-t u-t para1 para2 cur )
.ae16					_cmd_equ_have_para:
.ae16	b5 26		lda $26,x			lda DStack+0,x
.ae18	15 27		ora $27,x			ora DStack+1,x
.ae1a	d0 06		bne $ae22			bne _cmd_equ_two_paras
.ae1c	20 61 e1	jsr $e161			jsr Over		; ( addr-t u-t para1 para2 para1)
.ae1f	4c 25 ae	jmp $ae25			jmp _cmd_equ_done
.ae22					_cmd_equ_two_paras:
.ae22	20 8a e1	jsr $e18a			jsr Dup			; ( addr-t u-t para1 para2 para2) drop through
.ae25					_cmd_equ_done:
.ae25	20 b7 bc	jsr $bcb7			jsr CR			; number goes on new line
.ae28	20 f3 dd	jsr $ddf3			jsr U_Dot		; ( addr-t u-t para1 para2 )
.ae2b	20 b7 bc	jsr $bcb7			jsr CR
.ae2e	4c f1 ac	jmp $acf1			jmp ed_next_command
.ae31					ed_cmd_f:
.ae31	24 24		bit $24				bit ed_flags
.ae33	30 18		bmi $ae4d			bmi _cmd_f_have_para
.ae35	20 b7 bc	jsr $bcb7			jsr CR
.ae38	20 fa e0	jsr $e0fa			jsr To_R		; ( addr-t u-t 0 ) ( R: 0 )
.ae3b	20 6b e0	jsr $e06b			jsr Rot			; ( u-t 0 addr-t ) ( R: 0 )
.ae3e	20 8a e1	jsr $e18a			jsr Dup			; ( u-t 0 addr-t addr-t ) ( R: 0 )
.ae41	20 f3 dd	jsr $ddf3			jsr U_Dot		; ( u-t 0 addr-t ) ( R: 0 )
.ae44	20 90 e0	jsr $e090			jsr Not_Rot		; ( addr-t u-t 0 ) ( R: 0 )
.ae47	20 18 e1	jsr $e118			jsr R_From		; ( addr-t u-t 0 0 )
.ae4a	4c 5e ae	jmp $ae5e			jmp _cmd_f_done
.ae4d					_cmd_f_have_para:
.ae4d	20 61 e1	jsr $e161			jsr Over
.ae50	20 b7 bc	jsr $bcb7			jsr CR
.ae53	20 f3 dd	jsr $ddf3			jsr U_Dot
.ae56	b5 28		lda $28,x			lda DStack+2,x
.ae58	95 2c		sta $2c,x			sta DStack+6,x
.ae5a	b5 29		lda $29,x			lda DStack+3,x
.ae5c	95 2d		sta $2d,x			sta DStack+7,x		; fall through to _cmd_f_done
.ae5e					_cmd_f_done:
.ae5e	20 b7 bc	jsr $bcb7			jsr CR
.ae61	4c f1 ac	jmp $acf1			jmp ed_next_command
.ae64					ed_cmd_i:
.ae64	e8		inx				inx
.ae65	e8		inx				inx			;  DROP ( addr-t u-t para1 )
.ae66	24 24		bit $24				bit ed_flags
.ae68	30 08		bmi $ae72			bmi _cmd_i_have_para
.ae6a	a5 22		lda $22				lda ed_cur
.ae6c	95 26		sta $26,x			sta DStack+0,x
.ae6e	a5 23		lda $23				lda ed_cur+1
.ae70	95 27		sta $27,x			sta DStack+1,x		;  ( addr-t u-t cur ) drop through
.ae72					_cmd_i_have_para:
.ae72	b5 26		lda $26,x			lda DStack+0,x
.ae74	15 27		ora $27,x			ora DStack+1,x
.ae76	f0 09		beq $ae81			beq _cmd_i_done
.ae78	20 11 dc	jsr $dc11			jsr One_minus		; ( addr-t u-t para1-1 )
.ae7b	20 6b c9	jsr $c96b			jsr Zero		; ( addr-t u-t para1-1 0 )
.ae7e	20 45 db	jsr $db45			jsr Max			; ( addr-t u-t para1-1 | 0 )
.ae81					_cmd_i_done:
.ae81	4c 08 ad	jmp $ad08			jmp ed_entry_cmd_i
.ae84					ed_cmd_n:
.ae84	a9 01		lda #$01			lda #%00000001
.ae86	05 24		ora $24				ora ed_flags
.ae88	85 24		sta $24				sta ed_flags
.ae8a	4c 93 ae	jmp $ae93			jmp ed_cmd_p_entry_for_cmd_n
.ae8d					ed_cmd_p:
.ae8d					ed_cmd_p_from_external:
.ae8d	a9 fe		lda #$fe			lda #$ff-%00000001
.ae8f	25 24		and $24				and ed_flags
.ae91	85 24		sta $24				sta ed_flags
.ae93					ed_cmd_p_entry_for_cmd_n:
.ae93	20 c3 af	jsr $afc3			jsr ed_have_text
.ae96	20 06 b0	jsr $b006			jsr ed_no_line_zero
.ae99	20 b7 bc	jsr $bcb7			jsr CR
.ae9c	b5 26		lda $26,x			lda DStack+0,x
.ae9e	15 27		ora $27,x			ora DStack+1,x
.aea0	d0 11		bne $aeb3			bne _cmd_p_loop
.aea2	b5 28		lda $28,x			lda DStack+2,x
.aea4	85 22		sta $22				sta ed_cur
.aea6	b5 29		lda $29,x			lda DStack+3,x
.aea8	85 23		sta $23				sta ed_cur+1
.aeaa	20 61 e1	jsr $e161			jsr Over		; ( addr-t u-t para1 para2 para1 )
.aead	20 d4 ae	jsr $aed4			jsr _cmd_p_common	; ( addr-t u-t para1 para2 )
.aeb0	4c d1 ae	jmp $aed1			jmp _cmd_p_all_done
.aeb3					_cmd_p_loop:
.aeb3	b5 26		lda $26,x			lda DStack+0,x		; para1 > para2 ?
.aeb5	d5 28		cmp $28,x			cmp DStack+2,x
.aeb7	b5 27		lda $27,x			lda DStack+1,x
.aeb9	f5 29		sbc $29,x			sbc DStack+3,x
.aebb	90 0c		bcc $aec9			bcc _cmd_p_done
.aebd	20 61 e1	jsr $e161			jsr Over		; ( addr-t u-t para1 para2 para1 )
.aec0	20 d4 ae	jsr $aed4			jsr _cmd_p_common	; ( addr-t u-t para1 para2 )
.aec3	20 42 dc	jsr $dc42			jsr NOS_One_Plus
.aec6	4c b3 ae	jmp $aeb3			jmp _cmd_p_loop
.aec9					_cmd_p_done:
.aec9	b5 26		lda $26,x			lda DStack+0,x
.aecb	85 22		sta $22				sta ed_cur
.aecd	b5 27		lda $27,x			lda DStack+1,x
.aecf	85 23		sta $23				sta ed_cur+1
.aed1					_cmd_p_all_done:
.aed1	4c f1 ac	jmp $acf1			jmp ed_next_command
.aed4					_cmd_p_common:
.aed4	a5 24		lda $24				lda ed_flags
.aed6	4a		lsr a				lsr			; bit 0 now in carry
.aed7	90 0b		bcc $aee4			bcc _cmd_p_common_no_num
.aed9	20 8a e1	jsr $e18a			jsr Dup			; ( addr-t u-t para1 para1 )
.aedc	20 f3 dd	jsr $ddf3			jsr U_Dot		; ( addr-t u-t para1 )
.aedf	a9 09		lda #$09			lda #AscHT
.aee1	20 cd df	jsr $dfcd			jsr Emit_A
.aee4					_cmd_p_common_no_num:
.aee4	20 14 b0	jsr $b014			jsr ed_num_to_addr	  ; ( addr-t u-t addr )
.aee7	4c 38 b0	jmp $b038			jmp ed_print_addr
.aeea					ed_cmd_q:
.aeea	24 24		bit $24				bit ed_flags		; bit 6 is change flag
.aeec	50 03		bvc $aef1			bvc +
.aeee	4c a2 af	jmp $afa2			jmp ed_error_2drop
.aef1					+
.aef1	4c f7 ac	jmp $acf7			jmp ed_all_done		   ; can't fall thru because of PLX
.aef4					ed_cmd_qq:
.aef4	4c f7 ac	jmp $acf7			jmp ed_all_done
.aef7					ed_cmd_w:
.aef7	20 c3 af	jsr $afc3			jsr ed_have_text
.aefa	24 24		bit $24				bit ed_flags		; parameter given?
.aefc	30 12		bmi $af10			bmi _cmd_w_have_para
.aefe	b5 2d		lda $2d,x			lda DStack+7,x		; $0000 thru $00ff ?
.af00	d0 03		bne $af05			bne +
.af02	4c a2 af	jmp $afa2			jmp ed_error_2drop
.af05					+
.af05	b5 2c		lda $2c,x			lda DStack+6,x
.af07	95 28		sta $28,x			sta DStack+2,x
.af09	b5 2d		lda $2d,x			lda DStack+7,x
.af0b	95 29		sta $29,x			sta DStack+3,x		; ( addr-t u-t addr-t ? )
.af0d	4c 18 af	jmp $af18			jmp _cmd_w_para_ready
.af10					_cmd_w_have_para:
.af10	b5 28		lda $28,x			lda DStack+2,x
.af12	95 2c		sta $2c,x			sta DStack+6,x
.af14	b5 29		lda $29,x			lda DStack+3,x
.af16	95 2d		sta $2d,x			sta DStack+7,x		; drop through to _cmd_w_para_ready
.af18					_cmd_w_para_ready:
.af18	a9 20		lda #$20			lda #<ed_head
.af1a	95 26		sta $26,x			sta DStack+0,x
.af1c	a9 00		lda #$00			lda #>ed_head
.af1e	95 27		sta $27,x			sta DStack+1,x		; ( addr-t u-t addr-t addr-h )
.af20	20 61 e1	jsr $e161			jsr Over		; ( addr-t u-t addr-t addr-h addr-t )
.af23	20 fa e0	jsr $e0fa			jsr To_R		; ( addr-t u-t addr-t addr-h ) ( R: addr-t )
.af26					_cmd_w_loop:
.af26	20 b2 e0	jsr $e0b2			jsr Fetch		; ( addr-t u-t addr-t addr1 ) ( R: addr-t )
.af29	b5 26		lda $26,x			lda DStack+0,x
.af2b	15 27		ora $27,x			ora DStack+1,x
.af2d	f0 4d		beq $af7c			beq _cmd_w_eol
.af2f	20 97 de	jsr $de97			jsr Two_dup		; ( addr-t addr-1 addr-t addr-1 ) ( R: addr-t addr-1 addr-t )
.af32	20 36 d8	jsr $d836			jsr Two_to_r		; ( addr-t addr-1 ) (R: ... )
.af35	20 d8 db	jsr $dbd8			jsr Cell_Plus		; ( addr-t addr1+2 ) (R: ... )
.af38	20 8a e1	jsr $e18a			jsr Dup			; ( addr-t addr1+2 addr1+2 ) ( R: ... )
.af3b	20 b2 e0	jsr $e0b2			jsr Fetch		; ( addr-t addr1+2 addr-s ) ( R: ... )
.af3e	20 ad e1	jsr $e1ad			jsr Swap		; ( addr-t addr-s addr1+2 ) ( R: ... )
.af41	20 d8 db	jsr $dbd8			jsr Cell_Plus		; ( addr-t addr-s addr1+2 ) (R: ... )
.af44	20 b2 e0	jsr $e0b2			jsr Fetch		; ( addr-t addr-s u-s ) ( R: ... )
.af47	20 90 e0	jsr $e090			jsr Not_Rot		; ( u-s addr-t addr-s ) ( R: ... )
.af4a	20 ad e1	jsr $e1ad			jsr Swap		; ( u-s addr-s addr-t ) ( R: ... )
.af4d	20 6b e0	jsr $e06b			jsr Rot			; (addr-s addr-t u-s ) ( R: ... )
.af50	20 8a e1	jsr $e18a			jsr Dup			; (addr-s addr-t u-s u-s ) ( R: ... )
.af53	20 fa e0	jsr $e0fa			jsr To_R		; (addr-s addr-t u-s ) ( R: ... u-s )
.af56	20 df be	jsr $bedf			jsr Move		; ( )( R: addr-t addr-1 addr-t )
.af59	20 18 e1	jsr $e118			jsr R_From		; ( u-s )  ( R: addr-t addr-h addr-t )
.af5c	20 12 d8	jsr $d812			jsr Two_r_from		; ( u-s addr-t addr-h ) ( R: addr-t )
.af5f	20 90 e0	jsr $e090			jsr Not_Rot		; ( addr-h u-s addr-t ) ( R: addr-t )
.af62	20 90 dd	jsr $dd90			jsr Plus		; ( addr-h addr-t1 ) ( R: addr-t )
.af65	20 8a e1	jsr $e18a			jsr Dup			; ( addr-h addr-t1 addr-t1 ) ( R: addr-t )
.af68	a9 0a		lda #$0a			lda #AscLF
.af6a	20 5d c9	jsr $c95d			jsr PushZA		; ( addr-h addr-t1 addr-t1 c ) ( R: addr-t )
.af6d	20 ad e1	jsr $e1ad			jsr Swap		; ( addr-h addr-t1 c addr-t1 ) ( R: addr-t )
.af70	20 cb e0	jsr $e0cb			jsr Store		; ( addr-h addr-t1 ) ( R: addr-t )
.af73	20 37 dc	jsr $dc37			jsr One_plus		; ( addr-h addr-t1+1 ) ( R: addr-t )
.af76	20 ad e1	jsr $e1ad			jsr Swap		; ( addr-t1+1 addr-h ) ( R: addr-t )
.af79	4c 26 af	jmp $af26			jmp _cmd_w_loop
.af7c					_cmd_w_eol:
.af7c	20 ad e1	jsr $e1ad			jsr Swap		; ( addr-t u-t addr-n addr-tn ) ( R: addr-t )
.af7f	20 18 e1	jsr $e118			jsr R_From		; ( addr-t u-t addr-n addr-tn addr-t )
.af82	20 a9 dd	jsr $dda9			jsr Minus		; ( addr-t u-t addr-n u )
.af85	b5 26		lda $26,x			lda DStack+0,x
.af87	95 2a		sta $2a,x			sta DStack+4,x
.af89	b5 27		lda $27,x			lda DStack+1,x
.af8b	95 2b		sta $2b,x			sta DStack+5,x		; ( addr-t u addr-n u )
.af8d	20 b7 bc	jsr $bcb7			jsr CR
.af90	20 8a e1	jsr $e18a			jsr Dup			; ( addr-t u addr-n u u )
.af93	20 f3 dd	jsr $ddf3			jsr U_Dot		; ( addr-t u addr-n u )
.af96	20 b7 bc	jsr $bcb7			jsr CR
.af99	a9 bf		lda #$bf			lda #$ff-%01000000
.af9b	25 24		and $24				and ed_flags
.af9d	85 24		sta $24				sta ed_flags
.af9f	4c f1 ac	jmp $acf1			jmp ed_next_command
.afa2					ed_error_2drop:
.afa2	e8		inx				inx			; Drop para2
.afa3	e8		inx				inx
.afa4					ed_error_1drop:
.afa4	e8		inx				inx			; Drop para1
.afa5	e8		inx				inx
.afa6					ed_error:
.afa6	20 b7 bc	jsr $bcb7			jsr CR
.afa9	a9 3f		lda #$3f			lda #'?'
.afab	20 cd df	jsr $dfcd			jsr Emit_A
.afae	20 b7 bc	jsr $bcb7			jsr CR
.afb1	4c 0f ab	jmp $ab0f			jmp ed_input_loop
.afb4					ed_get_input:
.afb4	20 29 d4	jsr $d429			jsr Refill		;  ( addr-t u-t f )
.afb7	b5 26		lda $26,x			lda DStack+0,x
.afb9	d0 05		bne $afc0			bne +
.afbb	68		pla				pla
.afbc	68		pla				pla
.afbd	4c a4 af	jmp $afa4			jmp ed_error_1drop
.afc0					+
.afc0	e8		inx				inx
.afc1	e8		inx				inx
.afc2	60		rts				rts
.afc3					ed_have_text:
.afc3	a5 20		lda $20				lda ed_head
.afc5	05 21		ora $21				ora ed_head+1
.afc7	d0 05		bne $afce			bne +
.afc9	68		pla				pla
.afca	68		pla				pla
.afcb	4c a6 af	jmp $afa6			jmp ed_error
.afce					+
.afce	60		rts				rts
.afcf					ed_is_valid_line:
.afcf	38		sec				sec				; default is legal line number
.afd0	b5 26		lda $26,x			lda DStack+0,x
.afd2	15 27		ora $27,x			ora DStack+1,x
.afd4	f0 18		beq $afee			beq _nope_zero	; ( n )
.afd6	20 8a e1	jsr $e18a			jsr Dup				; ( n n )
.afd9	20 f0 af	jsr $aff0			jsr ed_last_line		; ( n n last )
.afdc	20 ad e1	jsr $e1ad			jsr Swap			; ( n last n )
.afdf	20 44 da	jsr $da44			jsr Less_Than			; ( n f )
.afe2	b5 26		lda $26,x			lda DStack+0,x			; 0 flag is good
.afe4	15 27		ora $27,x			ora DStack+1,x
.afe6	d0 04		bne $afec			bne _too_small
.afe8	e8		inx				inx
.afe9	e8		inx				inx			; DROP flag ( n )
.afea	38		sec				sec			; signal valid
.afeb	60		rts				rts
.afec					_too_small:
.afec	e8		inx				inx
.afed	e8		inx				inx
.afee					_nope_zero:
.afee	18		clc				clc			; signal not valid
.afef	60		rts				rts
.aff0					ed_last_line:
.aff0	20 6b c9	jsr $c96b			jsr Zero		; Set counter to zero
.aff3	a9 20		lda #$20			lda #ed_head
.aff5	20 5d c9	jsr $c95d			jsr PushZA		; ( count addr )
.aff8					_loop:
.aff8	20 b2 e0	jsr $e0b2			jsr Fetch		; ( count addr|0 )
.affb	b5 27		lda $27,x			lda DStack+1,x		; at end-of-list?
.affd	f0 06		beq $b005			beq _done
.afff	20 42 dc	jsr $dc42			jsr NOS_One_Plus	; Increase counter
.b002	4c f8 af	jmp $aff8			jmp _loop		; continue
.b005					_done:
.b005	60		rts				rts
.b006					ed_no_line_zero:
.b006	b5 28		lda $28,x			lda DStack+2,x
.b008	15 29		ora $29,x			ora DStack+3,x
.b00a	d0 07		bne $b013			bne _done
.b00c	24 24		bit $24				bit ed_flags
.b00e	10 03		bpl $b013			bpl _done
.b010	4c a2 af	jmp $afa2			jmp ed_error_2drop
.b013					_done:
.b013	60		rts				rts
.b014					ed_num_to_addr:
.b014	a9 20		lda #$20			lda #ed_head
.b016	20 5d c9	jsr $c95d			jsr PushZA		; ( u addr-h )
.b019	4c 26 b0	jmp $b026			jmp _test
.b01c					_loop:
.b01c	20 b2 e0	jsr $e0b2			jsr Fetch		; @ ( u addr1 )
.b01f	b5 27		lda $27,x			lda DStack+1,x		; at end of list?
.b021	f0 09		beq $b02c			beq _finished
.b023	20 1e dc	jsr $dc1e			jsr NOS_One_Minus	; decrement the line count
.b026	b5 28		lda $28,x	_test:		lda DStack+2,x		; is the nth element we're looking for?
.b028	15 29		ora $29,x			ora DStack+3,x
.b02a	d0 f0		bne $b01c			bne _loop
.b02c					_finished:
.b02c	4c 5f db	jmp $db5f			jmp Nip			; ( addr )
.b02f					ed_para1_to_cur:
.b02f	b5 28		lda $28,x			lda DStack+2,x
.b031	85 22		sta $22				sta ed_cur
.b033	b5 29		lda $29,x			lda DStack+3,x
.b035	85 23		sta $23				sta ed_cur+1
.b037	60		rts				rts
.b038					ed_print_addr:
.b038	20 d8 db	jsr $dbd8			jsr Cell_Plus		; ( addr+2 )
.b03b	20 8a e1	jsr $e18a			jsr Dup			; ( addr+2 addr+2 )
.b03e	20 d8 db	jsr $dbd8			jsr Cell_Plus		; ( addr+2 addr+4 )
.b041	20 b2 e0	jsr $e0b2			jsr Fetch		; ( addr+2 u-s )
.b044	20 ad e1	jsr $e1ad			jsr Swap		; ( u-s addr+2 )
.b047	20 b2 e0	jsr $e0b2			jsr Fetch		; ( u-s addr-s )
.b04a	20 ad e1	jsr $e1ad			jsr Swap		; ( addr-s u-s )
.b04d	20 f1 df	jsr $dff1			jsr Type
.b050	4c b7 bc	jmp $bcb7			jmp CR
>b053	61 66 69 64 70 6e 3d 77		ed_cmd_list:	.text "afidpn=wqQ", 0
>b05b	71 51 00
.b05e					ed_cmd_table:
>b05e	06 ad 31 ae 64 ae 9a ad				.word ed_cmd_a, ed_cmd_f, ed_cmd_i, ed_cmd_d, ed_cmd_p, ed_cmd_n
>b066	8d ae 84 ae
>b06a	f9 ad f7 ae ea ae f4 ae				.word ed_cmd_equ, ed_cmd_w, ed_cmd_q, ed_cmd_qq
.b072					ed6502_end:
>b072	53 65 65 4c 61 74 65 73		Name0:	.text "SeeLatest"	;  name of word as a string, ending at wh_NameLastChar
>b07a	74
=9					NameLength = *-Name0
=45051					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>b07b	89					.byte (("SeeLatest"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=1424					LinkDisplacement = Nt0-WordListLink
=$11						  WordFlags ::= WordFlags | FP
>b07c	11					.byte WordFlags	;wh_Flags
>b07d	03					.byte 3	;wh_CodeLength
>b07e	6b aa					  .word WordListLink
=$b080					XtPtr1 ::= *
=45051					WordListLink ::= Nt0 ; remember the nt of this word for later
.b080	20 e7 cb	jsr $cbe7	SeeLatest:	jsr current_to_dp
.b083	a5 10		lda $10				lda dp+0
.b085	a4 11		ldy $11				ldy dp+1
.b087	20 2e c9	jsr $c92e			jsr PushYA
.b08a	4c 97 b0	jmp $b097			jmp See3
=13					CodeLen	.var *-XtPtr1
=$b08d					Here1 = *	; remember here
>b07d	0d					.byte CodeLen	;patch wh_CodeLength
>b08d	53 65 65			Name0:	.text "See"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=45072					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>b090	a3					.byte (("See"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=21					LinkDisplacement = Nt0-WordListLink
>b091	10					.byte WordFlags	;wh_Flags
>b092	03					.byte 3	;wh_CodeLength
>b093	15					  .byte LinkDisplacement	; offset to previous nt
=$b094					XtPtr1 ::= *
=45072					WordListLink ::= Nt0 ; remember the nt of this word for later
.b094					See:
.b094	20 da cd	jsr $cdda			jsr Tick_Nt		; ( nt )
.b097	20 b7 bc	jsr $bcb7	See3:		jsr CR
.b09a	ad 00 03	lda $0300			lda base		; Save the current number base
.b09d	48		pha				pha
.b09e	a9 8d		lda #$8d			lda #<str_see_nt	; print nt
.b0a0	a0 ec		ldy #$ec			ldy #>str_see_nt
.b0a2	20 0d e0	jsr $e00d			jsr Print_ASCIIZ_YA_no_lf
.b0a5	20 8a e1	jsr $e18a			jsr Dup			; ( nt nt )
.b0a8	20 57 ba	jsr $ba57			jsr Dot_Hex
.b0ab	20 e5 df	jsr $dfe5			jsr Space		; ( nt )
.b0ae	20 8a e1	jsr $e18a			jsr Dup			; ( nt nt )
.b0b1	20 3c cf	jsr $cf3c			jsr Name_To_Int		; ( nt xt )
.b0b4	a9 93		lda #$93			lda #<str_see_xt	; print xt
.b0b6	a0 ec		ldy #$ec			ldy #>str_see_xt
.b0b8	20 0d e0	jsr $e00d			jsr Print_ASCIIZ_YA_no_lf
.b0bb	20 8a e1	jsr $e18a			jsr Dup			; ( nt xt xt )
.b0be	20 57 ba	jsr $ba57			jsr Dot_Hex
.b0c1	20 b7 bc	jsr $bcb7			jsr CR			; ( nt xt )
.b0c4	a9 86		lda #$86			lda #<str_see_flags
.b0c6	a0 ec		ldy #$ec			ldy #>str_see_flags
.b0c8	20 0d e0	jsr $e00d			jsr Print_ASCIIZ_YA_no_lf
.b0cb	20 61 e1	jsr $e161			jsr Over		; ( nt xt nt )
.b0ce	a9 81		lda #$81			lda #Wh_Flags
.b0d0	20 da db	jsr $dbda			jsr Plus_A		; ( nt xt ^flags )
.b0d3	a1 26		lda ($26,x)			lda (DStack+0,x)	; ( nt xt ^flags )
.b0d5	95 26		sta $26,x			sta DStack+0,x		; ( nt xt flags )
.b0d7	a0 0e		ldy #$0e			ldy #2*7		; for bit 7..0
.b0d9	20 e5 df	jsr $dfe5	_flag_loop:	jsr Space
.b0dc	b9 40 b1	lda $b140,y			lda _FlagLabels+0,y	;   print label
.b0df	20 cd df	jsr $dfcd			jsr Emit_A
.b0e2	b9 41 b1	lda $b141,y			lda _FlagLabels+1,y
.b0e5	20 cd df	jsr $dfcd			jsr Emit_A
.b0e8	a9 3d		lda #$3d			lda #'='
.b0ea	20 cd df	jsr $dfcd			jsr Emit_A
.b0ed	16 26		asl $26,x			asl DStack+0,x		;   c = flag, rotate the rest
.b0ef	a9 00		lda #$00			lda #0
.b0f1	69 30		adc #$30			adc #'0'
.b0f3	20 cd df	jsr $dfcd			jsr Emit_A
.b0f6	88		dey				dey
.b0f7	88		dey				dey
.b0f8	10 df		bpl $b0d9			bpl _flag_loop
.b0fa	e8		inx				inx
.b0fb	e8		inx				inx			; ( nt xt )
.b0fc	20 b7 bc	jsr $bcb7			jsr CR
.b0ff	a9 99		lda #$99			lda #<str_see_size	; print size
.b101	a0 ec		ldy #$ec			ldy #>str_see_size
.b103	20 0d e0	jsr $e00d			jsr Print_ASCIIZ_YA_no_lf
.b106	20 ad e1	jsr $e1ad			jsr Swap		; ( xt nt )
.b109	20 70 bc	jsr $bc70			jsr WordSize		; ( xt u )
.b10c	20 35 c3	jsr $c335			jsr Decimal
.b10f	b5 26		lda $26,x			lda DStack+0,x		; if = 255
.b111	c9 ff		cmp #$ff			cmp #$ff
.b113	d0 11		bne $b126			bne _size5
.b115	20 4b ca	jsr $ca4b			jsr sliteral_runtime	;   type "large"
.b118	4c 20 b1	jmp $b120			  jmp _size2
>b11b	6c 61 72 67 65					  .text "large"
.b120	20 f1 df	jsr $dff1	_size2:		jsr Type
.b123	4c 2c b1	jmp $b12c			jmp _size9		;  else
.b126	20 8a e1	jsr $e18a	_size5:		jsr Dup			;    type size
.b129	20 f3 dd	jsr $ddf3			jsr U_Dot
.b12c					_size9:
.b12c	20 b7 bc	jsr $bcb7			jsr CR
.b12f	68		pla				pla			; restore base
.b130	8d 00 03	sta $0300			sta base
.b133	20 97 de	jsr $de97			jsr Two_dup
.b136	20 b1 b9	jsr $b9b1			jsr Dump		; dump
.b139	20 b7 bc	jsr $bcb7			jsr CR
.b13c	20 19 ea	jsr $ea19			jsr DisAsm		; disassemble
=171					CodeLen	.var *-XtPtr1
=$b13f					Here1 = *	; remember here
>b092	ab					.byte CodeLen	;patch wh_CodeLength
.b13f	60		rts				rts
>b140	46 50 44 42 43 4f 49 4d		_FlagLabels:	.text "FPDBCOIMNNANUF__"
>b148	4e 4e 41 4e 55 46 5f 5f
>b150	46 6f 72 74 68 2d 57 6f		Name0:	.text "Forth-WordList"	;  name of word as a string, ending at wh_NameLastChar
>b158	72 64 4c 69 73 74
=14					NameLength = *-Name0
=45278					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>b15e	8e					.byte (("Forth-WordList"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=206					LinkDisplacement = Nt0-WordListLink
>b15f	10					.byte WordFlags	;wh_Flags
>b160	03					.byte 3	;wh_CodeLength
>b161	ce					  .byte LinkDisplacement	; offset to previous nt
=$b162					XtPtr1 ::= *
=45278					WordListLink ::= Nt0 ; remember the nt of this word for later
.b162	4c 6b c9	jmp $c96b	Forth_WordList:	jmp Zero
=3					CodeLen	.var *-XtPtr1
=$b165					Here1 = *	; remember here
>b160	03					.byte CodeLen	;patch wh_CodeLength
>b165	45 64 69 74 6f 72 2d 57		Name0:	.text "Editor-WordList"	;  name of word as a string, ending at wh_NameLastChar
>b16d	6f 72 64 4c 69 73 74
=15					NameLength = *-Name0
=45300					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>b174	8f					.byte (("Editor-WordList"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=22					LinkDisplacement = Nt0-WordListLink
>b175	10					.byte WordFlags	;wh_Flags
>b176	03					.byte 3	;wh_CodeLength
>b177	16					  .byte LinkDisplacement	; offset to previous nt
=$b178					XtPtr1 ::= *
=45300					WordListLink ::= Nt0 ; remember the nt of this word for later
.b178	4c 74 c9	jmp $c974	Editor_WordList: jmp One
=3					CodeLen	.var *-XtPtr1
=$b17b					Here1 = *	; remember here
>b176	03					.byte CodeLen	;patch wh_CodeLength
>b17b	41 73 73 65 6d 62 6c 65		Name0:	.text "Assembler-WordList"	;  name of word as a string, ending at wh_NameLastChar
>b183	72 2d 57 6f 72 64 4c 69 73 74
=18					NameLength = *-Name0
=45325					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>b18d	92					.byte (("Assembler-WordList"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=25					LinkDisplacement = Nt0-WordListLink
>b18e	10					.byte WordFlags	;wh_Flags
>b18f	03					.byte 3	;wh_CodeLength
>b190	19					  .byte LinkDisplacement	; offset to previous nt
=$b191					XtPtr1 ::= *
=45325					WordListLink ::= Nt0 ; remember the nt of this word for later
.b191	4c 7d c9	jmp $c97d	Assembler_WordList: jmp Two
=3					CodeLen	.var *-XtPtr1
=$b194					Here1 = *	; remember here
>b18f	03					.byte CodeLen	;patch wh_CodeLength
>b194	52 6f 6f 74 2d 57 6f 72		Name0:	.text "Root-Wordlist"	;  name of word as a string, ending at wh_NameLastChar
>b19c	64 6c 69 73 74
=13					NameLength = *-Name0
=45345					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>b1a1	8d					.byte (("Root-Wordlist"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=20					LinkDisplacement = Nt0-WordListLink
>b1a2	10					.byte WordFlags	;wh_Flags
>b1a3	03					.byte 3	;wh_CodeLength
>b1a4	14					  .byte LinkDisplacement	; offset to previous nt
=$b1a5					XtPtr1 ::= *
=45345					WordListLink ::= Nt0 ; remember the nt of this word for later
.b1a5	a9 03		lda #$03	Root_WordList:	lda #wid_Root
.b1a7	4c 5d c9	jmp $c95d			jmp PushZA
=5					CodeLen	.var *-XtPtr1
=$b1aa					Here1 = *	; remember here
>b1a3	05					.byte CodeLen	;patch wh_CodeLength
>b1aa	57 6f 72 64 4c 69 73 74		Name0:	.text "WordList"	;  name of word as a string, ending at wh_NameLastChar
=8					NameLength = *-Name0
=45362					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>b1b2	88					.byte (("WordList"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=17					LinkDisplacement = Nt0-WordListLink
>b1b3	10					.byte WordFlags	;wh_Flags
>b1b4	03					.byte 3	;wh_CodeLength
>b1b5	11					  .byte LinkDisplacement	; offset to previous nt
=$b1b6					XtPtr1 ::= *
=45362					WordListLink ::= Nt0 ; remember the nt of this word for later
.b1b6	ad 11 03	lda $0311	WordList:	lda Num_wordlistsV	; Get the current number of wordlists
.b1b9	c9 0c		cmp #$0c			cmp #max_wordlists	; already full?
.b1bb	b0 06		bcs $b1c3			bcs _err
.b1bd	ee 11 03	inc $0311			inc Num_WordlistsV	; increment wordlist count
.b1c0	4c 5d c9	jmp $c95d			jmp PushZA		; put it on the stack as wid.
.b1c3	a9 66		lda #$66	_err:		lda #$100+err_TooManyWordlists	;   throw an error
.b1c5	4c dc c5	jmp $c5dc			jmp ThrowA
=18					CodeLen	.var *-XtPtr1
=$b1c8					Here1 = *	; remember here
>b1b4	12					.byte CodeLen	;patch wh_CodeLength
>b1c8	44 65 66 69 6e 69 74 69		Name0:	.text "Definitions"	;  name of word as a string, ending at wh_NameLastChar
>b1d0	6f 6e 73
=11					NameLength = *-Name0
=45395					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>b1d3	6b					.byte (("Definitions"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=33					LinkDisplacement = Nt0-WordListLink
>b1d4	10					.byte WordFlags	;wh_Flags
>b1d5	03					.byte 3	;wh_CodeLength
>b1d6	21					  .byte LinkDisplacement	; offset to previous nt
=$b1d7					XtPtr1 ::= *
=45395					WordListLink ::= Nt0 ; remember the nt of this word for later
.b1d7	ad 2b 03	lda $032b	Definitions:	lda Search_OrderV+0	; Transfer SEARCH_ORDER[0] to
.b1da	8d 10 03	sta $0310			sta CurrentV		;   byte variable CURRENT.
=6					CodeLen	.var *-XtPtr1
=$b1dd					Here1 = *	; remember here
>b1d5	06					.byte CodeLen	;patch wh_CodeLength
.b1dd	60		rts				rts
>b1de	53 65 74 2d 43 75 72 72		Name0:	.text "Set-Current"	;  name of word as a string, ending at wh_NameLastChar
>b1e6	65 6e 74
=11					NameLength = *-Name0
=45417					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>b1e9	8b					.byte (("Set-Current"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=22					LinkDisplacement = Nt0-WordListLink
>b1ea	10					.byte WordFlags	;wh_Flags
>b1eb	03					.byte 3	;wh_CodeLength
>b1ec	16					  .byte LinkDisplacement	; offset to previous nt
=$b1ed					XtPtr1 ::= *
=45417					WordListLink ::= Nt0 ; remember the nt of this word for later
.b1ed	20 47 c5	jsr $c547	Set_Current:	jsr PopA	; pop wid
.b1f0	8d 10 03	sta $0310			sta CurrentV	; only the LSB is used.
=6					CodeLen	.var *-XtPtr1
=$b1f3					Here1 = *	; remember here
>b1eb	06					.byte CodeLen	;patch wh_CodeLength
.b1f3	60		rts				rts
>b1f4	47 65 74 2d 43 75 72 72		Name0:	.text "Get-Current"	;  name of word as a string, ending at wh_NameLastChar
>b1fc	65 6e 74
=11					NameLength = *-Name0
=45439					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>b1ff	8b					.byte (("Get-Current"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=22					LinkDisplacement = Nt0-WordListLink
>b200	10					.byte WordFlags	;wh_Flags
>b201	03					.byte 3	;wh_CodeLength
>b202	16					  .byte LinkDisplacement	; offset to previous nt
=$b203					XtPtr1 ::= *
=45439					WordListLink ::= Nt0 ; remember the nt of this word for later
.b203					Get_Current:
.b203	ad 10 03	lda $0310			lda CurrentV
.b206	4c 5d c9	jmp $c95d			jmp PushZA	; CURRENT is a byte variable
=6					CodeLen	.var *-XtPtr1
=$b209					Here1 = *	; remember here
>b201	06					.byte CodeLen	;patch wh_CodeLength
>b209	4f 72 64 65 72			Name0:	.text "Order"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=45454					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>b20e	45					.byte (("Order"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=15					LinkDisplacement = Nt0-WordListLink
>b20f	10					.byte WordFlags	;wh_Flags
>b210	03					.byte 3	;wh_CodeLength
>b211	0f					  .byte LinkDisplacement	; offset to previous nt
=$b212					XtPtr1 ::= *
=45454					WordListLink ::= Nt0 ; remember the nt of this word for later
.b212					Order:
.b212	20 b7 bc	jsr $bcb7			jsr CR
.b215	a0 00		ldy #$00			ldy #0			; for each search_orderV entry
.b217	f0 0b		beq $b224			beq _test
.b219	98		tya		_loop:		tya
.b21a	48		pha				pha
.b21b	b9 2b 03	lda $032b,y			lda Search_orderV,y
.b21e	20 2f b2	jsr $b22f			jsr print_wid_stringA	; internal helper function
.b221	68		pla				pla
.b222	a8		tay				tay
.b223	c8		iny				iny			;  next
.b224	cc 2a 03	cpy $032a	_test:		cpy Num_orderV
.b227	90 f0		bcc $b219			bcc _loop
.b229	20 b7 bc	jsr $bcb7			jsr CR
.b22c	ad 10 03	lda $0310			lda CurrentV		; print the current wordlist.
.b22f					print_wid_stringA:
.b22f	c9 04		cmp #$04			cmp #wid_Root+1		; do we have a string?
.b231	90 06		bcc $b239			bcc _string
.b233	20 5d c9	jsr $c95d			jsr PushZA		; print the WID number
.b236	4c f3 dd	jmp $ddf3			jmp U_Dot		; JSR/RTS
.b239	0a		asl a		_string:	asl			; Get the word index based on WID 0 to 3
.b23a	a8		tay				tay
.b23b	ca		dex				dex			; TOS= word nt
.b23c	ca		dex				dex
.b23d	b9 55 b2	lda $b255,y			lda _wid_Table+0,y
.b240	95 26		sta $26,x			sta DStack+0,x
.b242	b9 56 b2	lda $b256,y			lda _wid_Table+1,y
.b245	95 27		sta $27,x			sta DStack+1,x		; ( nt )
.b247	20 85 cf	jsr $cf85			jsr Name_To_String	; ( addr u )
.b24a	a9 f7		lda #$f7			lda #$100-9		;   cut off "_wordlist"
.b24c	20 27 dc	jsr $dc27			jsr Minus_A
.b24f	20 f1 df	jsr $dff1			jsr Type		; Print
.b252	4c e5 df	jmp $dfe5			jmp Space
=67					CodeLen	.var *-XtPtr1
=$b255					Here1 = *	; remember here
>b210	43					.byte CodeLen	;patch wh_CodeLength
.b255					_wid_Table:
>b255	de b0					.word forth_wordlist-wh_LinkNt-1	; WID 0:
>b257	f4 b0					.word editor_wordlist-wh_LinkNt-1	; WID 1:
>b259	0d b1					.word assembler_wordlist-wh_LinkNt-1	; WID 2:
>b25b	21 b1					.word root_wordlist-wh_LinkNt-1		; WID 3:
>b25d	46 6f 72 74 68			Name0:	.text "Forth"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=45538					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>b262	05					.byte (("Forth"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=84					LinkDisplacement = Nt0-WordListLink
>b263	10					.byte WordFlags	;wh_Flags
>b264	03					.byte 3	;wh_CodeLength
>b265	54					  .byte LinkDisplacement	; offset to previous nt
=$b266					XtPtr1 ::= *
=45538					WordListLink ::= Nt0 ; remember the nt of this word for later
.b266	a9 00		lda #$00	Forth:		lda #wid_Forth
.b268	8d 2b 03	sta $032b			sta Search_OrderV+0
=5					CodeLen	.var *-XtPtr1
=$b26b					Here1 = *	; remember here
>b264	05					.byte CodeLen	;patch wh_CodeLength
.b26b	60		rts				rts
>b26c	50 72 65 76 69 6f 75 73		Name0:	.text "Previous"	;  name of word as a string, ending at wh_NameLastChar
=8					NameLength = *-Name0
=45556					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>b274	68					.byte (("Previous"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=18					LinkDisplacement = Nt0-WordListLink
>b275	10					.byte WordFlags	;wh_Flags
>b276	03					.byte 3	;wh_CodeLength
>b277	12					  .byte LinkDisplacement	; offset to previous nt
=$b278					XtPtr1 ::= *
=45556					WordListLink ::= Nt0 ; remember the nt of this word for later
.b278	20 f6 b2	jsr $b2f6	Previous:	jsr Get_Order
.b27b	20 5f db	jsr $db5f			jsr Nip
.b27e	20 11 dc	jsr $dc11			jsr One_minus
.b281	4c cf b2	jmp $b2cf			jmp Set_Order
=12					CodeLen	.var *-XtPtr1
=$b284					Here1 = *	; remember here
>b276	0c					.byte CodeLen	;patch wh_CodeLength
>b284	41 6c 73 6f			Name0:	.text "Also"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=45576					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>b288	e4					.byte (("Also"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=20					LinkDisplacement = Nt0-WordListLink
>b289	10					.byte WordFlags	;wh_Flags
>b28a	03					.byte 3	;wh_CodeLength
>b28b	14					  .byte LinkDisplacement	; offset to previous nt
=$b28c					XtPtr1 ::= *
=45576					WordListLink ::= Nt0 ; remember the nt of this word for later
.b28c	20 f6 b2	jsr $b2f6	Also:		jsr Get_Order
.b28f	20 61 e1	jsr $e161			jsr Over
.b292	20 ad e1	jsr $e1ad			jsr Swap
.b295	20 37 dc	jsr $dc37			jsr One_plus
.b298	4c cf b2	jmp $b2cf			jmp Set_Order
=15					CodeLen	.var *-XtPtr1
=$b29b					Here1 = *	; remember here
>b28a	0f					.byte CodeLen	;patch wh_CodeLength
>b29b	3e 4f 72 64 65 72		Name0:	.text ">Order"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=45601					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>b2a1	46					.byte ((">Order"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=25					LinkDisplacement = Nt0-WordListLink
>b2a2	10					.byte WordFlags	;wh_Flags
>b2a3	03					.byte 3	;wh_CodeLength
>b2a4	19					  .byte LinkDisplacement	; offset to previous nt
=$b2a5					XtPtr1 ::= *
=45601					WordListLink ::= Nt0 ; remember the nt of this word for later
.b2a5	20 8c b2	jsr $b28c	To_Order:	jsr Also		; make room in search list
.b2a8	20 47 c5	jsr $c547			jsr PopA
.b2ab	8d 2b 03	sta $032b			sta Search_OrderV+0	; set 1st search entry
=9					CodeLen	.var *-XtPtr1
=$b2ae					Here1 = *	; remember here
>b2a3	09					.byte CodeLen	;patch wh_CodeLength
.b2ae	60		rts				rts
>b2af	4f 6e 6c 79			Name0:	.text "Only"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=45619					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>b2b3	24					.byte (("Only"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=18					LinkDisplacement = Nt0-WordListLink
>b2b4	10					.byte WordFlags	;wh_Flags
>b2b5	03					.byte 3	;wh_CodeLength
>b2b6	12					  .byte LinkDisplacement	; offset to previous nt
=$b2b7					XtPtr1 ::= *
=45619					WordListLink ::= Nt0 ; remember the nt of this word for later
.b2b7	a9 01		lda #$01	Only:		lda #1
.b2b9	8d 2a 03	sta $032a			sta Num_orderV	; set count
.b2bc	a9 03		lda #$03			lda #wid_Root
.b2be	8d 2b 03	sta $032b			sta Search_OrderV+0 ; set 1st search entry
=10					CodeLen	.var *-XtPtr1
=$b2c1					Here1 = *	; remember here
>b2b5	0a					.byte CodeLen	;patch wh_CodeLength
.b2c1	60		rts				rts
>b2c2	53 65 74 2d 4f 72 64 65		Name0:	.text "Set-Order"	;  name of word as a string, ending at wh_NameLastChar
>b2ca	72
=9					NameLength = *-Name0
=45643					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>b2cb	49					.byte (("Set-Order"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=24					LinkDisplacement = Nt0-WordListLink
>b2cc	10					.byte WordFlags	;wh_Flags
>b2cd	03					.byte 3	;wh_CodeLength
>b2ce	18					  .byte LinkDisplacement	; offset to previous nt
=$b2cf					XtPtr1 ::= *
=45643					WordListLink ::= Nt0 ; remember the nt of this word for later
.b2cf					Set_Order:
.b2cf	20 47 c5	jsr $c547			jsr PopA	; pop count
.b2d2	a8		tay				tay		; was it -1 ?
.b2d3	30 e2		bmi $b2b7			bmi Only
.b2d5	8d 2a 03	sta $032a			sta Num_orderV	; Set #ORDER - the number of wordlists in the search order.
.b2d8	a0 00		ldy #$00			ldy #0
.b2da	f0 07		beq $b2e3			beq _test
.b2dc					_loop:
.b2dc	20 47 c5	jsr $c547			jsr PopA		; The search order is a byte array
.b2df	99 2b 03	sta $032b,y			sta Search_OrderV,y	; so only save the LSB
.b2e2	c8		iny				iny
.b2e3					_test:
.b2e3	cc 2a 03	cpy $032a			cpy Num_orderV
.b2e6	d0 f4		bne $b2dc			bne _loop
=25					CodeLen	.var *-XtPtr1
=$b2e8					Here1 = *	; remember here
>b2cd	19					.byte CodeLen	;patch wh_CodeLength
.b2e8	60		rts				rts
>b2e9	47 65 74 2d 4f 72 64 65		Name0:	.text "Get-Order"	;  name of word as a string, ending at wh_NameLastChar
>b2f1	72
=9					NameLength = *-Name0
=45682					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>b2f2	49					.byte (("Get-Order"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=39					LinkDisplacement = Nt0-WordListLink
>b2f3	10					.byte WordFlags	;wh_Flags
>b2f4	03					.byte 3	;wh_CodeLength
>b2f5	27					  .byte LinkDisplacement	; offset to previous nt
=$b2f6					XtPtr1 ::= *
=45682					WordListLink ::= Nt0 ; remember the nt of this word for later
.b2f6					Get_Order:
.b2f6	ac 2a 03	ldy $032a			ldy Num_OrderV	; Get #ORDER - the number of wordlists in the search order.
.b2f9	f0 09		beq $b304			beq _done	; If zero, there are no wordlists.
.b2fb					_loop:
.b2fb	b9 2a 03	lda $032a,y			lda Search_OrderV-1,y	; Put that wordlist id on the stack.
.b2fe	20 5d c9	jsr $c95d			jsr PushZA
.b301	88		dey				dey
.b302	d0 f7		bne $b2fb			bne _loop		; See if that was the last one to process (first in the list).
.b304					_done:
.b304	ad 2a 03	lda $032a			lda Num_OrderV		; Push the number of items
.b307	4c 5d c9	jmp $c95d			jmp PushZA
=20					CodeLen	.var *-XtPtr1
=$b30a					Here1 = *	; remember here
>b2f4	14					.byte CodeLen	;patch wh_CodeLength
>b30a	53 65 61 72 63 68 2d 57		Name0:	.text "Search-Wordlist"	;  name of word as a string, ending at wh_NameLastChar
>b312	6f 72 64 6c 69 73 74
=15					NameLength = *-Name0
=45721					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>b319	8f					.byte (("Search-Wordlist"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=39					LinkDisplacement = Nt0-WordListLink
>b31a	10					.byte WordFlags	;wh_Flags
>b31b	03					.byte 3	;wh_CodeLength
>b31c	27					  .byte LinkDisplacement	; offset to previous nt
=$b31d					XtPtr1 ::= *
=45721					WordListLink ::= Nt0 ; remember the nt of this word for later
.b31d					Search_WordList:
.b31d	20 47 c5	jsr $c547			jsr PopA		; Pop wid
.b320	48		pha				pha			; ( addr u )
.b321	20 35 ce	jsr $ce35			jsr swl_prepare 	; ( )
.b324	68		pla				pla			; get wid
.b325	20 5e ce	jsr $ce5e			jsr swl_search_wordlist ; tmp1= nt of matching word
.b328	f0 11		beq $b33b			beq _NotFound
.b32a	20 3f cf	jsr $cf3f			jsr Name_To_Int_T	; ( xt )
.b32d	a0 81		ldy #$81			ldy #Wh_Flags		; get flags
.b32f	b1 14		lda ($14),y			lda (tmp1),y
.b331	29 08		and #$08			and #IM
.b333	d0 03		bne $b338			bne _immediate		; bit set, we're immediate
.b335	4c 3d c9	jmp $c93d			jmp True		; Word is not immediate, return -1
.b338	4c 74 c9	jmp $c974	_immediate:	jmp One			; Word is immediate, return 1
.b33b	4c 6b c9	jmp $c96b	_NotFound:	jmp Zero		; Word not found, return 0
=33					CodeLen	.var *-XtPtr1
=$b33e					Here1 = *	; remember here
>b31b	21					.byte CodeLen	;patch wh_CodeLength
>0339					BlockReadV: .word ?	; Vector to block reading routine
>033b					BlockWriteV: .word ?	; Vector to block writing routine
>033d					BuffBlockNumV: .word ?	; Block number current in BlockBuffer
>033f					BuffStatusV: .word ?	; Status of BlockBuffer (bit 0 = used, bit 1 = dirty)
>0341					BlockBuffer: .fill 1024
.b33e					BlockInit:
.b33e	a9 00		lda #$00			lda #0
.b340	8d 3f 03	sta $033f			sta BuffStatusV
.b343	a9 40		lda #$40			lda #<Platform_Block_Read
.b345	a0 f1		ldy #$f1			ldy #>Platform_Block_Read
.b347	8d 39 03	sta $0339			sta BlockReadV+0
.b34a	8c 3a 03	sty $033a			sty BlockReadV+1
.b34d	a9 40		lda #$40			lda #<Platform_Block_Write
.b34f	a0 f1		ldy #$f1			ldy #>Platform_Block_Write
.b351	8d 3b 03	sta $033b			sta BlockWriteV+0
.b354	8c 3c 03	sty $033c			sty BlockWriteV+1
.b357	60		rts				rts
>0741					RamDriveV: .word ?	; ptr to RamDrive storage area
=0					io_blk_status = 0
=0					io_blk_action = 0
=0					io_blk_number = 0
=0					io_blk_buffer = 0
>b358	42 6c 6f 63 6b 2d 52 61		Name0:	.text "Block-RamDrive-Init"	;  name of word as a string, ending at wh_NameLastChar
>b360	6d 44 72 69 76 65 2d 49 6e 69 74
=19					NameLength = *-Name0
=45803					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>b36b	93					.byte (("Block-RamDrive-Init"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=80					WordFlags ::= UF+NN	; modifiable copy, remember for later
=82					LinkDisplacement = Nt0-WordListLink
>b36c	50					.byte WordFlags	;wh_Flags
>b36d	03					.byte 3	;wh_CodeLength
>b36e	52					  .byte LinkDisplacement	; offset to previous nt
=$b36f					XtPtr1 ::= *
=45803					WordListLink ::= Nt0 ; remember the nt of this word for later
.b36f					Block_RamDrive_Init:
.b36f	a9 0a		lda #$0a			lda #10			; Calculate how many bytes are needed for numblocks blocks
.b371	20 2d dd	jsr $dd2d			jsr LShift_A
.b374	20 04 dc	jsr $dc04			jsr Here		; ( size addr )
.b377	8d 41 07	sta $0741			sta RamDriveV+0
.b37a	8c 42 07	sty $0742			sty RamDriveV+1
.b37d	20 61 e1	jsr $e161			jsr Over
.b380	20 54 d2	jsr $d254			jsr Allot		; Create ramdrive buffer
.b383	20 ad e1	jsr $e1ad			jsr Swap		; blank the buffer
.b386	20 cb cf	jsr $cfcb			jsr Blank
.b389	a9 9e		lda #$9e			lda #<_read		; set block read vector
.b38b	a0 b3		ldy #$b3			ldy #>_read
.b38d	8d 39 03	sta $0339			sta BlockReadV+0
.b390	8c 3a 03	sty $033a			sty BlockReadV+1
.b393	a9 ae		lda #$ae			lda #<_write		; set block write vector
.b395	a0 b3		ldy #$b3			ldy #>_write
.b397	8d 3b 03	sta $033b			sta BlockWriteV+0
.b39a	8c 3c 03	sty $033c			sty BlockWriteV+1
.b39d	60		rts				rts
=47					CodeLen	.var *-XtPtr1
=$b39e					Here1 = *	; remember here
>b36d	2f					.byte CodeLen	;patch wh_CodeLength
.b39e					_read:
.b39e	20 bb b3	jsr $b3bb			jsr _addr
.b3a1	20 ad e1	jsr $e1ad			jsr Swap
.b3a4	a9 00		lda #$00			lda #0
.b3a6	a0 04		ldy #$04			ldy #>1024
.b3a8	20 2e c9	jsr $c92e			jsr PushYA
.b3ab	4c df be	jmp $bedf			jmp Move
.b3ae					_write:
.b3ae	20 bb b3	jsr $b3bb			jsr _addr
.b3b1	a9 00		lda #$00			lda #0
.b3b3	a0 04		ldy #$04			ldy #>1024
.b3b5	20 2e c9	jsr $c92e			jsr PushYA
.b3b8	4c df be	jmp $bedf			jmp Move
.b3bb					_addr:
.b3bb	a9 0a		lda #$0a			lda #10
.b3bd	20 2d dd	jsr $dd2d			jsr LShift_A
.b3c0	20 d2 b3	jsr $b3d2			jsr RamDrive
.b3c3	4c 90 dd	jmp $dd90			jmp Plus
>b3c6	52 61 6d 44 72 69 76 65		Name0:	.text "RamDrive"	;  name of word as a string, ending at wh_NameLastChar
=8					NameLength = *-Name0
=45902					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>b3ce	a8					.byte (("RamDrive"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=99					LinkDisplacement = Nt0-WordListLink
>b3cf	10					.byte WordFlags	;wh_Flags
>b3d0	03					.byte 3	;wh_CodeLength
>b3d1	63					  .byte LinkDisplacement	; offset to previous nt
=$b3d2					XtPtr1 ::= *
=45902					WordListLink ::= Nt0 ; remember the nt of this word for later
.b3d2	ad 41 07	lda $0741	RamDrive:	lda RamDriveV+0
.b3d5	ac 42 07	ldy $0742			ldy RamDriveV+1
.b3d8	4c 2e c9	jmp $c92e			jmp PushYA
=9					CodeLen	.var *-XtPtr1
=$b3db					Here1 = *	; remember here
>b3d0	09					.byte CodeLen	;patch wh_CodeLength
>b3db	42 75 66 66 53 74 61 74		Name0:	.text "BuffStatus"	;  name of word as a string, ending at wh_NameLastChar
>b3e3	75 73
=10					NameLength = *-Name0
=45925					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>b3e5	6a					.byte (("BuffStatus"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=23					LinkDisplacement = Nt0-WordListLink
>b3e6	10					.byte WordFlags	;wh_Flags
>b3e7	03					.byte 3	;wh_CodeLength
>b3e8	17					  .byte LinkDisplacement	; offset to previous nt
=$b3e9					XtPtr1 ::= *
=45925					WordListLink ::= Nt0 ; remember the nt of this word for later
.b3e9	a0 03		ldy #$03	BuffStatus:	ldy #>BuffStatusV
.b3eb	a9 3f		lda #$3f			lda #<BuffStatusV
.b3ed	4c 2e c9	jmp $c92e			jmp PushYA
=7					CodeLen	.var *-XtPtr1
=$b3f0					Here1 = *	; remember here
>b3e7	07					.byte CodeLen	;patch wh_CodeLength
>b3f0	42 75 66 66 42 6c 6f 63		Name0:	.text "BuffBlockNum"	;  name of word as a string, ending at wh_NameLastChar
>b3f8	6b 4e 75 6d
=12					NameLength = *-Name0
=45948					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>b3fc	ac					.byte (("BuffBlockNum"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=23					LinkDisplacement = Nt0-WordListLink
>b3fd	10					.byte WordFlags	;wh_Flags
>b3fe	03					.byte 3	;wh_CodeLength
>b3ff	17					  .byte LinkDisplacement	; offset to previous nt
=$b400					XtPtr1 ::= *
=45948					WordListLink ::= Nt0 ; remember the nt of this word for later
.b400	a0 03		ldy #$03	BuffBlockNum:	ldy #>BuffBlockNumV
.b402	a9 3d		lda #$3d			lda #<BuffBlockNumV
.b404	4c 2e c9	jmp $c92e			jmp PushYA
=7					CodeLen	.var *-XtPtr1
=$b407					Here1 = *	; remember here
>b3fe	07					.byte CodeLen	;patch wh_CodeLength
>b407	42 6c 6b 42 75 66 66 65		Name0:	.text "BlkBuffer"	;  name of word as a string, ending at wh_NameLastChar
>b40f	72
=9					NameLength = *-Name0
=45968					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>b410	49					.byte (("BlkBuffer"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=20					LinkDisplacement = Nt0-WordListLink
>b411	10					.byte WordFlags	;wh_Flags
>b412	03					.byte 3	;wh_CodeLength
>b413	14					  .byte LinkDisplacement	; offset to previous nt
=$b414					XtPtr1 ::= *
=45968					WordListLink ::= Nt0 ; remember the nt of this word for later
.b414	a0 03		ldy #$03	BlkBuffer:	ldy #>BlockBuffer
.b416	a9 41		lda #$41			lda #<BlockBuffer
.b418	4c 2e c9	jmp $c92e			jmp PushYA
=7					CodeLen	.var *-XtPtr1
=$b41b					Here1 = *	; remember here
>b412	07					.byte CodeLen	;patch wh_CodeLength
>b41b	53 63 72			Name0:	.text "Scr"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=45982					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>b41e	43					.byte (("Scr"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=14					LinkDisplacement = Nt0-WordListLink
>b41f	10					.byte WordFlags	;wh_Flags
>b420	03					.byte 3	;wh_CodeLength
>b421	0e					  .byte LinkDisplacement	; offset to previous nt
=$b422					XtPtr1 ::= *
=45982					WordListLink ::= Nt0 ; remember the nt of this word for later
.b422	a0 03		ldy #$03	Scr:		ldy #>ScrV
.b424	a9 0e		lda #$0e			lda #<ScrV
.b426	4c 2e c9	jmp $c92e			jmp PushYA
=7					CodeLen	.var *-XtPtr1
=$b429					Here1 = *	; remember here
>b420	07					.byte CodeLen	;patch wh_CodeLength
>b429	42 6c 6b			Name0:	.text "Blk"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=45996					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>b42c	63					.byte (("Blk"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=14					LinkDisplacement = Nt0-WordListLink
>b42d	10					.byte WordFlags	;wh_Flags
>b42e	03					.byte 3	;wh_CodeLength
>b42f	0e					  .byte LinkDisplacement	; offset to previous nt
=$b430					XtPtr1 ::= *
=45996					WordListLink ::= Nt0 ; remember the nt of this word for later
.b430	a0 03		ldy #$03	Blk:		ldy #>BlkV
.b432	a9 0c		lda #$0c			lda #<BlkV
.b434	4c 2e c9	jmp $c92e			jmp PushYA
=7					CodeLen	.var *-XtPtr1
=$b437					Here1 = *	; remember here
>b42e	07					.byte CodeLen	;patch wh_CodeLength
>b437	42 6c 6f 63 6b 2d 57 72		Name0:	.text "Block-Write"	;  name of word as a string, ending at wh_NameLastChar
>b43f	69 74 65
=11					NameLength = *-Name0
=46018					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>b442	ab					.byte (("Block-Write"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=22					LinkDisplacement = Nt0-WordListLink
>b443	10					.byte WordFlags	;wh_Flags
>b444	03					.byte 3	;wh_CodeLength
>b445	16					  .byte LinkDisplacement	; offset to previous nt
=$b446					XtPtr1 ::= *
=46018					WordListLink ::= Nt0 ; remember the nt of this word for later
.b446	6c 3b 03	jmp ($033b)	Block_Write:	jmp (BlockWriteV)	; Execute the BLOCK-READ-VECTOR
=3					CodeLen	.var *-XtPtr1
=$b449					Here1 = *	; remember here
>b444	03					.byte CodeLen	;patch wh_CodeLength
>b449	42 6c 6f 63 6b 2d 52 65		Name0:	.text "Block-Read"	;  name of word as a string, ending at wh_NameLastChar
>b451	61 64
=10					NameLength = *-Name0
=46035					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>b453	8a					.byte (("Block-Read"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=17					LinkDisplacement = Nt0-WordListLink
>b454	10					.byte WordFlags	;wh_Flags
>b455	03					.byte 3	;wh_CodeLength
>b456	11					  .byte LinkDisplacement	; offset to previous nt
=$b457					XtPtr1 ::= *
=46035					WordListLink ::= Nt0 ; remember the nt of this word for later
.b457	6c 39 03	jmp ($0339)	Block_Read:	jmp (BlockReadV)	; Execute the BLOCK-READ-VECTOR
=3					CodeLen	.var *-XtPtr1
=$b45a					Here1 = *	; remember here
>b455	03					.byte CodeLen	;patch wh_CodeLength
>b45a	42 6c 6f 63 6b 2d 57 72		Name0:	.text "Block-Write-Vector"	;  name of word as a string, ending at wh_NameLastChar
>b462	69 74 65 2d 56 65 63 74 6f 72
=18					NameLength = *-Name0
=46060					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>b46c	52					.byte (("Block-Write-Vector"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=25					LinkDisplacement = Nt0-WordListLink
>b46d	10					.byte WordFlags	;wh_Flags
>b46e	03					.byte 3	;wh_CodeLength
>b46f	19					  .byte LinkDisplacement	; offset to previous nt
=$b470					XtPtr1 ::= *
=46060					WordListLink ::= Nt0 ; remember the nt of this word for later
.b470					Block_Write_Vector:
.b470	a0 03		ldy #$03			ldy #>BlockWriteV
.b472	a9 3b		lda #$3b			lda #<BlockWriteV	; Get the BLOCK-WRITE-VECTOR address
.b474	4c 2e c9	jmp $c92e			jmp PushYA
=7					CodeLen	.var *-XtPtr1
=$b477					Here1 = *	; remember here
>b46e	07					.byte CodeLen	;patch wh_CodeLength
>b477	42 6c 6f 63 6b 2d 52 65		Name0:	.text "Block-Read-Vector"	;  name of word as a string, ending at wh_NameLastChar
>b47f	61 64 2d 56 65 63 74 6f 72
=17					NameLength = *-Name0
=46088					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>b488	51					.byte (("Block-Read-Vector"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=28					LinkDisplacement = Nt0-WordListLink
>b489	10					.byte WordFlags	;wh_Flags
>b48a	03					.byte 3	;wh_CodeLength
>b48b	1c					  .byte LinkDisplacement	; offset to previous nt
=$b48c					XtPtr1 ::= *
=46088					WordListLink ::= Nt0 ; remember the nt of this word for later
.b48c					Block_Read_Vector:
.b48c	a0 03		ldy #$03			ldy #>BlockReadV
.b48e	a9 39		lda #$39			lda #<BlockReadV	; Get the BLOCK-READ-VECTOR address
.b490	4c 2e c9	jmp $c92e			jmp PushYA
=7					CodeLen	.var *-XtPtr1
=$b493					Here1 = *	; remember here
>b48a	07					.byte CodeLen	;patch wh_CodeLength
>b493	53 61 76 65 2d 42 75 66		Name0:	.text "Save-Buffers"	;  name of word as a string, ending at wh_NameLastChar
>b49b	66 65 72 73
=12					NameLength = *-Name0
=46111					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>b49f	6c					.byte (("Save-Buffers"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=0					WordFlags ::= 0	; modifiable copy, remember for later
=23					LinkDisplacement = Nt0-WordListLink
>b4a0	00					.byte WordFlags	;wh_Flags
>b4a1	03					.byte 3	;wh_CodeLength
>b4a2	17					  .byte LinkDisplacement	; offset to previous nt
=$b4a3					XtPtr1 ::= *
=46111					WordListLink ::= Nt0 ; remember the nt of this word for later
.b4a3					Save_Buffers:
.b4a3	ad 3f 03	lda $033f			lda BuffStatusV+0 ; Only bits 0 and 1 are used, so only
.b4a6	c9 03		cmp #$03			cmp #3		; LSB is needed.
.b4a8	d0 11		bne $b4bb			bne _done	; Either not used or not dirty = done!
.b4aa	20 14 b4	jsr $b414			jsr BlkBuffer
.b4ad	20 00 b4	jsr $b400			jsr BuffBlockNum
.b4b0	20 b2 e0	jsr $e0b2			jsr Fetch
.b4b3	20 46 b4	jsr $b446			jsr Block_Write
.b4b6	a9 01		lda #$01			lda #1
.b4b8	8d 3f 03	sta $033f			sta BuffStatusV+0
.b4bb					_done:
=24					CodeLen	.var *-XtPtr1
=$b4bb					Here1 = *	; remember here
>b4a1	18					.byte CodeLen	;patch wh_CodeLength
.b4bb	60		rts				rts
>b4bc	42 6c 6f 63 6b			Name0:	.text "Block"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=46145					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>b4c1	65					.byte (("Block"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=0					WordFlags ::= 0	; modifiable copy, remember for later
=34					LinkDisplacement = Nt0-WordListLink
>b4c2	00					.byte WordFlags	;wh_Flags
>b4c3	03					.byte 3	;wh_CodeLength
>b4c4	22					  .byte LinkDisplacement	; offset to previous nt
=$b4c5					XtPtr1 ::= *
=46145					WordListLink ::= Nt0 ; remember the nt of this word for later
.b4c5					Block:
.b4c5	ad 3d 03	lda $033d			lda BuffBlockNumV+0	; check the LSB
.b4c8	d5 26		cmp $26,x			cmp DStack+0,x
.b4ca	d0 0e		bne $b4da			bne _not_in_buffer
.b4cc	ad 3e 03	lda $033e			lda BuffBlockNumV+1	; check the MSB
.b4cf	d5 27		cmp $27,x			cmp DStack+1,x
.b4d1	d0 07		bne $b4da			bne _not_in_buffer
.b4d3	ad 3f 03	lda $033f			lda BuffStatusV+0
.b4d6	29 01		and #$01			and #1		; Check the in-use flag (bit 0)
.b4d8	d0 2d		bne $b507			bne _done	; It's already in the buffer and in use.
.b4da					_not_in_buffer:
.b4da	ad 3f 03	lda $033f			lda BuffStatusV+0 ; Only bits 0 and 1 are used, so only
.b4dd	c9 03		cmp #$03			cmp #3		; LSB is needed.
.b4df	d0 0c		bne $b4ed			bne _buffer_available ; Unused or not dirty = available
.b4e1	20 14 b4	jsr $b414			jsr BlkBuffer
.b4e4	20 00 b4	jsr $b400			jsr BuffBlockNum
.b4e7	20 b2 e0	jsr $e0b2			jsr Fetch
.b4ea	20 46 b4	jsr $b446			jsr Block_Write
.b4ed					_buffer_available:
.b4ed	b5 26		lda $26,x			lda DStack+0,x
.b4ef	8d 3d 03	sta $033d			sta BuffBlockNumV+0
.b4f2	b5 27		lda $27,x			lda DStack+1,x
.b4f4	8d 3e 03	sta $033e			sta BuffBlockNumV+1
.b4f7	20 14 b4	jsr $b414			jsr BlkBuffer
.b4fa	20 ad e1	jsr $e1ad			jsr Swap
.b4fd	20 57 b4	jsr $b457			jsr Block_Read
.b500	a9 01		lda #$01			lda #1
.b502	8d 3f 03	sta $033f			sta BuffStatusV+0
.b505	ca		dex				dex
.b506	ca		dex				dex
.b507					_done:
.b507	a9 41		lda #$41			lda #<BlockBuffer
.b509	95 26		sta $26,x			sta DStack+0,x
.b50b	a9 03		lda #$03			lda #>BlockBuffer
.b50d	95 27		sta $27,x			sta DStack+1,x
=74					CodeLen	.var *-XtPtr1
=$b50f					Here1 = *	; remember here
>b4c3	4a					.byte CodeLen	;patch wh_CodeLength
.b50f	60		rts				rts
>b510	55 70 64 61 74 65		Name0:	.text "Update"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=46230					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>b516	a6					.byte (("Update"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=0					WordFlags ::= 0	; modifiable copy, remember for later
=85					LinkDisplacement = Nt0-WordListLink
>b517	00					.byte WordFlags	;wh_Flags
>b518	03					.byte 3	;wh_CodeLength
>b519	55					  .byte LinkDisplacement	; offset to previous nt
=$b51a					XtPtr1 ::= *
=46230					WordListLink ::= Nt0 ; remember the nt of this word for later
.b51a					Update:
.b51a	ad 3f 03	lda $033f			lda BuffStatusV+0
.b51d	09 02		ora #$02			ora #2		; Turn on dirty flag (bit 2)
.b51f	8d 3f 03	sta $033f			sta BuffStatusV+0
=8					CodeLen	.var *-XtPtr1
=$b522					Here1 = *	; remember here
>b518	08					.byte CodeLen	;patch wh_CodeLength
.b522	60		rts				rts
>b523	42 75 66 66 65 72		Name0:	.text "Buffer"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=46249					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>b529	46					.byte (("Buffer"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=19					LinkDisplacement = Nt0-WordListLink
>b52a	10					.byte WordFlags	;wh_Flags
>b52b	03					.byte 3	;wh_CodeLength
>b52c	13					  .byte LinkDisplacement	; offset to previous nt
=$b52d					XtPtr1 ::= *
=46249					WordListLink ::= Nt0 ; remember the nt of this word for later
.b52d					Buffer:
.b52d	ad 3f 03	lda $033f			lda BuffStatusV+0 ; Only bits 0 and 1 are used, so only
.b530	c9 03		cmp #$03			cmp #3		; LSB is needed.
.b532	d0 0c		bne $b540			bne _buffer_available ; Unused or not dirty = available
.b534	20 14 b4	jsr $b414			jsr BlkBuffer
.b537	20 00 b4	jsr $b400			jsr BuffBlockNum
.b53a	20 b2 e0	jsr $e0b2			jsr Fetch
.b53d	20 46 b4	jsr $b446			jsr Block_Write
.b540					_buffer_available:
.b540	b5 26		lda $26,x			lda DStack+0,x
.b542	8d 3d 03	sta $033d			sta BuffBlockNumV+0
.b545	b5 27		lda $27,x			lda DStack+1,x
.b547	8d 3e 03	sta $033e			sta BuffBlockNumV+1
.b54a	a9 01		lda #$01			lda #1
.b54c	8d 3f 03	sta $033f			sta BuffStatusV+0
.b54f					_done:
.b54f	a9 41		lda #$41			lda #<BlockBuffer
.b551	95 26		sta $26,x			sta DStack+0,x
.b553	a9 03		lda #$03			lda #>BlockBuffer
.b555	95 27		sta $27,x			sta DStack+1,x
=42					CodeLen	.var *-XtPtr1
=$b557					Here1 = *	; remember here
>b52b	2a					.byte CodeLen	;patch wh_CodeLength
.b557	60		rts				rts
>b558	45 6d 70 74 79 2d 42 75		Name0:	.text "Empty-Buffers"	;  name of word as a string, ending at wh_NameLastChar
>b560	66 66 65 72 73
=13					NameLength = *-Name0
=46309					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>b565	6d					.byte (("Empty-Buffers"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=60					LinkDisplacement = Nt0-WordListLink
>b566	10					.byte WordFlags	;wh_Flags
>b567	03					.byte 3	;wh_CodeLength
>b568	3c					  .byte LinkDisplacement	; offset to previous nt
=$b569					XtPtr1 ::= *
=46309					WordListLink ::= Nt0 ; remember the nt of this word for later
.b569	a9 00		lda #$00	Empty_Buffers:	lda #0		; Set the buffer status to empty.
.b56b	8d 3f 03	sta $033f			sta BuffStatusV+0 ; Only LSB is used.
=5					CodeLen	.var *-XtPtr1
=$b56e					Here1 = *	; remember here
>b567	05					.byte CodeLen	;patch wh_CodeLength
.b56e	60		rts				rts
>b56f	46 6c 75 73 68			Name0:	.text "Flush"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=46324					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>b574	05					.byte (("Flush"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=15					LinkDisplacement = Nt0-WordListLink
>b575	10					.byte WordFlags	;wh_Flags
>b576	03					.byte 3	;wh_CodeLength
>b577	0f					  .byte LinkDisplacement	; offset to previous nt
=$b578					XtPtr1 ::= *
=46324					WordListLink ::= Nt0 ; remember the nt of this word for later
.b578	20 a3 b4	jsr $b4a3	Flush:		jsr Save_Buffers
.b57b	4c 69 b5	jmp $b569			jmp Empty_Buffers
=6					CodeLen	.var *-XtPtr1
=$b57e					Here1 = *	; remember here
>b576	06					.byte CodeLen	;patch wh_CodeLength
>b57e	4c 6f 61 64			Name0:	.text "Load"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=46338					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>b582	84					.byte (("Load"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=14					LinkDisplacement = Nt0-WordListLink
>b583	10					.byte WordFlags	;wh_Flags
>b584	03					.byte 3	;wh_CodeLength
>b585	0e					  .byte LinkDisplacement	; offset to previous nt
=$b586					XtPtr1 ::= *
=46338					WordListLink ::= Nt0 ; remember the nt of this word for later
.b586					Load:
.b586	20 8b c5	jsr $c58b			jsr underflow_1
.b589	ad 0d 03	lda $030d			lda BlkV+1		; Save the current value of BLK on the return stack.
.b58c	48		pha				pha
.b58d	ad 0c 03	lda $030c			lda BlkV+0
.b590	48		pha				pha
.b591	b5 26		lda $26,x			lda DStack+0,x		; Set BLK to the given block/screen number.
.b593	8d 0c 03	sta $030c			sta BlkV+0
.b596	b5 27		lda $27,x			lda DStack+1,x
.b598	8d 0d 03	sta $030d			sta BlkV+1
.b59b	20 c5 b4	jsr $b4c5			jsr Block		; Load that block into a buffer
.b59e	a9 00		lda #$00			lda #<1024		; block length.
.b5a0	a0 04		ldy #$04			ldy #>1024
.b5a2	20 2e c9	jsr $c92e			jsr PushYA
.b5a5	38		sec				sec		; Set a flag to not zero BLK
.b5a6	20 68 c1	jsr $c168			jsr load_evaluate
.b5a9	68		pla				pla
.b5aa	8d 0c 03	sta $030c			sta BlkV+0
.b5ad	68		pla				pla
.b5ae	8d 0d 03	sta $030d			sta BlkV+1
.b5b1	0d 0c 03	ora $030c			ora BlkV+0
.b5b4	f0 13		beq $b5c9			beq _done
.b5b6	ad 0c 03	lda $030c			lda BlkV+0
.b5b9	ac 0d 03	ldy $030d			ldy BlkV+1
.b5bc	20 2e c9	jsr $c92e			jsr PushYA
.b5bf	20 c5 b4	jsr $b4c5			jsr Block
.b5c2	20 62 c5	jsr $c562			jsr PopYA	; Pop the buffer address.
.b5c5	85 04		sta $04				sta cib+0
.b5c7	84 05		sty $05				sty cib+1
.b5c9					_done:
=67					CodeLen	.var *-XtPtr1
=$b5c9					Here1 = *	; remember here
>b584	43					.byte CodeLen	;patch wh_CodeLength
.b5c9	60		rts				rts
>b5ca	54 68 72 75			Name0:	.text "Thru"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=46414					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>b5ce	a4					.byte (("Thru"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=76					LinkDisplacement = Nt0-WordListLink
>b5cf	10					.byte WordFlags	;wh_Flags
>b5d0	03					.byte 3	;wh_CodeLength
>b5d1	4c					  .byte LinkDisplacement	; offset to previous nt
=$b5d2					XtPtr1 ::= *
=46414					WordListLink ::= Nt0 ; remember the nt of this word for later
.b5d2	20 9f c5	jsr $c59f	Thru:		jsr underflow_2
.b5d5	20 fa e0	jsr $e0fa			jsr To_R
.b5d8					_loop:
.b5d8	b5 27		lda $27,x			lda DStack+1,x		; copy to return stack
.b5da	48		pha				pha
.b5db	b5 26		lda $26,x			lda DStack+0,x
.b5dd	48		pha				pha
.b5de	20 86 b5	jsr $b586			jsr Load		; Load this screen.
.b5e1	20 18 e1	jsr $e118			jsr R_From		; Get the screen # we just loaded.
.b5e4	20 37 dc	jsr $dc37			jsr One_plus		; increment
.b5e7	86 14		stx $14				stx tmp1
.b5e9	ba		tsx				tsx
.b5ea	8a		txa				txa
.b5eb	a8		tay				tay
.b5ec	a6 14		ldx $14				ldx tmp1
.b5ee	b9 01 01	lda $0101,y			lda RStack+1,y
.b5f1	d5 26		cmp $26,x			cmp DStack+0,x
.b5f3	b9 02 01	lda $0102,y			lda RStack+2,y
.b5f6	f5 27		sbc $27,x			sbc DStack+1,x
.b5f8	b0 de		bcs $b5d8			bcs _loop
.b5fa	e8		inx				inx			; Drop index
.b5fb	e8		inx				inx
.b5fc	68		pla				pla			; RDrop limit
.b5fd	68		pla				pla
=44					CodeLen	.var *-XtPtr1
=$b5fe					Here1 = *	; remember here
>b5d0	2c					.byte CodeLen	;patch wh_CodeLength
.b5fe	60		rts				rts
>b5ff	4c 69 73 74			Name0:	.text "List"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=46467					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>b603	84					.byte (("List"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=53					LinkDisplacement = Nt0-WordListLink
>b604	10					.byte WordFlags	;wh_Flags
>b605	03					.byte 3	;wh_CodeLength
>b606	35					  .byte LinkDisplacement	; offset to previous nt
=$b607					XtPtr1 ::= *
=46467					WordListLink ::= Nt0 ; remember the nt of this word for later
.b607	20 62 c5	jsr $c562	List:		jsr PopYA	; Save the screen number
.b60a	8d 0e 03	sta $030e			sta ScrV+0
.b60d	8c 0f 03	sty $030f			sty ScrV+1
.b610					ListScr:
.b610	20 22 b4	jsr $b422			jsr Scr
.b613	20 b2 e0	jsr $e0b2			jsr Fetch
.b616	20 c5 b4	jsr $b4c5			jsr Block	; Get the current screen contents.
.b619	20 b7 bc	jsr $bcb7			jsr CR
.b61c	20 4b ca	jsr $ca4b			jsr SLiteral_Runtime
.b61f	4c 2a b6	jmp $b62a			  jmp +				; for SLiteral_Runtime
>b622	53 63 72 65 65 6e 20 23				  .text "Screen #"		; for SLiteral_Runtime
.b62a					+
.b62a	20 f1 df	jsr $dff1			jsr Type
.b62d	20 22 b4	jsr $b422			jsr Scr		; print screen number
.b630	20 b2 e0	jsr $e0b2			jsr Fetch
.b633	a9 04		lda #$04			lda #4		;    in 4 positions
.b635	20 25 de	jsr $de25			jsr U_Dot_R_A
.b638	a9 00		lda #$00			lda #0			; line #
.b63a					_line_loop:
.b63a	48		pha				pha
.b63b	20 b7 bc	jsr $bcb7			jsr CR
.b63e	68		pla				pla		; Print the line number
.b63f	48		pha				pha
.b640	20 5d c9	jsr $c95d			jsr PushZA
.b643	a9 02		lda #$02			lda #2		;   in 2 positions
.b645	20 25 de	jsr $de25			jsr U_Dot_R_A
.b648	20 e5 df	jsr $dfe5			jsr Space
.b64b	20 8a e1	jsr $e18a			jsr Dup		; Print one line using the address on the stack.
.b64e	a9 40		lda #$40			lda #64
.b650	20 5d c9	jsr $c95d			jsr PushZA
.b653	20 f1 df	jsr $dff1			jsr Type
.b656	a9 40		lda #$40			lda #64		; move address to the next line.
.b658	20 da db	jsr $dbda			jsr Plus_A
.b65b	68		pla				pla		; Increment the line number
.b65c	18		clc				clc
.b65d	69 01		adc #$01			adc #1
.b65f	c9 10		cmp #$10			cmp #16		; See if we are done.
.b661	d0 d7		bne $b63a			bne _line_loop
.b663	e8		inx				inx		; Drop the address
.b664	e8		inx				inx
.b665	4c b7 bc	jmp $bcb7			jmp CR
=97					CodeLen	.var *-XtPtr1
=$b668					Here1 = *	; remember here
>b605	61					.byte CodeLen	;patch wh_CodeLength
>b668	44 65 66 65 72			Name0:	.text "Defer"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=46573					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>b66d	45					.byte (("Defer"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=106					LinkDisplacement = Nt0-WordListLink
>b66e	10					.byte WordFlags	;wh_Flags
>b66f	03					.byte 3	;wh_CodeLength
>b670	6a					  .byte LinkDisplacement	; offset to previous nt
=$b671					XtPtr1 ::= *
=46573					WordListLink ::= Nt0 ; remember the nt of this word for later
.b671					Defer:
.b671	20 b2 d2	jsr $d2b2			jsr WordHeader_Comma	; compile word header
.b674	a9 7e		lda #$7e			lda #<_undefined	; compile "jmp _undefined" (patched by Defer! )
.b676	a0 b6		ldy #$b6			ldy #>_undefined
.b678	20 3b df	jsr $df3b			jsr Jmp_Comma_YA
.b67b	4c 6e cd	jmp $cd6e			jmp adjust_z		; set word length
=13					CodeLen	.var *-XtPtr1
=$b67e					Here1 = *	; remember here
>b66f	0d					.byte CodeLen	;patch wh_CodeLength
.b67e					_undefined:
.b67e	a9 6a		lda #$6a			lda #$100+err_Defer	; throw exception
.b680	4c dc c5	jmp $c5dc			jmp ThrowA
>b683	44 65 66 65 72 21		Name0:	.text "Defer!"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=46601					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>b689	26					.byte (("Defer!"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=28					LinkDisplacement = Nt0-WordListLink
>b68a	10					.byte WordFlags	;wh_Flags
>b68b	03					.byte 3	;wh_CodeLength
>b68c	1c					  .byte LinkDisplacement	; offset to previous nt
=$b68d					XtPtr1 ::= *
=46601					WordListLink ::= Nt0 ; remember the nt of this word for later
.b68d	20 62 c5	jsr $c562	Defer_Store:	jsr PopYA		; pop DEFERs xt
.b690	85 14		sta $14		Defer_Store_YA:	sta tmp1+0
.b692	84 15		sty $15				sty tmp1+1
.b694	b5 26		lda $26,x			lda DStack+0,x		; DEFERs JMP abs operand= xt2
.b696	a0 01		ldy #$01			ldy #1
.b698	91 14		sta ($14),y			sta (tmp1),y
.b69a	b5 27		lda $27,x			lda DStack+1,x
.b69c	c8		iny				iny
.b69d	91 14		sta ($14),y			sta (tmp1),y
.b69f	4c ca e1	jmp $e1ca			jmp Drop		; Drop xt2
=21					CodeLen	.var *-XtPtr1
=$b6a2					Here1 = *	; remember here
>b68b	15					.byte CodeLen	;patch wh_CodeLength
>b6a2	44 65 66 65 72 40		Name0:	.text "Defer@"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=46632					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>b6a8	06					.byte (("Defer@"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=0					WordFlags ::= 0	; modifiable copy, remember for later
=31					LinkDisplacement = Nt0-WordListLink
>b6a9	00					.byte WordFlags	;wh_Flags
>b6aa	03					.byte 3	;wh_CodeLength
>b6ab	1f					  .byte LinkDisplacement	; offset to previous nt
=$b6ac					XtPtr1 ::= *
=46632					WordListLink ::= Nt0 ; remember the nt of this word for later
.b6ac	20 62 c5	jsr $c562	Defer_Fetch:	jsr PopYA	; pop DEFERs xt
.b6af	85 14		sta $14		Defer_Fetch_YA:	sta tmp1+0
.b6b1	84 15		sty $15				sty tmp1+1
.b6b3	ca		dex				dex		; push DEFERs JMP abs operand
.b6b4	ca		dex				dex
.b6b5	a0 01		ldy #$01			ldy #1
.b6b7	b1 14		lda ($14),y			lda (tmp1),y
.b6b9	95 26		sta $26,x			sta DStack+0,x
.b6bb	c8		iny				iny
.b6bc	b1 14		lda ($14),y			lda (tmp1),y
.b6be	95 27		sta $27,x			sta DStack+1,x
=20					CodeLen	.var *-XtPtr1
=$b6c0					Here1 = *	; remember here
>b6aa	14					.byte CodeLen	;patch wh_CodeLength
.b6c0	60		rts				rts
>b6c1	49 73				Name0:	.text "Is"	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=46659					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>b6c3	62					.byte (("Is"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=24					WordFlags ::= IM+NN	; modifiable copy, remember for later
=27					LinkDisplacement = Nt0-WordListLink
>b6c4	18					.byte WordFlags	;wh_Flags
>b6c5	03					.byte 3	;wh_CodeLength
>b6c6	1b					  .byte LinkDisplacement	; offset to previous nt
=$b6c7					XtPtr1 ::= *
=46659					WordListLink ::= Nt0 ; remember the nt of this word for later
.b6c7	20 d4 cd	jsr $cdd4	Is:		jsr Tick		; get xt of "name"
.b6ca	a5 0a		lda $0a				lda state		; Check STATE
.b6cc	f0 bf		beq $b68d			beq Defer_Store		; interpreting, put xt in the DEFER word
.b6ce					_compiling:
.b6ce	20 15 c9	jsr $c915			jsr ldya_immed_comma	; compile LDY #; LDA # of the xt of "name"
.b6d1	a0 b6		ldy #$b6			ldy #>Defer_Store_YA	; Postpone DEFER! by compiling a JSR to it.
.b6d3	a9 90		lda #$90			lda #<Defer_Store_YA
.b6d5	4c 25 df	jmp $df25			jmp Jsr_Comma_YA
=17					CodeLen	.var *-XtPtr1
=$b6d8					Here1 = *	; remember here
>b6c5	11					.byte CodeLen	;patch wh_CodeLength
>b6d8	41 63 74 69 6f 6e 2d 4f		Name0:	.text "Action-Of"	;  name of word as a string, ending at wh_NameLastChar
>b6e0	66
=9					NameLength = *-Name0
=46689					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>b6e1	c9					.byte (("Action-Of"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=24					WordFlags ::= IM+NN	; modifiable copy, remember for later
=30					LinkDisplacement = Nt0-WordListLink
>b6e2	18					.byte WordFlags	;wh_Flags
>b6e3	03					.byte 3	;wh_CodeLength
>b6e4	1e					  .byte LinkDisplacement	; offset to previous nt
=$b6e5					XtPtr1 ::= *
=46689					WordListLink ::= Nt0 ; remember the nt of this word for later
.b6e5					Action_Of:
.b6e5	20 d4 cd	jsr $cdd4			jsr Tick		; get xt of "name"
.b6e8	a5 0a		lda $0a				lda state		; Check STATE
.b6ea	f0 c0		beq $b6ac			beq Defer_Fetch		; interpreting, get xt in the DEFER word
.b6ec					_compiling:
.b6ec	20 15 c9	jsr $c915			jsr ldya_immed_comma	; compile LDY #; LDA # of the xt of "name"
.b6ef	a0 b6		ldy #$b6			ldy #>Defer_Fetch_YA	; Postpone DEFER@ by compiling a JSR to it.
.b6f1	a9 af		lda #$af			lda #<Defer_Fetch_YA
.b6f3	4c 25 df	jmp $df25			jmp Jsr_Comma_YA
=17					CodeLen	.var *-XtPtr1
=$b6f6					Here1 = *	; remember here
>b6e3	11					.byte CodeLen	;patch wh_CodeLength
>b6f6	55 73 65 72 41 64 64 72		Name0:	.text "UserAddr"	;  name of word as a string, ending at wh_NameLastChar
=8					NameLength = *-Name0
=46718					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>b6fe	48					.byte (("UserAddr"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=29					LinkDisplacement = Nt0-WordListLink
>b6ff	10					.byte WordFlags	;wh_Flags
>b700	03					.byte 3	;wh_CodeLength
>b701	1d					  .byte LinkDisplacement	; offset to previous nt
=$b702					XtPtr1 ::= *
=46718					WordListLink ::= Nt0 ; remember the nt of this word for later
.b702	a9 ff		lda #$ff			lda #<User0
.b704	a0 02		ldy #$02			ldy #>User0
.b706	4c 2e c9	jmp $c92e			jmp PushYA
=7					CodeLen	.var *-XtPtr1
=$b709					Here1 = *	; remember here
>b700	07					.byte CodeLen	;patch wh_CodeLength
>b709	42 75 66 66 65 72 3a		Name0:	.text "Buffer:"	;  name of word as a string, ending at wh_NameLastChar
=7					NameLength = *-Name0
=46736					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>b710	47					.byte (("Buffer:"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=18					LinkDisplacement = Nt0-WordListLink
>b711	10					.byte WordFlags	;wh_Flags
>b712	03					.byte 3	;wh_CodeLength
>b713	12					  .byte LinkDisplacement	; offset to previous nt
=$b714					XtPtr1 ::= *
=46736					WordListLink ::= Nt0 ; remember the nt of this word for later
.b714	20 5f d3	jsr $d35f	Buffer_Colon:	jsr Create
.b717	4c 54 d2	jmp $d254			jmp Allot
=6					CodeLen	.var *-XtPtr1
=$b71a					Here1 = *	; remember here
>b712	06					.byte CodeLen	;patch wh_CodeLength
>b71a	43 61 73 65			Name0:	.text "Case"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=46750					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>b71e	a4					.byte (("Case"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=28					WordFlags ::= IM+CO+NN	; modifiable copy, remember for later
=14					LinkDisplacement = Nt0-WordListLink
>b71f	1c					.byte WordFlags	;wh_Flags
>b720	03					.byte 3	;wh_CodeLength
>b721	0e					  .byte LinkDisplacement	; offset to previous nt
=$b722					XtPtr1 ::= *
=46750					WordListLink ::= Nt0 ; remember the nt of this word for later
.b722	4c 6b c9	jmp $c96b	Case:		jmp Zero	; init jmp fixup chain
=3					CodeLen	.var *-XtPtr1
=$b725					Here1 = *	; remember here
>b720	03					.byte CodeLen	;patch wh_CodeLength
>b725	45 6e 64 43 61 73 65		Name0:	.text "EndCase"	;  name of word as a string, ending at wh_NameLastChar
=7					NameLength = *-Name0
=46764					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>b72c	a7					.byte (("EndCase"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=28					WordFlags ::= IM+CO+NN	; modifiable copy, remember for later
=14					LinkDisplacement = Nt0-WordListLink
>b72d	1c					.byte WordFlags	;wh_Flags
>b72e	03					.byte 3	;wh_CodeLength
>b72f	0e					  .byte LinkDisplacement	; offset to previous nt
=$b730					XtPtr1 ::= *
=46764					WordListLink ::= Nt0 ; remember the nt of this word for later
.b730					EndCase:
.b730	20 09 df	jsr $df09			jsr Drop_Comma
.b733					_loop:
.b733	b5 27		lda $27,x			lda DStack+1,x	; while addr fixup entries left
.b735	f0 06		beq $b73d			beq _done
.b737	20 b1 b7	jsr $b7b1			jsr Then	;   fixup another one
.b73a	4c 33 b7	jmp $b733			jmp _loop
.b73d					_done:
.b73d	e8		inx				inx		; Drop the 0
.b73e	e8		inx				inx
=15					CodeLen	.var *-XtPtr1
=$b73f					Here1 = *	; remember here
>b72e	0f					.byte CodeLen	;patch wh_CodeLength
.b73f	60		rts				rts
>b740	4f 66				Name0:	.text "Of"	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=46786					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>b742	c2					.byte (("Of"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=28					WordFlags ::= IM+CO+NN	; modifiable copy, remember for later
=22					LinkDisplacement = Nt0-WordListLink
>b743	1c					.byte WordFlags	;wh_Flags
>b744	03					.byte 3	;wh_CodeLength
>b745	16					  .byte LinkDisplacement	; offset to previous nt
=$b746					XtPtr1 ::= *
=46786					WordListLink ::= Nt0 ; remember the nt of this word for later
.b746					Of:
.b746	a0 b7		ldy #$b7			ldy #>_runtime		; Check if value is equal to this case.
.b748	a9 50		lda #$50			lda #<_runtime
.b74a	20 25 df	jsr $df25			jsr Jsr_Comma_YA
.b74d	4c 78 b7	jmp $b778			jmp zbranch_jmp0_comma	; save addr ptr; compile jmp abs
=10					CodeLen	.var *-XtPtr1
=$b750					Here1 = *	; remember here
>b744	0a					.byte CodeLen	;patch wh_CodeLength
.b750					_runtime:
.b750	e0 2d		cpx #$2d		cpx #(DSDim-2)*2+1	; far enough below end of data stack (& not negative)?
.b752	b0 52		bcs $b7a6		bcs Throw_Stack_26
.b754	e8		inx				inx		; Drop x2
.b755	e8		inx				inx
.b756	b5 24		lda $24,x			lda DStack-2,x	; compare x1 with x2
.b758	d5 26		cmp $26,x			cmp DStack+0,x
.b75a	d0 06		bne $b762			bne _NotEq
.b75c	b5 25		lda $25,x			lda DStack-1,x
.b75e	d5 27		cmp $27,x			cmp DStack+1,x
.b760	f0 34		beq $b796			beq zbranch_run2 ; Drop x1 & return to after the jmp abs
.b762	60		rts		_NotEq:		rts		; return to the jmp abs to next test
>b763	45 6e 64 4f 66			Name0:	.text "EndOf"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=46824					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>b768	c5					.byte (("EndOf"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=28					WordFlags ::= IM+CO+NN	; modifiable copy, remember for later
=38					LinkDisplacement = Nt0-WordListLink
>b769	1c					.byte WordFlags	;wh_Flags
>b76a	03					.byte 3	;wh_CodeLength
>b76b	26					  .byte LinkDisplacement	; offset to previous nt
=$b76c					XtPtr1 ::= *
=46824					WordListLink ::= Nt0 ; remember the nt of this word for later
.b76c	4c c2 b7	jmp $b7c2	EndOf:		jmp Else
=3					CodeLen	.var *-XtPtr1
=$b76f					Here1 = *	; remember here
>b76a	03					.byte CodeLen	;patch wh_CodeLength
>b76f	49 66				Name0:	.text "If"	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=46833					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>b771	c2					.byte (("If"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=28					WordFlags ::= IM+CO+NN	; modifiable copy, remember for later
=9					LinkDisplacement = Nt0-WordListLink
>b772	1c					.byte WordFlags	;wh_Flags
>b773	03					.byte 3	;wh_CodeLength
>b774	09					  .byte LinkDisplacement	; offset to previous nt
=$b775					XtPtr1 ::= *
=46833					WordListLink ::= Nt0 ; remember the nt of this word for later
.b775					If:
.b775	20 85 b7	jsr $b785	If3:		jsr zbranch_jsr_comma	; Compile a 0BRANCH
.b778					zbranch_jmp0_comma:
.b778	20 04 dc	jsr $dc04			jsr Here		; save ptr to address for else/then
.b77b	20 37 dc	jsr $dc37			jsr One_Plus
.b77e	a0 c5		ldy #$c5			ldy #>Abort		; compile jmp abs
.b780	a9 3a		lda #$3a			lda #<Abort		; THEN or ELSE will fix address later.
.b782	4c 3b df	jmp $df3b			jmp Jmp_Comma_YA
=16					CodeLen	.var *-XtPtr1
=$b785					Here1 = *	; remember here
>b773	10					.byte CodeLen	;patch wh_CodeLength
=$df38					zbranch_jmp_comma = Jmp_Comma		; compile jmp abs
.b785					zbranch_jsr_comma:
.b785	a0 b7		ldy #$b7			ldy #>_runtime
.b787	a9 8c		lda #$8c			lda #<_runtime
.b789	4c 25 df	jmp $df25			jmp Jsr_Comma_YA
.b78c					_runtime:
.b78c	e0 2f		cpx #$2f		cpx #(DSDim-1)*2+1	; far enough below end of data stack (& not negative)?
.b78e	b0 16		bcs $b7a6		bcs Throw_Stack_26
.b790	b5 26		lda $26,x			lda DStack+0,x		;flag is false?
.b792	15 27		ora $27,x			ora DStack+1,x
.b794	f0 0d		beq $b7a3			beq zbranch_run_done
.b796	18		clc		zbranch_run2:	clc			; move RTS addr over the next jmp abs.
.b797	68		pla				pla
.b798	69 03		adc #$03			adc #3
.b79a	90 06		bcc $b7a2			bcc +
.b79c	a8		tay				tay
.b79d	68		pla				pla
.b79e	69 00		adc #$00			adc #0
.b7a0	48		pha				pha
.b7a1	98		tya				tya
.b7a2	48		pha		+		pha
.b7a3					zbranch_run_done:
.b7a3	e8		inx				inx			; Drop f
.b7a4	e8		inx				inx
.b7a5	60		rts				rts
.b7a6	4c ae c5	jmp $c5ae	Throw_Stack_26: jmp Throw_Stack
>b7a9	54 68 65 6e			Name0:	.text "Then"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=46893					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>b7ad	c4					.byte (("Then"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=28					WordFlags ::= IM+CO+NN	; modifiable copy, remember for later
=60					LinkDisplacement = Nt0-WordListLink
>b7ae	1c					.byte WordFlags	;wh_Flags
>b7af	03					.byte 3	;wh_CodeLength
>b7b0	3c					  .byte LinkDisplacement	; offset to previous nt
=$b7b1					XtPtr1 ::= *
=46893					WordListLink ::= Nt0 ; remember the nt of this word for later
.b7b1					Then:
.b7b1	20 04 dc	jsr $dc04			jsr Here
.b7b4	20 ad e1	jsr $e1ad			jsr Swap
.b7b7	4c cb e0	jmp $e0cb			jmp Store
=9					CodeLen	.var *-XtPtr1
=$b7ba					Here1 = *	; remember here
>b7af	09					.byte CodeLen	;patch wh_CodeLength
>b7ba	45 6c 73 65			Name0:	.text "Else"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=46910					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>b7be	a4					.byte (("Else"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=28					WordFlags ::= IM+CO+NN	; modifiable copy, remember for later
=17					LinkDisplacement = Nt0-WordListLink
>b7bf	1c					.byte WordFlags	;wh_Flags
>b7c0	03					.byte 3	;wh_CodeLength
>b7c1	11					  .byte LinkDisplacement	; offset to previous nt
=$b7c2					XtPtr1 ::= *
=46910					WordListLink ::= Nt0 ; remember the nt of this word for later
.b7c2					Else:
.b7c2	20 78 b7	jsr $b778			jsr zbranch_jmp0_comma	; compile jmp 0, push addr of addr
.b7c5	20 04 dc	jsr $dc04			jsr Here
.b7c8	20 6b e0	jsr $e06b			jsr Rot
.b7cb	4c cb e0	jmp $e0cb			jmp Store
=12					CodeLen	.var *-XtPtr1
=$b7ce					Here1 = *	; remember here
>b7c0	0c					.byte CodeLen	;patch wh_CodeLength
>b7ce	42 65 67 69 6e			Name0:	.text "Begin"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=46931					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>b7d3	c5					.byte (("Begin"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=28					WordFlags ::= NN+CO+IM	; modifiable copy, remember for later
=21					LinkDisplacement = Nt0-WordListLink
>b7d4	1c					.byte WordFlags	;wh_Flags
>b7d5	03					.byte 3	;wh_CodeLength
>b7d6	15					  .byte LinkDisplacement	; offset to previous nt
=$b7d7					XtPtr1 ::= *
=46931					WordListLink ::= Nt0 ; remember the nt of this word for later
.b7d7	20 04 dc	jsr $dc04	Begin:		jsr Here	; remember the loop starting location
.b7da	a9 d7		lda #$d7			lda #<Begin	; pairing marker
.b7dc	4c 5d c9	jmp $c95d			jmp PushZA
=8					CodeLen	.var *-XtPtr1
=$b7df					Here1 = *	; remember here
>b7d5	08					.byte CodeLen	;patch wh_CodeLength
>b7df	41 67 61 69 6e			Name0:	.text "Again"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=46948					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>b7e4	c5					.byte (("Again"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=92					WordFlags ::= NN+CO+IM+UF	; modifiable copy, remember for later
=17					LinkDisplacement = Nt0-WordListLink
>b7e5	5c					.byte WordFlags	;wh_Flags
>b7e6	03					.byte 3	;wh_CodeLength
>b7e7	11					  .byte LinkDisplacement	; offset to previous nt
=$b7e8					XtPtr1 ::= *
=46948					WordListLink ::= Nt0 ; remember the nt of this word for later
.b7e8	20 9f c5	jsr $c59f	Again:		jsr underflow_2
.b7eb	a9 d7		lda #$d7			lda #<Begin	; check pairing
.b7ed	20 77 c3	jsr $c377			jsr QPairCtlA
.b7f0	4c 38 df	jmp $df38			jmp Jmp_Comma	; Compile a jmp abs.
=11					CodeLen	.var *-XtPtr1
=$b7f3					Here1 = *	; remember here
>b7e6	0b					.byte CodeLen	;patch wh_CodeLength
>b7f3	55 6e 74 69 6c			Name0:	.text "Until"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=46968					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>b7f8	85					.byte (("Until"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=28					WordFlags ::= IM+CO+NN	; modifiable copy, remember for later
=20					LinkDisplacement = Nt0-WordListLink
>b7f9	1c					.byte WordFlags	;wh_Flags
>b7fa	03					.byte 3	;wh_CodeLength
>b7fb	14					  .byte LinkDisplacement	; offset to previous nt
=$b7fc					XtPtr1 ::= *
=46968					WordListLink ::= Nt0 ; remember the nt of this word for later
.b7fc	a9 d7		lda #$d7	Until:		lda #<Begin		; check pairing
.b7fe	20 77 c3	jsr $c377			jsr QPairCtlA
.b801	4c 38 b8	jmp $b838			jmp ZBranch_Comma	; The address to loop back to is on the stack.
=8					CodeLen	.var *-XtPtr1
=$b804					Here1 = *	; remember here
>b7fa	08					.byte CodeLen	;patch wh_CodeLength
>b804	57 68 69 6c 65			Name0:	.text "While"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=46985					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>b809	a5					.byte (("While"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=28					WordFlags ::= IM+CO+NN	; modifiable copy, remember for later
=17					LinkDisplacement = Nt0-WordListLink
>b80a	1c					.byte WordFlags	;wh_Flags
>b80b	03					.byte 3	;wh_CodeLength
>b80c	11					  .byte LinkDisplacement	; offset to previous nt
=$b80d					XtPtr1 ::= *
=46985					WordListLink ::= Nt0 ; remember the nt of this word for later
.b80d	a9 d7		lda #$d7	While:		lda #<Begin	; check pairing
.b80f	20 77 c3	jsr $c377			jsr QPairCtlA
.b812	20 75 b7	jsr $b775			jsr If3		; Compile a 0branch & jmp, push addr of addr
.b815	20 ad e1	jsr $e1ad			jsr Swap	; Swap the two addresses on the stack.
.b818	a9 d7		lda #$d7			lda #<Begin	; pairing marker
.b81a	4c 5d c9	jmp $c95d			jmp PushZA
=16					CodeLen	.var *-XtPtr1
=$b81d					Here1 = *	; remember here
>b80b	10					.byte CodeLen	;patch wh_CodeLength
>b81d	52 65 70 65 61 74		Name0:	.text "Repeat"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=47011					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>b823	86					.byte (("Repeat"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=28					WordFlags ::= IM+CO+NN	; modifiable copy, remember for later
=26					LinkDisplacement = Nt0-WordListLink
>b824	1c					.byte WordFlags	;wh_Flags
>b825	03					.byte 3	;wh_CodeLength
>b826	1a					  .byte LinkDisplacement	; offset to previous nt
=$b827					XtPtr1 ::= *
=47011					WordListLink ::= Nt0 ; remember the nt of this word for later
.b827	a9 d7		lda #$d7	Repeat:		lda #<Begin	; check pairing
.b829	20 77 c3	jsr $c377			jsr QPairCtlA
.b82c	20 38 df	jsr $df38			jsr Jmp_Comma	; compile the jmp back
.b82f	20 04 dc	jsr $dc04			jsr Here	; patch the WHILE jmp operand
.b832	20 ad e1	jsr $e1ad			jsr Swap
.b835	4c cb e0	jmp $e0cb			jmp Store
=17					CodeLen	.var *-XtPtr1
=$b838					Here1 = *	; remember here
>b825	11					.byte CodeLen	;patch wh_CodeLength
.b838					ZBranch_Comma:
.b838	a9 e8		lda #$e8			lda #$e8		; compile inx; inx
.b83a	a8		tay				tay
.b83b	20 f6 de	jsr $def6			jsr Comma_YA
.b83e	a9 b5		lda #$b5			lda #$b5		; compile lda DStack-2,x
.b840	a0 24		ldy #$24			ldy #DStack-2
.b842	20 f6 de	jsr $def6			jsr Comma_YA
.b845	a9 15		lda #$15			lda #$15		; compile ora DStack-1,x
.b847	a0 25		ldy #$25			ldy #DStack-1
.b849	20 f6 de	jsr $def6			jsr Comma_YA
.b84c	a9 f0		lda #$f0			lda #$f0		; BEQ
.b84e	d0 0e		bne $b85e			bne Branch_CommaA
>b850	42 72 61 6e 63 68 2c		Name0:	.text "Branch,"	;  name of word as a string, ending at wh_NameLastChar
=7					NameLength = *-Name0
=47063					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>b857	87					.byte (("Branch,"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=52					LinkDisplacement = Nt0-WordListLink
>b858	10					.byte WordFlags	;wh_Flags
>b859	03					.byte 3	;wh_CodeLength
>b85a	34					  .byte LinkDisplacement	; offset to previous nt
=$b85b					XtPtr1 ::= *
=47063					WordListLink ::= Nt0 ; remember the nt of this word for later
.b85b	20 47 c5	jsr $c547			jsr PopA		; pop opcode to A
.b85e					Branch_CommaA:
.b85e	48		pha				pha			; save branch opcode
.b85f	38		sec				sec			; AY= displacement+2
.b860	b5 26		lda $26,x			lda DStack+0,x
.b862	e5 00		sbc $00				sbc cp+0
.b864	a8		tay				tay
.b865	b5 27		lda $27,x			lda DStack+1,x
.b867	e5 01		sbc $01				sbc cp+1
.b869	c9 ff		cmp #$ff			cmp #$ff		; offset maybe in range?
.b86b	f0 0b		beq $b878			beq _rev
.b86d	68		pla		_2byte:		pla			; restore branch opcode
.b86e	49 20		eor #$20			eor #$20		; reverse branch sense
.b870	a0 03		ldy #$03			ldy #3			; compile Bcc *+5
.b872	20 f6 de	jsr $def6			jsr Comma_YA
.b875	4c 38 df	jmp $df38			jmp Jmp_Comma		; compile JMP abs
.b878	c0 82		cpy #$82	_rev:		cpy #$80+2		; offset in range?
.b87a	90 f1		bcc $b86d			bcc _2byte
.b87c	e8		inx		_1byte:		inx			; Drop address
.b87d	e8		inx				inx
.b87e	88		dey				dey			; fix displacement
.b87f	88		dey				dey
.b880	68		pla				pla			; restore branch opcode
.b881	4c f6 de	jmp $def6			jmp Comma_YA		; compile Bcc
>b884	57 6f 72 64			Name0:	.text "Word"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=47112					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>b888	84					.byte (("Word"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=49					LinkDisplacement = Nt0-WordListLink
>b889	10					.byte WordFlags	;wh_Flags
>b88a	03					.byte 3	;wh_CodeLength
>b88b	31					  .byte LinkDisplacement	; offset to previous nt
=$b88c					XtPtr1 ::= *
=47112					WordListLink ::= Nt0 ; remember the nt of this word for later
.b88c					Word:
.b88c	20 8b c5	jsr $c58b			jsr underflow_1
.b88f	a4 08		ldy $08				ldy toin+0		; >IN
.b891	c4 06		cpy $06		_DelimLoop:	cpy ciblen+0		; quit if end of input
.b893	f0 09		beq $b89e			beq _found_char
.b895	b1 04		lda ($04),y			lda (cib),y
.b897	d5 26		cmp $26,x			cmp DStack+0,x		; ASCII of delimiter
.b899	d0 03		bne $b89e			bne _found_char
.b89b	c8		iny				iny
.b89c	d0 f3		bne $b891			bne _DelimLoop
.b89e					_found_char:
.b89e	84 08		sty $08				sty toin+0		; Save index of where word starts
.b8a0	20 5c cc	jsr $cc5c			jsr Parse		; The real work is done by parse
.b8a3	20 47 c5	jsr $c547			jsr PopA		; pop u
.b8a6	85 16		sta $16				sta tmp2+0
.b8a8	20 6d c5	jsr $c56d			jsr PopTmp1		; pop addr
.b8ab	20 04 dc	jsr $dc04			jsr Here		; Return caddr
.b8ae	a5 16		lda $16				lda tmp2+0
.b8b0	a0 00		ldy #$00			ldy #0			; Save length of string
.b8b2	f0 03		beq $b8b7			beq _CopyStart
.b8b4	b1 14		lda ($14),y	_CopyLoop:	lda (tmp1),y
.b8b6	c8		iny				iny
.b8b7	20 df de	jsr $dedf	_CopyStart:	jsr C_Comma_A
.b8ba	c4 16		cpy $16				cpy tmp2+0
.b8bc	90 f6		bcc $b8b4			bcc _CopyLoop
=50					CodeLen	.var *-XtPtr1
=$b8be					Here1 = *	; remember here
>b88a	32					.byte CodeLen	;patch wh_CodeLength
.b8be	60		rts				rts
>b8bf	28				Name0:	.text "("	;  name of word as a string, ending at wh_NameLastChar
=1					NameLength = *-Name0
=47168					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>b8c0	01					.byte (("("[-1]&7)<<5)+NameLength	;wh_HashNameLen
=24					WordFlags ::= IM+NN	; modifiable copy, remember for later
=56					LinkDisplacement = Nt0-WordListLink
>b8c1	18					.byte WordFlags	;wh_Flags
>b8c2	03					.byte 3	;wh_CodeLength
>b8c3	38					  .byte LinkDisplacement	; offset to previous nt
=$b8c4					XtPtr1 ::= *
=47168					WordListLink ::= Nt0 ; remember the nt of this word for later
.b8c4	a9 29		lda #$29	Paren:		lda #')'		; separator
.b8c6	20 5f cc	jsr $cc5f			jsr Parse_A		; get string
.b8c9	4c 04 d7	jmp $d704			jmp Two_drop		; 2Drop the result.
=8					CodeLen	.var *-XtPtr1
=$b8cc					Here1 = *	; remember here
>b8c2	08					.byte CodeLen	;patch wh_CodeLength
>b8cc	2e 28				Name0:	.text ".("	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=47182					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>b8ce	02					.byte ((".("[-1]&7)<<5)+NameLength	;wh_HashNameLen
=24					WordFlags ::= IM+NN	; modifiable copy, remember for later
=14					LinkDisplacement = Nt0-WordListLink
>b8cf	18					.byte WordFlags	;wh_Flags
>b8d0	03					.byte 3	;wh_CodeLength
>b8d1	0e					  .byte LinkDisplacement	; offset to previous nt
=$b8d2					XtPtr1 ::= *
=47182					WordListLink ::= Nt0 ; remember the nt of this word for later
.b8d2	a9 29		lda #$29	Dot_paren:	lda #')'		; separator
.b8d4	20 5f cc	jsr $cc5f			jsr Parse_A		; get string
.b8d7	4c f1 df	jmp $dff1			jmp Type		; type the string
=8					CodeLen	.var *-XtPtr1
=$b8da					Here1 = *	; remember here
>b8d0	08					.byte CodeLen	;patch wh_CodeLength
>b8da	48 61 73 68			Name0:	.text "Hash"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=47198					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>b8de	04					.byte (("Hash"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=16					LinkDisplacement = Nt0-WordListLink
>b8df	10					.byte WordFlags	;wh_Flags
>b8e0	03					.byte 3	;wh_CodeLength
>b8e1	10					  .byte LinkDisplacement	; offset to previous nt
=$b8e2					XtPtr1 ::= *
=47198					WordListLink ::= Nt0 ; remember the nt of this word for later
.b8e2	20 47 c5	jsr $c547	Hash:		jsr PopA		; save length
.b8e5	85 16		sta $16				sta tmp2+0
.b8e7	b5 26		lda $26,x			lda DStack+0,x		; copy addr
.b8e9	b4 27		ldy $27,x			ldy DStack+1,x
.b8eb	85 14		sta $14				sta tmp1+0
.b8ed	84 15		sty $15				sty tmp1+1
.b8ef	a9 b3		lda #$b3			lda #$b3		; init hash
.b8f1	95 26		sta $26,x			sta DStack+0,x
.b8f3	95 27		sta $27,x			sta DStack+1,x
.b8f5	a0 00		ldy #$00			ldy #0			; for each char
.b8f7	f0 15		beq $b90e			beq _next
.b8f9	b1 14		lda ($14),y	_loop:		lda (tmp1),y		;   get char
.b8fb	c9 61		cmp #$61			cmp #'a'		;   uppercase
.b8fd	90 06		bcc $b905			bcc _3
.b8ff	c9 7b		cmp #$7b			cmp #'z'+1
.b901	b0 02		bcs $b905			bcs _3
.b903	29 df		and #$df			and #$df
.b905	16 26		asl $26,x	_3:		asl DStack+0,x		;   add to hash
.b907	36 27		rol $27,x			rol DStack+1,x
.b909	75 26		adc $26,x			adc DStack+0,x
.b90b	95 26		sta $26,x			sta DStack+0,x
.b90d	c8		iny				iny
.b90e	c4 16		cpy $16		_Next:		cpy tmp2+0
.b910	90 e7		bcc $b8f9			bcc _loop
=48					CodeLen	.var *-XtPtr1
=$b912					Here1 = *	; remember here
>b8e0	30					.byte CodeLen	;patch wh_CodeLength
.b912	60		rts				rts
>b913	45 6e 76 69 72 6f 6e 6d		Name0:	.text "Environment?"	;  name of word as a string, ending at wh_NameLastChar
>b91b	65 6e 74 3f
=12					NameLength = *-Name0
=47263					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>b91f	ec					.byte (("Environment?"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=65					LinkDisplacement = Nt0-WordListLink
>b920	10					.byte WordFlags	;wh_Flags
>b921	03					.byte 3	;wh_CodeLength
>b922	41					  .byte LinkDisplacement	; offset to previous nt
=$b923					XtPtr1 ::= *
=47263					WordListLink ::= Nt0 ; remember the nt of this word for later
.b923					Environment_Q:
.b923	20 e2 b8	jsr $b8e2			jsr Hash		; ( hash )
.b926	a0 00		ldy #$00			ldy #0			; Y= table index
.b928	f0 0a		beq $b934			beq _entry_test
.b92a	98		tya		_entry_next:	tya
.b92b	c0 34		cpy #$34			cpy #_table_dbl		; if double
.b92d	90 02		bcc $b931			bcc +
.b92f	69 01		adc #$01			adc #6-4-1		;   skip double
.b931	69 04		adc #$04	+		adc #4			;   skip single
.b933	a8		tay		_3:		tay
.b934	b9 68 b9	lda $b968,y	_entry_test:	lda _Table+0,y		; match?
.b937	f0 28		beq $b961			beq _notfound
.b939	d5 26		cmp $26,x			cmp DStack+0,x
.b93b	d0 ed		bne $b92a			bne _entry_next
.b93d	b9 69 b9	lda $b969,y			lda _Table+1,y
.b940	d5 27		cmp $27,x			cmp DStack+1,x
.b942	d0 e6		bne $b92a			bne _entry_next
.b944	b9 6a b9	lda $b96a,y			lda _Table+2,y
.b947	95 26		sta $26,x			sta DStack+0,x
.b949	b9 6b b9	lda $b96b,y			lda _Table+3,y
.b94c	95 27		sta $27,x			sta DStack+1,x
.b94e	c0 34		cpy #$34			cpy #_table_dbl		; single or double data?
.b950	90 0c		bcc $b95e			bcc _single
.b952	ca		dex				dex			;  push 2nd cell
.b953	ca		dex				dex
.b954	b9 6c b9	lda $b96c,y			lda _Table+4,y
.b957	95 26		sta $26,x			sta DStack+0,x
.b959	b9 6d b9	lda $b96d,y			lda _Table+5,y
.b95c	95 27		sta $27,x			sta DStack+1,x
.b95e					_single:
.b95e	4c 3d c9	jmp $c93d			jmp True		; return True
.b961					_notfound:
.b961	a9 00		lda #$00			lda #0			; return 0
.b963	95 26		sta $26,x			sta DStack+0,x
.b965	95 27		sta $27,x			sta DStack+1,x
.b967	60		rts				rts
=69					CodeLen	.var *-XtPtr1
=$b968					Here1 = *	; remember here
>b921	45					.byte CodeLen	;patch wh_CodeLength
.b968					_Table:
>b968	5e e6 ff 7f				.word $e65e,$7fff	; "/COUNTED-STRING"
>b96c	be 79 ff 00				.word $79BE,$ff		; "/HOLD"
>b970	b9 3c 54 00				.word $3cb9,padoffset	; "/PAD"
>b974	8b 81 08 00				.word $818b,8		; "ADDRESS-UNIT-BITS"
>b978	57 fc 00 00				.word $fc57,0		; "FLOORED"	we have symmetric)
>b97c	4f fb ff 00				.word $fb4f,$ff		; "MAX-CHAR"
>b980	56 7f ff 7f				.word $7f56,$7fff	; "MAX-N"
>b984	5d 7f ff ff				.word $7f5d,$ffff	; "MAX-U"
>b988	38 ce 80 00				.word $ce38,$80		; "RETURN-STACK-CELLS"
>b98c	f2 c0 18 00				.word $c0f2,DSDim	; "STACK-CELLS"
>b990	36 e3 09 00				.word $e336,9		; "WORDLISTS"
>b994	4a f2 ff ff				.word $f24a,$ffff	; "FLOATING"		flag	no	   floating-point word set present
>b998	01 99 0a 00				.word $9901,FSDim	; "FLOATING-STACK"	n	yes	   If n = zero, floating-point numbers are
=52					_table_dbl = *-_Table	; These return a double-cell number
>b99c	4c 7f ff ff ff 7f			.word $7f4c,$ffff,$7fff	; "MAX-D"
>b9a2	fe fe ff ff ff ff			.word $fefe,$ffff,$ffff	; "MAX-UD"
>b9a8	00					.byte 0		; end of list
>b9a9	44 75 6d 70			Name0:	.text "Dump"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=47405					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>b9ad	04					.byte (("Dump"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=142					LinkDisplacement = Nt0-WordListLink
>b9ae	10					.byte WordFlags	;wh_Flags
>b9af	03					.byte 3	;wh_CodeLength
>b9b0	8e					  .byte LinkDisplacement	; offset to previous nt
=$b9b1					XtPtr1 ::= *
=47405					WordListLink ::= Nt0 ; remember the nt of this word for later
.b9b1	20 9f c5	jsr $c59f	Dump:		jsr underflow_2
.b9b4	ca		dex				dex			; alloc work area
.b9b5	ca		dex				dex
.b9b6					_row:
.b9b6	20 b7 bc	jsr $bcb7			jsr CR
.b9b9	b5 2b		lda $2b,x			lda DStack+5,x		; print address number
.b9bb	20 39 ba	jsr $ba39			jsr C_Dot_Hex_A
.b9be	b5 2a		lda $2a,x			lda DStack+4,x
.b9c0	20 39 ba	jsr $ba39			jsr C_Dot_Hex_A
.b9c3	20 e5 df	jsr $dfe5			jsr Space
.b9c6	20 e5 df	jsr $dfe5			jsr Space
.b9c9	a9 00		lda #$00			lda #0
.b9cb	95 26		sta $26,x			sta DStack+0,x
.b9cd					_loop:
.b9cd	b5 28		lda $28,x			lda DStack+2,x
.b9cf	15 29		ora $29,x			ora DStack+3,x
.b9d1	f0 36		beq $ba09			beq _all_printed
.b9d3	a1 2a		lda ($2a,x)			lda (DStack+4,x)
.b9d5	20 39 ba	jsr $ba39			jsr C_Dot_Hex_A
.b9d8	20 e5 df	jsr $dfe5			jsr Space
.b9db	a1 2a		lda ($2a,x)			lda (DStack+4,x)
.b9dd	20 5f ba	jsr $ba5f			jsr is_printable
.b9e0	b0 02		bcs $b9e4			bcs _printable
.b9e2	a9 2e		lda #$2e			lda #'.'		 ; Print dot if not printable
.b9e4					_printable:
.b9e4	b4 26		ldy $26,x			ldy DStack+0,x
.b9e6	91 00		sta ($00),y			sta (cp),y
.b9e8	c0 07		cpy #$07			cpy #7
.b9ea	d0 03		bne $b9ef			bne +
.b9ec	20 e5 df	jsr $dfe5			jsr Space
.b9ef					+
.b9ef	f6 2a		inc $2a,x			inc DStack+4,x
.b9f1	d0 02		bne $b9f5			bne +
.b9f3	f6 2b		inc $2b,x			inc DStack+5,x
.b9f5					+
.b9f5	20 1e dc	jsr $dc1e			jsr NOS_One_Minus	; loop counter
.b9f8	f6 26		inc $26,x			inc DStack+0,x
.b9fa	b5 26		lda $26,x			lda DStack+0,x
.b9fc	c9 10		cmp #$10			cmp #16
.b9fe	90 cd		bcc $b9cd			bcc _loop		; next byte
.ba00	20 e5 df	jsr $dfe5			jsr Space
.ba03	20 18 ba	jsr $ba18			jsr dump_print_ascii
.ba06	4c b6 b9	jmp $b9b6			jmp _row		; new row
.ba09					_all_printed:
.ba09	b5 26		lda $26,x			lda DStack+0,x
.ba0b	f0 06		beq $ba13			beq _done
.ba0d	20 e5 df	jsr $dfe5			jsr Space
.ba10	20 18 ba	jsr $ba18			jsr dump_print_ascii
.ba13					_done:
.ba13	e8		inx				inx			; drop work area
.ba14	e8		inx				inx
.ba15	4c 04 d7	jmp $d704			jmp Two_drop		; one byte less than 4x INX
.ba18					dump_print_ascii:
.ba18	a0 00		ldy #$00			ldy #0
.ba1a					_loop:
.ba1a	b1 00		lda ($00),y			lda (cp),y
.ba1c	20 cd df	jsr $dfcd			jsr Emit_A
.ba1f	c8		iny				iny
.ba20	c0 08		cpy #$08			cpy #8
.ba22	d0 03		bne $ba27			bne +
.ba24	20 e5 df	jsr $dfe5			jsr Space
.ba27					+
.ba27	98		tya				tya
.ba28	d5 26		cmp $26,x			cmp DStack+0,x
.ba2a	90 ee		bcc $ba1a			bcc _loop
.ba2c	60		rts				rts
=124					CodeLen	.var *-XtPtr1
=$ba2d					Here1 = *	; remember here
>b9af	7c					.byte CodeLen	;patch wh_CodeLength
>ba2d	43 2e 48 65 78			Name0:	.text "C.Hex"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=47538					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>ba32	05					.byte (("C.Hex"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=133					LinkDisplacement = Nt0-WordListLink
>ba33	10					.byte WordFlags	;wh_Flags
>ba34	03					.byte 3	;wh_CodeLength
>ba35	85					  .byte LinkDisplacement	; offset to previous nt
=$ba36					XtPtr1 ::= *
=47538					WordListLink ::= Nt0 ; remember the nt of this word for later
.ba36	20 47 c5	jsr $c547	C_Dot_Hex:	jsr PopA
.ba39	48		pha		C_Dot_Hex_A:	pha
.ba3a	4a		lsr a				lsr		; convert high nibble first
.ba3b	4a		lsr a				lsr
.ba3c	4a		lsr a				lsr
.ba3d	4a		lsr a				lsr
.ba3e	20 42 ba	jsr $ba42			jsr _nibble_to_ascii
.ba41	68		pla				pla
.ba42					_nibble_to_ascii:
.ba42	29 0f		and #$0f			and #$0F	; only use lower nibble
.ba44	c9 0a		cmp #$0a			cmp #9+1
.ba46	90 02		bcc $ba4a			bcc +
.ba48	69 06		adc #$06			adc #6
.ba4a	69 30		adc #$30	+		adc #'0'
.ba4c	4c cd df	jmp $dfcd			jmp Emit_A
=25					CodeLen	.var *-XtPtr1
=$ba4f					Here1 = *	; remember here
>ba34	19					.byte CodeLen	;patch wh_CodeLength
>ba4f	2e 48 65 78			Name0:	.text ".Hex"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=47571					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>ba53	04					.byte ((".Hex"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=33					LinkDisplacement = Nt0-WordListLink
>ba54	10					.byte WordFlags	;wh_Flags
>ba55	03					.byte 3	;wh_CodeLength
>ba56	21					  .byte LinkDisplacement	; offset to previous nt
=$ba57					XtPtr1 ::= *
=47571					WordListLink ::= Nt0 ; remember the nt of this word for later
.ba57	b5 27		lda $27,x	Dot_Hex:	lda DStack+1,x	; do hi byte
.ba59	20 39 ba	jsr $ba39			jsr C_Dot_Hex_A
.ba5c	4c 36 ba	jmp $ba36			jmp C_Dot_Hex	; do lo byte
=8					CodeLen	.var *-XtPtr1
=$ba5f					Here1 = *	; remember here
>ba55	08					.byte CodeLen	;patch wh_CodeLength
.ba5f					is_printable:
.ba5f	c9 20		cmp #$20	                cmp #AscSP              ; $20
.ba61	90 07		bcc $ba6a	                bcc _done
.ba63	c9 80		cmp #$80	                cmp #$7F + 1             ; '~'
.ba65	b0 02		bcs $ba69	                bcs _failed
.ba67	38		sec		                sec
.ba68	60		rts		                rts
.ba69	18		clc		_failed:	clc
.ba6a	60		rts		_done:		rts
>ba6b	2e 53				Name0:	.text ".S"	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=47597					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>ba6d	62					.byte ((".S"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=26					LinkDisplacement = Nt0-WordListLink
>ba6e	10					.byte WordFlags	;wh_Flags
>ba6f	03					.byte 3	;wh_CodeLength
>ba70	1a					  .byte LinkDisplacement	; offset to previous nt
=$ba71					XtPtr1 ::= *
=47597					WordListLink ::= Nt0 ; remember the nt of this word for later
.ba71					Dot_s:
.ba71	a9 3c		lda #$3c			lda #'<'
.ba73	20 cd df	jsr $dfcd			jsr Emit_A
.ba76	20 f3 d3	jsr $d3f3			jsr Depth	; ( -- u )
.ba79	20 0c de	jsr $de0c			jsr print_u
.ba7c	a9 3e		lda #$3e			lda #'>'
.ba7e	20 cd df	jsr $dfcd			jsr Emit_A
.ba81	20 e5 df	jsr $dfe5			jsr Space
.ba84	a0 30		ldy #$30			ldy #DSDim*2		; for each cell on the stack
.ba86	88		dey		_loop:		dey
.ba87	88		dey				dey
.ba88	86 14		stx $14				stx tmp1
.ba8a	c4 14		cpy $14				cpy tmp1
.ba8c	90 15		bcc $baa3			bcc _done
.ba8e	98		tya				tya			; save index
.ba8f	48		pha				pha
.ba90	ca		dex				dex			; push stack[index]
.ba91	ca		dex				dex
.ba92	b9 26 00	lda $0026,y			lda DStack+0,y
.ba95	95 26		sta $26,x			sta DStack+0,x
.ba97	b9 27 00	lda $0027,y			lda DStack+1,y
.ba9a	95 27		sta $27,x			sta DStack+1,x
.ba9c	20 c2 dd	jsr $ddc2			jsr Dot
.ba9f	68		pla				pla			; restore index
.baa0	a8		tay				tay
.baa1	d0 e3		bne $ba86			bne _loop
.baa3					_done:
=50					CodeLen	.var *-XtPtr1
=$baa3					Here1 = *	; remember here
>ba6f	32					.byte CodeLen	;patch wh_CodeLength
.baa3	60		rts				rts
>baa4	43 6f 6d 70 61 72 65		Name0:	.text "Compare"	;  name of word as a string, ending at wh_NameLastChar
=7					NameLength = *-Name0
=47659					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>baab	a7					.byte (("Compare"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=80					WordFlags ::= UF+NN	; modifiable copy, remember for later
=62					LinkDisplacement = Nt0-WordListLink
>baac	50					.byte WordFlags	;wh_Flags
>baad	03					.byte 3	;wh_CodeLength
>baae	3e					  .byte LinkDisplacement	; offset to previous nt
=$baaf					XtPtr1 ::= *
=47659					WordListLink ::= Nt0 ; remember the nt of this word for later
.baaf					Compare:
.baaf	20 a9 c5	jsr $c5a9			jsr underflow_4
.bab2	b5 26		lda $26,x			lda DStack+0,x		; tmp3+1= u2.lo
.bab4	85 19		sta $19				sta tmp3+1
.bab6	b5 28		lda $28,x			lda DStack+2,x		; tmp2= addr2
.bab8	b4 29		ldy $29,x			ldy DStack+3,x
.baba	85 16		sta $16				sta tmp2+0
.babc	84 17		sty $17				sty tmp2+1
.babe	b5 2a		lda $2a,x			lda DStack+4,x		; tmp3+0= u1.lo
.bac0	85 18		sta $18				sta tmp3+0
.bac2	b5 2c		lda $2c,x			lda DStack+6,x		; tmp1= addr1
.bac4	b4 2d		ldy $2d,x			ldy DStack+7,x
.bac6	85 14		sta $14				sta tmp1+0
.bac8	84 15		sty $15				sty tmp1+1
.baca	a0 00		ldy #$00			ldy #0		; for each char
.bacc					_loop:
.bacc	c4 18		cpy $18				cpy tmp3+0	; string1 empty?
.bace	f0 13		beq $bae3			beq _str1
.bad0					_L1:
.bad0	c4 19		cpy $19				cpy tmp3+1	; string2 empty?
.bad2	f0 27		beq $bafb			beq _str2
.bad4					_L2:
.bad4	b1 14		lda ($14),y			lda (tmp1),y	; Are they different?
.bad6	d1 16		cmp ($16),y			cmp (tmp2),y
.bad8	d0 19		bne $baf3			bne _neq
.bada	c8		iny				iny		; to next char
.badb	d0 ef		bne $bacc			bne _loop
.badd	e6 15		inc $15				inc tmp1+1	; to next page
.badf	e6 17		inc $17				inc tmp2+1
.bae1	d0 e9		bne $bacc			bne _loop
.bae3	d6 2b		dec $2b,x	_str1:		dec DStack+5,x	; string1 really empty?
.bae5	10 e9		bpl $bad0			bpl _L1
.bae7	c4 19		cpy $19				cpy tmp3+1	; string2 empty?
.bae9	d0 0a		bne $baf5			bne _less
.baeb	b5 27		lda $27,x			lda DStack+1,x
.baed	d0 06		bne $baf5			bne _less
.baef	a9 00		lda #$00	_equal:		lda #0		; Return 0
.baf1	f0 0e		beq $bb01			beq _gt2
.baf3	b0 0a		bcs $baff	_neq:		bcs _greater
.baf5	a9 ff		lda #$ff	_less:		lda #$FF	; Return -1
.baf7	95 2c		sta $2c,x			sta DStack+6,x
.baf9	d0 0a		bne $bb05			bne _done
.bafb	d6 27		dec $27,x	_str2:		dec DStack+1,x	; is string2 empty?
.bafd	10 d5		bpl $bad4			bpl _L2
.baff	a9 01		lda #$01	_greater:	lda #1		; Return 1
.bb01	95 2c		sta $2c,x	_gt2:		sta DStack+6,x
.bb03	a9 00		lda #$00			lda #0
.bb05	95 2d		sta $2d,x	_done:		sta DStack+7,x
.bb07	8a		txa				txa		; Remove all but the result from the stack.
.bb08	18		clc				clc
.bb09	69 06		adc #$06			adc #6
.bb0b	aa		tax				tax
=93					CodeLen	.var *-XtPtr1
=$bb0c					Here1 = *	; remember here
>baad	5d					.byte CodeLen	;patch wh_CodeLength
.bb0c	60		rts				rts
>bb0d	53 65 61 72 63 68		Name0:	.text "Search"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=47763					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>bb13	06					.byte (("Search"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=104					LinkDisplacement = Nt0-WordListLink
>bb14	10					.byte WordFlags	;wh_Flags
>bb15	03					.byte 3	;wh_CodeLength
>bb16	68					  .byte LinkDisplacement	; offset to previous nt
=$bb17					XtPtr1 ::= *
=47763					WordListLink ::= Nt0 ; remember the nt of this word for later
.bb17					Search:
.bb17	20 a9 c5	jsr $c5a9			jsr underflow_4
.bb1a	b5 26		lda $26,x			lda DStack+0,x
.bb1c	15 27		ora $27,x			ora DStack+1,x
.bb1e	d0 09		bne $bb29			bne _start_search
.bb20	e8		inx				inx		; Drop u2
.bb21	e8		inx				inx
.bb22	a9 ff		lda #$ff			lda #$FF	; overwrite addr2 with a true flag
.bb24	95 26		sta $26,x			sta DStack+0,x
.bb26	95 27		sta $27,x			sta DStack+1,x
.bb28	60		rts				rts
.bb29					_start_search:
.bb29	20 6b c9	jsr $c96b			jsr Zero
.bb2c					_search_loop:
.bb2c	18		clc				clc
.bb2d	b5 26		lda $26,x			lda DStack+0,x
.bb2f	75 28		adc $28,x			adc DStack+2,x
.bb31	85 14		sta $14				sta tmp1+0
.bb33	b5 27		lda $27,x			lda DStack+1,x
.bb35	75 29		adc $29,x			adc DStack+3,x
.bb37	85 15		sta $15				sta tmp1+1
.bb39	d5 2d		cmp $2d,x			cmp DStack+7,x
.bb3b	90 13		bcc $bb50			bcc _init_comparison ; Obviously less
.bb3d	d0 06		bne $bb45			bne _not_found
.bb3f	b5 2c		lda $2c,x			lda DStack+6,x
.bb41	c5 14		cmp $14				cmp tmp1
.bb43	b0 0b		bcs $bb50			bcs _init_comparison
.bb45					_not_found:
.bb45	e8		inx				inx		; Remove offset
.bb46	e8		inx				inx
.bb47	e8		inx				inx		; Remove u2
.bb48	e8		inx				inx
.bb49	a9 00		lda #$00			lda #0
.bb4b	95 26		sta $26,x			sta DStack+0,x	; Turn addr2 into a false flag
.bb4d	95 27		sta $27,x			sta DStack+1,x
.bb4f	60		rts				rts
.bb50					_init_comparison:
.bb50	18		clc				clc
.bb51	b5 2e		lda $2e,x			lda DStack+8,x
.bb53	75 26		adc $26,x			adc DStack+0,x
.bb55	85 14		sta $14				sta tmp1
.bb57	b5 2f		lda $2f,x			lda DStack+9,x
.bb59	75 27		adc $27,x			adc DStack+1,x
.bb5b	85 15		sta $15				sta tmp1+1
.bb5d	b5 2a		lda $2a,x			lda DStack+4,x
.bb5f	85 16		sta $16				sta tmp2
.bb61	b5 2b		lda $2b,x			lda DStack+5,x
.bb63	85 17		sta $17				sta tmp2+1
.bb65	b5 28		lda $28,x			lda DStack+2,x
.bb67	85 18		sta $18				sta tmp3+0
.bb69	b5 29		lda $29,x			lda DStack+3,x
.bb6b	85 19		sta $19				sta tmp3+1
.bb6d					_comparison_loop:
.bb6d	a0 00		ldy #$00			ldy #0
.bb6f	b1 14		lda ($14),y			lda (tmp1),y
.bb71	d1 16		cmp ($16),y			cmp (tmp2),y
.bb73	f0 06		beq $bb7b			beq _letters_match
.bb75	20 37 dc	jsr $dc37			jsr One_plus
.bb78	4c 2c bb	jmp $bb2c			jmp _search_loop
.bb7b					_letters_match:
.bb7b	e6 14		inc $14				inc tmp1
.bb7d	d0 02		bne $bb81			bne +
.bb7f	e6 15		inc $15				inc tmp1+1
.bb81					+
.bb81	e6 16		inc $16				inc tmp2
.bb83	d0 02		bne $bb87			bne +
.bb85	e6 17		inc $17				inc tmp2+1
.bb87					+
.bb87	a5 18		lda $18				lda tmp3
.bb89	d0 02		bne $bb8d			bne +
.bb8b	c6 19		dec $19				dec tmp3+1
.bb8d					+
.bb8d	c6 18		dec $18				dec tmp3
.bb8f	a5 18		lda $18				lda tmp3
.bb91	05 19		ora $19				ora tmp3+1
.bb93	d0 d8		bne $bb6d			bne _comparison_loop ; Check the next letter
.bb95	18		clc				clc
.bb96	b5 26		lda $26,x			lda DStack+0,x
.bb98	75 2e		adc $2e,x			adc DStack+8,x
.bb9a	95 2e		sta $2e,x			sta DStack+8,x
.bb9c	b5 27		lda $27,x			lda DStack+1,x
.bb9e	75 2f		adc $2f,x			adc DStack+9,x
.bba0	95 2f		sta $2f,x			sta DStack+9,x
.bba2	38		sec				sec
.bba3	b5 2c		lda $2c,x			lda DStack+6,x
.bba5	f5 26		sbc $26,x			sbc DStack+0,x
.bba7	95 2c		sta $2c,x			sta DStack+6,x
.bba9	b5 2d		lda $2d,x			lda DStack+7,x
.bbab	f5 27		sbc $27,x			sbc DStack+1,x
.bbad	95 2d		sta $2d,x			sta DStack+7,x
.bbaf	e8		inx				inx		; drop offset
.bbb0	e8		inx				inx
.bbb1	e8		inx				inx		; drop u2
.bbb2	e8		inx				inx
.bbb3	a9 ff		lda #$ff			lda #$FF
.bbb5	95 26		sta $26,x			sta DStack+0,x	; Turn addr2 into a true flag.
.bbb7	95 27		sta $27,x			sta DStack+1,x
=162					CodeLen	.var *-XtPtr1
=$bbb9					Here1 = *	; remember here
>bb15	a2					.byte CodeLen	;patch wh_CodeLength
.bbb9	60		rts				rts
>bbba	4d 61 72 6b 65 72		Name0:	.text "Marker"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=47936					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>bbc0	46					.byte (("Marker"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=24					WordFlags ::= IM+NN	; modifiable copy, remember for later
=173					LinkDisplacement = Nt0-WordListLink
>bbc1	18					.byte WordFlags	;wh_Flags
>bbc2	03					.byte 3	;wh_CodeLength
>bbc3	ad					  .byte LinkDisplacement	; offset to previous nt
=$bbc4					XtPtr1 ::= *
=47936					WordListLink ::= Nt0 ; remember the nt of this word for later
.bbc4					Marker:
.bbc4	20 04 dc	jsr $dc04			jsr Here		; Save original CP, which
.bbc7	20 c0 d2	jsr $d2c0			jsr Header_Build	; compile a word header, but don't link into wordlist
.bbca	a0 bb		ldy #$bb			ldy #>_runtime		; compile JSR _runtime
.bbcc	a9 e4		lda #$e4			lda #<_runtime
.bbce	20 25 df	jsr $df25			jsr Jsr_Comma_YA
.bbd1	20 f3 de	jsr $def3			jsr Comma		; Append original CP
.bbd4	a0 00		ldy #$00			ldy #0			; Start at CURRENT
.bbd6	b9 10 03	lda $0310,y	_loop:		lda CurrentV,y
.bbd9	20 df de	jsr $dedf			jsr C_Comma_A
.bbdc	c8		iny				iny
.bbdd	c0 24		cpy #$24			cpy #MarkEnd-CurrentV	; One past the end of the search order.
.bbdf	90 f5		bcc $bbd6			bcc _loop
.bbe1	4c b5 d2	jmp $d2b5			jmp Header_Link		; link built header into current dictionary
=32					CodeLen	.var *-XtPtr1
=$bbe4					Here1 = *	; remember here
>bbc2	20					.byte CodeLen	;patch wh_CodeLength
.bbe4					_runtime:
.bbe4	68		pla				pla		; Pop the RTS address off the stack
.bbe5	85 14		sta $14				sta tmp1+0
.bbe7	68		pla				pla
.bbe8	85 15		sta $15				sta tmp1+1
.bbea	a0 01		ldy #$01			ldy #1		; start just aftet JSR _runtime
.bbec	b1 14		lda ($14),y			lda (tmp1),y	; CP was stored first
.bbee	85 00		sta $00				sta cp+0
.bbf0	c8		iny				iny
.bbf1	b1 14		lda ($14),y			lda (tmp1),y
.bbf3	85 01		sta $01				sta cp+1
.bbf5	c8		iny				iny
.bbf6					_rloop:
.bbf6	b1 14		lda ($14),y			lda (tmp1),y
.bbf8	99 0d 03	sta $030d,y			sta CurrentV-2-1,y
.bbfb	c8		iny				iny
.bbfc	c0 27		cpy #$27			cpy #MarkEnd-CurrentV+2+1 ; One past the end of the search order.
.bbfe	90 f6		bcc $bbf6			bcc _rloop
.bc00	60		rts				rts
>bc01	57 6f 72 64 73			Name0:	.text "Words"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=48006					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>bc06	65					.byte (("Words"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=70					LinkDisplacement = Nt0-WordListLink
>bc07	10					.byte WordFlags	;wh_Flags
>bc08	03					.byte 3	;wh_CodeLength
>bc09	46					  .byte LinkDisplacement	; offset to previous nt
=$bc0a					XtPtr1 ::= *
=48006					WordListLink ::= Nt0 ; remember the nt of this word for later
.bc0a					Words:
.bc0a	a9 ff		lda #$ff			lda #$ff
.bc0c	20 5d c9	jsr $c95d			jsr PushZA		; Alloc space for line size & wordlist #
.bc0f	ca		dex				dex			; Alloc space for a nt
.bc10	ca		dex				dex
.bc11					_wordlist_next:
.bc11	20 b7 bc	jsr $bcb7			jsr CR			; start wordlist on new line
.bc14	f6 28		inc $28,x			inc DStack+2,x		; step to next search wordlist
.bc16	b4 28		ldy $28,x			ldy DStack+2,x		; Y= wordlist index
.bc18	cc 2a 03	cpy $032a			cpy Num_OrderV
.bc1b	b0 44		bcs $bc61			bcs _wordslist_done	; ran out of search wordlist entries?
.bc1d	b9 2b 03	lda $032b,y			lda Search_OrderV,y	; A= SEARCH-ORDER[Y]	Get the current wordlist id
.bc20	0a		asl a				asl			; TOS= WORDLISTS[A]
.bc21	a8		tay				tay
.bc22	b9 12 03	lda $0312,y			lda WordlistsV+0,y
.bc25	95 26		sta $26,x			sta DStack+0,x
.bc27	b9 13 03	lda $0313,y			lda WordlistsV+1,y
.bc2a	95 27		sta $27,x			sta DStack+1,x
.bc2c	f0 e3		beq $bc11			beq _wordlist_next	; end of list?
.bc2e					_word_loop:
.bc2e	20 8a e1	jsr $e18a			jsr Dup			; ( wordlist# nt nt )
.bc31	20 85 cf	jsr $cf85			jsr Name_To_String	; ( wordlist# nt addr u )
.bc34	b5 2d		lda $2d,x			lda DStack+7,x
.bc36	38		sec				sec			; don't forget the space between words
.bc37	75 26		adc $26,x			adc DStack+0,x
.bc39	c9 4e		cmp #$4e			cmp #MAX_LINE_LENGTH-1
.bc3b	90 05		bcc $bc42			bcc +
.bc3d	20 b7 bc	jsr $bcb7			jsr CR
.bc40	b5 26		lda $26,x			lda DStack+0,x		; After going to next line, start
.bc42	95 2d		sta $2d,x	+		sta DStack+7,x
.bc44	20 f1 df	jsr $dff1			jsr Type		; ( wordlist# nt )
.bc47	20 e5 df	jsr $dfe5			jsr Space
.bc4a	b5 26		lda $26,x			lda DStack+0,x
.bc4c	85 14		sta $14				sta tmp1+0
.bc4e	b5 27		lda $27,x			lda DStack+1,x
.bc50	85 15		sta $15				sta tmp1+1
.bc52	20 95 82	jsr $8295			jsr LinkNext		; tmp1= next word nt in list
.bc55	a5 14		lda $14				lda tmp1+0
.bc57	95 26		sta $26,x			sta DStack+0,x
.bc59	a5 15		lda $15				lda tmp1+1
.bc5b	95 27		sta $27,x			sta DStack+1,x
.bc5d	d0 cf		bne $bc2e			bne _word_loop		; end of list?
.bc5f	f0 b0		beq $bc11			beq _wordlist_next
.bc61					_wordslist_done:
.bc61	4c 04 d7	jmp $d704			jmp Two_Drop
=90					CodeLen	.var *-XtPtr1
=$bc64					Here1 = *	; remember here
>bc08	5a					.byte CodeLen	;patch wh_CodeLength
>bc64	57 6f 72 64 53 69 7a 65		Name0:	.text "WordSize"	;  name of word as a string, ending at wh_NameLastChar
=8					NameLength = *-Name0
=48108					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>bc6c	a8					.byte (("WordSize"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=102					LinkDisplacement = Nt0-WordListLink
>bc6d	10					.byte WordFlags	;wh_Flags
>bc6e	03					.byte 3	;wh_CodeLength
>bc6f	66					  .byte LinkDisplacement	; offset to previous nt
=$bc70					XtPtr1 ::= *
=48108					WordListLink ::= Nt0 ; remember the nt of this word for later
.bc70	20 6d c5	jsr $c56d	WordSize:	jsr PopTmp1
.bc73	a0 82		ldy #$82			ldy #Wh_CodeLength
.bc75	b1 14		lda ($14),y			lda (tmp1),y
.bc77	4c 5d c9	jmp $c95d			jmp PushZA
=10					CodeLen	.var *-XtPtr1
=$bc7a					Here1 = *	; remember here
>bc6e	0a					.byte CodeLen	;patch wh_CodeLength
>bc7a	41 6c 69 67 6e 65 64		Name0:	.text "Aligned"	;  name of word as a string, ending at wh_NameLastChar
=7					NameLength = *-Name0
=48129					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>bc81	87					.byte (("Aligned"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=0					WordFlags ::= 0	; modifiable copy, remember for later
=21					LinkDisplacement = Nt0-WordListLink
>bc82	00					.byte WordFlags	;wh_Flags
>bc83	03					.byte 3	;wh_CodeLength
>bc84	15					  .byte LinkDisplacement	; offset to previous nt
=$bc85					XtPtr1 ::= *
=48129					WordListLink ::= Nt0 ; remember the nt of this word for later
.bc85					Aligned:
=0					CodeLen	.var *-XtPtr1
=$bc85					Here1 = *	; remember here
>bc83	00					.byte CodeLen	;patch wh_CodeLength
.bc85	60		rts				rts
>bc86	41 6c 69 67 6e			Name0:	.text "Align"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=48139					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>bc8b	c5					.byte (("Align"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=0					WordFlags ::= 0	; modifiable copy, remember for later
=10					LinkDisplacement = Nt0-WordListLink
>bc8c	00					.byte WordFlags	;wh_Flags
>bc8d	03					.byte 3	;wh_CodeLength
>bc8e	0a					  .byte LinkDisplacement	; offset to previous nt
=$bc8f					XtPtr1 ::= *
=48139					WordListLink ::= Nt0 ; remember the nt of this word for later
.bc8f					Align:
=0					CodeLen	.var *-XtPtr1
=$bc8f					Here1 = *	; remember here
>bc8d	00					.byte CodeLen	;patch wh_CodeLength
.bc8f	60		rts				rts
>bc90	4f 75 74 70 75 74		Name0:	.text "Output"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=48150					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>bc96	86					.byte (("Output"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=11					LinkDisplacement = Nt0-WordListLink
>bc97	10					.byte WordFlags	;wh_Flags
>bc98	03					.byte 3	;wh_CodeLength
>bc99	0b					  .byte LinkDisplacement	; offset to previous nt
=$bc9a					XtPtr1 ::= *
=48150					WordListLink ::= Nt0 ; remember the nt of this word for later
.bc9a	a9 06		lda #$06			lda #<output
.bc9c	a0 03		ldy #$03			ldy #>output
.bc9e	4c 2e c9	jmp $c92e			jmp PushYA
=7					CodeLen	.var *-XtPtr1
=$bca1					Here1 = *	; remember here
>bc98	07					.byte CodeLen	;patch wh_CodeLength
>bca1	49 6e 70 75 74			Name0:	.text "Input"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=48166					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>bca6	85					.byte (("Input"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=16					LinkDisplacement = Nt0-WordListLink
>bca7	10					.byte WordFlags	;wh_Flags
>bca8	03					.byte 3	;wh_CodeLength
>bca9	10					  .byte LinkDisplacement	; offset to previous nt
=$bcaa					XtPtr1 ::= *
=48166					WordListLink ::= Nt0 ; remember the nt of this word for later
.bcaa	a9 08		lda #$08			lda #<input
.bcac	a0 03		ldy #$03			ldy #>input
.bcae	4c 2e c9	jmp $c92e			jmp PushYA
=7					CodeLen	.var *-XtPtr1
=$bcb1					Here1 = *	; remember here
>bca8	07					.byte CodeLen	;patch wh_CodeLength
>bcb1	43 52				Name0:	.text "CR"	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=48179					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>bcb3	42					.byte (("CR"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>bcb4	10					.byte WordFlags	;wh_Flags
>bcb5	03					.byte 3	;wh_CodeLength
>bcb6	0d					  .byte LinkDisplacement	; offset to previous nt
=$bcb7					XtPtr1 ::= *
=48179					WordListLink ::= Nt0 ; remember the nt of this word for later
.bcb7					CR:
.bcb7	a9 0d		lda #$0d			lda #AscCR
.bcb9	20 cd df	jsr $dfcd			jsr Emit_A
.bcbc	a9 0a		lda #$0a			lda #AscLF
.bcbe	20 cd df	jsr $dfcd			jsr Emit_A
=10					CodeLen	.var *-XtPtr1
=$bcc1					Here1 = *	; remember here
>bcb5	0a					.byte CodeLen	;patch wh_CodeLength
.bcc1	60		rts				rts
>bcc2	50 61 67 65			Name0:	.text "Page"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=48198					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>bcc6	a4					.byte (("Page"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=19					LinkDisplacement = Nt0-WordListLink
>bcc7	10					.byte WordFlags	;wh_Flags
>bcc8	03					.byte 3	;wh_CodeLength
>bcc9	13					  .byte LinkDisplacement	; offset to previous nt
=$bcca					XtPtr1 ::= *
=48198					WordListLink ::= Nt0 ; remember the nt of this word for later
.bcca	20 4b ca	jsr $ca4b	Page:		jsr SLiteral_Runtime
.bccd	4c da bc	jmp $bcda			  jmp +
>bcd0	1b 5b 32 4a					  .text AscESC,"[2J"	; ANSI clear screen
>bcd4	1b 5b 31 3b 31 48				  .text AscESC,"[1;1H"	; move cursor to top left of screen
.bcda	4c f1 df	jmp $dff1	+		jmp Type
=19					CodeLen	.var *-XtPtr1
=$bcdd					Here1 = *	; remember here
>bcc8	13					.byte CodeLen	;patch wh_CodeLength
>bcdd	41 74 2d 58 59			Name0:	.text "At-XY"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=48226					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>bce2	25					.byte (("At-XY"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=28					LinkDisplacement = Nt0-WordListLink
>bce3	10					.byte WordFlags	;wh_Flags
>bce4	03					.byte 3	;wh_CodeLength
>bce5	1c					  .byte LinkDisplacement	; offset to previous nt
=$bce6					XtPtr1 ::= *
=48226					WordListLink ::= Nt0 ; remember the nt of this word for later
.bce6					At_XY:
.bce6	20 9f c5	jsr $c59f			jsr underflow_2
.bce9	ad 00 03	lda $0300			lda base	; Save the BASE
.bcec	48		pha				pha
.bced	20 35 c3	jsr $c335			jsr Decimal	; ANSI escape code values need to be in decimal.
.bcf0	a9 1b		lda #$1b			lda #AscESC
.bcf2	20 cd df	jsr $dfcd			jsr Emit_A
.bcf5	a9 5b		lda #$5b			lda #'['
.bcf7	20 cd df	jsr $dfcd			jsr Emit_A
.bcfa	f6 26		inc $26,x			inc DStack+0,x	; AT-XY is zero based, but ANSI is 1 based
.bcfc	20 0c de	jsr $de0c			jsr print_u
.bcff	a9 3b		lda #$3b			lda #';'
.bd01	20 cd df	jsr $dfcd			jsr Emit_A
.bd04	f6 26		inc $26,x			inc DStack+0,x	; AT-XY is zero based, but ANSI is 1 based
.bd06	20 0c de	jsr $de0c			jsr print_u
.bd09	a9 48		lda #$48			lda #'H'
.bd0b	20 cd df	jsr $dfcd			jsr Emit_A
.bd0e	68		pla				pla		; Restore the base
.bd0f	8d 00 03	sta $0300			sta base
=44					CodeLen	.var *-XtPtr1
=$bd12					Here1 = *	; remember here
>bce4	2c					.byte CodeLen	;patch wh_CodeLength
.bd12	60		rts				rts
>bd13	50 61 64			Name0:	.text "Pad"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=48278					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>bd16	83					.byte (("Pad"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=0					WordFlags ::= 0	; modifiable copy, remember for later
=52					LinkDisplacement = Nt0-WordListLink
>bd17	00					.byte WordFlags	;wh_Flags
>bd18	03					.byte 3	;wh_CodeLength
>bd19	34					  .byte LinkDisplacement	; offset to previous nt
=$bd1a					XtPtr1 ::= *
=48278					WordListLink ::= Nt0 ; remember the nt of this word for later
.bd1a	ca		dex		Pad:		dex		; push cp+PadOffset
.bd1b	ca		dex				dex
.bd1c	18		clc				clc
.bd1d	a5 00		lda $00				lda cp+0
.bd1f	69 54		adc #$54			adc #PadOffset
.bd21	95 26		sta $26,x			sta DStack+0,x
.bd23	a5 01		lda $01				lda cp+1
.bd25	69 00		adc #$00			adc #0
.bd27	95 27		sta $27,x			sta DStack+1,x
=15					CodeLen	.var *-XtPtr1
=$bd29					Here1 = *	; remember here
>bd18	0f					.byte CodeLen	;patch wh_CodeLength
.bd29	60		rts				rts
>bd2a	3c 23				Name0:	.text "<#"	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=48300					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>bd2c	62					.byte (("<#"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=0					WordFlags ::= 0	; modifiable copy, remember for later
=22					LinkDisplacement = Nt0-WordListLink
>bd2d	00					.byte WordFlags	;wh_Flags
>bd2e	03					.byte 3	;wh_CodeLength
>bd2f	16					  .byte LinkDisplacement	; offset to previous nt
=$bd30					XtPtr1 ::= *
=48300					WordListLink ::= Nt0 ; remember the nt of this word for later
.bd30					Less_Number_Sign:
.bd30	a9 54		lda #$54			lda #PadOffset		; init hold buffer index
.bd32	8d 34 03	sta $0334			sta ToHold
=5					CodeLen	.var *-XtPtr1
=$bd35					Here1 = *	; remember here
>bd2e	05					.byte CodeLen	;patch wh_CodeLength
.bd35	60		rts				rts
>bd36	23 3e				Name0:	.text "#>"	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=48312					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>bd38	c2					.byte (("#>"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=12					LinkDisplacement = Nt0-WordListLink
>bd39	10					.byte WordFlags	;wh_Flags
>bd3a	03					.byte 3	;wh_CodeLength
>bd3b	0c					  .byte LinkDisplacement	; offset to previous nt
=$bd3c					XtPtr1 ::= *
=48312					WordListLink ::= Nt0 ; remember the nt of this word for later
.bd3c					Number_Sign_Greater:
.bd3c	20 9f c5	jsr $c59f			jsr underflow_2		; double number
.bd3f	18		clc				clc			; addr= cp + ToHold
.bd40	a5 00		lda $00				lda cp+0
.bd42	6d 34 03	adc $0334			adc ToHold
.bd45	95 28		sta $28,x			sta DStack+2,x
.bd47	a5 01		lda $01				lda cp+1
.bd49	69 00		adc #$00			adc #0
.bd4b	95 29		sta $29,x			sta DStack+3,x
.bd4d	90 0e		bcc $bd5d			bcc HoldSize3
=19					CodeLen	.var *-XtPtr1
=$bd4f					Here1 = *	; remember here
>bd3a	13					.byte CodeLen	;patch wh_CodeLength
>bd4f	48 6f 6c 64 53 69 7a 65		Name0:	.text "HoldSize"	;  name of word as a string, ending at wh_NameLastChar
=8					NameLength = *-Name0
=48343					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>bd57	a8					.byte (("HoldSize"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=31					LinkDisplacement = Nt0-WordListLink
>bd58	10					.byte WordFlags	;wh_Flags
>bd59	03					.byte 3	;wh_CodeLength
>bd5a	1f					  .byte LinkDisplacement	; offset to previous nt
=$bd5b					XtPtr1 ::= *
=48343					WordListLink ::= Nt0 ; remember the nt of this word for later
.bd5b	ca		dex		HoldSize:	dex
.bd5c	ca		dex				dex
.bd5d	38		sec		HoldSize3:	sec			; u= PadOffset - ToHold
.bd5e	a9 54		lda #$54			lda #PadOffset
.bd60	ed 34 03	sbc $0334			sbc ToHold
.bd63	95 26		sta $26,x			sta DStack+0,x
.bd65	a9 00		lda #$00			lda #0
.bd67	95 27		sta $27,x			sta DStack+1,x
=14					CodeLen	.var *-XtPtr1
=$bd69					Here1 = *	; remember here
>bd59	0e					.byte CodeLen	;patch wh_CodeLength
.bd69	60		rts				rts
>bd6a	48 6f 6c 64			Name0:	.text "Hold"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=48366					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>bd6e	84					.byte (("Hold"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=0					WordFlags ::= 0	; modifiable copy, remember for later
=23					LinkDisplacement = Nt0-WordListLink
>bd6f	00					.byte WordFlags	;wh_Flags
>bd70	03					.byte 3	;wh_CodeLength
>bd71	17					  .byte LinkDisplacement	; offset to previous nt
=$bd72					XtPtr1 ::= *
=48366					WordListLink ::= Nt0 ; remember the nt of this word for later
.bd72	20 47 c5	jsr $c547	Hold:		jsr PopA
.bd75	ce 34 03	dec $0334	Hold_A:		dec ToHold
.bd78	ac 34 03	ldy $0334			ldy ToHold
.bd7b	91 00		sta ($00),y			sta (cp),y
=11					CodeLen	.var *-XtPtr1
=$bd7d					Here1 = *	; remember here
>bd70	0b					.byte CodeLen	;patch wh_CodeLength
.bd7d	60		rts				rts
>bd7e	23				Name0:	.text "#"	;  name of word as a string, ending at wh_NameLastChar
=1					NameLength = *-Name0
=48383					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>bd7f	61					.byte (("#"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=80					WordFlags ::= UF+NN	; modifiable copy, remember for later
=17					LinkDisplacement = Nt0-WordListLink
>bd80	50					.byte WordFlags	;wh_Flags
>bd81	03					.byte 3	;wh_CodeLength
>bd82	11					  .byte LinkDisplacement	; offset to previous nt
=$bd83					XtPtr1 ::= *
=48383					WordListLink ::= Nt0 ; remember the nt of this word for later
.bd83					Number_Sign:
.bd83	20 9f c5	jsr $c59f			jsr underflow_2		; double number
.bd86	a9 00		lda #$00			lda #0			;   init remainder
.bd88	18		clc				clc
.bd89	a0 21		ldy #$21			ldy #32+1		;   for each bit
.bd8b					_div1:
.bd8b	2a		rol a				rol a			;     shift remainder
.bd8c	cd 00 03	cmp $0300			cmp base		;     will it fit?
.bd8f	90 03		bcc $bd94			bcc _div7
.bd91	ed 00 03	sbc $0300			sbc base
.bd94					_div7:
.bd94	36 28		rol $28,x			rol DStack+2,x		;     shift ud
.bd96	36 29		rol $29,x			rol DStack+3,x
.bd98	36 26		rol $26,x			rol DStack+0,x
.bd9a	36 27		rol $27,x			rol DStack+1,x
.bd9c	88		dey				dey			;    next bit
.bd9d	d0 ec		bne $bd8b			bne _div1
.bd9f	c9 0a		cmp #$0a			cmp #9+1		; alternatively this could use s_abc_upper
.bda1	90 02		bcc $bda5			bcc +
.bda3	69 06		adc #$06			adc #7-1
.bda5	69 30		adc #$30	+		adc #'0'
.bda7	d0 cc		bne $bd75			bne Hold_A
=38					CodeLen	.var *-XtPtr1
=$bda9					Here1 = *	; remember here
>bd81	26					.byte CodeLen	;patch wh_CodeLength
>bda9	23 53				Name0:	.text "#S"	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=48427					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>bdab	62					.byte (("#S"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=0					WordFlags ::= 0	; modifiable copy, remember for later
=44					LinkDisplacement = Nt0-WordListLink
>bdac	00					.byte WordFlags	;wh_Flags
>bdad	03					.byte 3	;wh_CodeLength
>bdae	2c					  .byte LinkDisplacement	; offset to previous nt
=$bdaf					XtPtr1 ::= *
=48427					WordListLink ::= Nt0 ; remember the nt of this word for later
.bdaf					Number_Sign_S:
.bdaf					_loop:
.bdaf	20 83 bd	jsr $bd83			jsr Number_sign	; convert a single number ("#")
.bdb2	b5 26		lda $26,x			lda DStack+0,x	; until d is zero
.bdb4	15 27		ora $27,x			ora DStack+1,x
.bdb6	15 28		ora $28,x			ora DStack+2,x
.bdb8	15 29		ora $29,x			ora DStack+3,x
.bdba	d0 f3		bne $bdaf			bne _loop
=13					CodeLen	.var *-XtPtr1
=$bdbc					Here1 = *	; remember here
>bdad	0d					.byte CodeLen	;patch wh_CodeLength
.bdbc	60		rts				rts
>bdbd	53 69 67 6e			Name0:	.text "Sign"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=48449					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>bdc1	c4					.byte (("Sign"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=22					LinkDisplacement = Nt0-WordListLink
>bdc2	10					.byte WordFlags	;wh_Flags
>bdc3	03					.byte 3	;wh_CodeLength
>bdc4	16					  .byte LinkDisplacement	; offset to previous nt
=$bdc5					XtPtr1 ::= *
=48449					WordListLink ::= Nt0 ; remember the nt of this word for later
.bdc5	20 62 c5	jsr $c562	Sign:		jsr PopYA
.bdc8	98		tya				tya		; test MSB of TOS
.bdc9					Sign_P:
.bdc9	30 01		bmi $bdcc			bmi _minus
.bdcb	60		rts				rts
.bdcc	a9 2d		lda #$2d	_minus:		lda #'-'	; add minus sign
.bdce	d0 a5		bne $bd75			bne hold_a
=11					CodeLen	.var *-XtPtr1
=$bdd0					Here1 = *	; remember here
>bdc3	0b					.byte CodeLen	;patch wh_CodeLength
>bdd0	43 6c 65 61 76 65		Name0:	.text "Cleave"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=48470					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>bdd6	a6					.byte (("Cleave"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=21					LinkDisplacement = Nt0-WordListLink
>bdd7	10					.byte WordFlags	;wh_Flags
>bdd8	03					.byte 3	;wh_CodeLength
>bdd9	15					  .byte LinkDisplacement	; offset to previous nt
=$bdda					XtPtr1 ::= *
=48470					WordListLink ::= Nt0 ; remember the nt of this word for later
.bdda	20 9f c5	jsr $c59f	Cleave:		jsr underflow_2
.bddd	20 b2 d6	jsr $d6b2			jsr Minus_leading	; -LEADING ( addr u )
.bde0	20 a8 d5	jsr $d5a8			jsr Input_To_R	; save old imput state
.bde3	b5 26		lda $26,x			lda DStack+0,x	; u is new ciblen
.bde5	85 06		sta $06				sta ciblen
.bde7	b5 27		lda $27,x			lda DStack+1,x
.bde9	85 07		sta $07				sta ciblen+1
.bdeb	b5 28		lda $28,x			lda DStack+2,x	; addr is new cib
.bded	85 04		sta $04				sta cib
.bdef	b5 29		lda $29,x			lda DStack+3,x
.bdf1	85 05		sta $05				sta cib+1
.bdf3	a9 00		lda #$00			lda #0
.bdf5	85 08		sta $08				sta toin	; >IN pointer is zero
.bdf7	85 09		sta $09				sta toin+1
.bdf9	20 15 cc	jsr $cc15			jsr parse_name	; ( addr u addr-s u-s )
.bdfc	b5 26		lda $26,x			lda DStack+0,x
.bdfe	15 27		ora $27,x			ora DStack+1,x
.be00	f0 23		beq $be25			beq _done
.be02	38		sec				sec
.be03	b5 2a		lda $2a,x			lda DStack+4,x	; LSB of original u
.be05	f5 26		sbc $26,x			sbc DStack+0,x
.be07	95 2a		sta $2a,x			sta DStack+4,x
.be09	b5 2b		lda $2b,x			lda DStack+5,x	; MSB of original u
.be0b	f5 27		sbc $27,x			sbc DStack+1,x
.be0d	95 2b		sta $2b,x			sta DStack+5,x
.be0f	18		clc				clc
.be10	b5 2c		lda $2c,x			lda DStack+6,x	; LSB of original addr
.be12	75 26		adc $26,x			adc DStack+0,x
.be14	95 2c		sta $2c,x			sta DStack+6,x
.be16	b5 2d		lda $2d,x			lda DStack+7,x	; MSB of original addr
.be18	75 27		adc $27,x			adc DStack+1,x
.be1a	95 2d		sta $2d,x			sta DStack+7,x
.be1c	20 16 d7	jsr $d716			jsr Two_swap		; ( addr-s u-s addr u )
.be1f	20 b2 d6	jsr $d6b2			jsr Minus_leading
.be22	20 16 d7	jsr $d716			jsr Two_swap		; ( addr u addr-s u-s )
.be25					_done:
.be25	20 c9 d5	jsr $d5c9			jsr R_To_Input
=78					CodeLen	.var *-XtPtr1
=$be28					Here1 = *	; remember here
>bdd8	4e					.byte CodeLen	;patch wh_CodeLength
.be28	60		rts				rts
>be29	48 65 78 53 74 6f 72 65		Name0:	.text "HexStore"	;  name of word as a string, ending at wh_NameLastChar
=8					NameLength = *-Name0
=48561					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>be31	a8					.byte (("HexStore"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=91					LinkDisplacement = Nt0-WordListLink
>be32	10					.byte WordFlags	;wh_Flags
>be33	03					.byte 3	;wh_CodeLength
>be34	5b					  .byte LinkDisplacement	; offset to previous nt
=$be35					XtPtr1 ::= *
=48561					WordListLink ::= Nt0 ; remember the nt of this word for later
.be35	20 a4 c5	jsr $c5a4	Hexstore:	jsr underflow_3
.be38	20 8a e1	jsr $e18a			jsr Dup		; Save copy of original address
.be3b	20 36 d8	jsr $d836			jsr Two_to_r		; ( addr1 u1 ) ( R: addr2 addr2 )
.be3e					_loop:
.be3e	b5 26		lda $26,x			lda DStack+0,x
.be40	15 27		ora $27,x			ora DStack+1,x
.be42	f0 37		beq $be7b			beq _done
.be44	20 da bd	jsr $bdda			jsr Cleave		; ( addr1 u1 addr3 u3 ) ( R: addr2 addr2 )
.be47	20 36 d8	jsr $d836			jsr Two_to_r
.be4a	20 6b c9	jsr $c96b			jsr Zero
.be4d	20 6b c9	jsr $c96b			jsr Zero
.be50	20 12 d8	jsr $d812			jsr Two_r_from	; ( addr1 u1 0 0 addr3 u3 ) ( R: addr2 addr2 )
.be53	20 b4 c1	jsr $c1b4			jsr To_Number	; ( addr1 u1 n n addr4 u4 ) ( R: addr2 addr2 )
.be56	b5 26		lda $26,x			lda DStack+0,x
.be58	15 27		ora $27,x			ora DStack+1,x
.be5a	d0 18		bne $be74			bne _have_chars_left
.be5c	20 04 d7	jsr $d704			jsr Two_drop		; ( addr1 u1 n n ) ( R: addr2 addr2 )
.be5f	20 b2 d1	jsr $d1b2			jsr D_To_S		; ( addr1 u1 n ) ( R: addr2 addr2 )
.be62	20 33 e1	jsr $e133			jsr R_Fetch		; ( addr1 u1 n addr2 ) ( R: addr2 addr2 )
.be65	20 64 df	jsr $df64			jsr C_Store		; ( addr1 u1 ) ( R: addr2 addr2 )
.be68	20 18 e1	jsr $e118			jsr R_From		; R>
.be6b	20 37 dc	jsr $dc37			jsr One_plus		; 1+
.be6e	20 fa e0	jsr $e0fa			jsr To_R		; >R ( addr1 u1 ) ( R: addr2+1 addr2 )
.be71	4c 3e be	jmp $be3e			jmp _loop
.be74					_have_chars_left:
.be74	8a		txa				txa
.be75	18		clc				clc
.be76	69 08		adc #$08			adc #8
.be78	aa		tax				tax
.be79	d0 c3		bne $be3e			bne _loop
.be7b					_done:
.be7b	e8		inx				inx
.be7c	e8		inx				inx
.be7d	e8		inx				inx
.be7e	e8		inx				inx			; 2DROP
.be7f	20 12 d8	jsr $d812			jsr Two_r_from		; ( addr2+n addr2 )
.be82	20 ad e1	jsr $e1ad			jsr Swap
.be85	4c a9 dd	jmp $dda9			jmp Minus		; ( n )
=83					CodeLen	.var *-XtPtr1
=$be88					Here1 = *	; remember here
>be33	53					.byte CodeLen	;patch wh_CodeLength
.be88	4c ae c5	jmp $c5ae	Throw_Stack_24: jmp Throw_Stack
>be8b	57 69 74 68 69 6e		Name0:	.text "Within"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=48657					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>be91	c6					.byte (("Within"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=96					LinkDisplacement = Nt0-WordListLink
>be92	10					.byte WordFlags	;wh_Flags
>be93	03					.byte 3	;wh_CodeLength
>be94	60					  .byte LinkDisplacement	; offset to previous nt
=$be95					XtPtr1 ::= *
=48657					WordListLink ::= Nt0 ; remember the nt of this word for later
.be95					Within:
.be95	e0 2b		cpx #$2b		cpx #(DSDim-3)*2+1	; far enough below end of data stack (& not negative)?
.be97	b0 ef		bcs $be88		bcs Throw_Stack_24
.be99	20 61 e1	jsr $e161			jsr Over
.be9c	20 a9 dd	jsr $dda9			jsr Minus
.be9f	20 fa e0	jsr $e0fa			jsr To_R
.bea2	20 a9 dd	jsr $dda9			jsr Minus
.bea5	20 18 e1	jsr $e118			jsr R_From
.bea8	4c 66 da	jmp $da66			jmp U_Less_Than
=22					CodeLen	.var *-XtPtr1
=$beab					Here1 = *	; remember here
>be93	16					.byte CodeLen	;patch wh_CodeLength
>beab	5c				Name0:	.text "\"	;  name of word as a string, ending at wh_NameLastChar
=1					NameLength = *-Name0
=48684					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>beac	81					.byte (("\"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=24					WordFlags ::= IM+NN	; modifiable copy, remember for later
=27					LinkDisplacement = Nt0-WordListLink
>bead	18					.byte WordFlags	;wh_Flags
>beae	03					.byte 3	;wh_CodeLength
>beaf	1b					  .byte LinkDisplacement	; offset to previous nt
=$beb0					XtPtr1 ::= *
=48684					WordListLink ::= Nt0 ; remember the nt of this word for later
.beb0					Backslash:
.beb0	ad 0c 03	lda $030c			lda BlkV+0		; interpreting a block?
.beb3	0d 0d 03	ora $030d			ora BlkV+1
.beb6	f0 16		beq $bece			beq _not_block
.beb8	a5 08		lda $08				lda toin+0
.beba	29 3f		and #$3f			and #$3F
.bebc	c9 02		cmp #$02			cmp #2
.bebe	90 0d		bcc $becd			bcc _rts
.bec0	a5 08		lda $08		                lda toin+0		; Move toin to next multiple of 64.
.bec2	29 c0		and #$c0	                and #$C0        	;   Clear lower bits to move to beginning of line.
.bec4	18		clc		                clc             	;   Add $40 (64 decimal) to move to next line.
.bec5	69 40		adc #$40	                adc #$40
.bec7	85 08		sta $08		                sta toin+0
.bec9	90 02		bcc $becd	                bcc _rts
.becb	e6 09		inc $09		                inc toin+1
.becd	60		rts		_rts:		rts
.bece					_not_block:
.bece	a5 06		lda $06		                lda ciblen+0		; consume the remainder of the line
.bed0	85 08		sta $08		                sta toin+0
.bed2	a5 07		lda $07		                lda ciblen+1
.bed4	85 09		sta $09		                sta toin+1
=38					CodeLen	.var *-XtPtr1
=$bed6					Here1 = *	; remember here
>beae	26					.byte CodeLen	;patch wh_CodeLength
.bed6	60		rts				rts
>bed7	4d 6f 76 65			Name0:	.text "Move"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=48731					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>bedb	a4					.byte (("Move"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=47					LinkDisplacement = Nt0-WordListLink
>bedc	10					.byte WordFlags	;wh_Flags
>bedd	03					.byte 3	;wh_CodeLength
>bede	2f					  .byte LinkDisplacement	; offset to previous nt
=$bedf					XtPtr1 ::= *
=48731					WordListLink ::= Nt0 ; remember the nt of this word for later
.bedf					Move:
.bedf	b5 29		lda $29,x			lda DStack+3,x		; MSB of addr2
.bee1	d5 2b		cmp $2b,x			cmp DStack+5,x		; MSB of addr1
.bee3	d0 04		bne $bee9			bne _ne
.bee5	b5 28		lda $28,x			lda DStack+2,x		; LSB of addr2
.bee7	d5 2a		cmp $2a,x			cmp DStack+4,x		; LSB of addr1
.bee9	90 59		bcc $bf44	_ne:		bcc CMove
.beeb	d0 10		bne $befd			bne CMove_up
.beed	8a		txa		ThreeDrop:	txa		; drop three entries from Data Stack
.beee	18		clc				clc
.beef	69 06		adc #$06			adc #6
.bef1	aa		tax				tax
=19					CodeLen	.var *-XtPtr1
=$bef2					Here1 = *	; remember here
>bedd	13					.byte CodeLen	;patch wh_CodeLength
.bef2	60		rts				rts
>bef3	43 4d 6f 76 65 3e		Name0:	.text "CMove>"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=48761					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>bef9	c6					.byte (("CMove>"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=30					LinkDisplacement = Nt0-WordListLink
>befa	10					.byte WordFlags	;wh_Flags
>befb	03					.byte 3	;wh_CodeLength
>befc	1e					  .byte LinkDisplacement	; offset to previous nt
=$befd					XtPtr1 ::= *
=48761					WordListLink ::= Nt0 ; remember the nt of this word for later
.befd					CMove_up:
.befd	e0 2b		cpx #$2b		cpx #(DSDim-3)*2+1	; far enough below end of data stack (& not negative)?
.beff	b0 37		bcs $bf38		bcs Throw_Stack_14
.bf01	b5 28		lda $28,x			lda DStack+2,x
.bf03	85 16		sta $16				sta tmp2	; use tmp2 because easier to remember
.bf05	b5 29		lda $29,x			lda DStack+3,x
.bf07	18		clc				clc
.bf08	75 27		adc $27,x			adc DStack+1,x
.bf0a	85 17		sta $17				sta tmp2+1	; point to last page of destination
.bf0c	b5 2a		lda $2a,x			lda DStack+4,x
.bf0e	85 14		sta $14				sta tmp1	; use tmp1 because easier to remember
.bf10	b5 2b		lda $2b,x			lda DStack+5,x
.bf12	18		clc				clc
.bf13	75 27		adc $27,x			adc DStack+1,x
.bf15	85 15		sta $15				sta tmp1+1	; point to last page of source
.bf17	f6 27		inc $27,x			inc DStack+1,x	; allows us to use bne with dec DStack+1,x below
.bf19	b4 26		ldy $26,x			ldy DStack+0,x	; length of last page
.bf1b	f0 10		beq $bf2d			beq _nopartial
.bf1d					_outerloop:
.bf1d	88		dey				dey
.bf1e	f0 07		beq $bf27			beq _finishpage
.bf20					_innerloop:
.bf20	b1 14		lda ($14),y			lda (tmp1),y
.bf22	91 16		sta ($16),y			sta (tmp2),y
.bf24	88		dey				dey
.bf25	d0 f9		bne $bf20			bne _innerloop
.bf27					_finishpage:
.bf27	a0 00		ldy #$00			ldy #0
.bf29	b1 14		lda ($14),y			lda (tmp1),y	; handle y = 0 separately
.bf2b	91 16		sta ($16),y			sta (tmp2),y
.bf2d					_nopartial:
.bf2d	c6 15		dec $15				dec tmp1+1	; back up to previous pages
.bf2f	c6 17		dec $17				dec tmp2+1
.bf31	d6 27		dec $27,x			dec DStack+1,x
.bf33	d0 e8		bne $bf1d			bne _outerloop
.bf35					_done:
.bf35	4c ed be	jmp $beed			jmp ThreeDrop	; clear up the stack and leave
=59					CodeLen	.var *-XtPtr1
=$bf38					Here1 = *	; remember here
>befb	3b					.byte CodeLen	;patch wh_CodeLength
.bf38	4c ae c5	jmp $c5ae	Throw_Stack_14: jmp Throw_Stack
>bf3b	43 4d 6f 76 65			Name0:	.text "CMove"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=48832					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>bf40	a5					.byte (("CMove"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=71					LinkDisplacement = Nt0-WordListLink
>bf41	10					.byte WordFlags	;wh_Flags
>bf42	03					.byte 3	;wh_CodeLength
>bf43	47					  .byte LinkDisplacement	; offset to previous nt
=$bf44					XtPtr1 ::= *
=48832					WordListLink ::= Nt0 ; remember the nt of this word for later
.bf44					CMove:
.bf44	e0 2b		cpx #$2b		cpx #(DSDim-3)*2+1	; far enough below end of data stack (& not negative)?
.bf46	b0 f0		bcs $bf38		bcs Throw_Stack_14
.bf48	b5 28		lda $28,x			lda DStack+2,x
.bf4a	85 16		sta $16				sta tmp2+0	; use tmp2 because easier to remember
.bf4c	b5 29		lda $29,x			lda DStack+3,x
.bf4e	85 17		sta $17				sta tmp2+1
.bf50	b5 2a		lda $2a,x			lda DStack+4,x
.bf52	85 14		sta $14				sta tmp1+0	; use tmp1 because easier to remember
.bf54	b5 2b		lda $2b,x			lda DStack+5,x
.bf56	85 15		sta $15				sta tmp1+1
.bf58	a0 00		ldy #$00			ldy #0
.bf5a	b5 27		lda $27,x			lda DStack+1,x	; number of whole pages to move
.bf5c	f0 0f		beq $bf6d			beq _dopartial
.bf5e					_page:
.bf5e	b1 14		lda ($14),y			lda (tmp1),y
.bf60	91 16		sta ($16),y			sta (tmp2),y
.bf62	c8		iny				iny
.bf63	d0 f9		bne $bf5e			bne _page
.bf65	e6 15		inc $15				inc tmp1+1
.bf67	e6 17		inc $17				inc tmp2+1
.bf69	d6 27		dec $27,x			dec DStack+1,x
.bf6b	d0 f1		bne $bf5e			bne _page
.bf6d					_dopartial:
.bf6d	b5 26		lda $26,x			lda DStack+0,x	; length of last page
.bf6f	f0 09		beq $bf7a			beq _done
.bf71					_partial:
.bf71	b1 14		lda ($14),y			lda (tmp1),y
.bf73	91 16		sta ($16),y			sta (tmp2),y
.bf75	c8		iny				iny
.bf76	d6 26		dec $26,x			dec DStack+0,x
.bf78	d0 f7		bne $bf71			bne _partial
.bf7a	4c ed be	jmp $beed	_done:		jmp ThreeDrop	; clear the stack
=57					CodeLen	.var *-XtPtr1
=$bf7d					Here1 = *	; remember here
>bf42	39					.byte CodeLen	;patch wh_CodeLength
>bf7d	55 4d 2a			Name0:	.text "UM*"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=48896					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>bf80	43					.byte (("UM*"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=64					LinkDisplacement = Nt0-WordListLink
>bf81	10					.byte WordFlags	;wh_Flags
>bf82	03					.byte 3	;wh_CodeLength
>bf83	40					  .byte LinkDisplacement	; offset to previous nt
=$bf84					XtPtr1 ::= *
=48896					WordListLink ::= Nt0 ; remember the nt of this word for later
.bf84					UM_Star:
.bf84	e0 2d		cpx #$2d		cpx #(DSDim-2)*2+1	; far enough below end of data stack (& not negative)?
.bf86	b0 b0		bcs $bf38		bcs Throw_Stack_14
.bf88	18		clc				clc		; tmp2= divsor-1
.bf89	b5 26		lda $26,x			lda DStack+0,x
.bf8b	e9 00		sbc #$00			sbc #0
.bf8d	85 16		sta $16				sta tmp2+0
.bf8f	b5 27		lda $27,x			lda DStack+1,x
.bf91	e9 00		sbc #$00			sbc #0
.bf93	85 17		sta $17				sta tmp2+1
.bf95	90 2e		bcc $bfc5			bcc _zero	; is divisor zero?
.bf97	a9 00		lda #$00			lda #0
.bf99	85 14		sta $14				sta tmp1
.bf9b	86 18		stx $18				stx tmp3	; tested for exit from outer loop
.bf9d	ca		dex				dex
.bf9e	ca		dex				dex
.bf9f					_outer_loop:
.bf9f	a0 08		ldy #$08			ldy #8		; counter inner loop
.bfa1	56 2a		lsr $2a,x			lsr DStack+4,x	; think "DStack+2,x" then later "DStack+3,x"
.bfa3					_inner_loop:
.bfa3	90 0c		bcc $bfb1			bcc _no_add
.bfa5	85 15		sta $15				sta tmp1+1	; save time, don't CLC
.bfa7	a5 14		lda $14				lda tmp1
.bfa9	65 16		adc $16				adc tmp2
.bfab	85 14		sta $14				sta tmp1
.bfad	a5 15		lda $15				lda tmp1+1
.bfaf	65 17		adc $17				adc tmp2+1
.bfb1					_no_add:
.bfb1	6a		ror a				ror
.bfb2	66 14		ror $14				ror tmp1
.bfb4	76 2a		ror $2a,x			ror DStack+4,x	; think "DStack+2,x" then later "DStack+3,x"
.bfb6	88		dey				dey
.bfb7	d0 ea		bne $bfa3			bne _inner_loop ; go back for one more shift?
.bfb9	e8		inx				inx
.bfba	e4 18		cpx $18				cpx tmp3
.bfbc	d0 e1		bne $bf9f			bne _outer_loop ; go back for eight more shifts?
.bfbe	95 27		sta $27,x			sta DStack+1,x
.bfc0	a5 14		lda $14				lda tmp1
.bfc2	95 26		sta $26,x			sta DStack+0,x
.bfc4	60		rts				rts
.bfc5	a9 00		lda #$00	_zero:		lda #0
.bfc7	95 28		sta $28,x			sta DStack+2,x
.bfc9	95 29		sta $29,x			sta DStack+3,x
.bfcb	60		rts				rts
=72					CodeLen	.var *-XtPtr1
=$bfcc					Here1 = *	; remember here
>bf82	48					.byte CodeLen	;patch wh_CodeLength
>bfcc	4d 2a				Name0:	.text "M*"	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=48974					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>bfce	42					.byte (("M*"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=78					LinkDisplacement = Nt0-WordListLink
>bfcf	10					.byte WordFlags	;wh_Flags
>bfd0	03					.byte 3	;wh_CodeLength
>bfd1	4e					  .byte LinkDisplacement	; offset to previous nt
=$bfd2					XtPtr1 ::= *
=48974					WordListLink ::= Nt0 ; remember the nt of this word for later
.bfd2					M_Star:
.bfd2	e0 2d		cpx #$2d		cpx #(DSDim-2)*2+1	; far enough below end of data stack (& not negative)?
.bfd4	b0 6b		bcs $c041		bcs Throw_Stack_15
.bfd6	b5 27		lda $27,x			lda DStack+1,x	; MSB of n1
.bfd8	55 29		eor $29,x			eor DStack+3,x	; MSB of n2
.bfda	08		php				php
.bfdb	20 94 d8	jsr $d894			jsr Abs
.bfde	20 ad e1	jsr $e1ad			jsr Swap
.bfe1	20 94 d8	jsr $d894			jsr Abs
.bfe4	20 84 bf	jsr $bf84			jsr UM_Star		; ( d )
.bfe7	28		plp				plp			; handle the sign
.bfe8	10 03		bpl $bfed			bpl +
.bfea	4c ab d8	jmp $d8ab			jmp DNegate
.bfed					+
=27					CodeLen	.var *-XtPtr1
=$bfed					Here1 = *	; remember here
>bfd0	1b					.byte CodeLen	;patch wh_CodeLength
.bfed	60		rts				rts
>bfee	2a				Name0:	.text "*"	;  name of word as a string, ending at wh_NameLastChar
=1					NameLength = *-Name0
=49007					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>bfef	41					.byte (("*"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=0					WordFlags ::= 0	; modifiable copy, remember for later
=33					LinkDisplacement = Nt0-WordListLink
>bff0	00					.byte WordFlags	;wh_Flags
>bff1	03					.byte 3	;wh_CodeLength
>bff2	21					  .byte LinkDisplacement	; offset to previous nt
=$bff3					XtPtr1 ::= *
=49007					WordListLink ::= Nt0 ; remember the nt of this word for later
.bff3					Star:
.bff3	20 84 bf	jsr $bf84			jsr UM_Star
.bff6	e8		inx				inx		; D>S	drop hi cell
.bff7	e8		inx				inx
=5					CodeLen	.var *-XtPtr1
=$bff8					Here1 = *	; remember here
>bff1	05					.byte CodeLen	;patch wh_CodeLength
.bff8	60		rts				rts
>bff9	55 4d 2f 4d 6f 64		Name0:	.text "UM/Mod"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=49023					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>bfff	86					.byte (("UM/Mod"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=16					LinkDisplacement = Nt0-WordListLink
>c000	10					.byte WordFlags	;wh_Flags
>c001	03					.byte 3	;wh_CodeLength
>c002	10					  .byte LinkDisplacement	; offset to previous nt
=$c003					XtPtr1 ::= *
=49023					WordListLink ::= Nt0 ; remember the nt of this word for later
.c003					UM_Slash_Mod:
.c003	e0 2b		cpx #$2b		cpx #(DSDim-3)*2+1	; far enough below end of data stack (& not negative)?
.c005	b0 3a		bcs $c041		bcs Throw_Stack_15
.c007	b5 26		lda $26,x			lda DStack+0,x		; catch division by zero
.c009	15 27		ora $27,x			ora DStack+1,x
.c00b	f0 2f		beq $c03c			beq _DivByZero
.c00d	a0 10		ldy #$10			ldy #16			; for 16 bits
.c00f					_loop:
.c00f	36 2a		rol $2a,x			rol DStack+4,x		;   rotate low cell of dividend one bit left
.c011	36 2b		rol $2b,x			rol DStack+5,x
.c013	36 28		rol $28,x			rol DStack+2,x		;   rotate high cell of dividend one bit left
.c015	36 29		rol $29,x			rol DStack+3,x
.c017	b0 0a		bcs $c023			bcs _subtract		;   overflow?
.c019	b5 28		lda $28,x			lda DStack+2,x		;   dividend.hi >= divisor?
.c01b	d5 26		cmp $26,x			cmp DStack+0,x
.c01d	b5 29		lda $29,x			lda DStack+3,x
.c01f	f5 27		sbc $27,x			sbc DStack+1,x
.c021	90 0d		bcc $c030			bcc _next
.c023	b5 28		lda $28,x	_subtract:	lda DStack+2,x		;   dividend.hi -= divisor
.c025	f5 26		sbc $26,x			sbc DStack+0,x
.c027	95 28		sta $28,x			sta DStack+2,x
.c029	b5 29		lda $29,x			lda DStack+3,x
.c02b	f5 27		sbc $27,x			sbc DStack+1,x
.c02d	95 29		sta $29,x			sta DStack+3,x
.c02f	38		sec				sec			;   it always fits
.c030	88		dey		_next:		dey			;  next
.c031	d0 dc		bne $c00f			bne _loop
.c033	36 2a		rol $2a,x			rol DStack+4,x		; finish rotating quotient bit in
.c035	36 2b		rol $2b,x			rol DStack+5,x
.c037	e8		inx				inx			; drop divisor
.c038	e8		inx				inx
.c039	4c ad e1	jmp $e1ad			jmp Swap
.c03c	a9 f6		lda #$f6	_DivByZero:	lda #$100+err_DivideBy0
.c03e	4c dc c5	jmp $c5dc			jmp ThrowA
=62					CodeLen	.var *-XtPtr1
=$c041					Here1 = *	; remember here
>c001	3e					.byte CodeLen	;patch wh_CodeLength
.c041	4c ae c5	jmp $c5ae	Throw_Stack_15: jmp Throw_Stack
>c044	53 4d 2f 52 65 6d		Name0:	.text "SM/Rem"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=49098					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>c04a	a6					.byte (("SM/Rem"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=75					LinkDisplacement = Nt0-WordListLink
>c04b	10					.byte WordFlags	;wh_Flags
>c04c	03					.byte 3	;wh_CodeLength
>c04d	4b					  .byte LinkDisplacement	; offset to previous nt
=$c04e					XtPtr1 ::= *
=49098					WordListLink ::= Nt0 ; remember the nt of this word for later
.c04e					SM_Slash_Rem:
.c04e	e0 2b		cpx #$2b		cpx #(DSDim-3)*2+1	; far enough below end of data stack (& not negative)?
.c050	b0 ef		bcs $c041		bcs Throw_Stack_15
.c052	b5 29		lda $29,x			lda DStack+3,x
.c054	08		php				php
.c055	55 27		eor $27,x			eor DStack+1,x
.c057	08		php				php
.c058	20 94 d8	jsr $d894			jsr Abs
.c05b	e8		inx				inx		; pretend we pushed n1 to R
.c05c	e8		inx				inx
.c05d	20 c7 d8	jsr $d8c7			jsr DAbs
.c060	ca		dex				dex
.c061	ca		dex				dex
.c062	20 03 c0	jsr $c003			jsr UM_Slash_Mod	; UM/MOD
.c065	28		plp				plp
.c066	10 03		bpl $c06b			bpl +
.c068	20 7b d8	jsr $d87b			jsr Negate
.c06b					+
.c06b	28		plp				plp
.c06c	10 07		bpl $c075			bpl _done
.c06e	e8		inx				inx		; pretend we pushed quotient to R
.c06f	e8		inx				inx
.c070	20 7b d8	jsr $d87b			jsr Negate
.c073	ca		dex				dex
.c074	ca		dex				dex
.c075					_done:
=39					CodeLen	.var *-XtPtr1
=$c075					Here1 = *	; remember here
>c04c	27					.byte CodeLen	;patch wh_CodeLength
.c075	60		rts				rts
>c076	46 4d 2f 4d 6f 64		Name0:	.text "FM/Mod"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=49148					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>c07c	86					.byte (("FM/Mod"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=50					LinkDisplacement = Nt0-WordListLink
>c07d	10					.byte WordFlags	;wh_Flags
>c07e	03					.byte 3	;wh_CodeLength
>c07f	32					  .byte LinkDisplacement	; offset to previous nt
=$c080					XtPtr1 ::= *
=49148					WordListLink ::= Nt0 ; remember the nt of this word for later
.c080					FM_Slash_Mod:
.c080	e0 2b		cpx #$2b		cpx #(DSDim-3)*2+1	; far enough below end of data stack (& not negative)?
.c082	b0 bd		bcs $c041		bcs Throw_Stack_15
.c084	b5 27		lda $27,x			lda DStack+1,x	; MSB of n1
.c086	08		php				php		;  save sign
.c087	10 0a		bpl $c093			bpl +
.c089	20 7b d8	jsr $d87b			jsr Negate	; NEGATE
.c08c	e8		inx				inx
.c08d	e8		inx				inx
.c08e	20 ab d8	jsr $d8ab			jsr DNegate	; DNEGATE
.c091	ca		dex				dex
.c092	ca		dex				dex
.c093					+
.c093	b5 29		lda $29,x			lda DStack+3,x	; MSB of high word of d
.c095	10 0d		bpl $c0a4			bpl +
.c097	18		clc				clc
.c098	b5 26		lda $26,x			lda DStack+0,x	; LSB of n1
.c09a	75 28		adc $28,x			adc DStack+2,x	; LSB of dh
.c09c	95 28		sta $28,x			sta DStack+2,x
.c09e	b5 27		lda $27,x			lda DStack+1,x	; MSB of n1
.c0a0	75 29		adc $29,x			adc DStack+3,x	; MSB of dh
.c0a2	95 29		sta $29,x			sta DStack+3,x
.c0a4					+
.c0a4	20 03 c0	jsr $c003			jsr UM_Slash_Mod	; ( d n1 -- rem n2 )
.c0a7	28		plp				plp
.c0a8	10 07		bpl $c0b1			bpl +
.c0aa	e8		inx				inx		; pretend that we SWAP
.c0ab	e8		inx				inx
.c0ac	20 7b d8	jsr $d87b			jsr Negate
.c0af	ca		dex				dex
.c0b0	ca		dex				dex
.c0b1					+
=49					CodeLen	.var *-XtPtr1
=$c0b1					Here1 = *	; remember here
>c07e	31					.byte CodeLen	;patch wh_CodeLength
.c0b1	60		rts				rts
>c0b2	2f 4d 6f 64			Name0:	.text "/Mod"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=49206					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>c0b6	84					.byte (("/Mod"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=58					LinkDisplacement = Nt0-WordListLink
>c0b7	10					.byte WordFlags	;wh_Flags
>c0b8	03					.byte 3	;wh_CodeLength
>c0b9	3a					  .byte LinkDisplacement	; offset to previous nt
=$c0ba					XtPtr1 ::= *
=49206					WordListLink ::= Nt0 ; remember the nt of this word for later
.c0ba	20 8a e1	jsr $e18a	Slash_Mod:	jsr Dup			; ( n1 n_div n_div )
.c0bd	a0 00		ldy #$00			ldy #0			; sign extend n1
.c0bf	b5 2b		lda $2b,x			lda DStack+5,x
.c0c1	10 01		bpl $c0c4			bpl +
.c0c3	88		dey				dey
.c0c4	94 28		sty $28,x	+		sty DStack+2,x
.c0c6	94 29		sty $29,x			sty DStack+3,x		; ( d1 n_div )
.c0c8	4c 4e c0	jmp $c04e			jmp SM_Slash_Rem	; SM/REM
=17					CodeLen	.var *-XtPtr1
=$c0cb					Here1 = *	; remember here
>c0b8	11					.byte CodeLen	;patch wh_CodeLength
>c0cb	2f				Name0:	.text "/"	;  name of word as a string, ending at wh_NameLastChar
=1					NameLength = *-Name0
=49228					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>c0cc	e1					.byte (("/"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=22					LinkDisplacement = Nt0-WordListLink
>c0cd	10					.byte WordFlags	;wh_Flags
>c0ce	03					.byte 3	;wh_CodeLength
>c0cf	16					  .byte LinkDisplacement	; offset to previous nt
=$c0d0					XtPtr1 ::= *
=49228					WordListLink ::= Nt0 ; remember the nt of this word for later
.c0d0	20 ba c0	jsr $c0ba	Slash:		jsr Slash_Mod
.c0d3	4c 5f db	jmp $db5f			jmp Nip		; Nip remainder
=6					CodeLen	.var *-XtPtr1
=$c0d6					Here1 = *	; remember here
>c0ce	06					.byte CodeLen	;patch wh_CodeLength
>c0d6	4d 6f 64			Name0:	.text "Mod"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=49241					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>c0d9	83					.byte (("Mod"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=0					WordFlags ::= 0	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>c0da	00					.byte WordFlags	;wh_Flags
>c0db	03					.byte 3	;wh_CodeLength
>c0dc	0d					  .byte LinkDisplacement	; offset to previous nt
=$c0dd					XtPtr1 ::= *
=49241					WordListLink ::= Nt0 ; remember the nt of this word for later
.c0dd	20 ba c0	jsr $c0ba	Mod:		jsr Slash_Mod
.c0e0	e8		inx				inx		; Drop quotient
.c0e1	e8		inx				inx
=5					CodeLen	.var *-XtPtr1
=$c0e2					Here1 = *	; remember here
>c0db	05					.byte CodeLen	;patch wh_CodeLength
.c0e2	60		rts				rts
>c0e3	2a 2f 4d 6f 64			Name0:	.text "*/Mod"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=49256					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>c0e8	85					.byte (("*/Mod"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=15					LinkDisplacement = Nt0-WordListLink
>c0e9	10					.byte WordFlags	;wh_Flags
>c0ea	03					.byte 3	;wh_CodeLength
>c0eb	0f					  .byte LinkDisplacement	; offset to previous nt
=$c0ec					XtPtr1 ::= *
=49256					WordListLink ::= Nt0 ; remember the nt of this word for later
.c0ec					Star_Slash_Mod:
.c0ec	20 a4 c5	jsr $c5a4			jsr underflow_3
.c0ef	20 fa e0	jsr $e0fa			jsr To_R
.c0f2	20 d2 bf	jsr $bfd2			jsr M_Star
.c0f5	20 18 e1	jsr $e118			jsr R_From
.c0f8	4c 4e c0	jmp $c04e			jmp SM_Slash_Rem
=15					CodeLen	.var *-XtPtr1
=$c0fb					Here1 = *	; remember here
>c0ea	0f					.byte CodeLen	;patch wh_CodeLength
>c0fb	2a 2f				Name0:	.text "*/"	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=49277					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>c0fd	e2					.byte (("*/"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=21					LinkDisplacement = Nt0-WordListLink
>c0fe	10					.byte WordFlags	;wh_Flags
>c0ff	03					.byte 3	;wh_CodeLength
>c100	15					  .byte LinkDisplacement	; offset to previous nt
=$c101					XtPtr1 ::= *
=49277					WordListLink ::= Nt0 ; remember the nt of this word for later
.c101					Star_Slash:
.c101	20 ec c0	jsr $c0ec			jsr Star_Slash_Mod
.c104	4c 5f db	jmp $db5f			jmp Nip			; mod
=6					CodeLen	.var *-XtPtr1
=$c107					Here1 = *	; remember here
>c0ff	06					.byte CodeLen	;patch wh_CodeLength
>c107	4d 2a 2f			Name0:	.text "M*/"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=49290					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>c10a	e3					.byte (("M*/"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>c10b	10					.byte WordFlags	;wh_Flags
>c10c	03					.byte 3	;wh_CodeLength
>c10d	0d					  .byte LinkDisplacement	; offset to previous nt
=$c10e					XtPtr1 ::= *
=49290					WordListLink ::= Nt0 ; remember the nt of this word for later
.c10e					m_star_slash:
.c10e	20 a9 c5	jsr $c5a9	                jsr underflow_4
.c111	b5 27		lda $27,x			lda DStack+1,x		; calc result sign
.c113	55 29		eor $29,x			eor DStack+3,x
.c115	55 2b		eor $2b,x			eor DStack+5,x
.c117	08		php				php
.c118	20 94 d8	jsr $d894	                jsr Abs			; Abs
.c11b	20 fa e0	jsr $e0fa	                jsr To_R		; >R		( d1 n1 ) ( R: sign abs(n2) )
.c11e	20 94 d8	jsr $d894	                jsr Abs			; Abs
.c121	20 fa e0	jsr $e0fa	                jsr To_R		; >R		( d1 ) ( R: sign abs(n2) abs(n1) )
.c124	20 c7 d8	jsr $d8c7	                jsr DAbs		; DAbs		( abs(d1) ) ( R: sign abs(n2) abs(n1) )
.c127	20 ad e1	jsr $e1ad	                jsr Swap		; Swap
.c12a	20 33 e1	jsr $e133	                jsr R_Fetch		; R@
.c12d	20 84 bf	jsr $bf84	                jsr UM_Star		; UM*
.c130	20 6b e0	jsr $e06b	                jsr Rot			; Rot
.c133	20 18 e1	jsr $e118	                jsr R_From		; R>
.c136	20 84 bf	jsr $bf84	                jsr UM_Star		; UM*
.c139	20 6b e0	jsr $e06b	                jsr Rot			; Rot
.c13c	20 53 dc	jsr $dc53	                jsr UMPlus		; 0 D+
.c13f	20 33 e1	jsr $e133	                jsr R_Fetch		; R@
.c142	20 03 c0	jsr $c003	                jsr UM_Slash_Mod	; UM/Mod
.c145	20 90 e0	jsr $e090	                jsr Not_Rot		; Rot Rot
.c148	20 18 e1	jsr $e118	                jsr R_From		; R>
.c14b	20 03 c0	jsr $c003	                jsr UM_Slash_Mod	; UM/Mod
.c14e	20 5f db	jsr $db5f	                jsr Nip			; Swap Drop
.c151	20 ad e1	jsr $e1ad	                jsr Swap		; Swap
.c154	28		plp				plp
.c155	10 03		bpl $c15a			bpl _rts		; ... 0< if ...
.c157	4c ab d8	jmp $d8ab	                jmp DNegate
.c15a	60		rts		_rts:		rts
=77					CodeLen	.var *-XtPtr1
=$c15b					Here1 = *	; remember here
>c10c	4d					.byte CodeLen	;patch wh_CodeLength
>c15b	45 76 61 6c 75 61 74 65		Name0:	.text "Evaluate"	;  name of word as a string, ending at wh_NameLastChar
=8					NameLength = *-Name0
=49379					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>c163	a8					.byte (("Evaluate"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=89					LinkDisplacement = Nt0-WordListLink
>c164	10					.byte WordFlags	;wh_Flags
>c165	03					.byte 3	;wh_CodeLength
>c166	59					  .byte LinkDisplacement	; offset to previous nt
=$c167					XtPtr1 ::= *
=49379					WordListLink ::= Nt0 ; remember the nt of this word for later
.c167					Evaluate:
.c167	18		clc				clc			; signal to zero BLK.
.c168					load_evaluate:
.c168	ad 0d 03	lda $030d			lda BlkV+1	; Save the current value of BLK on the return stack.
.c16b	48		pha				pha
.c16c	ad 0c 03	lda $030c			lda BlkV+0
.c16f	48		pha				pha
.c170	b0 08		bcs $c17a			bcs +		; See if we should zero BLK.
.c172	a9 00		lda #$00			lda #0		; Set BLK to zero.
.c174	8d 0c 03	sta $030c			sta BlkV+0
.c177	8d 0d 03	sta $030d			sta BlkV+1
.c17a					+
.c17a	20 a8 d5	jsr $d5a8			jsr Input_To_R	; Save the input state to the Return Stack
.c17d	a9 ff		lda #$ff			lda #$ff	; SOURCE-ID= -1
.c17f	85 02		sta $02				sta insrc+0
.c181	85 03		sta $03				sta insrc+1
.c183	a9 00		lda #$00			lda #0		; >IN= zero
.c185	85 08		sta $08				sta toin+0
.c187	85 09		sta $09				sta toin+1
.c189	20 62 c5	jsr $c562			jsr PopYA	; ciblen= string length (u)
.c18c	85 06		sta $06				sta ciblen+0
.c18e	84 07		sty $07				sty ciblen+1
.c190	20 62 c5	jsr $c562			jsr PopYA	; cib= string addr
.c193	85 04		sta $04				sta cib+0
.c195	84 05		sty $05				sty cib+1
.c197	20 94 c6	jsr $c694			jsr interpret	; ( -- )
.c19a	20 c9 d5	jsr $d5c9			jsr R_To_Input	; restore input state
.c19d	68		pla				pla		; Restore BLK from the return stack.
.c19e	8d 0c 03	sta $030c			sta BlkV+0
.c1a1	68		pla				pla
.c1a2	8d 0d 03	sta $030d			sta BlkV+1
=62					CodeLen	.var *-XtPtr1
=$c1a5					Here1 = *	; remember here
>c165	3e					.byte CodeLen	;patch wh_CodeLength
.c1a5	60		rts				rts
.c1a6	4c ae c5	jmp $c5ae	Throw_Stack_11: jmp Throw_Stack
>c1a9	3e 4e 75 6d 62 65 72		Name0:	.text ">Number"	;  name of word as a string, ending at wh_NameLastChar
=7					NameLength = *-Name0
=49456					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>c1b0	47					.byte ((">Number"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=77					LinkDisplacement = Nt0-WordListLink
>c1b1	10					.byte WordFlags	;wh_Flags
>c1b2	03					.byte 3	;wh_CodeLength
>c1b3	4d					  .byte LinkDisplacement	; offset to previous nt
=$c1b4					XtPtr1 ::= *
=49456					WordListLink ::= Nt0 ; remember the nt of this word for later
.c1b4					To_Number:
.c1b4	e0 29		cpx #$29		cpx #(DSDim-4)*2+1	; far enough below end of data stack (& not negative)?
.c1b6	b0 ee		bcs $c1a6		bcs Throw_Stack_11
.c1b8	b5 26		lda $26,x			lda DStack+0,x		; no chars left?
.c1ba	f0 72		beq $c22e			beq _done
.c1bc					_Char_loop:
.c1bc	a1 28		lda ($28,x)			lda (DStack+2,x)	; Get next character
.c1be	c9 30		cmp #$30			cmp #'0'		; convert to value (Digit_Question)
.c1c0	90 6c		bcc $c22e			bcc _done
.c1c2	c9 3a		cmp #$3a			cmp #'9'+1
.c1c4	90 08		bcc $c1ce			bcc _digit
.c1c6	29 df		and #$df			and #$df		;   ASCII uppercase
.c1c8	c9 41		cmp #$41			cmp #'A'
.c1ca	90 62		bcc $c22e			bcc _done
.c1cc	e9 07		sbc #$07			sbc #7 ;'A'-'0'-10	;   to make 'A'=10 below
.c1ce	38		sec		_digit:		sec
.c1cf	e9 30		sbc #$30			sbc #'0'
.c1d1	cd 00 03	cmp $0300			cmp base		; must be < base
.c1d4	b0 58		bcs $c22e			bcs _done
.c1d6	48		pha				pha			; Save char value
.c1d7	20 37 d7	jsr $d737			jsr Two_Over		;   copy ud to work (multiplicand)
.c1da	a9 00		lda #$00			lda #0			;   zero ud (product)
.c1dc	95 2e		sta $2e,x			sta DStack+8,x
.c1de	95 2f		sta $2f,x			sta DStack+9,x
.c1e0	95 30		sta $30,x			sta DStack+10,x
.c1e2	95 31		sta $31,x			sta DStack+11,x
.c1e4	ad 00 03	lda $0300			lda base		;   get multiplier
.c1e7	d0 23		bne $c20c			bne _Mul_Test
.c1e9	48		pha		_Mul_Add:	pha			;   save multiplier
.c1ea	18		clc				clc			;   ud += work
.c1eb	b5 28		lda $28,x			lda DStack+2,x
.c1ed	75 30		adc $30,x			adc DStack+10,x
.c1ef	95 30		sta $30,x			sta DStack+10,x
.c1f1	b5 29		lda $29,x			lda DStack+3,x
.c1f3	75 31		adc $31,x			adc DStack+11,x
.c1f5	95 31		sta $31,x			sta DStack+11,x
.c1f7	b5 26		lda $26,x			lda DStack+0,x
.c1f9	75 2e		adc $2e,x			adc DStack+8,x
.c1fb	95 2e		sta $2e,x			sta DStack+8,x
.c1fd	b5 27		lda $27,x			lda DStack+1,x
.c1ff	75 2f		adc $2f,x			adc DStack+9,x
.c201	95 2f		sta $2f,x			sta DStack+9,x
.c203	68		pla				pla			;   restore multiplier
.c204	16 28		asl $28,x	_Mul_Shift:	asl DStack+2,x		;   work <<= 1
.c206	36 29		rol $29,x			rol DStack+3,x
.c208	36 26		rol $26,x			rol DStack+0,x
.c20a	36 27		rol $27,x			rol DStack+1,x
.c20c	4a		lsr a		_Mul_Test:	lsr a			;   shift multiplier
.c20d	b0 da		bcs $c1e9			bcs _Mul_Add
.c20f	d0 f3		bne $c204			bne _Mul_Shift
.c211	e8		inx				inx			;   2Drop work
.c212	e8		inx				inx
.c213	e8		inx				inx
.c214	e8		inx				inx
.c215	68		pla				pla			; recover value
.c216	18		clc				clc			; add to ud
.c217	75 2c		adc $2c,x			adc DStack+6,x
.c219	95 2c		sta $2c,x			sta DStack+6,x
.c21b	90 0a		bcc $c227			bcc +
.c21d	f6 2d		inc $2d,x			inc DStack+7,x
.c21f	d0 06		bne $c227			bne +
.c221	f6 2a		inc $2a,x			inc DStack+4,x
.c223	d0 02		bne $c227			bne +
.c225	f6 2b		inc $2b,x			inc DStack+5,x
.c227					+
.c227	20 42 dc	jsr $dc42			jsr NOS_One_Plus	; consume the char
.c22a	d6 26		dec $26,x			dec DStack+0,x
.c22c	d0 8e		bne $c1bc			bne _Char_loop
.c22e					_done:
=122					CodeLen	.var *-XtPtr1
=$c22e					Here1 = *	; remember here
>c1b2	7a					.byte CodeLen	;patch wh_CodeLength
.c22e	60		rts				rts
>c22f	4e 75 6d 62 65 72		Name0:	.text "Number"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=49589					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>c235	46					.byte (("Number"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=80					WordFlags ::= UF+NN	; modifiable copy, remember for later
=133					LinkDisplacement = Nt0-WordListLink
>c236	50					.byte WordFlags	;wh_Flags
>c237	03					.byte 3	;wh_CodeLength
>c238	85					  .byte LinkDisplacement	; offset to previous nt
=$c239					XtPtr1 ::= *
=49589					WordListLink ::= Nt0 ; remember the nt of this word for later
.c239					Number:
.c239	20 9f c5	jsr $c59f			jsr underflow_2
.c23c	a9 00		lda #$00			lda #0
.c23e	85 1a		sta $1a				sta tmp4+0	; flag for double
.c240	85 1b		sta $1b				sta tmp4+1	; flag for minus
.c242	ad 00 03	lda $0300			lda base
.c245	48		pha				pha
.c246	20 97 de	jsr $de97			jsr Two_dup		; ( addr u addr u )
.c249	a1 28		lda ($28,x)			lda (DStack+2,x)	; get 1st char
.c24b	20 0d c3	jsr $c30d			jsr _MinusCheck		; a minus sign?
.c24e	a0 0a		ldy #$0a			ldy #10			; decimal?
.c250	c9 23		cmp #$23			cmp #'#'
.c252	f0 35		beq $c289			beq _base_changed
.c254	a0 10		ldy #$10			ldy #16			; hex?
.c256	c9 24		cmp #$24			cmp #'$'
.c258	f0 2f		beq $c289			beq _base_changed
.c25a	a0 02		ldy #$02			ldy #2			; binary?
.c25c	c9 25		cmp #$25			cmp #'%'
.c25e	f0 29		beq $c289			beq _base_changed
.c260	c9 27		cmp #$27			cmp #$27		; ASCII for "'"
.c262	d0 2f		bne $c293			bne _check_dot
.c264	b5 26		lda $26,x			lda DStack+0,x	; length=3 ?
.c266	c9 03		cmp #$03			cmp #3
.c268	d0 1c		bne $c286			bne _not_a_char
.c26a	b5 28		lda $28,x			lda DStack+2,x	; LSB of address
.c26c	85 1c		sta $1c				sta tmp5
.c26e	b5 29		lda $29,x			lda DStack+3,x
.c270	85 1d		sta $1d				sta tmp5+1
.c272	a0 02		ldy #$02			ldy #2
.c274	b1 1c		lda ($1c),y			lda (tmp5),y
.c276	c9 27		cmp #$27			cmp #$27	; ASCII for "'"
.c278	d0 0c		bne $c286			bne _not_a_char
.c27a	88		dey				dey		; The char we want is between the single quotes.
.c27b	b1 1c		lda ($1c),y			lda (tmp5),y
.c27d	95 28		sta $28,x			sta DStack+2,x
.c27f	a9 00		lda #$00			lda #0
.c281	95 29		sta $29,x			sta DStack+3,x
.c283	4c e2 c2	jmp $c2e2			jmp _drop_original_string ; Single flag will drop the TOS for us.
.c286					_not_a_char:
.c286	4c bf c2	jmp $c2bf			jmp _number_error
.c289					_base_changed:
.c289	8c 00 03	sty $0300			sty base	; Switch to the new base
.c28c	20 42 dc	jsr $dc42			jsr NOS_One_Plus ; start one character later
.c28f	d6 26		dec $26,x			dec DStack+0,x	; decrease string length by one
.c291	a1 28		lda ($28,x)			lda (DStack+2,x) ; Load the first char again
.c293					_check_dot:
.c293	20 0d c3	jsr $c30d			jsr _MinusCheck
.c296	b5 28		lda $28,x			lda DStack+2,x	; LSB of address
.c298	85 1c		sta $1c				sta tmp5
.c29a	b5 29		lda $29,x			lda DStack+3,x
.c29c	85 1d		sta $1d				sta tmp5+1
.c29e	b4 26		ldy $26,x			ldy DStack+0,x	; Y now points to the first character after the string,
.c2a0	88		dey				dey		; but we need the last character
.c2a1	b1 1c		lda ($1c),y			lda (tmp5),y
.c2a3	c9 2e		cmp #$2e			cmp #'.'
.c2a5	d0 04		bne $c2ab			bne _main
.c2a7	c6 1a		dec $1a				dec tmp4	; Flag the fact
.c2a9	d6 26		dec $26,x			dec DStack+0,x	; reduce string length by one
.c2ab					_main:
.c2ab	20 97 de	jsr $de97			jsr Two_Dup
.c2ae	a9 00		lda #$00			lda #0
.c2b0	95 2a		sta $2a,x			sta DStack+4,x	; clear ud
.c2b2	95 2b		sta $2b,x			sta DStack+5,x
.c2b4	95 2c		sta $2c,x			sta DStack+6,x
.c2b6	95 2d		sta $2d,x			sta DStack+7,x
.c2b8	20 b4 c1	jsr $c1b4			jsr To_Number	; ( ud addr u -- ud addr u )
.c2bb	b5 26		lda $26,x			lda DStack+0,x
.c2bd	f0 1f		beq $c2de			beq _all_converted
.c2bf					_number_error:
.c2bf	20 04 d7	jsr $d704			jsr Two_drop	; >NUMBER modified addr u
.c2c2	20 04 d7	jsr $d704			jsr Two_drop	; ud   (partially converted number)
.c2c5	a9 3e		lda #$3e			lda #'>'	; print the unknown
.c2c7	20 cd df	jsr $dfcd			jsr Emit_A	; word using the original addr u we saved at the beginning.
.c2ca	20 f1 df	jsr $dff1			jsr Type
.c2cd	a9 3c		lda #$3c			lda #'<'
.c2cf	20 cd df	jsr $dfcd			jsr Emit_A
.c2d2	20 e5 df	jsr $dfe5			jsr Space
.c2d5	68		pla				pla		; restore base
.c2d6	8d 00 03	sta $0300			sta base
.c2d9	a9 f3		lda #$f3			lda #$100+err_UndefinedWord
.c2db	4c dc c5	jmp $c5dc			jmp ThrowA
.c2de					_all_converted:
.c2de	e8		inx				inx		; Drop the current addr u
.c2df	e8		inx				inx
.c2e0	e8		inx				inx
.c2e1	e8		inx				inx
.c2e2					_drop_original_string:
.c2e2	20 7b d1	jsr $d17b			jsr TwoNip	 ; Drop the original addr u
.c2e5	a5 1a		lda $1a				lda tmp4	; flag for double
.c2e7	f0 10		beq $c2f9			beq _single
.c2e9	a9 20		lda #$20			lda #%00100000
.c2eb	05 0c		ora $0c				ora status
.c2ed	85 0c		sta $0c				sta status
.c2ef	a5 1b		lda $1b				lda tmp4+1
.c2f1	f0 15		beq $c308			beq _done	; no minus, all done
.c2f3	20 ab d8	jsr $d8ab			jsr DNegate
.c2f6	4c 08 c3	jmp $c308			jmp _done
.c2f9					_single:
.c2f9	e8		inx				inx		; convert ud to u
.c2fa	e8		inx				inx
.c2fb	a9 df		lda #$df			lda #$ff-%00100000
.c2fd	25 0c		and $0c				and status
.c2ff	85 0c		sta $0c				sta status
.c301	a5 1b		lda $1b				lda tmp4+1
.c303	f0 03		beq $c308			beq _done	; no minus, all done
.c305	20 7b d8	jsr $d87b			jsr Negate
.c308					_done:
.c308	68		pla				pla
.c309	8d 00 03	sta $0300			sta base
=211					CodeLen	.var *-XtPtr1
=$c30c					Here1 = *	; remember here
>c237	d3					.byte CodeLen	;patch wh_CodeLength
.c30c	60		rts				rts
.c30d					_MinusCheck:
.c30d	c9 2b		cmp #$2b			cmp #'+'
.c30f	f0 06		beq $c317			beq _mcp
.c311	c9 2d		cmp #$2d			cmp #'-'		; a minus sign?
.c313	d0 09		bne $c31e			bne _mc9
.c315	c6 1b		dec $1b				dec tmp4+1		; set flag
.c317	20 42 dc	jsr $dc42	_mcp:		jsr NOS_One_Plus	; start one character later
.c31a	d6 26		dec $26,x			dec DStack+0,x		; decrease string length by one
.c31c	a1 28		lda ($28,x)			lda (DStack+2,x)	; get next char
.c31e	60		rts		_mc9:		rts
>c31f	48 65 78			Name0:	.text "Hex"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=49826					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>c322	03					.byte (("Hex"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=237					LinkDisplacement = Nt0-WordListLink
>c323	10					.byte WordFlags	;wh_Flags
>c324	03					.byte 3	;wh_CodeLength
>c325	ed					  .byte LinkDisplacement	; offset to previous nt
=$c326					XtPtr1 ::= *
=49826					WordListLink ::= Nt0 ; remember the nt of this word for later
.c326	a9 10		lda #$10	Hex:		lda #16
.c328	d0 0d		bne $c337			bne Decimal_a
=4					CodeLen	.var *-XtPtr1
=$c32a					Here1 = *	; remember here
>c324	04					.byte CodeLen	;patch wh_CodeLength
>c32a	44 65 63 69 6d 61 6c		Name0:	.text "Decimal"	;  name of word as a string, ending at wh_NameLastChar
=7					NameLength = *-Name0
=49841					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>c331	87					.byte (("Decimal"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=0					WordFlags ::= 0	; modifiable copy, remember for later
=15					LinkDisplacement = Nt0-WordListLink
>c332	00					.byte WordFlags	;wh_Flags
>c333	03					.byte 3	;wh_CodeLength
>c334	0f					  .byte LinkDisplacement	; offset to previous nt
=$c335					XtPtr1 ::= *
=49841					WordListLink ::= Nt0 ; remember the nt of this word for later
.c335	a9 0a		lda #$0a	Decimal:	lda #10
.c337	8d 00 03	sta $0300	Decimal_a:	sta base+0
.c33a	a9 00		lda #$00			lda #0
.c33c	8d 01 03	sta $0301			sta base+1		; paranoid
=10					CodeLen	.var *-XtPtr1
=$c33f					Here1 = *	; remember here
>c333	0a					.byte CodeLen	;patch wh_CodeLength
.c33f	60		rts				rts
>c340	42 61 73 65			Name0:	.text "Base"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=49860					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>c344	a4					.byte (("Base"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=19					LinkDisplacement = Nt0-WordListLink
>c345	10					.byte WordFlags	;wh_Flags
>c346	03					.byte 3	;wh_CodeLength
>c347	13					  .byte LinkDisplacement	; offset to previous nt
=$c348					XtPtr1 ::= *
=49860					WordListLink ::= Nt0 ; remember the nt of this word for later
.c348	a9 00		lda #$00			lda #<base
.c34a	a0 03		ldy #$03			ldy #>base
.c34c	4c 2e c9	jmp $c92e			jmp PushYA
=7					CodeLen	.var *-XtPtr1
=$c34f					Here1 = *	; remember here
>c346	07					.byte CodeLen	;patch wh_CodeLength
.c34f	4c ae c5	jmp $c5ae	Throw_Stack_10: jmp Throw_Stack
>c352	43 6f 75 6e 74			Name0:	.text "Count"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=49879					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>c357	85					.byte (("Count"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=19					LinkDisplacement = Nt0-WordListLink
>c358	10					.byte WordFlags	;wh_Flags
>c359	03					.byte 3	;wh_CodeLength
>c35a	13					  .byte LinkDisplacement	; offset to previous nt
=$c35b					XtPtr1 ::= *
=49879					WordListLink ::= Nt0 ; remember the nt of this word for later
.c35b					Count:
.c35b	e0 2f		cpx #$2f		cpx #(DSDim-1)*2+1	; far enough below end of data stack (& not negative)?
.c35d	b0 f0		bcs $c34f		bcs Throw_Stack_10
.c35f	a1 26		lda ($26,x)			lda (DStack+0,x)	; A= number of characters
.c361	f6 26		inc $26,x			inc DStack+0,x		; move start address up by one
.c363	d0 02		bne $c367			bne +
.c365	f6 27		inc $27,x			inc DStack+1,x
.c367					+
.c367	4c 5d c9	jmp $c95d			jmp PushZA		; push number of characters, return
=15					CodeLen	.var *-XtPtr1
=$c36a					Here1 = *	; remember here
>c359	0f					.byte CodeLen	;patch wh_CodeLength
>c36a	3f 50 61 69 72 43 74 6c		Name0:	.text "?PairCtlA"	;  name of word as a string, ending at wh_NameLastChar
>c372	41
=9					NameLength = *-Name0
=49907					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>c373	29					.byte (("?PairCtlA"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=28					LinkDisplacement = Nt0-WordListLink
>c374	10					.byte WordFlags	;wh_Flags
>c375	03					.byte 3	;wh_CodeLength
>c376	1c					  .byte LinkDisplacement	; offset to previous nt
=$c377					XtPtr1 ::= *
=49907					WordListLink ::= Nt0 ; remember the nt of this word for later
.c377	d5 26		cmp $26,x	QPairCtlA:	cmp DStack+0,x
.c379	f0 05		beq $c380			beq _8
.c37b	a9 ea		lda #$ea			lda #$100+err_ControlMismatch
.c37d	4c dc c5	jmp $c5dc			jmp ThrowA
.c380	e8		inx		_8:		inx
.c381	e8		inx				inx	; Drop n
.c382	60		rts				rts
=12					CodeLen	.var *-XtPtr1
=$c383					Here1 = *	; remember here
>c375	0c					.byte CodeLen	;patch wh_CodeLength
>0743					DoLeave  .word ?	; head of leave addr patch chain
>0745					DoStkIndex: .byte ?
>0746					DoIndexL: .fill DoStkDim
>074e					DoIndexH: .fill DoStkDim
>0756					DoFufaL:  .fill DoStkDim
>075e					DoFufaH:  .fill DoStkDim
>c383	3f 44 6f			Name0:	.text "?Do"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=49926					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>c386	e3					.byte (("?Do"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=28					WordFlags ::= CO+IM+NN	; modifiable copy, remember for later
=19					LinkDisplacement = Nt0-WordListLink
>c387	1c					.byte WordFlags	;wh_Flags
>c388	03					.byte 3	;wh_CodeLength
>c389	13					  .byte LinkDisplacement	; offset to previous nt
=$c38a					XtPtr1 ::= *
=49926					WordListLink ::= Nt0 ; remember the nt of this word for later
.c38a					Question_Do:
.c38a	20 c4 c4	jsr $c4c4			jsr Do_Leave_Init
.c38d	a9 a1		lda #$a1			lda #<_runtime
.c38f	a0 c3		ldy #$c3			ldy #>_runtime
.c391	20 25 df	jsr $df25			jsr Jsr_Comma_YA	; compile JSR _runtime
.c394	a9 d0		lda #$d0			lda #$d0		; compile BNE *+5
.c396	a0 03		ldy #$03			ldy #3
.c398	20 f6 de	jsr $def6			jsr Comma_YA
.c39b	20 a7 c4	jsr $c4a7			jsr Leave		; compile JMP leave
.c39e	4c be c3	jmp $c3be			jmp Do_8		; finish
=23					CodeLen	.var *-XtPtr1
=$c3a1					Here1 = *	; remember here
>c388	17					.byte CodeLen	;patch wh_CodeLength
.c3a1					_runtime:
.c3a1	20 c6 c3	jsr $c3c6			jsr Do_Runtime	; start normally (we assume TOS!=NOS)
.c3a4	a5 12		lda $12				lda DoIndex+0	; Are TOS and NOS equal?
.c3a6	f0 01		beq $c3a9			beq _2
.c3a8	60		rts				rts		; return Z=0 to signal continue
.c3a9	a5 13		lda $13		_2:		lda DoIndex+1
.c3ab	c9 80		cmp #$80			cmp #$80
.c3ad	60		rts				rts		; return Z
>c3ae	44 6f				Name0:	.text "Do"	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=49968					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>c3b0	e2					.byte (("Do"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=28					WordFlags ::= CO+IM+NN	; modifiable copy, remember for later
=42					LinkDisplacement = Nt0-WordListLink
>c3b1	1c					.byte WordFlags	;wh_Flags
>c3b2	03					.byte 3	;wh_CodeLength
>c3b3	2a					  .byte LinkDisplacement	; offset to previous nt
=$c3b4					XtPtr1 ::= *
=49968					WordListLink ::= Nt0 ; remember the nt of this word for later
.c3b4					Do:
.c3b4	20 c4 c4	jsr $c4c4			jsr Do_Leave_Init
.c3b7	a9 c6		lda #$c6			lda #<Do_runtime
.c3b9	a0 c3		ldy #$c3			ldy #>Do_runtime
.c3bb	20 25 df	jsr $df25			jsr Jsr_Comma_YA	; compile JSR _runtime
.c3be	20 04 dc	jsr $dc04	Do_8:		jsr Here		; remember loop body start addr
.c3c1	a9 b4		lda #$b4			lda #<Do		; identifier
.c3c3	4c 5d c9	jmp $c95d			jmp PushZA
=18					CodeLen	.var *-XtPtr1
=$c3c6					Here1 = *	; remember here
>c3b2	12					.byte CodeLen	;patch wh_CodeLength
.c3c6					Do_Runtime:
.c3c6	ce 45 07	dec $0745			dec DoStkIndex		; alloc DO stack entry
.c3c9	ac 45 07	ldy $0745			ldy DoStkIndex
.c3cc	30 2d		bmi $c3fb			bmi _TooDeep
.c3ce	a5 12		lda $12				lda DoIndex+0		; save previous DoIndex
.c3d0	99 46 07	sta $0746,y			sta DoIndexL,y
.c3d3	a5 13		lda $13				lda DoIndex+1
.c3d5	99 4e 07	sta $074e,y			sta DoIndexH,y
.c3d8	38		sec				sec			; fudge factor (FUFA)= $8000 - limit
.c3d9	a9 00		lda #$00			lda #0			;   the number that will trip the overflow flag
.c3db	f5 28		sbc $28,x			sbc DStack+2,x
.c3dd	99 56 07	sta $0756,y			sta DoFuFaL,y
.c3e0	a9 80		lda #$80			lda #$80
.c3e2	f5 29		sbc $29,x			sbc DStack+3,x
.c3e4	99 5e 07	sta $075e,y			sta DoFuFaH,y
.c3e7	18		clc				clc			; index= FUFA plus original index
.c3e8	b5 26		lda $26,x			lda DStack+0,x
.c3ea	79 56 07	adc $0756,y			adc DoFuFaL,y
.c3ed	85 12		sta $12				sta DoIndex+0
.c3ef	b5 27		lda $27,x			lda DStack+1,x
.c3f1	79 5e 07	adc $075e,y			adc DoFuFaH,y
.c3f4	85 13		sta $13				sta DoIndex+1
.c3f6	e8		inx				inx			; Drop orig index
.c3f7	e8		inx				inx
.c3f8	e8		inx				inx			; Drop orig limit
.c3f9	e8		inx				inx
.c3fa	60		rts				rts			; return
.c3fb	a9 f9		lda #$f9	_TooDeep:	lda #$100+err_DoLoop_TooDeep
.c3fd	20 dc c5	jsr $c5dc			jsr ThrowA
>c400	4c 6f 6f 70			Name0:	.text "Loop"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=50052					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>c404	04					.byte (("Loop"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=28					WordFlags ::= CO+IM+NN	; modifiable copy, remember for later
=84					LinkDisplacement = Nt0-WordListLink
>c405	1c					.byte WordFlags	;wh_Flags
>c406	03					.byte 3	;wh_CodeLength
>c407	54					  .byte LinkDisplacement	; offset to previous nt
=$c408					XtPtr1 ::= *
=50052					WordListLink ::= Nt0 ; remember the nt of this word for later
.c408					Loop:
.c408	a9 0e		lda #$0e			lda #<_Runtime
.c40a	a0 c4		ldy #$c4			ldy #>_Runtime
.c40c	d0 1b		bne $c429			bne Plus_Loop_5
=6					CodeLen	.var *-XtPtr1
=$c40e					Here1 = *	; remember here
>c406	06					.byte CodeLen	;patch wh_CodeLength
.c40e					_Runtime:
.c40e	e6 12		inc $12				inc DoIndex+0
.c410	f0 02		beq $c414			beq _Runtime2
.c412	b8		clv				clv			; return V=0 to signal loop back
.c413	60		rts				rts
.c414	18		clc		_Runtime2:	clc
.c415	a5 13		lda $13				lda DoIndex+1		; handle carry from lo byte
.c417	69 01		adc #$01			adc #1
.c419	85 13		sta $13				sta DoIndex+1
.c41b	60		rts				rts			; return V to signal loop back
>c41c	2b 4c 6f 6f 70			Name0:	.text "+Loop"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=50081					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>c421	05					.byte (("+Loop"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=28					WordFlags ::= CO+IM+NN	; modifiable copy, remember for later
=29					LinkDisplacement = Nt0-WordListLink
>c422	1c					.byte WordFlags	;wh_Flags
>c423	03					.byte 3	;wh_CodeLength
>c424	1d					  .byte LinkDisplacement	; offset to previous nt
=$c425					XtPtr1 ::= *
=50081					WordListLink ::= Nt0 ; remember the nt of this word for later
.c425					Plus_Loop:
.c425	a9 33		lda #$33			lda #<Plus_Loop_Runtime
.c427	a0 c4		ldy #$c4			ldy #>Plus_Loop_Runtime
.c429	20 49 c4	jsr $c449	Plus_Loop_5:	jsr Loop_End		; compile JSR _runtime, BVC back
.c42c	a9 8d		lda #$8d			lda #<Unloop ;(Unloop-wh_LinkNt-1)
.c42e	a0 c4		ldy #$c4			ldy #>Unloop ;(Unloop-wh_LinkNt-1)
.c430	4c 25 df	jmp $df25			jmp Jsr_Comma_YA ;Compile_Comma_NT_YA ; compile Unloop, return
=14					CodeLen	.var *-XtPtr1
=$c433					Here1 = *	; remember here
>c423	0e					.byte CodeLen	;patch wh_CodeLength
.c433					Plus_Loop_Runtime:
.c433	e0 2f		cpx #$2f		cpx #(DSDim-1)*2+1	; far enough below end of data stack (& not negative)?
.c435	b0 0f		bcs $c446		bcs Throw_Stack_12
.c437	b5 26		lda $26,x			lda DStack+0,x		; DoIndex += step
.c439	65 12		adc $12				adc DoIndex+0
.c43b	85 12		sta $12				sta DoIndex+0
.c43d	b5 27		lda $27,x			lda DStack+1,x
.c43f	65 13		adc $13				adc DoIndex+1
.c441	85 13		sta $13				sta DoIndex+1
.c443	e8		inx				inx			; Drop step
.c444	e8		inx				inx
.c445	60		rts				rts			; return V=0 to signal loop back
.c446	4c ae c5	jmp $c5ae	Throw_Stack_12: jmp Throw_Stack
.c449					Loop_End:
.c449	20 25 df	jsr $df25			jsr Jsr_Comma_YA	; compile JSR runtime
.c44c	a9 b4		lda #$b4			lda #<Do		; check id
.c44e	20 77 c3	jsr $c377	Loop_End_3:	jsr QPairCtlA
.c451	a9 50		lda #$50			lda #$50		; compile BVC body
.c453	20 5e b8	jsr $b85e			jsr Branch_CommaA
.c456	ac 43 07	ldy $0743			ldy DoLeave+0		; for each leave addr entry
.c459	ad 44 07	lda $0744			lda DoLeave+1
.c45c	f0 1b		beq $c479			beq _p9
.c45e	84 14		sty $14		_p1:		sty tmp1+0		;   save entry pointer
.c460	85 15		sta $15				sta tmp1+1
.c462	a0 01		ldy #$01			ldy #1			;   save link
.c464	b1 14		lda ($14),y			lda (tmp1),y
.c466	48		pha				pha
.c467	88		dey				dey
.c468	b1 14		lda ($14),y			lda (tmp1),y
.c46a	48		pha				pha
.c46b	a5 00		lda $00				lda cp+0		;   patch addr
.c46d	91 14		sta ($14),y			sta (tmp1),y
.c46f	a5 01		lda $01				lda cp+1
.c471	c8		iny				iny
.c472	91 14		sta ($14),y			sta (tmp1),y
.c474	68		pla				pla			;   get saved link
.c475	a8		tay				tay
.c476	68		pla				pla
.c477	d0 e5		bne $c45e			bne _p1
.c479					_p9:
.c479	20 62 c5	jsr $c562			jsr PopYA		; restore DoLeave
.c47c	8d 43 07	sta $0743			sta DoLeave+0
.c47f	8c 44 07	sty $0744			sty DoLeave+1
.c482	60		rts				rts
>c483	55 6e 6c 6f 6f 70		Name0:	.text "Unloop"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=50185					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>c489	06					.byte (("Unloop"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$04					WordFlags ::= CO	; modifiable copy, remember for later
=104					LinkDisplacement = Nt0-WordListLink
>c48a	04					.byte WordFlags	;wh_Flags
>c48b	03					.byte 3	;wh_CodeLength
>c48c	68					  .byte LinkDisplacement	; offset to previous nt
=$c48d					XtPtr1 ::= *
=50185					WordListLink ::= Nt0 ; remember the nt of this word for later
.c48d					Unloop:
.c48d	ac 45 07	ldy $0745			ldy DoStkIndex
.c490	b9 46 07	lda $0746,y			lda DoIndexL,y	; restore Index
.c493	85 12		sta $12				sta DoIndex+0
.c495	b9 4e 07	lda $074e,y			lda DoIndexH,y
.c498	85 13		sta $13				sta DoIndex+1
.c49a	ee 45 07	inc $0745			inc DoStkIndex	; drop Do stack entry
=16					CodeLen	.var *-XtPtr1
=$c49d					Here1 = *	; remember here
>c48b	10					.byte CodeLen	;patch wh_CodeLength
.c49d	60		rts				rts
>c49e	4c 65 61 76 65			Name0:	.text "Leave"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=50211					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>c4a3	a5					.byte (("Leave"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=28					WordFlags ::= IM+NN+CO	; modifiable copy, remember for later
=26					LinkDisplacement = Nt0-WordListLink
>c4a4	1c					.byte WordFlags	;wh_Flags
>c4a5	03					.byte 3	;wh_CodeLength
>c4a6	1a					  .byte LinkDisplacement	; offset to previous nt
=$c4a7					XtPtr1 ::= *
=50211					WordListLink ::= Nt0 ; remember the nt of this word for later
.c4a7					Leave:
.c4a7	a9 4c		lda #$4c			lda #$4c	; JMP abs
.c4a9	20 df de	jsr $dedf			jsr C_Comma_A
.c4ac	a5 01		lda $01				lda cp+1	; save cp
.c4ae	48		pha				pha
.c4af	a5 00		lda $00				lda cp+0
.c4b1	48		pha				pha
.c4b2	ad 43 07	lda $0743			lda DoLeave+0	; compile DoLeave link, patched later
.c4b5	ac 44 07	ldy $0744			ldy DoLeave+1
.c4b8	20 f6 de	jsr $def6			jsr Comma_YA
.c4bb	68		pla				pla		; update DoLeave
.c4bc	8d 43 07	sta $0743			sta DoLeave+0
.c4bf	68		pla				pla
.c4c0	8d 44 07	sta $0744			sta DoLeave+1
=28					CodeLen	.var *-XtPtr1
=$c4c3					Here1 = *	; remember here
>c4a5	1c					.byte CodeLen	;patch wh_CodeLength
.c4c3	60		rts				rts
.c4c4					Do_Leave_Init:
.c4c4	ad 43 07	lda $0743			lda DoLeave+0
.c4c7	ac 44 07	ldy $0744			ldy DoLeave+1
.c4ca	20 2e c9	jsr $c92e			jsr PushYA	; save old leave head
.c4cd	a9 00		lda #$00			lda #0		; init
.c4cf	8d 44 07	sta $0744			sta DoLeave+1
.c4d2	60		rts				rts
>c4d3	49				Name0:	.text "I"	;  name of word as a string, ending at wh_NameLastChar
=1					NameLength = *-Name0
=50260					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>c4d4	21					.byte (("I"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$04					WordFlags ::= CO	; modifiable copy, remember for later
=49					LinkDisplacement = Nt0-WordListLink
>c4d5	04					.byte WordFlags	;wh_Flags
>c4d6	03					.byte 3	;wh_CodeLength
>c4d7	31					  .byte LinkDisplacement	; offset to previous nt
=$c4d8					XtPtr1 ::= *
=50260					WordListLink ::= Nt0 ; remember the nt of this word for later
.c4d8	ac 45 07	ldy $0745	I:		ldy DoStkIndex
.c4db	ca		dex				dex
.c4dc	ca		dex				dex
.c4dd	38		sec				sec		; n= fudged index - fudge factor (FUFA)
.c4de	a5 12		lda $12				lda DoIndex+0
.c4e0	f9 56 07	sbc $0756,y			sbc DoFuFaL,y
.c4e3	95 26		sta $26,x			sta DStack+0,x
.c4e5	a5 13		lda $13				lda DoIndex+1
.c4e7	f9 5e 07	sbc $075e,y			sbc DoFuFaH,y
.c4ea	95 27		sta $27,x			sta DStack+1,x
=20					CodeLen	.var *-XtPtr1
=$c4ec					Here1 = *	; remember here
>c4d6	14					.byte CodeLen	;patch wh_CodeLength
.c4ec	60		rts				rts
>c4ed	4a				Name0:	.text "J"	;  name of word as a string, ending at wh_NameLastChar
=1					NameLength = *-Name0
=50286					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>c4ee	41					.byte (("J"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$04					WordFlags ::= CO	; modifiable copy, remember for later
=26					LinkDisplacement = Nt0-WordListLink
>c4ef	04					.byte WordFlags	;wh_Flags
>c4f0	03					.byte 3	;wh_CodeLength
>c4f1	1a					  .byte LinkDisplacement	; offset to previous nt
=$c4f2					XtPtr1 ::= *
=50286					WordListLink ::= Nt0 ; remember the nt of this word for later
.c4f2	ac 45 07	ldy $0745	J:		ldy DoStkIndex
.c4f5	ca		dex				dex
.c4f6	ca		dex				dex
.c4f7	38		sec				sec		; n= 2nd fudged index - 2nd fudge factor (FUFA)
.c4f8	b9 46 07	lda $0746,y			lda DoIndexL+0,y	; LSB
.c4fb	f9 57 07	sbc $0757,y			sbc DoFufaL+1,y
.c4fe	95 26		sta $26,x			sta DStack+0,x
.c500	b9 4e 07	lda $074e,y			lda DoIndexH+0,y	; MSB
.c503	f9 5f 07	sbc $075f,y			sbc DoFufaH+1,y
.c506	95 27		sta $27,x			sta DStack+1,x
=22					CodeLen	.var *-XtPtr1
=$c508					Here1 = *	; remember here
>c4f0	16					.byte CodeLen	;patch wh_CodeLength
.c508	60		rts				rts
>c509	41 62 6f 72 74 22		Name0:	.text 'Abort"'	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=50319					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>c50f	46					.byte (('Abort"'[-1]&7)<<5)+NameLength	;wh_HashNameLen
=28					WordFlags ::= CO+IM+NN	; modifiable copy, remember for later
=33					LinkDisplacement = Nt0-WordListLink
>c510	1c					.byte WordFlags	;wh_Flags
>c511	03					.byte 3	;wh_CodeLength
>c512	21					  .byte LinkDisplacement	; offset to previous nt
=$c513					XtPtr1 ::= *
=50319					WordListLink ::= Nt0 ; remember the nt of this word for later
.c513					Abort_Quote:
.c513	20 9d ca	jsr $ca9d			jsr S_Quote		; compile the string literal
.c516	a0 c5		ldy #$c5			ldy #>_runtime		; compile JSR runtime, return
.c518	a9 1d		lda #$1d			lda #<_runtime
.c51a	4c 25 df	jmp $df25			jmp Jsr_Comma_YA
=10					CodeLen	.var *-XtPtr1
=$c51d					Here1 = *	; remember here
>c511	0a					.byte CodeLen	;patch wh_CodeLength
.c51d					_runtime:
.c51d	b5 2a		lda $2a,x			lda DStack+4,x
.c51f	15 2b		ora $2b,x			ora DStack+5,x
.c521	d0 03		bne $c526			bne _do_abort	; true?
.c523	4c ed be	jmp $beed			jmp ThreeDrop	; Drop three entries from the Data Stack
.c526					_do_abort:
.c526	20 f1 df	jsr $dff1			jsr Type	; print string
.c529	20 b7 bc	jsr $bcb7			jsr CR		; We follow Gforth in going to a new line
.c52c	a9 fe		lda #$fe			lda #$100+err_AbortQuote
.c52e	4c dc c5	jmp $c5dc			jmp ThrowA
>c531	41 62 6f 72 74			Name0:	.text "Abort"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=50358					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>c536	85					.byte (("Abort"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=39					LinkDisplacement = Nt0-WordListLink
>c537	10					.byte WordFlags	;wh_Flags
>c538	03					.byte 3	;wh_CodeLength
>c539	27					  .byte LinkDisplacement	; offset to previous nt
=$c53a					XtPtr1 ::= *
=50358					WordListLink ::= Nt0 ; remember the nt of this word for later
.c53a	a9 ff		lda #$ff	Abort:		lda #$100+err_Abort
.c53c	4c dc c5	jmp $c5dc			jmp ThrowA
=5					CodeLen	.var *-XtPtr1
=$c53f					Here1 = *	; remember here
>c538	05					.byte CodeLen	;patch wh_CodeLength
>c53f	50 6f 70 41			Name0:	.text "PopA"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=50371					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>c543	24					.byte (("PopA"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>c544	10					.byte WordFlags	;wh_Flags
>c545	03					.byte 3	;wh_CodeLength
>c546	0d					  .byte LinkDisplacement	; offset to previous nt
=$c547					XtPtr1 ::= *
=50371					WordListLink ::= Nt0 ; remember the nt of this word for later
.c547					PopA:
.c547	e0 2f		cpx #$2f		cpx #(DSDim-1)*2+1	; far enough below end of data stack (& not negative)?
.c549	b0 63		bcs $c5ae		bcs Throw_Stack
.c54b	b5 26		lda $26,x			lda DStack+0,x		; pop TOS to A (1 byte)
.c54d	e8		inx				inx
.c54e	e8		inx				inx
=8					CodeLen	.var *-XtPtr1
=$c54f					Here1 = *	; remember here
>c545	08					.byte CodeLen	;patch wh_CodeLength
.c54f	60		rts		                rts
.c550					PopA2:
.c550	e0 2d		cpx #$2d		cpx #(DSDim-2)*2+1	; far enough below end of data stack (& not negative)?
.c552	b0 5a		bcs $c5ae		bcs Throw_Stack
.c554	b5 26		lda $26,x			lda DStack+0,x		; pop TOS to A (1 byte)
.c556	e8		inx				inx
.c557	e8		inx				inx
.c558	60		rts		                rts
>c559	50 6f 70 59 41			Name0:	.text "PopYA"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=50398					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>c55e	25					.byte (("PopYA"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=27					LinkDisplacement = Nt0-WordListLink
>c55f	10					.byte WordFlags	;wh_Flags
>c560	03					.byte 3	;wh_CodeLength
>c561	1b					  .byte LinkDisplacement	; offset to previous nt
=$c562					XtPtr1 ::= *
=50398					WordListLink ::= Nt0 ; remember the nt of this word for later
.c562					PopYA:
.c562	e0 2f		cpx #$2f		cpx #(DSDim-1)*2+1	; far enough below end of data stack (& not negative)?
.c564	b0 48		bcs $c5ae		bcs Throw_Stack
.c566	b5 26		lda $26,x			lda DStack+0,x		; pop TOS to YA
.c568	b4 27		ldy $27,x			ldy DStack+1,x
.c56a	e8		inx				inx
.c56b	e8		inx				inx
=10					CodeLen	.var *-XtPtr1
=$c56c					Here1 = *	; remember here
>c560	0a					.byte CodeLen	;patch wh_CodeLength
.c56c	60		rts				rts
.c56d					PopTmp1:
.c56d	e0 2f		cpx #$2f		cpx #(DSDim-1)*2+1	; far enough below end of data stack (& not negative)?
.c56f	b0 3d		bcs $c5ae		bcs Throw_Stack
.c571	b5 26		lda $26,x			lda DStack+0,x	; PopYA
.c573	b4 27		ldy $27,x			ldy DStack+1,x
.c575	e8		inx				inx
.c576	e8		inx				inx
.c577	85 14		sta $14				sta tmp1+0
.c579	84 15		sty $15				sty tmp1+1
.c57b	60		rts				rts
>c57c	75 6e 64 65 72 66 6c 6f		Name0:	.text "underflow_1"	;  name of word as a string, ending at wh_NameLastChar
>c584	77 5f 31
=11					NameLength = *-Name0
=50439					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>c587	2b					.byte (("underflow_1"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=41					LinkDisplacement = Nt0-WordListLink
>c588	10					.byte WordFlags	;wh_Flags
>c589	03					.byte 3	;wh_CodeLength
>c58a	29					  .byte LinkDisplacement	; offset to previous nt
=$c58b					XtPtr1 ::= *
=50439					WordListLink ::= Nt0 ; remember the nt of this word for later
.c58b					underflow_1:
.c58b	e0 2f		cpx #$2f		cpx #(DSDim-1)*2+1	; far enough below end of data stack (& not negative)?
.c58d	b0 1f		bcs $c5ae		bcs Throw_Stack
=4					CodeLen	.var *-XtPtr1
=$c58f					Here1 = *	; remember here
>c589	04					.byte CodeLen	;patch wh_CodeLength
.c58f	60		rts				rts
>c590	75 6e 64 65 72 66 6c 6f		Name0:	.text "underflow_2"	;  name of word as a string, ending at wh_NameLastChar
>c598	77 5f 32
=11					NameLength = *-Name0
=50459					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>c59b	4b					.byte (("underflow_2"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=20					LinkDisplacement = Nt0-WordListLink
>c59c	10					.byte WordFlags	;wh_Flags
>c59d	03					.byte 3	;wh_CodeLength
>c59e	14					  .byte LinkDisplacement	; offset to previous nt
=$c59f					XtPtr1 ::= *
=50459					WordListLink ::= Nt0 ; remember the nt of this word for later
.c59f					underflow_2:
.c59f	e0 2d		cpx #$2d		cpx #(DSDim-2)*2+1	; far enough below end of data stack (& not negative)?
.c5a1	b0 0b		bcs $c5ae		bcs Throw_Stack
=4					CodeLen	.var *-XtPtr1
=$c5a3					Here1 = *	; remember here
>c59d	04					.byte CodeLen	;patch wh_CodeLength
.c5a3	60		rts		                rts
.c5a4					underflow_3:
.c5a4	e0 2b		cpx #$2b		cpx #(DSDim-3)*2+1	; far enough below end of data stack (& not negative)?
.c5a6	b0 06		bcs $c5ae		bcs Throw_Stack
.c5a8	60		rts		                rts
.c5a9					underflow_4:
.c5a9	e0 29		cpx #$29		cpx #(DSDim-4)*2+1	; far enough below end of data stack (& not negative)?
.c5ab	b0 01		bcs $c5ae		bcs Throw_Stack
.c5ad	60		rts		                rts
.c5ae					Throw_Stack:
.c5ae	30 04		bmi $c5b4			bmi _over
.c5b0	a9 fc		lda #$fc			lda #$100+err_Stack_Underflow
.c5b2	d0 28		bne $c5dc			bne ThrowA
.c5b4	a9 fd		lda #$fd	_over:		lda #$100+err_Stack_Overflow
.c5b6	d0 24		bne $c5dc			bne ThrowA
>c5b8	3f 53 74 61 63 6b		Name0:	.text "?Stack"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=50494					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>c5be	66					.byte (("?Stack"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=35					LinkDisplacement = Nt0-WordListLink
>c5bf	10					.byte WordFlags	;wh_Flags
>c5c0	03					.byte 3	;wh_CodeLength
>c5c1	23					  .byte LinkDisplacement	; offset to previous nt
=$c5c2					XtPtr1 ::= *
=50494					WordListLink ::= Nt0 ; remember the nt of this word for later
.c5c2					QStack:
.c5c2	e0 31		cpx #$31		cpx #(DSDim-0)*2+1	; far enough below end of data stack (& not negative)?
.c5c4	b0 e8		bcs $c5ae		bcs Throw_Stack
.c5c6	a4 56		ldy $56				ldy FIndex		; check floating point stack
.c5c8	c0 0b		cpy #$0b			cpy #FSDim+1
.c5ca	90 03		bcc $c5cf			bcc _3
.c5cc	4c dd 84	jmp $84dd			jmp Throw_FPStack
.c5cf					_3:
=13					CodeLen	.var *-XtPtr1
=$c5cf					Here1 = *	; remember here
>c5c0	0d					.byte CodeLen	;patch wh_CodeLength
.c5cf	60		rts				rts			; all OK
>c5d0	54 68 72 6f 77			Name0:	.text "Throw"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=50517					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>c5d5	e5					.byte (("Throw"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=23					LinkDisplacement = Nt0-WordListLink
>c5d6	10					.byte WordFlags	;wh_Flags
>c5d7	03					.byte 3	;wh_CodeLength
>c5d8	17					  .byte LinkDisplacement	; offset to previous nt
=$c5d9					XtPtr1 ::= *
=50517					WordListLink ::= Nt0 ; remember the nt of this word for later
.c5d9	20 47 c5	jsr $c547	Throw:		jsr PopA		; pop n
.c5dc	20 07 c6	jsr $c607	ThrowA:		jsr Type_Exception_Text_A ; print the associated error string
.c5df	a2 30		ldx #$30			ldx #DSDim*2		; reset data stack (in case of underflow)
.c5e1					Abort_Core:
.c5e1	20 4b ca	jsr $ca4b			jsr SLiteral_runtime
.c5e4	4c ea c5	jmp $c5ea			  jmp +
>c5e7	3f 00 20					  .text "?",0," "	; signal an error to the simulator
.c5ea	20 f1 df	jsr $dff1	+		jsr Type
.c5ed	20 18 e1	jsr $e118			jsr R_From		; show return stack TOS
.c5f0	20 98 81	jsr $8198			jsr TypeSymbol
.c5f3	20 33 e1	jsr $e133			jsr R_Fetch		; show return stack NOS
.c5f6	20 98 81	jsr $8198			jsr TypeSymbol
.c5f9	20 b7 bc	jsr $bcb7			jsr CR
.c5fc					Abort_Core2:
.c5fc	a9 08		lda #$08			lda #DoStkDim		; init do stack
.c5fe	8d 45 07	sta $0745			sta DoStkIndex
.c601	20 4a c6	jsr $c64a			jsr Empty_Stack		; empty the Data Stack & FP stack
.c604	4c 59 c6	jmp $c659			jmp Quit		; continue into QUIT.
.c607					Type_Exception_Text_A:
.c607	85 16		sta $16				sta tmp2+0	; save error code
.c609	a9 a1		lda #$a1			lda #<Exception_Text_List
.c60b	a0 ec		ldy #$ec			ldy #>Exception_Text_List	; for each table entry
.c60d	85 18		sta $18				sta tmp3+0
.c60f	84 19		sty $19				sty tmp3+1
.c611	a0 00		ldy #$00	_TestEntry:	ldy #0		;   code match?
.c613	b1 18		lda ($18),y			lda (tmp3),y
.c615	f0 1a		beq $c631			beq _NotFound
.c617	c5 16		cmp $16				cmp tmp2+0
.c619	f0 11		beq $c62c			beq _Found
.c61b	c8		iny		-		iny		;   step to end of entry
.c61c	b1 18		lda ($18),y			lda (tmp3),y
.c61e	d0 fb		bne $c61b			bne -
.c620	98		tya				tya		;   step to next entry
.c621	38		sec				sec
.c622	65 18		adc $18				adc tmp3+0
.c624	85 18		sta $18				sta tmp3+0
.c626	90 e9		bcc $c611			bcc _TestEntry
.c628	e6 19		inc $19				inc tmp3+1
.c62a	d0 e5		bne $c611			bne _TestEntry
.c62c					_Found:
.c62c	a0 01		ldy #$01			ldy #1
.c62e	4c 13 e0	jmp $e013			jmp Print_ASCIIZ_tmp3_no_lf
.c631	a0 ff		ldy #$ff	_NotFound:	ldy #$ff		; print code
.c633	a5 16		lda $16				lda tmp2+0
.c635	20 2e c9	jsr $c92e			jsr PushYA
.c638	4c c2 dd	jmp $ddc2			jmp Dot
=98					CodeLen	.var *-XtPtr1
=$c63b					Here1 = *	; remember here
>c5d7	62					.byte CodeLen	;patch wh_CodeLength
>c63b	45 6d 70 74 79 2d 53 74		Name0:	.text "Empty-Stack"	;  name of word as a string, ending at wh_NameLastChar
>c643	61 63 6b
=11					NameLength = *-Name0
=50630					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>c646	6b					.byte (("Empty-Stack"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=113					LinkDisplacement = Nt0-WordListLink
>c647	10					.byte WordFlags	;wh_Flags
>c648	03					.byte 3	;wh_CodeLength
>c649	71					  .byte LinkDisplacement	; offset to previous nt
=$c64a					XtPtr1 ::= *
=50630					WordListLink ::= Nt0 ; remember the nt of this word for later
.c64a	a2 30		ldx #$30	Empty_Stack:	ldx #DSDim*2	; init data stack
.c64c	a9 0a		lda #$0a			lda #FSDim	; init FP stack
.c64e	85 56		sta $56				sta FIndex
=6					CodeLen	.var *-XtPtr1
=$c650					Here1 = *	; remember here
>c648	06					.byte CodeLen	;patch wh_CodeLength
.c650	60		rts				rts
>c651	51 75 69 74			Name0:	.text "Quit"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=50645					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>c655	84					.byte (("Quit"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=15					LinkDisplacement = Nt0-WordListLink
>c656	10					.byte WordFlags	;wh_Flags
>c657	03					.byte 3	;wh_CodeLength
>c658	0f					  .byte LinkDisplacement	; offset to previous nt
=$c659					XtPtr1 ::= *
=50645					WordListLink ::= Nt0 ; remember the nt of this word for later
.c659					Quit:
.c659	8a		txa				txa		; Save the DStack index
.c65a	a2 ff		ldx #$ff			ldx #rsp0	; Set the return stack ptr
.c65c	9a		txs				txs
.c65d	aa		tax				tax		; Restore the DStack index.
.c65e	a9 00		lda #$00			lda #0		; SOURCE-ID= zero (keyboard input)
.c660	85 02		sta $02				sta insrc+0
.c662	85 03		sta $03				sta insrc+1
.c664	20 a7 c8	jsr $c8a7			jsr Left_Bracket_NoCheck ; switch to interpret state
.c667					_get_line:
.c667	a9 00		lda #$00			lda #<buffer0	; input buffer, this is paranoid
.c669	85 04		sta $04				sta cib+0
.c66b	a9 02		lda #$02			lda #>buffer0
.c66d	85 05		sta $05				sta cib+1
.c66f	20 29 d4	jsr $d429			jsr Refill		; ( -- f )
.c672	b5 26		lda $26,x			lda DStack+0,x
.c674	d0 05		bne $c67b			bne +
.c676	a9 6b		lda #$6b			lda #$100+err_Refill	; REFILL returned a FALSE flag, something went wrong
.c678	4c dc c5	jmp $c5dc			jmp ThrowA
.c67b	e8		inx		+		inx			; drop the flag
.c67c	e8		inx				inx
.c67d	20 94 c6	jsr $c694			jsr interpret
.c680	a5 0a		lda $0a				lda state
.c682	d0 06		bne $c68a			bne _print_compiled
.c684	a9 6d		lda #$6d			lda #<str_ok
.c686	a0 ec		ldy #$ec			ldy #>str_ok
.c688	d0 04		bne $c68e			bne _print
.c68a	a9 71		lda #$71	_print_compiled: lda #<str_compiled	; "compile" string
.c68c	a0 ec		ldy #$ec			ldy #>str_compiled
.c68e	20 1e e0	jsr $e01e	_print:		jsr Print_ASCIIZ_YA
.c691	4c 67 c6	jmp $c667			jmp _get_line
=59					CodeLen	.var *-XtPtr1
=$c694					Here1 = *	; remember here
>c657	3b					.byte CodeLen	;patch wh_CodeLength
.c694					Interpret:
.c694					_loop:
.c694	20 c2 c5	jsr $c5c2			jsr QStack		; check stack bounds
.c697	20 15 cc	jsr $cc15			jsr parse_name		; ( "string" -- addr u )
.c69a	b5 26		lda $26,x	                lda DStack+0,x		; empty line?
.c69c	f0 53		beq $c6f1	                beq _line_done
.c69e	20 97 de	jsr $de97			jsr Two_dup		; ( addr u -- addr u addr u )
.c6a1	20 fa cd	jsr $cdfa			jsr Find_Name		; ( addr u addr u -- addr u nt|0 )
.c6a4	b5 27		lda $27,x			lda DStack+1,x		; word found?
.c6a6	d0 1b		bne $c6c3			bne _got_name_token
.c6a8	e8		inx		                inx                     ; ( addr u 0 -- addr u )
.c6a9	e8		inx		                inx
.c6aa	20 39 c2	jsr $c239	                jsr Number           ; ( addr u -- u|d )
.c6ad	a5 0a		lda $0a		                lda state		; interpreting?
.c6af	f0 e3		beq $c694	                beq _loop		;   we're done
.c6b1	a9 20		lda #$20	                lda #$20		; double cell number?
.c6b3	24 0c		bit $0c		                bit status
.c6b5	f0 06		beq $c6bd	                beq _single_number
.c6b7	20 ff c8	jsr $c8ff			jsr Two_literal		; compile a double number
.c6ba	4c 94 c6	jmp $c694			jmp _loop
.c6bd	20 cb c8	jsr $c8cb	_single_number:	jsr Literal		; compile a single number
.c6c0	4c 94 c6	jmp $c694			jmp _loop
.c6c3					_got_name_token:
.c6c3	20 5f db	jsr $db5f			jsr Nip
.c6c6	20 5f db	jsr $db5f			jsr Nip			; ( nt )
.c6c9	85 14		sta $14				sta tmp1+0		; save a work copy of nt
.c6cb	84 15		sty $15				sty tmp1+1
.c6cd	a0 81		ldy #$81			ldy #Wh_Flags		; get word flags, we'll need them shortly
.c6cf	b1 14		lda ($14),y			lda (tmp1),y		;    using saved nt
.c6d1	a4 0a		ldy $0a				ldy state		; interpreting or compiling?
.c6d3	d0 12		bne $c6e7			bne _compile
.c6d5	29 04		and #$04			and #CO			; is the word COMPILE-ONLY?
.c6d7	f0 05		beq $c6de			beq _execute
.c6d9	a9 f2		lda #$f2			lda #$100+err_CompileOnly ;   complain & quit
.c6db	20 dc c5	jsr $c5dc			jsr ThrowA
.c6de	20 3c cf	jsr $cf3c	_execute:	jsr Name_To_Int		; ( nt -- xt )
.c6e1	20 2f e0	jsr $e02f			jsr Execute		; EXECUTE the xt that is TOS
.c6e4	4c 94 c6	jmp $c694	                jmp _loop
.c6e7					_compile:
.c6e7	29 08		and #$08			and #IM			; is the word IMMEDIATE?
.c6e9	d0 f3		bne $c6de			bne _execute		;   IMMEDIATE word, execute now
.c6eb	20 16 c8	jsr $c816			jsr Compile_Comma_NT	; Compile the nt into the Dictionary
.c6ee	4c 94 c6	jmp $c694			jmp _loop
.c6f1					_line_done:
.c6f1	e8		inx				inx			; drop stuff from PARSE_NAME
.c6f2	e8		inx				inx
.c6f3	e8		inx				inx
.c6f4	e8		inx				inx
.c6f5	60		rts				rts
>c6f6	49 6d 6d 65 64 69 61 74		Name0:	.text "Immediate"	;  name of word as a string, ending at wh_NameLastChar
>c6fe	65
=9					NameLength = *-Name0
=50815					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>c6ff	a9					.byte (("Immediate"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=170					LinkDisplacement = Nt0-WordListLink
>c700	10					.byte WordFlags	;wh_Flags
>c701	03					.byte 3	;wh_CodeLength
>c702	aa					  .byte LinkDisplacement	; offset to previous nt
=$c703					XtPtr1 ::= *
=50815					WordListLink ::= Nt0 ; remember the nt of this word for later
.c703	a9 08		lda #$08	Immediate:	lda #IM
.c705	48		pha		SetFlag:	pha
.c706	20 e7 cb	jsr $cbe7			jsr current_to_dp
.c709	a0 81		ldy #$81			ldy #Wh_Flags
.c70b	68		pla				pla
.c70c	11 10		ora ($10),y			ora (dp),y
.c70e	91 10		sta ($10),y			sta (dp),y
=13					CodeLen	.var *-XtPtr1
=$c710					Here1 = *	; remember here
>c701	0d					.byte CodeLen	;patch wh_CodeLength
.c710	60		rts				rts
>c711	43 6f 6d 70 69 6c 65 2d		Name0:	.text "Compile-only"	;  name of word as a string, ending at wh_NameLastChar
>c719	6f 6e 6c 79
=12					NameLength = *-Name0
=50845					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>c71d	2c					.byte (("Compile-only"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=30					LinkDisplacement = Nt0-WordListLink
>c71e	10					.byte WordFlags	;wh_Flags
>c71f	03					.byte 3	;wh_CodeLength
>c720	1e					  .byte LinkDisplacement	; offset to previous nt
=$c721					XtPtr1 ::= *
=50845					WordListLink ::= Nt0 ; remember the nt of this word for later
.c721	a9 04		lda #$04	Compile_Only:	lda #CO
.c723	d0 e0		bne $c705			bne SetFlag
=4					CodeLen	.var *-XtPtr1
=$c725					Here1 = *	; remember here
>c71f	04					.byte CodeLen	;patch wh_CodeLength
>c725	6e 65 76 65 72 2d 6e 61		Name0:	.text "never-native"	;  name of word as a string, ending at wh_NameLastChar
>c72d	74 69 76 65
=12					NameLength = *-Name0
=50865					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>c731	ac					.byte (("never-native"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=20					LinkDisplacement = Nt0-WordListLink
>c732	10					.byte WordFlags	;wh_Flags
>c733	03					.byte 3	;wh_CodeLength
>c734	14					  .byte LinkDisplacement	; offset to previous nt
=$c735					XtPtr1 ::= *
=50865					WordListLink ::= Nt0 ; remember the nt of this word for later
.c735	20 e7 cb	jsr $cbe7	Never_Native:	jsr current_to_dp
.c738	a0 81		ldy #$81			ldy #Wh_Flags
.c73a	b1 10		lda ($10),y			lda (dp),y
.c73c	09 10		ora #$10			ora #NN		; set NN flag
.c73e	29 df		and #$df			and #$ff-AN	; clear AN flag
.c740	91 10		sta ($10),y			sta (dp),y
=13					CodeLen	.var *-XtPtr1
=$c742					Here1 = *	; remember here
>c733	0d					.byte CodeLen	;patch wh_CodeLength
.c742	60		rts				rts
>c743	61 6c 77 61 79 73 2d 6e		Name0:	.text "always-native"	;  name of word as a string, ending at wh_NameLastChar
>c74b	61 74 69 76 65
=13					NameLength = *-Name0
=50896					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>c750	ad					.byte (("always-native"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=31					LinkDisplacement = Nt0-WordListLink
>c751	10					.byte WordFlags	;wh_Flags
>c752	03					.byte 3	;wh_CodeLength
>c753	1f					  .byte LinkDisplacement	; offset to previous nt
=$c754					XtPtr1 ::= *
=50896					WordListLink ::= Nt0 ; remember the nt of this word for later
.c754	20 e7 cb	jsr $cbe7	Always_Native:	jsr current_to_dp
.c757	a0 81		ldy #$81			ldy #Wh_Flags
.c759	b1 10		lda ($10),y			lda (dp),y
.c75b	09 20		ora #$20			ora #AN		; Make sure AN flag is set
.c75d	29 ef		and #$ef			and #$ff-NN	; and NN flag is clear.
.c75f	91 10		sta ($10),y			sta (dp),y
=13					CodeLen	.var *-XtPtr1
=$c761					Here1 = *	; remember here
>c752	0d					.byte CodeLen	;patch wh_CodeLength
.c761	60		rts				rts
>c762	61 6c 6c 6f 77 2d 6e 61		Name0:	.text "allow-native"	;  name of word as a string, ending at wh_NameLastChar
>c76a	74 69 76 65
=12					NameLength = *-Name0
=50926					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>c76e	ac					.byte (("allow-native"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=30					LinkDisplacement = Nt0-WordListLink
>c76f	10					.byte WordFlags	;wh_Flags
>c770	03					.byte 3	;wh_CodeLength
>c771	1e					  .byte LinkDisplacement	; offset to previous nt
=$c772					XtPtr1 ::= *
=50926					WordListLink ::= Nt0 ; remember the nt of this word for later
.c772	20 e7 cb	jsr $cbe7	Allow_Native:	jsr current_to_dp
.c775	a0 81		ldy #$81			ldy #Wh_Flags	; offset for status byte
.c777	b1 10		lda ($10),y			lda (dp),y
.c779	29 cf		and #$cf			and #$ff-NN-AN	; AN and NN flag is clear.
.c77b	91 10		sta ($10),y			sta (dp),y
=11					CodeLen	.var *-XtPtr1
=$c77d					Here1 = *	; remember here
>c770	0b					.byte CodeLen	;patch wh_CodeLength
.c77d	60		rts				rts
>c77e	6e 63 2d 6c 69 6d 69 74		Name0:	.text "nc-limit"	;  name of word as a string, ending at wh_NameLastChar
=8					NameLength = *-Name0
=50950					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>c786	88					.byte (("nc-limit"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=24					LinkDisplacement = Nt0-WordListLink
>c787	10					.byte WordFlags	;wh_Flags
>c788	03					.byte 3	;wh_CodeLength
>c789	18					  .byte LinkDisplacement	; offset to previous nt
=$c78a					XtPtr1 ::= *
=50950					WordListLink ::= Nt0 ; remember the nt of this word for later
.c78a	a9 02		lda #$02			lda #<nc_limit
.c78c	a0 03		ldy #$03			ldy #>nc_limit
.c78e	4c 2e c9	jmp $c92e			jmp PushYA
=7					CodeLen	.var *-XtPtr1
=$c791					Here1 = *	; remember here
>c788	07					.byte CodeLen	;patch wh_CodeLength
>c791	73 74 72 69 70 2d 75 6e		Name0:	.text "strip-underflow"	;  name of word as a string, ending at wh_NameLastChar
>c799	64 65 72 66 6c 6f 77
=15					NameLength = *-Name0
=50976					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>c7a0	ef					.byte (("strip-underflow"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=26					LinkDisplacement = Nt0-WordListLink
>c7a1	10					.byte WordFlags	;wh_Flags
>c7a2	03					.byte 3	;wh_CodeLength
>c7a3	1a					  .byte LinkDisplacement	; offset to previous nt
=$c7a4					XtPtr1 ::= *
=50976					WordListLink ::= Nt0 ; remember the nt of this word for later
.c7a4	a9 04		lda #$04			lda #<uf_strip
.c7a6	a0 03		ldy #$03			ldy #>uf_strip
.c7a8	4c 2e c9	jmp $c92e			jmp PushYA
=7					CodeLen	.var *-XtPtr1
=$c7ab					Here1 = *	; remember here
>c7a2	07					.byte CodeLen	;patch wh_CodeLength
>c7ab	70 6f 73 74 70 6f 6e 65		Name0:	.text "postpone"	;  name of word as a string, ending at wh_NameLastChar
=8					NameLength = *-Name0
=50995					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>c7b3	a8					.byte (("postpone"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=28					WordFlags ::= IM+CO+NN	; modifiable copy, remember for later
=19					LinkDisplacement = Nt0-WordListLink
>c7b4	1c					.byte WordFlags	;wh_Flags
>c7b5	03					.byte 3	;wh_CodeLength
>c7b6	13					  .byte LinkDisplacement	; offset to previous nt
=$c7b7					XtPtr1 ::= *
=50995					WordListLink ::= Nt0 ; remember the nt of this word for later
.c7b7					Postpone:
.c7b7	20 46 cc	jsr $cc46			jsr parse_name_check	; get name string
.c7ba	20 28 ce	jsr $ce28			jsr find_name_check	; lookup name
.c7bd	a0 81		ldy #$81			ldy #Wh_Flags		; IMMEDIATE word?
.c7bf	b1 14		lda ($14),y			lda (tmp1),y		;    using saved nt
.c7c1	29 08		and #$08			and #IM
.c7c3	f0 03		beq $c7c8			beq _not_immediate
.c7c5	4c 16 c8	jmp $c816			jmp Compile_Comma_NT	; compile it as if it was not IMMEDIATE
.c7c8					_not_immediate:
.c7c8	20 15 c9	jsr $c915			jsr LDYA_Immed_Comma		; compile LDA #; LDY # with nt of the word
.c7cb	a0 c8		ldy #$c8			ldy #>Compile_Comma_NT_YA	; compile COMPILE,
.c7cd	a9 19		lda #$19			lda #<Compile_Comma_NT_YA
.c7cf	4c 25 df	jmp $df25			jmp Jsr_Comma_YA
=27					CodeLen	.var *-XtPtr1
=$c7d2					Here1 = *	; remember here
>c7b5	1b					.byte CodeLen	;patch wh_CodeLength
>c7d2	52 65 63 75 72 73 65		Name0:	.text "Recurse"	;  name of word as a string, ending at wh_NameLastChar
=7					NameLength = *-Name0
=51033					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>c7d9	a7					.byte (("Recurse"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=28					WordFlags ::= CO+IM+NN	; modifiable copy, remember for later
=38					LinkDisplacement = Nt0-WordListLink
>c7da	1c					.byte WordFlags	;wh_Flags
>c7db	03					.byte 3	;wh_CodeLength
>c7dc	26					  .byte LinkDisplacement	; offset to previous nt
=$c7dd					XtPtr1 ::= *
=51033					WordListLink ::= Nt0 ; remember the nt of this word for later
.c7dd					Recurse:
.c7dd	a5 0e		lda $0e				lda WorkWord+0
.c7df	a4 0f		ldy $0f				ldy WorkWord+1
.c7e1	20 2e c9	jsr $c92e			jsr PushYA
.c7e4	24 0c		bit $0c				bit status		; does WorkWord contain xt or nt?
.c7e6	50 10		bvc $c7f8			bvc _xt
.c7e8	a0 81		ldy #$81			ldy #wh_Flags		; is it Always-Native ?
.c7ea	b1 0e		lda ($0e),y			lda (WorkWord),y
.c7ec	29 20		and #$20			and #AN
.c7ee	f0 05		beq $c7f5			beq _NotAn
.c7f0	a9 e5		lda #$e5			lda #$100+err_InvalidRecursion
.c7f2	20 dc c5	jsr $c5dc			jsr ThrowA
.c7f5					_NotAN:
.c7f5	20 3c cf	jsr $cf3c			jsr Name_To_Int		; convert nt to xt
.c7f8					_xt:
.c7f8	4c 22 df	jmp $df22			jmp Jsr_Comma		; compile JSR xt, return
=30					CodeLen	.var *-XtPtr1
=$c7fb					Here1 = *	; remember here
>c7db	1e					.byte CodeLen	;patch wh_CodeLength
>c7fb	43 6f 6d 70 69 6c 65 2c		Name0:	.text "Compile,"	;  name of word as a string, ending at wh_NameLastChar
=8					NameLength = *-Name0
=51075					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>c803	88					.byte (("Compile,"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=42					LinkDisplacement = Nt0-WordListLink
>c804	10					.byte WordFlags	;wh_Flags
>c805	03					.byte 3	;wh_CodeLength
>c806	2a					  .byte LinkDisplacement	; offset to previous nt
=$c807					XtPtr1 ::= *
=51075					WordListLink ::= Nt0 ; remember the nt of this word for later
.c807					Compile_Comma:
.c807	20 8a e1	jsr $e18a			jsr Dup			; ( xt xt )
.c80a	20 eb ce	jsr $ceeb			jsr Int_To_Name		; ( xt nt )	does a dictionary search, tmp1=nt
.c80d	e8		inx				inx			; drop nt
.c80e	e8		inx				inx
.c80f	a5 15		lda $15				lda tmp1+1
.c811	d0 0a		bne $c81d			bne Compile_Comma_NT_Tmp1
.c813	4c 22 df	jmp $df22			jmp Jsr_Comma		; compile jsr, return
.c816					Compile_Comma_NT:
.c816	20 62 c5	jsr $c562			jsr PopYA
.c819					Compile_Comma_NT_YA:
.c819	85 14		sta $14				sta tmp1+0		; tmp1= nt
.c81b	84 15		sty $15				sty tmp1+1
.c81d					Compile_Comma_NT_Tmp1:
.c81d	20 49 cf	jsr $cf49			jsr NameToIntTmp	; tmp2= xt
.c820	a5 16		lda $16				lda tmp2+0
.c822	a4 17		ldy $17				ldy tmp2+1
.c824	20 2e c9	jsr $c92e			jsr PushYA		; ( xt )
.c827	a0 82		ldy #$82			ldy #wh_CodeLength
.c829	b1 14		lda ($14),y			lda (tmp1),y
.c82b	20 5d c9	jsr $c95d			jsr PushZA		; ( xt u )
.c82e	a0 81		ldy #$81			ldy #Wh_Flags		; save word flags
.c830	b1 14		lda ($14),y			lda (tmp1),y
.c832	29 30		and #$30			and #ST
.c834	c9 30		cmp #$30			cmp #ST			; inline & strip RTS addr save/restore?
.c836	f0 2d		beq $c865			beq _strip
.c838	c9 10		cmp #$10			cmp #NN			; Never Native word?
.c83a	f0 12		beq $c84e			beq _jsr_opt
.c83c	c9 20		cmp #$20			cmp #AN			; Always Native word?
.c83e	f0 2f		beq $c86f			beq _inline
.c840	ad 03 03	lda $0303			lda nc_limit+1		; wordsize<=nc_limit?
.c843	d0 2a		bne $c86f			bne _inline
.c845	ad 02 03	lda $0302			lda nc_limit+0
.c848	d5 26		cmp $26,x			cmp DStack+0,x
.c84a	f0 02		beq $c84e			beq _jsr_opt
.c84c	b0 21		bcs $c86f			bcs _inline
.c84e					_jsr_opt:
.c84e	ad 04 03	lda $0304			lda uf_strip
.c851	f0 0d		beq $c860			beq _jsr
.c853	a0 81		ldy #$81			ldy #wh_Flags		; underflow strip & not stack strip?
.c855	b1 14		lda ($14),y			lda (tmp1),y
.c857	29 40		and #$40			and #UF
.c859	f0 05		beq $c860			beq _jsr
.c85b	a9 03		lda #$03			lda #3			;   strip the underflow check
.c85d	20 e7 db	jsr $dbe7			jsr Nos_Plus_A
.c860					_jsr:
.c860	e8		inx				inx			; Drop len
.c861	e8		inx				inx
.c862	4c 22 df	jmp $df22			jmp Jsr_Comma		; compile jsr, return
.c865					_strip:
.c865	a9 06		lda #$06			lda #6			;   Adjust xt: skip over the leading RTS addr save
.c867	20 e7 db	jsr $dbe7			jsr Nos_Plus_A
.c86a	a9 f4		lda #$f4			lda #$100-12		;   Adjust u: omit the leading RTS addr save & trailing RTS addr restore
.c86c	20 27 dc	jsr $dc27			jsr minus_a
.c86f					_inline:
.c86f	ad 04 03	lda $0304			lda uf_strip+0		; user wants underflow stripping?
.c872	f0 12		beq $c886			beq +
.c874	a0 81		ldy #$81			ldy #wh_Flags		; this word contains underflow checking?
.c876	b1 14		lda ($14),y			lda (tmp1),y
.c878	29 40		and #$40			and #UF
.c87a	f0 0a		beq $c886			beq +
.c87c	a9 03		lda #$03			lda #3			;   Adjust xt: Start after underflow check
.c87e	20 e7 db	jsr $dbe7			jsr Nos_Plus_A
.c881	a9 fd		lda #$fd			lda #$100-3		;   Adjust u: omit underflow check
.c883	20 27 dc	jsr $dc27			jsr minus_a
.c886					+
.c886	b5 26		lda $26,x			lda DStack+0,x		; compile code bytes
.c888	f0 0c		beq $c896			beq _copy_end
.c88a	a1 28		lda ($28,x)	_copy_loop:	lda (DStack+2,x)
.c88c	20 df de	jsr $dedf			jsr C_Comma_A
.c88f	20 42 dc	jsr $dc42			jsr NOS_One_Plus
.c892	d6 26		dec $26,x			dec DStack+0,x
.c894	d0 f4		bne $c88a			bne _copy_loop
.c896					_copy_end:
.c896	4c 04 d7	jmp $d704			jmp Two_drop
=146					CodeLen	.var *-XtPtr1
=$c899					Here1 = *	; remember here
>c805	92					.byte CodeLen	;patch wh_CodeLength
>c899	5b				Name0:	.text "["	;  name of word as a string, ending at wh_NameLastChar
=1					NameLength = *-Name0
=51226					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>c89a	61					.byte (("["[-1]&7)<<5)+NameLength	;wh_HashNameLen
=28					WordFlags ::= IM+CO+NN	; modifiable copy, remember for later
=151					LinkDisplacement = Nt0-WordListLink
>c89b	1c					.byte WordFlags	;wh_Flags
>c89c	03					.byte 3	;wh_CodeLength
>c89d	97					  .byte LinkDisplacement	; offset to previous nt
=$c89e					XtPtr1 ::= *
=51226					WordListLink ::= Nt0 ; remember the nt of this word for later
.c89e	a5 0a		lda $0a		Left_Bracket:	lda state+0		; Already in the interpret state?
.c8a0	d0 05		bne $c8a7			bne Left_Bracket_NoCheck
.c8a2	a9 69		lda #$69			lda #$100+err_AlreadyInterpreting
.c8a4	4c dc c5	jmp $c5dc			jmp ThrowA
.c8a7					Left_Bracket_NoCheck:
.c8a7	a9 00		lda #$00			lda #0
.c8a9	85 0a		sta $0a		Left_Bracket_3:	sta state+0
.c8ab	85 0b		sta $0b				sta state+1
=15					CodeLen	.var *-XtPtr1
=$c8ad					Here1 = *	; remember here
>c89c	0f					.byte CodeLen	;patch wh_CodeLength
.c8ad	60		rts				rts
>c8ae	5d				Name0:	.text "]"	;  name of word as a string, ending at wh_NameLastChar
=1					NameLength = *-Name0
=51247					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>c8af	a1					.byte (("]"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=24					WordFlags ::= IM+NN	; modifiable copy, remember for later
=21					LinkDisplacement = Nt0-WordListLink
>c8b0	18					.byte WordFlags	;wh_Flags
>c8b1	03					.byte 3	;wh_CodeLength
>c8b2	15					  .byte LinkDisplacement	; offset to previous nt
=$c8b3					XtPtr1 ::= *
=51247					WordListLink ::= Nt0 ; remember the nt of this word for later
.c8b3					Right_Bracket:
.c8b3	a5 0a		lda $0a				lda state+0		; Already in the compile state?
.c8b5	f0 05		beq $c8bc			beq +
.c8b7	a9 68		lda #$68			lda #$100+err_AlreadyCompiling ;   complain and quit
.c8b9	4c dc c5	jmp $c5dc			jmp ThrowA
.c8bc					+
.c8bc	a9 ff		lda #$ff			lda #$FF
.c8be	d0 e9		bne $c8a9			bne Left_Bracket_3
=13					CodeLen	.var *-XtPtr1
=$c8c0					Here1 = *	; remember here
>c8b1	0d					.byte CodeLen	;patch wh_CodeLength
>c8c0	4c 69 74 65 72 61 6c		Name0:	.text "Literal"	;  name of word as a string, ending at wh_NameLastChar
=7					NameLength = *-Name0
=51271					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>c8c7	87					.byte (("Literal"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=28					WordFlags ::= IM+CO+NN	; modifiable copy, remember for later
=24					LinkDisplacement = Nt0-WordListLink
>c8c8	1c					.byte WordFlags	;wh_Flags
>c8c9	03					.byte 3	;wh_CodeLength
>c8ca	18					  .byte LinkDisplacement	; offset to previous nt
=$c8cb					XtPtr1 ::= *
=51271					WordListLink ::= Nt0 ; remember the nt of this word for later
.c8cb					Literal:
.c8cb	20 8b c5	jsr $c58b			jsr underflow_1
.c8ce	20 d4 c8	jsr $c8d4			jsr LitCompile		; compile load regs, choose a runtime routine
.c8d1	4c 19 c8	jmp $c819			jmp Compile_Comma_NT_YA ; compile JSR runtime
=9					CodeLen	.var *-XtPtr1
=$c8d4					Here1 = *	; remember here
>c8c9	09					.byte CodeLen	;patch wh_CodeLength
.c8d4					LitCompile:
.c8d4	b5 27		lda $27,x			lda DStack+1,x		; hi byte zero?
.c8d6	f0 08		beq $c8e0			beq _ZByte
.c8d8	20 15 c9	jsr $c915			jsr ldya_immed_comma	; compile "ldy #; lda #" using TOS
.c8db	a9 aa		lda #$aa			lda #<(PushYA-wh_LinkNt-1) ; prepare for Compile_Comma_NT_YA or Jmp_Comma_NT_YA
.c8dd	a0 c8		ldy #$c8			ldy #>(PushYA-wh_LinkNt-1)
.c8df	60		rts				rts
.c8e0					_ZByte:
.c8e0	b4 26		ldy $26,x			ldy DStack+0,x		; is it 0 ?
.c8e2	f0 08		beq $c8ec			beq _zero
.c8e4	20 1c c9	jsr $c91c			jsr lda_immed_comma	; compile "lda #" using TOS
.c8e7	a9 d9		lda #$d9			lda #<(PushZA-wh_LinkNt-1) ; prepare for Jsr_Comma_YA or Jmp_Comma_YA
.c8e9	a0 c8		ldy #$c8			ldy #>(PushZA-wh_LinkNt-1)
.c8eb	60		rts				rts
.c8ec	e8		inx		_zero:		inx			; drop
.c8ed	e8		inx				inx
.c8ee	a9 e7		lda #$e7			lda #<(Zero-wh_LinkNt-1)	; prepare for Jsr_Comma_YA or Jmp_Comma_YA
.c8f0	a0 c8		ldy #$c8			ldy #>(Zero-wh_LinkNt-1)
.c8f2	60		rts				rts
>c8f3	32 4c 69 74 65 72 61 6c		Name0:	.text "2Literal"	;  name of word as a string, ending at wh_NameLastChar
=8					NameLength = *-Name0
=51323					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>c8fb	88					.byte (("2Literal"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=24					WordFlags ::= IM+NN	; modifiable copy, remember for later
=52					LinkDisplacement = Nt0-WordListLink
>c8fc	18					.byte WordFlags	;wh_Flags
>c8fd	03					.byte 3	;wh_CodeLength
>c8fe	34					  .byte LinkDisplacement	; offset to previous nt
=$c8ff					XtPtr1 ::= *
=51323					WordListLink ::= Nt0 ; remember the nt of this word for later
.c8ff					Two_literal:
.c8ff	20 9f c5	jsr $c59f			jsr underflow_2 ; check double number
.c902	20 ad e1	jsr $e1ad			jsr Swap
.c905	20 cb c8	jsr $c8cb			jsr Literal	; do lo cell
.c908	4c cb c8	jmp $c8cb			jmp Literal	; do hi cell
=12					CodeLen	.var *-XtPtr1
=$c90b					Here1 = *	; remember here
>c8fd	0c					.byte CodeLen	;patch wh_CodeLength
>c90b	4c 44 59 41 2e 23		Name0:	.text "LDYA.#"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=51345					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>c911	66					.byte (("LDYA.#"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=22					LinkDisplacement = Nt0-WordListLink
>c912	10					.byte WordFlags	;wh_Flags
>c913	03					.byte 3	;wh_CodeLength
>c914	16					  .byte LinkDisplacement	; offset to previous nt
=$c915					XtPtr1 ::= *
=51345					WordListLink ::= Nt0 ; remember the nt of this word for later
.c915					ldya_immed_comma:
.c915	a9 a0		lda #$a0			lda #$a0		; ldy #
.c917	b4 27		ldy $27,x			ldy DStack+1,x
.c919	20 f6 de	jsr $def6			jsr Comma_YA
.c91c					lda_immed_comma:
.c91c	a9 a9		lda #$a9			lda #$a9		; lda #
.c91e	20 df de	jsr $dedf			jsr C_Comma_A
.c921	4c dc de	jmp $dedc			jmp C_Comma
=15					CodeLen	.var *-XtPtr1
=$c924					Here1 = *	; remember here
>c913	0f					.byte CodeLen	;patch wh_CodeLength
>c924	50 75 73 68 59 41		Name0:	.text "PushYA"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=51370					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>c92a	26					.byte (("PushYA"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=0					WordFlags ::= 0	; modifiable copy, remember for later
=25					LinkDisplacement = Nt0-WordListLink
>c92b	00					.byte WordFlags	;wh_Flags
>c92c	03					.byte 3	;wh_CodeLength
>c92d	19					  .byte LinkDisplacement	; offset to previous nt
=$c92e					XtPtr1 ::= *
=51370					WordListLink ::= Nt0 ; remember the nt of this word for later
.c92e	ca		dex		PushYA:		dex
.c92f	ca		dex				dex
.c930	95 26		sta $26,x			sta DStack+0,x
.c932	94 27		sty $27,x			sty DStack+1,x
=6					CodeLen	.var *-XtPtr1
=$c934					Here1 = *	; remember here
>c92c	06					.byte CodeLen	;patch wh_CodeLength
.c934	60		rts				rts
>c935	54 72 75 65			Name0:	.text "True"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=51385					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>c939	a4					.byte (("True"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=0					WordFlags ::= 0	; modifiable copy, remember for later
=15					LinkDisplacement = Nt0-WordListLink
>c93a	00					.byte WordFlags	;wh_Flags
>c93b	03					.byte 3	;wh_CodeLength
>c93c	0f					  .byte LinkDisplacement	; offset to previous nt
=$c93d					XtPtr1 ::= *
=51385					WordListLink ::= Nt0 ; remember the nt of this word for later
.c93d	a9 ff		lda #$ff	True:		lda #$FF
.c93f	ca		dex		PushAA:		dex
.c940	ca		dex				dex
.c941	95 26		sta $26,x			sta DStack+0,x
.c943	95 27		sta $27,x			sta DStack+1,x
=8					CodeLen	.var *-XtPtr1
=$c945					Here1 = *	; remember here
>c93b	08					.byte CodeLen	;patch wh_CodeLength
.c945	60		rts				rts
>c946	46 61 6c 73 65			Name0:	.text "False"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=51403					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>c94b	a5					.byte (("False"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=18					LinkDisplacement = Nt0-WordListLink
>c94c	10					.byte WordFlags	;wh_Flags
>c94d	03					.byte 3	;wh_CodeLength
>c94e	12					  .byte LinkDisplacement	; offset to previous nt
=$c94f					XtPtr1 ::= *
=51403					WordListLink ::= Nt0 ; remember the nt of this word for later
.c94f	a9 00		lda #$00	False:		lda #0
.c951	f0 ec		beq $c93f			beq PushAA
=4					CodeLen	.var *-XtPtr1
=$c953					Here1 = *	; remember here
>c94d	04					.byte CodeLen	;patch wh_CodeLength
>c953	50 75 73 68 5a 41		Name0:	.text "PushZA"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=51417					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>c959	26					.byte (("PushZA"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=0					WordFlags ::= 0	; modifiable copy, remember for later
=14					LinkDisplacement = Nt0-WordListLink
>c95a	00					.byte WordFlags	;wh_Flags
>c95b	03					.byte 3	;wh_CodeLength
>c95c	0e					  .byte LinkDisplacement	; offset to previous nt
=$c95d					XtPtr1 ::= *
=51417					WordListLink ::= Nt0 ; remember the nt of this word for later
.c95d	ca		dex		PushZA:		dex
.c95e	ca		dex				dex			; check for overflow???
.c95f	95 26		sta $26,x			sta DStack+0,x
.c961	a9 00		lda #$00			lda #0
.c963	95 27		sta $27,x			sta DStack+1,x
=8					CodeLen	.var *-XtPtr1
=$c965					Here1 = *	; remember here
>c95b	08					.byte CodeLen	;patch wh_CodeLength
.c965	60		rts				rts
>c966	30				Name0:	.text "0"	;  name of word as a string, ending at wh_NameLastChar
=1					NameLength = *-Name0
=51431					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>c967	01					.byte (("0"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=14					LinkDisplacement = Nt0-WordListLink
>c968	10					.byte WordFlags	;wh_Flags
>c969	03					.byte 3	;wh_CodeLength
>c96a	0e					  .byte LinkDisplacement	; offset to previous nt
=$c96b					XtPtr1 ::= *
=51431					WordListLink ::= Nt0 ; remember the nt of this word for later
.c96b	a9 00		lda #$00	Zero:		lda #0
.c96d	f0 d0		beq $c93f			beq PushAA
=4					CodeLen	.var *-XtPtr1
=$c96f					Here1 = *	; remember here
>c969	04					.byte CodeLen	;patch wh_CodeLength
>c96f	31				Name0:	.text "1"	;  name of word as a string, ending at wh_NameLastChar
=1					NameLength = *-Name0
=51440					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>c970	21					.byte (("1"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=9					LinkDisplacement = Nt0-WordListLink
>c971	10					.byte WordFlags	;wh_Flags
>c972	03					.byte 3	;wh_CodeLength
>c973	09					  .byte LinkDisplacement	; offset to previous nt
=$c974					XtPtr1 ::= *
=51440					WordListLink ::= Nt0 ; remember the nt of this word for later
.c974	a9 01		lda #$01	One:		lda #1
.c976	d0 e5		bne $c95d			bne PushZA
=4					CodeLen	.var *-XtPtr1
=$c978					Here1 = *	; remember here
>c972	04					.byte CodeLen	;patch wh_CodeLength
>c978	32				Name0:	.text "2"	;  name of word as a string, ending at wh_NameLastChar
=1					NameLength = *-Name0
=51449					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>c979	41					.byte (("2"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=9					LinkDisplacement = Nt0-WordListLink
>c97a	10					.byte WordFlags	;wh_Flags
>c97b	03					.byte 3	;wh_CodeLength
>c97c	09					  .byte LinkDisplacement	; offset to previous nt
=$c97d					XtPtr1 ::= *
=51449					WordListLink ::= Nt0 ; remember the nt of this word for later
.c97d	a9 02		lda #$02	Two:		lda #2
.c97f	d0 dc		bne $c95d			bne PushZA
=4					CodeLen	.var *-XtPtr1
=$c981					Here1 = *	; remember here
>c97b	04					.byte CodeLen	;patch wh_CodeLength
>c981	42 6c				Name0:	.text "Bl"	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=51459					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>c983	82					.byte (("Bl"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=10					LinkDisplacement = Nt0-WordListLink
>c984	10					.byte WordFlags	;wh_Flags
>c985	03					.byte 3	;wh_CodeLength
>c986	0a					  .byte LinkDisplacement	; offset to previous nt
=$c987					XtPtr1 ::= *
=51459					WordListLink ::= Nt0 ; remember the nt of this word for later
.c987	a9 20		lda #$20	Bl:		lda #AscSP
.c989	d0 d2		bne $c95d			bne PushZA
=4					CodeLen	.var *-XtPtr1
=$c98b					Here1 = *	; remember here
>c985	04					.byte CodeLen	;patch wh_CodeLength
>c98b	3e 49 6e			Name0:	.text ">In"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=51470					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>c98e	c3					.byte ((">In"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=11					LinkDisplacement = Nt0-WordListLink
>c98f	10					.byte WordFlags	;wh_Flags
>c990	03					.byte 3	;wh_CodeLength
>c991	0b					  .byte LinkDisplacement	; offset to previous nt
=$c992					XtPtr1 ::= *
=51470					WordListLink ::= Nt0 ; remember the nt of this word for later
.c992	a9 08		lda #$08			lda #ToIn
.c994	4c 5d c9	jmp $c95d			jmp PushZA
=5					CodeLen	.var *-XtPtr1
=$c997					Here1 = *	; remember here
>c990	05					.byte CodeLen	;patch wh_CodeLength
>c997	53 74 61 74 65			Name0:	.text "State"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=51484					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>c99c	a5					.byte (("State"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=14					LinkDisplacement = Nt0-WordListLink
>c99d	10					.byte WordFlags	;wh_Flags
>c99e	03					.byte 3	;wh_CodeLength
>c99f	0e					  .byte LinkDisplacement	; offset to previous nt
=$c9a0					XtPtr1 ::= *
=51484					WordListLink ::= Nt0 ; remember the nt of this word for later
.c9a0	a9 0a		lda #$0a			lda #State
.c9a2	4c 5d c9	jmp $c95d			jmp PushZA
=5					CodeLen	.var *-XtPtr1
=$c9a5					Here1 = *	; remember here
>c99e	05					.byte CodeLen	;patch wh_CodeLength
>c9a5	64 70				Name0:	.text "dp"	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=51495					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>c9a7	02					.byte (("dp"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=11					LinkDisplacement = Nt0-WordListLink
>c9a8	10					.byte WordFlags	;wh_Flags
>c9a9	03					.byte 3	;wh_CodeLength
>c9aa	0b					  .byte LinkDisplacement	; offset to previous nt
=$c9ab					XtPtr1 ::= *
=51495					WordListLink ::= Nt0 ; remember the nt of this word for later
.c9ab	a9 10		lda #$10			lda #dp
.c9ad	4c 5d c9	jmp $c95d			jmp PushZA
=5					CodeLen	.var *-XtPtr1
=$c9b0					Here1 = *	; remember here
>c9a9	05					.byte CodeLen	;patch wh_CodeLength
>c9b0	54 6d 70 31			Name0:	.text "Tmp1"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=51508					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>c9b4	24					.byte (("Tmp1"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>c9b5	10					.byte WordFlags	;wh_Flags
>c9b6	03					.byte 3	;wh_CodeLength
>c9b7	0d					  .byte LinkDisplacement	; offset to previous nt
=$c9b8					XtPtr1 ::= *
=51508					WordListLink ::= Nt0 ; remember the nt of this word for later
.c9b8	a9 14		lda #$14			lda #tmp1
.c9ba	4c 5d c9	jmp $c95d			jmp PushZA
=5					CodeLen	.var *-XtPtr1
=$c9bd					Here1 = *	; remember here
>c9b6	05					.byte CodeLen	;patch wh_CodeLength
>c9bd	54 6d 70 32			Name0:	.text "Tmp2"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=51521					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>c9c1	44					.byte (("Tmp2"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>c9c2	10					.byte WordFlags	;wh_Flags
>c9c3	03					.byte 3	;wh_CodeLength
>c9c4	0d					  .byte LinkDisplacement	; offset to previous nt
=$c9c5					XtPtr1 ::= *
=51521					WordListLink ::= Nt0 ; remember the nt of this word for later
.c9c5	a9 16		lda #$16			lda #tmp2
.c9c7	4c 5d c9	jmp $c95d			jmp PushZA
=5					CodeLen	.var *-XtPtr1
=$c9ca					Here1 = *	; remember here
>c9c3	05					.byte CodeLen	;patch wh_CodeLength
>c9ca	54 6d 70 33			Name0:	.text "Tmp3"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=51534					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>c9ce	64					.byte (("Tmp3"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>c9cf	10					.byte WordFlags	;wh_Flags
>c9d0	03					.byte 3	;wh_CodeLength
>c9d1	0d					  .byte LinkDisplacement	; offset to previous nt
=$c9d2					XtPtr1 ::= *
=51534					WordListLink ::= Nt0 ; remember the nt of this word for later
.c9d2	a9 18		lda #$18			lda #tmp3
.c9d4	4c 5d c9	jmp $c95d			jmp PushZA
=5					CodeLen	.var *-XtPtr1
=$c9d7					Here1 = *	; remember here
>c9d0	05					.byte CodeLen	;patch wh_CodeLength
>c9d7	54 6d 70 34			Name0:	.text "Tmp4"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=51547					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>c9db	84					.byte (("Tmp4"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>c9dc	10					.byte WordFlags	;wh_Flags
>c9dd	03					.byte 3	;wh_CodeLength
>c9de	0d					  .byte LinkDisplacement	; offset to previous nt
=$c9df					XtPtr1 ::= *
=51547					WordListLink ::= Nt0 ; remember the nt of this word for later
.c9df	a9 1a		lda #$1a			lda #tmp4
.c9e1	4c 5d c9	jmp $c95d			jmp PushZA
=5					CodeLen	.var *-XtPtr1
=$c9e4					Here1 = *	; remember here
>c9dd	05					.byte CodeLen	;patch wh_CodeLength
>c9e4	54 6d 70 35			Name0:	.text "Tmp5"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=51560					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>c9e8	a4					.byte (("Tmp5"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>c9e9	10					.byte WordFlags	;wh_Flags
>c9ea	03					.byte 3	;wh_CodeLength
>c9eb	0d					  .byte LinkDisplacement	; offset to previous nt
=$c9ec					XtPtr1 ::= *
=51560					WordListLink ::= Nt0 ; remember the nt of this word for later
.c9ec	a9 1c		lda #$1c			lda #tmp5
.c9ee	4c 5d c9	jmp $c95d			jmp PushZA
=5					CodeLen	.var *-XtPtr1
=$c9f1					Here1 = *	; remember here
>c9ea	05					.byte CodeLen	;patch wh_CodeLength
>c9f1	54 6d 70 36			Name0:	.text "Tmp6"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=51573					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>c9f5	c4					.byte (("Tmp6"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>c9f6	10					.byte WordFlags	;wh_Flags
>c9f7	03					.byte 3	;wh_CodeLength
>c9f8	0d					  .byte LinkDisplacement	; offset to previous nt
=$c9f9					XtPtr1 ::= *
=51573					WordListLink ::= Nt0 ; remember the nt of this word for later
.c9f9	a9 1e		lda #$1e			lda #tmp6
.c9fb	4c 5d c9	jmp $c95d			jmp PushZA
=5					CodeLen	.var *-XtPtr1
=$c9fe					Here1 = *	; remember here
>c9f7	05					.byte CodeLen	;patch wh_CodeLength
>c9fe	53 4c 69 74 65 72 61 6c		Name0:	.text "SLiteral"	;  name of word as a string, ending at wh_NameLastChar
=8					NameLength = *-Name0
=51590					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>ca06	88					.byte (("SLiteral"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=92					WordFlags ::= CO+IM+UF+NN	; modifiable copy, remember for later
=17					LinkDisplacement = Nt0-WordListLink
>ca07	5c					.byte WordFlags	;wh_Flags
>ca08	03					.byte 3	;wh_CodeLength
>ca09	11					  .byte LinkDisplacement	; offset to previous nt
=$ca0a					XtPtr1 ::= *
=51590					WordListLink ::= Nt0 ; remember the nt of this word for later
.ca0a					SLiteral:
.ca0a	20 9f c5	jsr $c59f			jsr underflow_2
.ca0d	20 2d ca	jsr $ca2d			jsr SLiteral_Start	; compile header
.ca10	4c 21 ca	jmp $ca21			jmp _Move_Test
.ca13	a1 2a		lda ($2a,x)	_Move_Loop:	lda (DStack+4,x)
.ca15	20 df de	jsr $dedf			jsr C_Comma_A
.ca18	f6 2a		inc $2a,x			inc DStack+4,x
.ca1a	d0 02		bne $ca1e			bne +
.ca1c	f6 2b		inc $2b,x			inc DStack+5,x
.ca1e					+
.ca1e	20 1e dc	jsr $dc1e			jsr NOS_One_Minus
.ca21	b5 28		lda $28,x	_Move_Test:	lda DStack+2,x
.ca23	15 29		ora $29,x			ora DStack+3,x
.ca25	d0 ec		bne $ca13			bne _Move_Loop
.ca27	20 3a ca	jsr $ca3a			jsr SLiteral_End
.ca2a	4c 04 d7	jmp $d704			jmp Two_Drop		; clean up and leave
=35					CodeLen	.var *-XtPtr1
=$ca2d					Here1 = *	; remember here
>ca08	23					.byte CodeLen	;patch wh_CodeLength
.ca2d					SLiteral_Start:
.ca2d	a9 4b		lda #$4b			lda #<SLiteral_runtime	; compile JSR SLiteral_Runtime
.ca2f	a0 ca		ldy #$ca			ldy #>SLiteral_runtime
.ca31	20 25 df	jsr $df25			jsr Jsr_Comma_YA
.ca34	20 04 dc	jsr $dc04			jsr Here		; push addr of start of JMP
.ca37	4c 3b df	jmp $df3b			jmp Jmp_Comma_YA	; compile JMP around string (dummy addr)
.ca3a					SLiteral_End:
.ca3a	20 37 dc	jsr $dc37			jsr One_Plus
.ca3d	a5 00		lda $00				lda cp+0		; Update the address of the jump to HERE.
.ca3f	81 26		sta ($26,x)			sta (DStack+0,x)
.ca41	20 37 dc	jsr $dc37			jsr One_Plus
.ca44	a5 01		lda $01				lda cp+1
.ca46	81 26		sta ($26,x)			sta (DStack+0,x)
.ca48	e8		inx				inx			; drop herej
.ca49	e8		inx				inx
.ca4a	60		rts				rts
.ca4b					SLiteral_Runtime:
.ca4b	86 16		stx $16				stx tmp2	; save data stack index
.ca4d	ba		tsx				tsx
.ca4e	bd 01 01	lda $0101,x	SLiteral_Run2:	lda RStack+1,x	; tmp1= RTS addr
.ca51	85 14		sta $14				sta tmp1+0
.ca53	bd 02 01	lda $0102,x			lda RStack+2,x
.ca56	85 15		sta $15				sta tmp1+1
.ca58	a6 16		ldx $16				ldx tmp2	; restore data stack index
.ca5a	ca		dex				dex		; push string addr
.ca5b	ca		dex				dex
.ca5c	18		clc				clc
.ca5d	a5 14		lda $14				lda tmp1+0
.ca5f	69 04		adc #$04			adc #3+1	;   just after the following JMP + correcting for JSR behavior
.ca61	95 26		sta $26,x			sta DStack+0,x
.ca63	a5 15		lda $15				lda tmp1+1
.ca65	69 00		adc #$00			adc #0
.ca67	95 27		sta $27,x			sta DStack+1,x
.ca69	ca		dex				dex		; push string length
.ca6a	ca		dex				dex
.ca6b	38		sec				sec
.ca6c	a0 02		ldy #$02			ldy #2		;   = string_end - string_addr
.ca6e	b1 14		lda ($14),y			lda (tmp1),y
.ca70	f5 28		sbc $28,x			sbc DStack+2,x
.ca72	95 26		sta $26,x			sta DStack+0,x
.ca74	c8		iny				iny
.ca75	b1 14		lda ($14),y			lda (tmp1),y
.ca77	f5 29		sbc $29,x			sbc DStack+3,x
.ca79	95 27		sta $27,x			sta DStack+1,x
.ca7b	60		rts				rts
>ca7c	2e 22				Name0:	.text '."'	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=51710					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>ca7e	42					.byte (('."'[-1]&7)<<5)+NameLength	;wh_HashNameLen
=28					WordFlags ::= CO+IM+NN	; modifiable copy, remember for later
=120					LinkDisplacement = Nt0-WordListLink
>ca7f	1c					.byte WordFlags	;wh_Flags
>ca80	03					.byte 3	;wh_CodeLength
>ca81	78					  .byte LinkDisplacement	; offset to previous nt
=$ca82					XtPtr1 ::= *
=51710					WordListLink ::= Nt0 ; remember the nt of this word for later
.ca82					Dot_quote:
.ca82	20 9d ca	jsr $ca9d			jsr S_Quote		; compile the string literal
.ca85	a0 df		ldy #$df			ldy #>Type		; compile: print string
.ca87	a9 f1		lda #$f1			lda #<Type
.ca89	4c 25 df	jmp $df25			jmp Jsr_Comma_YA
=10					CodeLen	.var *-XtPtr1
=$ca8c					Here1 = *	; remember here
>ca80	0a					.byte CodeLen	;patch wh_CodeLength
>ca8c	53 5c 22			Name0:	.text 'S\"'	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=51727					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>ca8f	43					.byte (('S\"'[-1]&7)<<5)+NameLength	;wh_HashNameLen
=24					WordFlags ::= IM+NN	; modifiable copy, remember for later
=17					LinkDisplacement = Nt0-WordListLink
>ca90	18					.byte WordFlags	;wh_Flags
>ca91	03					.byte 3	;wh_CodeLength
>ca92	11					  .byte LinkDisplacement	; offset to previous nt
=$ca93					XtPtr1 ::= *
=51727					WordListLink ::= Nt0 ; remember the nt of this word for later
.ca93					S_Backslash_Quote:
.ca93	a9 ff		lda #$ff			lda #$ff	; Do handle escaped chars.
.ca95	d0 08		bne $ca9f			bne S_Quote_start
=4					CodeLen	.var *-XtPtr1
=$ca97					Here1 = *	; remember here
>ca91	04					.byte CodeLen	;patch wh_CodeLength
>ca97	53 22				Name0:	.text 'S"'	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=51737					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>ca99	42					.byte (('S"'[-1]&7)<<5)+NameLength	;wh_HashNameLen
=24					WordFlags ::= IM+NN	; modifiable copy, remember for later
=10					LinkDisplacement = Nt0-WordListLink
>ca9a	18					.byte WordFlags	;wh_Flags
>ca9b	03					.byte 3	;wh_CodeLength
>ca9c	0a					  .byte LinkDisplacement	; offset to previous nt
=$ca9d					XtPtr1 ::= *
=51737					WordListLink ::= Nt0 ; remember the nt of this word for later
.ca9d					S_Quote:
.ca9d	a9 00		lda #$00			lda #0		; Don't handle escaped chars.
.ca9f					S_Quote_start:
.ca9f	48		pha				pha			; save "handle escaped chars" flag
.caa0	a5 0a		lda $0a				lda state		; compiling?
.caa2	f0 06		beq $caaa			beq _15
.caa4	20 2d ca	jsr $ca2d			jsr SLiteral_Start	; compile SLiteral header
.caa7	4c ad ca	jmp $caad			jmp _19
.caaa	20 04 dc	jsr $dc04	_15:		jsr Here		; remember start addr
.caad					_19:
.caad	68		pla				pla			; init t2 flags
.caae	20 5d c9	jsr $c95d			jsr PushZA
.cab1	20 6b c9	jsr $c96b			jsr Zero		; init t3 flags
.cab4					_savechars_loop:
.cab4	a5 08		lda $08				lda toin+0		; LSB
.cab6	c5 06		cmp $06				cmp ciblen+0
.cab8	a5 09		lda $09				lda toin+1		; MSB
.caba	e5 07		sbc $07				sbc ciblen+1
.cabc	90 10		bcc $cace			bcc _input_fine		; input buffer empty?
.cabe	20 29 d4	jsr $d429			jsr Refill		; Refill it  ( -- f )
.cac1	b5 26		lda $26,x			lda DStack+0,x		; Check result of refill.
.cac3	d0 05		bne $caca			bne +
.cac5	a9 6b		lda #$6b			lda #$100+err_refill	; Something when wrong with refill.
.cac7	4c dc c5	jmp $c5dc			jmp ThrowA
.caca	e8		inx		+		inx			; Drop the refill flag
.cacb	e8		inx				inx
.cacc	d0 e6		bne $cab4			bne _savechars_loop	; jump back up to the empty check, just in
.cace					_input_fine:
.cace	18		clc				clc			; tmp1= A= the char at Cib+ToIn
.cacf	a5 04		lda $04				lda cib+0
.cad1	85 14		sta $14				sta tmp1+0
.cad3	a5 05		lda $05				lda cib+1
.cad5	65 09		adc $09				adc toin+1
.cad7	85 15		sta $15				sta tmp1+1
.cad9	a4 08		ldy $08				ldy ToIn
.cadb	b1 14		lda ($14),y			lda (tmp1),y
.cadd	85 14		sta $14				sta tmp1
.cadf	e6 08		inc $08				inc toin+0		; Move on to the next character.
.cae1	d0 02		bne $cae5			bne +
.cae3	e6 09		inc $09				inc toin+1
.cae5					+
.cae5	b4 28		ldy $28,x			ldy DStack+2,x		; handling escaped characters?
.cae7	30 03		bmi $caec			bmi +
.cae9	4c 8f cb	jmp $cb8f			jmp _regular_char
.caec					+
.caec	b4 29		ldy $29,x			ldy DStack+3,x  		; already seen the backslash?
.caee	30 03		bmi $caf3			bmi +
.caf0	4c 85 cb	jmp $cb85			jmp _not_escaped
.caf3					+
.caf3	84 15		sty $15				sty tmp1+1
.caf5	24 15		bit $15				bit tmp1+1		; in the middle of a \x sequence ?
.caf7	70 25		bvs $cb1e			bvs _check_esc_chars
.caf9	a9 01		lda #$01			lda #1
.cafb	24 15		bit $15				bit tmp1+1
.cafd	d0 11		bne $cb10			bne _esc_x_second_digit
.caff	c8		iny				iny			; Adjust flag for second digit next time.
.cb00	94 29		sty $29,x			sty DStack+3,x
.cb02	a5 14		lda $14				lda tmp1+0		; Get the char again.
.cb04	20 b2 cb	jsr $cbb2			jsr convert_hex_value	; Convert to hex
.cb07	0a		asl a				asl			; This is the upper nybble, so move it up.
.cb08	0a		asl a				asl
.cb09	0a		asl a				asl
.cb0a	0a		asl a				asl
.cb0b	95 26		sta $26,x			sta DStack+0,x		; Save it for later.
.cb0d	4c 96 cb	jmp $cb96			jmp _next_character
.cb10					_esc_x_second_digit:
.cb10	a9 00		lda #$00			lda #0			; Clear the escaped character flag
.cb12	95 29		sta $29,x			sta DStack+3,x		;   (because we are handling it right here)
.cb14	a5 14		lda $14				lda tmp1+0		; Convert to hex
.cb16	20 b2 cb	jsr $cbb2			jsr convert_hex_value
.cb19	15 26		ora $26,x			ora DStack+0,x		; combine with value in t3
.cb1b	4c 93 cb	jmp $cb93			jmp _save_character
.cb1e					_check_esc_chars:
.cb1e	a0 00		ldy #$00			ldy #0
.cb20	94 29		sty $29,x			sty DStack+3,x
.cb22	a8		tay				tay
.cb23	a9 07		lda #$07			lda #AscBELL	      ; BEL (ASCII value 7)
.cb25	c0 61		cpy #$61			cpy #'a'
.cb27	f0 6a		beq $cb93			beq _save_character
.cb29	a9 08		lda #$08			lda #AscBS	      ; Backspace (ASCII value 8)
.cb2b	c0 62		cpy #$62			cpy #'b'
.cb2d	f0 64		beq $cb93			beq _save_character
.cb2f	a9 1b		lda #$1b			lda #AscESC	      ; ESC (ASCII value 27)
.cb31	c0 65		cpy #$65			cpy #'e'
.cb33	f0 5e		beq $cb93			beq _save_character
.cb35	a9 0c		lda #$0c			lda #AscFF	      ; FF (ASCII value 12)
.cb37	c0 66		cpy #$66			cpy #'f'
.cb39	f0 58		beq $cb93			beq _save_character
.cb3b	a9 0a		lda #$0a			lda #AscLF	      ; LF (ASCII value 10)
.cb3d	c0 6c		cpy #$6c			cpy #'l'
.cb3f	f0 52		beq $cb93			beq _save_character
.cb41	c0 6e		cpy #$6e			cpy #'n'
.cb43	f0 4e		beq $cb93			beq _save_character
.cb45	c0 6d		cpy #$6d			cpy #'m'
.cb47	d0 09		bne $cb52			bne +
.cb49	a9 0d		lda #$0d			lda #AscCR		; CR/LF pair (ASCII values 13, 10)
.cb4b	20 df de	jsr $dedf			jsr C_Comma_A
.cb4e	a9 0a		lda #$0a			lda #AscLF
.cb50	d0 41		bne $cb93			bne _save_character
.cb52					+
.cb52	a9 22		lda #$22			lda #AscDQuote		; Double quote (ASCII value 34)
.cb54	c0 71		cpy #$71			cpy #'q'
.cb56	f0 3b		beq $cb93			beq _save_character
.cb58	c0 22		cpy #$22			cpy #AscDQuote
.cb5a	f0 37		beq $cb93			beq _save_character
.cb5c	a9 0d		lda #$0d			lda #AscCR		; CR (ASCII value 13)
.cb5e	c0 72		cpy #$72			cpy #'r'
.cb60	f0 31		beq $cb93			beq _save_character
.cb62	a9 09		lda #$09			lda #AscHT		; Horizontal TAB (ASCII value 9)
.cb64	c0 74		cpy #$74			cpy #'t'
.cb66	f0 2b		beq $cb93			beq _save_character
.cb68	a9 0b		lda #$0b			lda #AscVT		; Vertical TAB (ASCII value 11)
.cb6a	c0 76		cpy #$76			cpy #'v'
.cb6c	f0 25		beq $cb93			beq _save_character
.cb6e	a9 00		lda #$00			lda #0			; NULL (ASCII value 0)
.cb70	c0 7a		cpy #$7a			cpy #'z'
.cb72	f0 1f		beq $cb93			beq _save_character
.cb74					_check_esc_x:
.cb74	c0 78		cpy #$78			cpy #'x'
.cb76	d0 06		bne $cb7e			bne +
.cb78	a9 be		lda #$be			lda #$BE	; Clear bits 6 and 0
.cb7a	95 29		sta $29,x			sta DStack+3,x
.cb7c	d0 18		bne $cb96			bne _next_character
.cb7e					+
.cb7e	a9 5c		lda #$5c			lda #AscBackslash	; Backslash (ASCII value 92)
.cb80	c0 5c		cpy #$5c			cpy #AscBackslash
.cb82	f0 0f		beq $cb93			beq _save_character
.cb84	98		tya				tya
.cb85					_not_escaped:
.cb85	c9 5c		cmp #$5c			cmp #$5C	; The backslash char
.cb87	d0 06		bne $cb8f			bne _regular_char
.cb89	a9 ff		lda #$ff			lda #$FF
.cb8b	95 29		sta $29,x			sta DStack+3,x
.cb8d	d0 07		bne $cb96			bne _next_character
.cb8f					_regular_char:
.cb8f	c9 22		cmp #$22			cmp #AscDQuote		; ASCII for "
.cb91	f0 06		beq $cb99			beq _found_string_end
.cb93					_save_character:
.cb93	20 df de	jsr $dedf			jsr C_Comma_A		; compile this character into the dictionary
.cb96					_next_character:
.cb96	4c b4 ca	jmp $cab4			jmp _savechars_loop
.cb99					_found_string_end:
.cb99	e8		inx				inx			; Drop t3
.cb9a	e8		inx				inx
.cb9b	a5 0a		lda $0a				lda state		; What happens next depends on the state (which is bad, but
.cb9d	d0 0e		bne $cbad			bne _cmpl		; that's the way it works at the moment).
.cb9f	38		sec				sec			; TOS= length of string = Here - start_addr
.cba0	a5 00		lda $00				lda cp+0
.cba2	f5 28		sbc $28,x			sbc DStack+2,x
.cba4	95 26		sta $26,x			sta DStack+0,x		;   LSB
.cba6	a5 01		lda $01				lda cp+1
.cba8	f5 29		sbc $29,x			sbc DStack+3,x
.cbaa	95 27		sta $27,x			sta DStack+1,x		;   MSB
.cbac	60		rts				rts			; ( startaddr u )
.cbad					_cmpl:
.cbad	e8		inx				inx			; Drop t2
.cbae	e8		inx				inx
.cbaf	4c 3a ca	jmp $ca3a			jmp SLiteral_End	; ( jmpaddr )
=277					CodeLen	.var *-XtPtr1
=$ff					CodeLen	 .var $ff
=$cbb2					Here1 = *	; remember here
>ca9b	ff					.byte CodeLen	;patch wh_CodeLength
.cbb2					convert_hex_value:
.cbb2	c9 41		cmp #$41			cmp #'A'
.cbb4	90 05		bcc $cbbb			bcc _digit
.cbb6	29 1f		and #$1f	_alpha:		and #$1F		; Make it uppercase.
.cbb8	69 08		adc #$08			adc #9-1		; gives value 10 for 'A'
.cbba	60		rts				rts
.cbbb					_digit:
.cbbb	e9 2f		sbc #$2f			sbc #'0'-1
.cbbd	60		rts				rts
>cbbe	4c 61 74 65 73 74 58 74		Name0:	.text "LatestXt"	;  name of word as a string, ending at wh_NameLastChar
=8					NameLength = *-Name0
=52038					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>cbc6	88					.byte (("LatestXt"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=301					LinkDisplacement = Nt0-WordListLink
=$11						  WordFlags ::= WordFlags | FP
>cbc7	11					.byte WordFlags	;wh_Flags
>cbc8	03					.byte 3	;wh_CodeLength
>cbc9	19 ca					  .word WordListLink
=$cbcb					XtPtr1 ::= *
=52038					WordListLink ::= Nt0 ; remember the nt of this word for later
.cbcb	20 dd cb	jsr $cbdd	LatestXt:	jsr LatestNt	; ( nt )
.cbce	4c 3c cf	jmp $cf3c			jmp Name_To_Int	; ( xt )
=6					CodeLen	.var *-XtPtr1
=$cbd1					Here1 = *	; remember here
>cbc8	06					.byte CodeLen	;patch wh_CodeLength
>cbd1	4c 61 74 65 73 74 4e 74		Name0:	.text "LatestNt"	;  name of word as a string, ending at wh_NameLastChar
=8					NameLength = *-Name0
=52057					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>cbd9	88					.byte (("LatestNt"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=19					LinkDisplacement = Nt0-WordListLink
>cbda	10					.byte WordFlags	;wh_Flags
>cbdb	03					.byte 3	;wh_CodeLength
>cbdc	13					  .byte LinkDisplacement	; offset to previous nt
=$cbdd					XtPtr1 ::= *
=52057					WordListLink ::= Nt0 ; remember the nt of this word for later
.cbdd	20 e7 cb	jsr $cbe7	LatestNt:	jsr current_to_dp
.cbe0	a5 10		lda $10				lda dp+0
.cbe2	a4 11		ldy $11				ldy dp+1
.cbe4	4c 2e c9	jmp $c92e			jmp PushYA
=10					CodeLen	.var *-XtPtr1
=$cbe7					Here1 = *	; remember here
>cbdb	0a					.byte CodeLen	;patch wh_CodeLength
.cbe7					current_to_dp:
.cbe7	ad 10 03	lda $0310			lda CurrentV		; A= current wordlist wid
.cbea	0a		asl a				asl			; dp= wordlists[A]
.cbeb	a8		tay				tay
.cbec	b9 12 03	lda $0312,y			lda WordlistsV+0,y
.cbef	85 10		sta $10				sta dp+0
.cbf1	b9 13 03	lda $0313,y			lda WordlistsV+1,y
.cbf4	85 11		sta $11				sta dp+1
.cbf6	60		rts				rts
.cbf7					dp_to_current:
.cbf7	ad 10 03	lda $0310			lda CurrentV		; A= current wordlist wid
.cbfa	0a		asl a		                asl			; wordlists[A]=dp
.cbfb	a8		tay		                tay
.cbfc	a5 10		lda $10		                lda dp+0
.cbfe	99 12 03	sta $0312,y			sta WordlistsV+0,y
.cc01	a5 11		lda $11		                lda dp+1
.cc03	99 13 03	sta $0313,y	                sta WordlistsV+1,y
.cc06	60		rts		                rts
>cc07	50 61 72 73 65 2d 4e 61		Name0:	.text "Parse-Name"	;  name of word as a string, ending at wh_NameLastChar
>cc0f	6d 65
=10					NameLength = *-Name0
=52113					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>cc11	aa					.byte (("Parse-Name"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=56					LinkDisplacement = Nt0-WordListLink
>cc12	10					.byte WordFlags	;wh_Flags
>cc13	03					.byte 3	;wh_CodeLength
>cc14	38					  .byte LinkDisplacement	; offset to previous nt
=$cc15					XtPtr1 ::= *
=52113					WordListLink ::= Nt0 ; remember the nt of this word for later
.cc15					Parse_Name:
.cc15	a5 04		lda $04				lda cib+0		; tmp2= cib+(toin & $ff00)
.cc17	85 16		sta $16				sta tmp2+0
.cc19	18		clc				clc
.cc1a	a5 05		lda $05				lda cib+1
.cc1c	65 09		adc $09				adc toin+1
.cc1e	85 17		sta $17				sta tmp2+1
.cc20	a4 08		ldy $08				ldy toin+0		; Y= toin & $00ff
.cc22					_skip_loop:
.cc22	c4 06		cpy $06				cpy ciblen+0		; more chars left?
.cc24	a5 09		lda $09				lda toin+1
.cc26	e5 07		sbc $07				sbc ciblen+1
.cc28	b0 11		bcs $cc3b			bcs _empty_line
.cc2a	b1 16		lda ($16),y			lda (tmp2),y		; get cib[toin]
.cc2c	c9 21		cmp #$21			cmp #AscSP+1		; is_whitespace
.cc2e	b0 10		bcs $cc40			bcs _char_found
.cc30	c8		iny				iny			; increment toin
.cc31	84 08		sty $08				sty toin+0
.cc33	d0 ed		bne $cc22			bne _skip_loop
.cc35	e6 09		inc $09				inc toin+1
.cc37	e6 17		inc $17				inc tmp2+1
.cc39	d0 e7		bne $cc22			bne _skip_loop
.cc3b					_empty_line:
.cc3b	ca		dex				dex			; junk address
.cc3c	ca		dex				dex
.cc3d	4c 6b c9	jmp $c96b			jmp Zero		; length=0
.cc40					_char_found:
.cc40	20 87 c9	jsr $c987			jsr Bl			; push delimiter char
.cc43	4c 5c cc	jmp $cc5c			jmp Parse
=49					CodeLen	.var *-XtPtr1
=$cc46					Here1 = *	; remember here
>cc13	31					.byte CodeLen	;patch wh_CodeLength
.cc46					parse_name_check:
.cc46	20 15 cc	jsr $cc15			jsr parse_name		; get character from string
.cc49	b5 26		lda $26,x			lda DStack+0,x		; empty string?
.cc4b	f0 01		beq $cc4e			beq _empty
.cc4d	60		rts				rts
.cc4e	a9 f3		lda #$f3	_empty:		lda #$100+err_UndefinedWord	; complain & abort
.cc50	4c dc c5	jmp $c5dc			jmp ThrowA
>cc53	50 61 72 73 65			Name0:	.text "Parse"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=52184					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>cc58	a5					.byte (("Parse"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=71					LinkDisplacement = Nt0-WordListLink
>cc59	10					.byte WordFlags	;wh_Flags
>cc5a	03					.byte 3	;wh_CodeLength
>cc5b	47					  .byte LinkDisplacement	; offset to previous nt
=$cc5c					XtPtr1 ::= *
=52184					WordListLink ::= Nt0 ; remember the nt of this word for later
.cc5c	20 47 c5	jsr $c547	Parse:		jsr PopA		; pop c (check for underflow)
.cc5f	85 1c		sta $1c		Parse_A:	sta tmp5		; save delimiter
.cc61	ca		dex				dex			; alloc space for addr
.cc62	ca		dex				dex
.cc63	ca		dex				dex			; alloc space for length
.cc64	ca		dex				dex
.cc65	18		clc				clc			; addr= cib+toin
.cc66	a5 08		lda $08				lda toin+0
.cc68	65 04		adc $04				adc cib+0
.cc6a	95 28		sta $28,x			sta DStack+2,x
.cc6c	a5 09		lda $09				lda toin+1
.cc6e	65 05		adc $05				adc cib+1
.cc70	95 29		sta $29,x			sta DStack+3,x
.cc72	a4 08		ldy $08				ldy toin+0		; Y= toin & $00ff
.cc74	84 14		sty $14				sty tmp1+0
.cc76	a5 04		lda $04				lda cib+0		; tmp2= cib + (toin & $ff00)
.cc78	85 16		sta $16				sta tmp2+0
.cc7a	18		clc				clc
.cc7b	a5 09		lda $09				lda toin+1		; tmp1= toin
.cc7d	85 15		sta $15				sta tmp1+1
.cc7f	65 05		adc $05				adc cib+1
.cc81	85 17		sta $17				sta tmp2+1
.cc83	a9 00		lda #$00			lda #0		; Initialize the offset we use to adjust EOL or found delimiter
.cc85	85 1d		sta $1d				sta tmp5+1
.cc87					_loop:
.cc87	c4 06		cpy $06				cpy ciblen+0		; end of string?
.cc89	a5 09		lda $09				lda toin+1
.cc8b	e5 07		sbc $07				sbc ciblen+1
.cc8d	b0 1d		bcs $ccac			bcs _eol
.cc8f	a5 1c		lda $1c				lda tmp5+0		; get delimiter
.cc91	c9 20		cmp #$20			cmp #AscSP		; is it whitespace?
.cc93	d0 08		bne $cc9d			bne _not_whitespace
.cc95	b1 16		lda ($16),y			lda (tmp2),y		; get cib[toin]
.cc97	c9 21		cmp #$21			cmp #AscSP+1		; we're looking for all whitespace
.cc99	90 0f		bcc $ccaa			bcc _found_delimiter
.cc9b	b0 04		bcs $cca1			bcs _not_delimiter
.cc9d	d1 16		cmp ($16),y	_not_whitespace: cmp (tmp2),y		; compare delimter to cib[toin]
.cc9f	f0 09		beq $ccaa			beq _found_delimiter
.cca1					_not_delimiter:
.cca1	c8		iny				iny			; next character
.cca2	d0 e3		bne $cc87			bne _loop
.cca4	e6 09		inc $09				inc toin+1
.cca6	e6 17		inc $17				inc tmp2+1
.cca8	d0 dd		bne $cc87			bne _loop
.ccaa					_found_delimiter:
.ccaa	e6 1d		inc $1d				inc tmp5+1
.ccac					_eol:
.ccac	38		sec				sec			; length = toin - tmp1
.ccad	98		tya				tya
.ccae	e5 14		sbc $14				sbc tmp1+0
.ccb0	95 26		sta $26,x			sta DStack+0,x
.ccb2	a5 09		lda $09				lda toin+1
.ccb4	e5 15		sbc $15				sbc tmp1+1
.ccb6	95 27		sta $27,x			sta DStack+1,x
.ccb8	18		clc				clc			; toin = toin + delimiter_offset
.ccb9	98		tya				tya
.ccba	65 1d		adc $1d				adc tmp5+1
.ccbc	85 08		sta $08				sta toin+0
.ccbe	90 02		bcc $ccc2			bcc +
.ccc0	e6 09		inc $09				inc toin+1
.ccc2					+
=102					CodeLen	.var *-XtPtr1
=$ccc2					Here1 = *	; remember here
>cc5a	66					.byte CodeLen	;patch wh_CodeLength
.ccc2	60		rts				rts
>ccc3	45 78 65 63 75 74 65 2d		Name0:	.text "Execute-Parsing"	;  name of word as a string, ending at wh_NameLastChar
>cccb	50 61 72 73 69 6e 67
=15					NameLength = *-Name0
=52306					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>ccd2	ef					.byte (("Execute-Parsing"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=122					LinkDisplacement = Nt0-WordListLink
>ccd3	10					.byte WordFlags	;wh_Flags
>ccd4	03					.byte 3	;wh_CodeLength
>ccd5	7a					  .byte LinkDisplacement	; offset to previous nt
=$ccd6					XtPtr1 ::= *
=52306					WordListLink ::= Nt0 ; remember the nt of this word for later
.ccd6					Execute_parsing:
.ccd6	20 a4 c5	jsr $c5a4			jsr underflow_3
.ccd9	20 a8 d5	jsr $d5a8			jsr Input_To_R		; save existing input for later
.ccdc	20 90 e0	jsr $e090			jsr Not_Rot		; -ROT ( xt addr u )
.ccdf	20 62 c5	jsr $c562			jsr PopYA		; TOS is new ciblen
.cce2	85 06		sta $06				sta ciblen+0
.cce4	84 07		sty $07				sty ciblen+1
.cce6	20 62 c5	jsr $c562			jsr PopYA		; NOS is new cib
.cce9	85 04		sta $04				sta cib+0
.cceb	84 05		sty $05				sty cib+1
.cced	a9 00		lda #$00			lda #0
.ccef	85 08		sta $08				sta toin+0		; Set >IN to zero
.ccf1	85 09		sta $09				sta toin+1
.ccf3	20 2f e0	jsr $e02f			jsr Execute
.ccf6	20 c9 d5	jsr $d5c9			jsr R_To_Input		; restore
=35					CodeLen	.var *-XtPtr1
=$ccf9					Here1 = *	; remember here
>ccd4	23					.byte CodeLen	;patch wh_CodeLength
.ccf9	60		rts				rts
>ccfa	53 6f 75 72 63 65		Name0:	.text "Source"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=52352					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>cd00	a6					.byte (("Source"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=46					LinkDisplacement = Nt0-WordListLink
>cd01	10					.byte WordFlags	;wh_Flags
>cd02	03					.byte 3	;wh_CodeLength
>cd03	2e					  .byte LinkDisplacement	; offset to previous nt
=$cd04					XtPtr1 ::= *
=52352					WordListLink ::= Nt0 ; remember the nt of this word for later
.cd04					Source:
.cd04	a5 04		lda $04				lda cib+0	; push address
.cd06	a4 05		ldy $05				ldy cib+1
.cd08	20 2e c9	jsr $c92e			jsr PushYA
.cd0b	a5 06		lda $06				lda ciblen+0	; push size, return
.cd0d	a4 07		ldy $07				ldy ciblen+1
.cd0f	4c 2e c9	jmp $c92e			jmp PushYA
=14					CodeLen	.var *-XtPtr1
=$cd12					Here1 = *	; remember here
>cd02	0e					.byte CodeLen	;patch wh_CodeLength
>cd12	53 6f 75 72 63 65 2d 49		Name0:	.text "Source-Id"	;  name of word as a string, ending at wh_NameLastChar
>cd1a	64
=9					NameLength = *-Name0
=52379					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>cd1b	89					.byte (("Source-Id"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=27					LinkDisplacement = Nt0-WordListLink
>cd1c	10					.byte WordFlags	;wh_Flags
>cd1d	03					.byte 3	;wh_CodeLength
>cd1e	1b					  .byte LinkDisplacement	; offset to previous nt
=$cd1f					XtPtr1 ::= *
=52379					WordListLink ::= Nt0 ; remember the nt of this word for later
.cd1f	a5 02		lda $02		Source_Id:	lda insrc+0
.cd21	a4 03		ldy $03				ldy insrc+1
.cd23	4c 2e c9	jmp $c92e			jmp PushYA
=7					CodeLen	.var *-XtPtr1
=$cd26					Here1 = *	; remember here
>cd1d	07					.byte CodeLen	;patch wh_CodeLength
>cd26	45 78 69 74			Name0:	.text "Exit"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=52394					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>cd2a	84					.byte (("Exit"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=36					WordFlags ::= AN+CO	; modifiable copy, remember for later
=15					LinkDisplacement = Nt0-WordListLink
>cd2b	24					.byte WordFlags	;wh_Flags
>cd2c	03					.byte 3	;wh_CodeLength
>cd2d	0f					  .byte LinkDisplacement	; offset to previous nt
=$cd2e					XtPtr1 ::= *
=52394					WordListLink ::= Nt0 ; remember the nt of this word for later
.cd2e					Exit:
.cd2e	60		rts				rts		; keep before WordEnd so it gets inlined
=1					CodeLen	.var *-XtPtr1
=$cd2f					Here1 = *	; remember here
>cd2c	01					.byte CodeLen	;patch wh_CodeLength
>cd2f	3b				Name0:	.text ";"	;  name of word as a string, ending at wh_NameLastChar
=1					NameLength = *-Name0
=52400					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>cd30	61					.byte ((";"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=28					WordFlags ::= CO+IM+NN	; modifiable copy, remember for later
=6					LinkDisplacement = Nt0-WordListLink
>cd31	1c					.byte WordFlags	;wh_Flags
>cd32	03					.byte 3	;wh_CodeLength
>cd33	06					  .byte LinkDisplacement	; offset to previous nt
=$cd34					XtPtr1 ::= *
=52400					WordListLink ::= Nt0 ; remember the nt of this word for later
.cd34					Semicolon:
.cd34	20 9e c8	jsr $c89e			jsr Left_Bracket	; switch to interpret state
.cd37	24 0c		bit $0c				bit status		; is this a : word or a :NONAME word?
.cd39	70 0c		bvs $cd47			bvs _colonword
.cd3b	a9 60		lda #$60			lda #$60		; compile an RTS
.cd3d	20 df de	jsr $dedf			jsr C_Comma_A
.cd40	a5 0e		lda $0e				lda WorkWord+0		; push xt, return
.cd42	a4 0f		ldy $0f				ldy WorkWord+1
.cd44	4c 2e c9	jmp $c92e			jmp PushYA
.cd47					_colonword:
.cd47	10 1a		bpl $cd63			bpl _new_word	; Bit 7 is clear = new word
.cd49	a5 0e		lda $0e				lda WorkWord+0		; push our nt
.cd4b	a4 0f		ldy $0f				ldy WorkWord+1
.cd4d	20 88 cf	jsr $cf88			jsr Name_To_String_YA	; get our name string
.cd50	a9 7b		lda #$7b			lda #<str_redefined	; string "redefined"
.cd52	a0 ec		ldy #$ec			ldy #>str_redefined
.cd54	20 0d e0	jsr $e00d			jsr Print_ASCIIZ_YA_no_lf
.cd57	20 f1 df	jsr $dff1			jsr Type		; print the ofWordEnding word.
.cd5a	20 e5 df	jsr $dfe5			jsr Space
.cd5d	a9 7f		lda #$7f			lda #$ff-%10000000
.cd5f	25 0c		and $0c				and status
.cd61	85 0c		sta $0c				sta status
.cd63					_new_word:
.cd63	20 b5 d2	jsr $d2b5			jsr Header_Link		; finish linking into current dictionary
.cd66	20 6e cd	jsr $cd6e			jsr adjust_z		; fix word length
.cd69	a9 60		lda #$60			lda #$60		; compile an RTS
.cd6b	4c df de	jmp $dedf			jmp C_Comma_A
=58					CodeLen	.var *-XtPtr1
=$cd6e					Here1 = *	; remember here
>cd32	3a					.byte CodeLen	;patch wh_CodeLength
.cd6e					adjust_z:
.cd6e	a0 81		ldy #$81			ldy #wh_Flags		; tmp1= xt
.cd70	b1 10		lda ($10),y			lda (dp),y
.cd72	29 03		and #$03			and #FP+DB
.cd74	18		clc				clc
.cd75	69 84		adc #$84			adc #wh_LinkNt+1
.cd77	65 10		adc $10				adc dp+0
.cd79	85 14		sta $14				sta tmp1+0
.cd7b	a9 00		lda #$00			lda #0
.cd7d	65 11		adc $11				adc dp+1
.cd7f	85 15		sta $15				sta tmp1+1
.cd81	38		sec				sec			; length= cp-xt
.cd82	a5 00		lda $00				lda cp+0
.cd84	e5 14		sbc $14				sbc tmp1+0
.cd86	a8		tay				tay
.cd87	a5 01		lda $01				lda cp+1
.cd89	e5 15		sbc $15				sbc tmp1+1
.cd8b	f0 0c		beq $cd99			beq _short		; length > $ff ?
.cd8d	a0 81		ldy #$81			ldy #Wh_Flags		; make it NN
.cd8f	b1 10		lda ($10),y			lda (dp),y
.cd91	29 df		and #$df			and #$ff-AN
.cd93	09 10		ora #$10			ora #NN
.cd95	91 10		sta ($10),y			sta (dp),y
.cd97	a0 ff		ldy #$ff			ldy #$ff		; set max length for header
.cd99	98		tya		_short:		tya			; fill in length in header
.cd9a	a0 82		ldy #$82			ldy #Wh_CodeLength
.cd9c	91 10		sta ($10),y			sta (dp),y
.cd9e	60		rts				rts
>cd9f	3a				Name0:	.text ":"	;  name of word as a string, ending at wh_NameLastChar
=1					NameLength = *-Name0
=52512					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>cda0	41					.byte ((":"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=112					LinkDisplacement = Nt0-WordListLink
>cda1	10					.byte WordFlags	;wh_Flags
>cda2	03					.byte 3	;wh_CodeLength
>cda3	70					  .byte LinkDisplacement	; offset to previous nt
=$cda4					XtPtr1 ::= *
=52512					WordListLink ::= Nt0 ; remember the nt of this word for later
.cda4					Colon:
.cda4	20 b3 c8	jsr $c8b3			jsr Right_Bracket	; switch to compile state
.cda7	a5 0c		lda $0c				lda status
.cda9	09 40		ora #$40			ora #%01000000	; tell ";" and RECURSE that WorkWord contains nt
.cdab	09 80		ora #$80			ora #%10000000	; Tell Header_Build not to print warning for duplicate name.
.cdad	85 0c		sta $0c				sta status
.cdaf	4c c0 d2	jmp $d2c0			jmp Header_Build	; compile word header (but don't link into wordlist)
=14					CodeLen	.var *-XtPtr1
=$cdb2					Here1 = *	; remember here
>cda2	0e					.byte CodeLen	;patch wh_CodeLength
>cdb2	3a 4e 6f 4e 61 6d 65		Name0:	.text ":NoName"	;  name of word as a string, ending at wh_NameLastChar
=7					NameLength = *-Name0
=52537					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>cdb9	a7					.byte ((":NoName"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=25					LinkDisplacement = Nt0-WordListLink
>cdba	10					.byte WordFlags	;wh_Flags
>cdbb	03					.byte 3	;wh_CodeLength
>cdbc	19					  .byte LinkDisplacement	; offset to previous nt
=$cdbd					XtPtr1 ::= *
=52537					WordListLink ::= Nt0 ; remember the nt of this word for later
.cdbd					Colon_NoName:
.cdbd	20 b3 c8	jsr $c8b3			jsr Right_Bracket	; switch to compile state
.cdc0	a9 bf		lda #$bf			lda #$ff-%01000000	; tell ";" and RECURSE that WorkWord contains xt
.cdc2	25 0c		and $0c				and status
.cdc4	85 0c		sta $0c				sta status
.cdc6	a5 00		lda $00				lda cp+0
.cdc8	85 0e		sta $0e				sta WorkWord+0
.cdca	a5 01		lda $01				lda cp+1
.cdcc	85 0f		sta $0f				sta WorkWord+1
=17					CodeLen	.var *-XtPtr1
=$cdce					Here1 = *	; remember here
>cdbb	11					.byte CodeLen	;patch wh_CodeLength
.cdce	60		rts				rts
>cdcf	27				Name0:	.text "'"	;  name of word as a string, ending at wh_NameLastChar
=1					NameLength = *-Name0
=52560					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>cdd0	e1					.byte (("'"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=23					LinkDisplacement = Nt0-WordListLink
>cdd1	10					.byte WordFlags	;wh_Flags
>cdd2	03					.byte 3	;wh_CodeLength
>cdd3	17					  .byte LinkDisplacement	; offset to previous nt
=$cdd4					XtPtr1 ::= *
=52560					WordListLink ::= Nt0 ; remember the nt of this word for later
.cdd4	20 da cd	jsr $cdda	Tick:		jsr Tick_Nt
.cdd7	4c 3c cf	jmp $cf3c			jmp Name_To_Int	; ( nt -- xt )
=6					CodeLen	.var *-XtPtr1
=$cdda					Here1 = *	; remember here
>cdd2	06					.byte CodeLen	;patch wh_CodeLength
.cdda	20 46 cc	jsr $cc46	Tick_Nt:	jsr parse_name_check	; ( -- addr u )
.cddd	4c 28 ce	jmp $ce28			jmp find_name_check	; ( addr u -- nt )
>cde0	5b 27 5d			Name0:	.text "[']"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=52579					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>cde3	a3					.byte (("[']"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=28					WordFlags ::= CO+IM+NN	; modifiable copy, remember for later
=19					LinkDisplacement = Nt0-WordListLink
>cde4	1c					.byte WordFlags	;wh_Flags
>cde5	03					.byte 3	;wh_CodeLength
>cde6	13					  .byte LinkDisplacement	; offset to previous nt
=$cde7					XtPtr1 ::= *
=52579					WordListLink ::= Nt0 ; remember the nt of this word for later
.cde7	20 d4 cd	jsr $cdd4	Bracket_Tick:	jsr Tick
.cdea	4c cb c8	jmp $c8cb			jmp Literal
=6					CodeLen	.var *-XtPtr1
=$cded					Here1 = *	; remember here
>cde5	06					.byte CodeLen	;patch wh_CodeLength
>cded	46 69 6e 64 2d 4e 61 6d		Name0:	.text "Find-Name"	;  name of word as a string, ending at wh_NameLastChar
>cdf5	65
=9					NameLength = *-Name0
=52598					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>cdf6	a9					.byte (("Find-Name"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=19					LinkDisplacement = Nt0-WordListLink
>cdf7	10					.byte WordFlags	;wh_Flags
>cdf8	03					.byte 3	;wh_CodeLength
>cdf9	13					  .byte LinkDisplacement	; offset to previous nt
=$cdfa					XtPtr1 ::= *
=52598					WordListLink ::= Nt0 ; remember the nt of this word for later
.cdfa					Find_Name:
.cdfa	20 35 ce	jsr $ce35			jsr swl_prepare 	; setup for search
.cdfd	ca		dex				dex
.cdfe	ca		dex				dex			; ( ? )
.cdff	a9 ff		lda #$ff			lda #$ff		; for each entry in search order
.ce01	95 27		sta $27,x			sta DStack+1,x
.ce03	f6 27		inc $27,x	_wordlist_next:	inc DStack+1,x		; step to next search order entry
.ce05	b4 27		ldy $27,x			ldy DStack+1,x
.ce07	cc 2a 03	cpy $032a			cpy Num_OrderV		; at end of list?
.ce0a	90 06		bcc $ce12			bcc _nextS
.ce0c	d0 15		bne $ce23			bne _fail
.ce0e	a9 03		lda #$03			lda #wid_Root		; also try root wordlist
.ce10	d0 03		bne $ce15			bne _nextA
.ce12	b9 2b 03	lda $032b,y	_nextS:		lda Search_OrderV,y	; A= search_order[Y]  get wordlist ID
.ce15	20 5e ce	jsr $ce5e	_nextA:		jsr swl_search_wordlist
.ce18	f0 e9		beq $ce03			beq _wordlist_next
.ce1a	a5 14		lda $14				lda tmp1+0		; return nt
.ce1c	a4 15		ldy $15				ldy tmp1+1
.ce1e	95 26		sta $26,x	_exit:		sta DStack+0,x
.ce20	94 27		sty $27,x			sty DStack+1,x
.ce22	60		rts				rts			; ( ? )
.ce23	a9 00		lda #$00	_fail:		lda #0			; return 0
.ce25	a8		tay				tay
.ce26	f0 f6		beq $ce1e			beq _exit
=46					CodeLen	.var *-XtPtr1
=$ce28					Here1 = *	; remember here
>cdf8	2e					.byte CodeLen	;patch wh_CodeLength
.ce28					find_name_check:
.ce28	20 fa cd	jsr $cdfa			jsr Find_Name
.ce2b	b5 27		lda $27,x			lda DStack+1,x		; check that we found a word
.ce2d	f0 01		beq $ce30			beq _NotFound
.ce2f	60		rts				rts
.ce30	a9 f3		lda #$f3	_NotFound:	lda #$100+err_UndefinedWord ; complain & quit
.ce32	4c dc c5	jmp $c5dc			jmp ThrowA
.ce35					swl_prepare:
.ce35	20 9f c5	jsr $c59f			jsr underflow_2
.ce38	38		sec				sec			; A= 0 - name start offset
.ce39	b5 26		lda $26,x			lda DStack+0,x
.ce3b	e9 80		sbc #$80			sbc #wh_NameLastChar+1
.ce3d	75 28		adc $28,x			adc DStack+2,x		; tmp2= pattern nt
.ce3f	85 16		sta $16				sta tmp2+0
.ce41	a9 ff		lda #$ff			lda #$ff
.ce43	75 29		adc $29,x			adc DStack+3,x
.ce45	85 17		sta $17				sta tmp2+1
.ce47	a9 7f		lda #$7f			lda #wh_NameLastChar	; tmp4+0= starting name char index -1
.ce49	38		sec				sec
.ce4a	f5 26		sbc $26,x			sbc DStack+0,x
.ce4c	85 1a		sta $1a				sta tmp4+0
.ce4e	a0 7f		ldy #$7f			ldy #wh_NameLastChar	; tmp3+0= wh_HashNameLength
.ce50	b1 16		lda ($16),y			lda (tmp2),y
.ce52	0a		asl a				asl a
.ce53	0a		asl a				asl a
.ce54	0a		asl a				asl a
.ce55	0a		asl a				asl a
.ce56	0a		asl a				asl a
.ce57	15 26		ora $26,x			ora DStack+0,x
.ce59	85 18		sta $18				sta tmp3+0
.ce5b	4c 04 d7	jmp $d704			jmp Two_Drop		; Drop addr & u
.ce5e					swl_search_wordlist:
.ce5e	86 19		stx $19				stx tmp3+1		; save data stack index
.ce60	0a		asl a				asl			; tmp1 = up->wordlists[A]
.ce61	a8		tay				tay
.ce62	be 12 03	ldx $0312,y			ldx WordlistsV+0,y
.ce65	b9 13 03	lda $0313,y			lda WordlistsV+1,y
.ce68	d0 15		bne $ce7f			bne _word_3		;   not end-of-list?
.ce6a	08		php		_rts:		php
.ce6b	a6 19		ldx $19				ldx tmp3+1		; restore data stack index
.ce6d	28		plp				plp
.ce6e	60		rts				rts			; Z= end_of_list
.ce6f					_word_next:
.ce6f	a0 81		ldy #$81			ldy #wh_Flags		; what kind of LinkNt?
.ce71	b1 14		lda ($14),y			lda (tmp1),y
.ce73	a0 83		ldy #$83			ldy #wh_LinkNt
.ce75	29 01		and #$01			and #FP
.ce77	f0 0e		beq $ce87			beq _LinkShort
.ce79	b1 14		lda ($14),y	_LinkLong:	lda (tmp1),y		; tmp1= tmp1->Wh_LinkNt_word
.ce7b	aa		tax				tax
.ce7c	c8		iny				iny
.ce7d	b1 14		lda ($14),y			lda (tmp1),y
.ce7f	85 15		sta $15		_word_3:	sta tmp1+1
.ce81	86 14		stx $14				stx tmp1+0
.ce83	d0 0d		bne $ce92			bne _Test
.ce85	f0 e3		beq $ce6a			beq _rts
.ce87	a5 14		lda $14		_LinkShort:	lda tmp1+0		; tmp1 -= tmp1->wh_LinkNt offset byte
.ce89	38		sec				sec
.ce8a	f1 14		sbc ($14),y			sbc (tmp1),y
.ce8c	85 14		sta $14				sta tmp1+0
.ce8e	b0 02		bcs $ce92			bcs +
.ce90	c6 15		dec $15				dec tmp1+1
.ce92					+
.ce92	a0 80		ldy #$80	_Test:		ldy #Wh_HashNameLen	; Are hash & name length the same?
.ce94	b1 14		lda ($14),y			lda (tmp1),y
.ce96	c5 18		cmp $18				cmp tmp3+0
.ce98	d0 d5		bne $ce6f			bne _word_next
.ce9a	a4 1a		ldy $1a				ldy tmp4+0		; Y= index of 1st char -1
.ce9c	c8		iny		_char_next:	iny			; to next char
.ce9d	30 cb		bmi $ce6a			bmi _rts		; end of string?
.ce9f	b1 16		lda ($16),y			lda (tmp2),y		; char of pattern name
.cea1	51 14		eor ($14),y			eor (tmp1),y		; char of this word name
.cea3	f0 f7		beq $ce9c			beq _char_next		;   exact match?
.cea5	c9 20		cmp #$20			cmp #$20		;   only a case mismatch?
.cea7	d0 c6		bne $ce6f			bne _word_next
.cea9	b1 16		lda ($16),y			lda (tmp2),y		;   verify it is alpha char
.ceab	29 df		and #$df			and #$df
.cead	e9 41		sbc #$41			sbc #'A'
.ceaf	c9 1a		cmp #$1a			cmp #'Z'-'A'+1
.ceb1	90 e9		bcc $ce9c			bcc _char_next
.ceb3	b0 ba		bcs $ce6f			bcs _word_next
>ceb5	46 69 6e 64			Name0:	.text "Find"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=52793					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>ceb9	84					.byte (("Find"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=195					LinkDisplacement = Nt0-WordListLink
>ceba	10					.byte WordFlags	;wh_Flags
>cebb	03					.byte 3	;wh_CodeLength
>cebc	c3					  .byte LinkDisplacement	; offset to previous nt
=$cebd					XtPtr1 ::= *
=52793					WordListLink ::= Nt0 ; remember the nt of this word for later
.cebd					Find:
.cebd	20 8a e1	jsr $e18a			jsr Dup			; Save caddr in case conversion fails, check underflow
.cec0	20 5b c3	jsr $c35b			jsr Count		; Convert counted string address to modern format
.cec3	20 fa cd	jsr $cdfa			jsr Find_Name		; ( caddr nt | 0 ) tmp1=nt
.cec6	b5 27		lda $27,x			lda DStack+1,x		; word found?
.cec8	d0 01		bne $cecb			bne _found_word
.ceca	60		rts				rts			; ( caddr 0 )
.cecb					_found_word:
.cecb	20 5f db	jsr $db5f			jsr Nip			; ( nt )
.cece	20 3c cf	jsr $cf3c			jsr Name_To_Int		; ( xt ) tmp1=nt
.ced1	a0 81		ldy #$81			ldy #Wh_Flags		; immediate?
.ced3	b1 14		lda ($14),y			lda (tmp1),y
.ced5	29 08		and #$08			and #IM
.ced7	d0 03		bne $cedc			bne _immediate
.ced9	4c 3d c9	jmp $c93d			jmp True		; not immediate, return ( xt -1 )
.cedc	4c 74 c9	jmp $c974	_immediate:	jmp One			; immediate, return ( xt 1 )
=34					CodeLen	.var *-XtPtr1
=$cedf					Here1 = *	; remember here
>cebb	22					.byte CodeLen	;patch wh_CodeLength
>cedf	49 6e 74 3e 4e 61 6d 65		Name0:	.text "Int>Name"	;  name of word as a string, ending at wh_NameLastChar
=8					NameLength = *-Name0
=52839					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>cee7	a8					.byte (("Int>Name"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=46					LinkDisplacement = Nt0-WordListLink
>cee8	10					.byte WordFlags	;wh_Flags
>cee9	03					.byte 3	;wh_CodeLength
>ceea	2e					  .byte LinkDisplacement	; offset to previous nt
=$ceeb					XtPtr1 ::= *
=52839					WordListLink ::= Nt0 ; remember the nt of this word for later
.ceeb	20 8b c5	jsr $c58b	Int_To_Name:	jsr underflow_1
.ceee	a9 fe		lda #$fe			lda #$100-2		; for each wordlist
.cef0	85 19		sta $19				sta tmp3+1
.cef2					_wordlist_next:
.cef2	a4 19		ldy $19				ldy tmp3+1		; get next wordlist index
.cef4	c8		iny				iny
.cef5	c8		iny				iny
.cef6	84 19		sty $19				sty tmp3+1
.cef8	c0 0c		cpy #$0c			cpy #(Num_OrderV-WordlistsV)/2
.cefa	b0 2b		bcs $cf27			bcs _fail
.cefc	b9 12 03	lda $0312,y			lda WordlistsV+0,y
.ceff	85 14		sta $14				sta tmp1+0
.cf01	b9 13 03	lda $0313,y			lda WordlistsV+1,y
.cf04	85 15		sta $15				sta tmp1+1
.cf06	d0 07		bne $cf0f			bne _calc
.cf08	f0 e8		beq $cef2			beq _wordlist_next
.cf0a	20 95 82	jsr $8295	_word_next:	jsr LinkNext		; step to next word
.cf0d	f0 e3		beq $cef2			beq _wordlist_next
.cf0f	20 49 cf	jsr $cf49	_calc:		jsr NameToIntTmp	; tmp2= xt
.cf12	a5 16		lda $16				lda tmp2+0
.cf14	d5 26		cmp $26,x			cmp DStack+0,x		;  match?
.cf16	d0 f2		bne $cf0a			bne _word_next
.cf18	a5 17		lda $17				lda tmp2+1
.cf1a	d5 27		cmp $27,x			cmp DStack+1,x
.cf1c	d0 ec		bne $cf0a			bne _word_next
.cf1e	a5 14		lda $14				lda tmp1+0
.cf20	95 26		sta $26,x			sta DStack+0,x
.cf22	a5 15		lda $15				lda tmp1+1
.cf24	95 27		sta $27,x			sta DStack+1,x
.cf26	60		rts				rts			; return P.Z=0
.cf27					_fail:
.cf27	a9 00		lda #$00			lda #0			; return a zero to indicate that we didn't find it.
.cf29	95 26		sta $26,x			sta DStack+0,x
.cf2b	95 27		sta $27,x			sta DStack+1,x
.cf2d	85 15		sta $15				sta tmp1+1
.cf2f	60		rts				rts			; return P.Z=1
=69					CodeLen	.var *-XtPtr1
=$cf30					Here1 = *	; remember here
>cee9	45					.byte CodeLen	;patch wh_CodeLength
>cf30	4e 61 6d 65 3e 49 6e 74		Name0:	.text "Name>Int"	;  name of word as a string, ending at wh_NameLastChar
=8					NameLength = *-Name0
=52920					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>cf38	88					.byte (("Name>Int"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=81					LinkDisplacement = Nt0-WordListLink
>cf39	10					.byte WordFlags	;wh_Flags
>cf3a	03					.byte 3	;wh_CodeLength
>cf3b	51					  .byte LinkDisplacement	; offset to previous nt
=$cf3c					XtPtr1 ::= *
=52920					WordListLink ::= Nt0 ; remember the nt of this word for later
.cf3c	20 6d c5	jsr $c56d	Name_To_Int:	jsr PopTmp1
.cf3f	20 49 cf	jsr $cf49	Name_To_Int_T:	jsr NameToIntTmp
.cf42	a5 16		lda $16				lda tmp2+0
.cf44	a4 17		ldy $17				ldy tmp2+1
.cf46	4c 2e c9	jmp $c92e			jmp PushYA
=13					CodeLen	.var *-XtPtr1
=$cf49					Here1 = *	; remember here
>cf3a	0d					.byte CodeLen	;patch wh_CodeLength
.cf49					NameToIntTmp:
.cf49	a0 81		ldy #$81			ldy #wh_Flags
.cf4b	b1 14		lda ($14),y			lda (tmp1),y
.cf4d	29 02		and #$02			and #DB			; has XT ptr?
.cf4f	d0 12		bne $cf63			bne _HasXtPtr
.cf51	b1 14		lda ($14),y			lda (tmp1),y		; A= header length
.cf53	29 03		and #$03			and #DB+FP
.cf55	18		clc				clc
.cf56	69 84		adc #$84			adc #wh_LinkNt+1
.cf58	65 14		adc $14				adc tmp1+0		; TOS=tmp1+A
.cf5a	85 16		sta $16				sta tmp2+0
.cf5c	a9 00		lda #$00			lda #0
.cf5e	65 15		adc $15				adc tmp1+1
.cf60	85 17		sta $17				sta tmp2+1
.cf62	60		rts				rts
.cf63	b1 14		lda ($14),y	_HasXtPtr:	lda (tmp1),y		; get wh_Flags again
.cf65	a0 84		ldy #$84			ldy #wh_LinkNt+1
.cf67	29 01		and #$01			and #FP			; has long LinkNt ?
.cf69	f0 01		beq $cf6c			beq _short
.cf6b	c8		iny				iny			;   skip extra byte
.cf6c	b1 14		lda ($14),y	_short:		lda (tmp1),y		; tmp2= xt pointer
.cf6e	85 16		sta $16				sta tmp2+0
.cf70	c8		iny				iny
.cf71	b1 14		lda ($14),y			lda (tmp1),y
.cf73	85 17		sta $17				sta tmp2+1
.cf75	60		rts				rts
>cf76	4e 61 6d 65 3e 53 74 72		Name0:	.text "Name>String"	;  name of word as a string, ending at wh_NameLastChar
>cf7e	69 6e 67
=11					NameLength = *-Name0
=52993					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>cf81	eb					.byte (("Name>String"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=73					LinkDisplacement = Nt0-WordListLink
>cf82	10					.byte WordFlags	;wh_Flags
>cf83	03					.byte 3	;wh_CodeLength
>cf84	49					  .byte LinkDisplacement	; offset to previous nt
=$cf85					XtPtr1 ::= *
=52993					WordListLink ::= Nt0 ; remember the nt of this word for later
.cf85	20 62 c5	jsr $c562	Name_To_String:	jsr PopYA
.cf88					Name_To_String_YA:
.cf88	85 14		sta $14				sta tmp1+0		; tmp1= nt
.cf8a	84 15		sty $15				sty tmp1+1
.cf8c	20 2e c9	jsr $c92e			jsr PushYA		; ( nt )
.cf8f	a0 80		ldy #$80			ldy #Wh_HashNameLen	; A= name length
.cf91	b1 14		lda ($14),y			lda (tmp1),y
.cf93	29 1f		and #$1f			and #wh_NameLengthMask
.cf95	48		pha				pha			; save string length
.cf96	49 ff		eor #$ff			eor #$ff
.cf98	38		sec				sec
.cf99	69 80		adc #$80			adc #Wh_NameLastChar+1	; calc string start offset
.cf9b	20 da db	jsr $dbda			jsr Plus_A		; calc string start addr
.cf9e	68		pla				pla			; push string length
.cf9f	4c 5d c9	jmp $c95d			jmp PushZA
=29					CodeLen	.var *-XtPtr1
=$cfa2					Here1 = *	; remember here
>cf83	1d					.byte CodeLen	;patch wh_CodeLength
>cfa2	3e 42 6f 64 79			Name0:	.text ">Body"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=53031					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>cfa7	25					.byte ((">Body"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=38					LinkDisplacement = Nt0-WordListLink
>cfa8	10					.byte WordFlags	;wh_Flags
>cfa9	03					.byte 3	;wh_CodeLength
>cfaa	26					  .byte LinkDisplacement	; offset to previous nt
=$cfab					XtPtr1 ::= *
=53031					WordListLink ::= Nt0 ; remember the nt of this word for later
.cfab	a9 03		lda #$03	To_Body:	lda #3		; PFA is after the beginning JSR abs
.cfad	4c da db	jmp $dbda			jmp Plus_A
=5					CodeLen	.var *-XtPtr1
=$cfb0					Here1 = *	; remember here
>cfa9	05					.byte CodeLen	;patch wh_CodeLength
.cfb0	4c ae c5	jmp $c5ae	Throw_Stack_07: jmp Throw_Stack
>cfb3	45 72 61 73 65			Name0:	.text "Erase"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=53048					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>cfb8	a5					.byte (("Erase"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=17					LinkDisplacement = Nt0-WordListLink
>cfb9	10					.byte WordFlags	;wh_Flags
>cfba	03					.byte 3	;wh_CodeLength
>cfbb	11					  .byte LinkDisplacement	; offset to previous nt
=$cfbc					XtPtr1 ::= *
=53048					WordListLink ::= Nt0 ; remember the nt of this word for later
.cfbc					Erase:
.cfbc	20 6b c9	jsr $c96b			jsr Zero
.cfbf	4c d9 cf	jmp $cfd9			jmp Fill
=6					CodeLen	.var *-XtPtr1
=$cfc2					Here1 = *	; remember here
>cfba	06					.byte CodeLen	;patch wh_CodeLength
>cfc2	42 6c 61 6e 6b			Name0:	.text "Blank"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=53063					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>cfc7	65					.byte (("Blank"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=15					LinkDisplacement = Nt0-WordListLink
>cfc8	10					.byte WordFlags	;wh_Flags
>cfc9	03					.byte 3	;wh_CodeLength
>cfca	0f					  .byte LinkDisplacement	; offset to previous nt
=$cfcb					XtPtr1 ::= *
=53063					WordListLink ::= Nt0 ; remember the nt of this word for later
.cfcb					Blank:
.cfcb	20 87 c9	jsr $c987			jsr Bl
.cfce	4c d9 cf	jmp $cfd9			jmp Fill
=6					CodeLen	.var *-XtPtr1
=$cfd1					Here1 = *	; remember here
>cfc9	06					.byte CodeLen	;patch wh_CodeLength
>cfd1	46 69 6c 6c			Name0:	.text "Fill"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=53077					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>cfd5	84					.byte (("Fill"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=14					LinkDisplacement = Nt0-WordListLink
>cfd6	10					.byte WordFlags	;wh_Flags
>cfd7	03					.byte 3	;wh_CodeLength
>cfd8	0e					  .byte LinkDisplacement	; offset to previous nt
=$cfd9					XtPtr1 ::= *
=53077					WordListLink ::= Nt0 ; remember the nt of this word for later
.cfd9					Fill:
.cfd9	e0 2b		cpx #$2b		cpx #(DSDim-3)*2+1	; far enough below end of data stack (& not negative)?
.cfdb	b0 d3		bcs $cfb0		bcs Throw_Stack_07
.cfdd	b5 2a		lda $2a,x			lda DStack+4,x		; tmp1= address
.cfdf	85 14		sta $14				sta tmp1+0
.cfe1	b5 2b		lda $2b,x			lda DStack+5,x
.cfe3	85 15		sta $15				sta tmp1+1
.cfe5	b5 28		lda $28,x			lda DStack+2,x		; tmp2= counter.lo
.cfe7	85 16		sta $16				sta tmp2+0
.cfe9	f6 29		inc $29,x			inc DStack+3,x		; so decrement & test for 0 works
.cfeb	b5 26		lda $26,x			lda DStack+0,x		; A= fill byte
.cfed	a0 00		ldy #$00			ldy #0
.cfef	c4 16		cpy $16		_loop:		cpy tmp2+0		; done?
.cff1	f0 09		beq $cffc			beq _test2
.cff3	91 14		sta ($14),y	_3:		sta (tmp1),y		; store a byte
.cff5	c8		iny				iny			; to next byte
.cff6	d0 f7		bne $cfef			bne _loop
.cff8	e6 15		inc $15				inc tmp1+1		; increment addr page
.cffa	d0 f3		bne $cfef			bne _loop
.cffc	d6 29		dec $29,x	_test2:		dec DStack+3,x		; any more pages?
.cffe	d0 f3		bne $cff3			bne _3
.d000	4c ed be	jmp $beed			jmp ThreeDrop	; Drop three cells off the Data Stack.
=42					CodeLen	.var *-XtPtr1
=$d003					Here1 = *	; remember here
>cfd7	2a					.byte CodeLen	;patch wh_CodeLength
>d003	56 61 72 69 61 62 6c 65		Name0:	.text "Variable"	;  name of word as a string, ending at wh_NameLastChar
=8					NameLength = *-Name0
=53131					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>d00b	a8					.byte (("Variable"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=54					LinkDisplacement = Nt0-WordListLink
>d00c	10					.byte WordFlags	;wh_Flags
>d00d	03					.byte 3	;wh_CodeLength
>d00e	36					  .byte LinkDisplacement	; offset to previous nt
=$d00f					XtPtr1 ::= *
=53131					WordListLink ::= Nt0 ; remember the nt of this word for later
.d00f	20 5f d3	jsr $d35f	Variable:	jsr Create		; compile word header & push PFA
.d012	a9 00		lda #$00	Z_Comma:	lda #0			; allot & initialize the variable's data
.d014	a8		tay				tay
.d015	4c f6 de	jmp $def6			jmp Comma_YA
=9					CodeLen	.var *-XtPtr1
=$d018					Here1 = *	; remember here
>d00d	09					.byte CodeLen	;patch wh_CodeLength
>d018	32 56 61 72 69 61 62 6c		Name0:	.text "2Variable"	;  name of word as a string, ending at wh_NameLastChar
>d020	65
=9					NameLength = *-Name0
=53153					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>d021	a9					.byte (("2Variable"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=22					LinkDisplacement = Nt0-WordListLink
>d022	10					.byte WordFlags	;wh_Flags
>d023	03					.byte 3	;wh_CodeLength
>d024	16					  .byte LinkDisplacement	; offset to previous nt
=$d025					XtPtr1 ::= *
=53153					WordListLink ::= Nt0 ; remember the nt of this word for later
.d025	20 0f d0	jsr $d00f	Two_variable:	jsr Variable		; compile word header & push PFA & 1st cell of data
.d028	4c 12 d0	jmp $d012			jmp Z_Comma		; alloc & init 2nd cell of data
=6					CodeLen	.var *-XtPtr1
=$d02b					Here1 = *	; remember here
>d023	06					.byte CodeLen	;patch wh_CodeLength
>d02b	43 6f 6e 73 74 61 6e 74		Name0:	.text "Constant"	;  name of word as a string, ending at wh_NameLastChar
=8					NameLength = *-Name0
=53171					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>d033	88					.byte (("Constant"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=80					WordFlags ::= UF+NN	; modifiable copy, remember for later
=18					LinkDisplacement = Nt0-WordListLink
>d034	50					.byte WordFlags	;wh_Flags
>d035	03					.byte 3	;wh_CodeLength
>d036	12					  .byte LinkDisplacement	; offset to previous nt
=$d037					XtPtr1 ::= *
=53171					WordListLink ::= Nt0 ; remember the nt of this word for later
.d037	20 8b c5	jsr $c58b	Constant:	jsr underflow_1
.d03a	20 b2 d2	jsr $d2b2			jsr WordHeader_Comma	; compile word header
.d03d	20 d4 c8	jsr $c8d4			jsr LitCompile		; compile code to load registers, & pick a subroutine
.d040	20 42 df	jsr $df42			jsr Jmp_Comma_NT_YA	; compile code to JMP to the subroutine
.d043	4c 6e cd	jmp $cd6e			jmp adjust_z		; fix word length
=15					CodeLen	.var *-XtPtr1
=$d046					Here1 = *	; remember here
>d035	0f					.byte CodeLen	;patch wh_CodeLength
>d046	32 43 6f 6e 73 74 61 6e		Name0:	.text "2Constant"	;  name of word as a string, ending at wh_NameLastChar
>d04e	74
=9					NameLength = *-Name0
=53199					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>d04f	89					.byte (("2Constant"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=28					LinkDisplacement = Nt0-WordListLink
>d050	10					.byte WordFlags	;wh_Flags
>d051	03					.byte 3	;wh_CodeLength
>d052	1c					  .byte LinkDisplacement	; offset to previous nt
=$d053					XtPtr1 ::= *
=53199					WordListLink ::= Nt0 ; remember the nt of this word for later
.d053					Two_constant:
.d053	4c 7c d0	jmp $d07c			jmp TwoValue
=3					CodeLen	.var *-XtPtr1
=$d056					Here1 = *	; remember here
>d051	03					.byte CodeLen	;patch wh_CodeLength
>d056	56 61 6c 75 65			Name0:	.text "Value"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=53211					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>d05b	a5					.byte (("Value"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=12					LinkDisplacement = Nt0-WordListLink
>d05c	10					.byte WordFlags	;wh_Flags
>d05d	03					.byte 3	;wh_CodeLength
>d05e	0c					  .byte LinkDisplacement	; offset to previous nt
=$d05f					XtPtr1 ::= *
=53211					WordListLink ::= Nt0 ; remember the nt of this word for later
.d05f	20 8b c5	jsr $c58b	Value:		jsr underflow_1
.d062	20 b2 d2	jsr $d2b2			jsr WordHeader_Comma	; compile word header
.d065	20 15 c9	jsr $c915			jsr ldya_immed_comma	; compile lda # & ldy #
.d068	a9 2e		lda #$2e			lda #<PushYA		; compile jmp PushYA
.d06a	a0 c9		ldy #$c9			ldy #>PushYA
.d06c	20 3b df	jsr $df3b			jsr Jmp_Comma_YA
.d06f	4c 6e cd	jmp $cd6e			jmp adjust_z		; fix word length
=19					CodeLen	.var *-XtPtr1
=$d072					Here1 = *	; remember here
>d05d	13					.byte CodeLen	;patch wh_CodeLength
>d072	32 56 61 6c 75 65		Name0:	.text "2Value"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=53240					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>d078	a6					.byte (("2Value"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=29					LinkDisplacement = Nt0-WordListLink
>d079	10					.byte WordFlags	;wh_Flags
>d07a	03					.byte 3	;wh_CodeLength
>d07b	1d					  .byte LinkDisplacement	; offset to previous nt
=$d07c					XtPtr1 ::= *
=53240					WordListLink ::= Nt0 ; remember the nt of this word for later
.d07c	20 b2 d2	jsr $d2b2	TwoValue:	jsr WordHeader_Comma	; compile word header
.d07f	a9 8c		lda #$8c			lda #<TwoValue_Runtime	; compile JSR TValue_Runtime
.d081	a0 d0		ldy #$d0			ldy #>TwoValue_Runtime
.d083	20 25 df	jsr $df25			jsr Jsr_Comma_YA
.d086	20 6e cd	jsr $cd6e			jsr adjust_z		; fix word length
.d089	4c 03 df	jmp $df03			jmp Two_Comma		; compile the value, return
=16					CodeLen	.var *-XtPtr1
=$d08c					Here1 = *	; remember here
>d07a	10					.byte CodeLen	;patch wh_CodeLength
.d08c					TwoValue_Runtime:
.d08c	68		pla				pla			; pop RTS addr
.d08d	85 14		sta $14				sta tmp1+0
.d08f	68		pla				pla
.d090	85 15		sta $15				sta tmp1+1
.d092	a0 01		ldy #$01			ldy #1			; start at offset 1 (for RTS addr behavior)
.d094	4c 80 d7	jmp $d780			jmp Two_Fetch_Tmp1Y	; fetch the data, return
>d097	54 6f				Name0:	.text "To"	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=53273					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>d099	e2					.byte (("To"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=24					WordFlags ::= NN+IM	; modifiable copy, remember for later
=33					LinkDisplacement = Nt0-WordListLink
>d09a	18					.byte WordFlags	;wh_Flags
>d09b	03					.byte 3	;wh_CodeLength
>d09c	21					  .byte LinkDisplacement	; offset to previous nt
=$d09d					XtPtr1 ::= *
=53273					WordListLink ::= Nt0 ; remember the nt of this word for later
.d09d					To:
.d09d	20 d4 cd	jsr $cdd4			jsr Tick		; We always need the xt of the target word
.d0a0	b5 26		lda $26,x			lda DStack+0,x		; tmp1= xt
.d0a2	b4 27		ldy $27,x			ldy DStack+1,x
.d0a4	85 14		sta $14				sta tmp1+0
.d0a6	84 15		sty $15				sty tmp1+1
.d0a8	a0 00		ldy #$00			ldy #0			; determine what type xt points at
.d0aa	b1 14		lda ($14),y			lda (tmp1),y
.d0ac	c9 a0		cmp #$a0			cmp #$a0		;   LDY #
.d0ae	d0 38		bne $d0e8			bne _Test2
.d0b0	a5 0a		lda $0a				lda state		; check compile state
.d0b2	f0 20		beq $d0d4			beq _Value_interpret
.d0b4	a9 62		lda #$62			lda #<PopYA		; compile jsr PopYA
.d0b6	a0 c5		ldy #$c5			ldy #>PopYA
.d0b8	20 25 df	jsr $df25			jsr Jsr_Comma_YA
.d0bb	a9 8c		lda #$8c			lda #$8C		; compile STY xt+1
.d0bd	20 df de	jsr $dedf			jsr C_Comma_A
.d0c0	20 37 dc	jsr $dc37			jsr One_plus
.d0c3	20 8a e1	jsr $e18a			jsr Dup
.d0c6	20 f3 de	jsr $def3			jsr Comma
.d0c9	a9 8d		lda #$8d			lda #$8D		; compile STA xt+3
.d0cb	20 df de	jsr $dedf			jsr C_Comma_A
.d0ce	20 d8 db	jsr $dbd8			jsr Cell_Plus
.d0d1	4c f3 de	jmp $def3			jmp Comma
.d0d4					_Value_interpret:
.d0d4	20 9f c5	jsr $c59f			jsr underflow_2		; ( n xt )
.d0d7	e8		inx				inx			; Drop xt
.d0d8	e8		inx				inx
.d0d9	b5 26		lda $26,x			lda DStack+0,x		; LSB
.d0db	a0 03		ldy #$03			ldy #3			;   modify LDA # data
.d0dd	91 14		sta ($14),y			sta (tmp1),y
.d0df	b5 27		lda $27,x			lda DStack+1,x		; MSB
.d0e1	a0 01		ldy #$01			ldy #1			;   modify LDY # data
.d0e3	91 14		sta ($14),y			sta (tmp1),y
.d0e5	e8		inx				inx			; Drop n
.d0e6	e8		inx				inx
.d0e7	60		rts				rts
.d0e8	c9 20		cmp #$20	_Test2:		cmp #$20		;   JSR abs ?
.d0ea	d0 48		bne $d134			bne _Err
.d0ec	a9 03		lda #$03			lda #3			; advance xt over the JSR abs to the data
.d0ee	20 da db	jsr $dbda			jsr Plus_A
.d0f1	a0 01		ldy #$01			ldy #1			; get JSR abs addr lo byte
.d0f3	b1 14		lda ($14),y			lda (tmp1),y
.d0f5	c9 8c		cmp #$8c			cmp #<TwoValue_Runtime
.d0f7	d0 11		bne $d10a			bne _Test3
.d0f9	a5 0a		lda $0a				lda state		; check compile state
.d0fb	f0 0a		beq $d107			beq _2Value_runtime
.d0fd	20 15 c9	jsr $c915			jsr ldya_immed_comma	; compile LDY #; LDA #  of xt+3
.d100	a9 4f		lda #$4f			lda #<Two_Store_YA
.d102	a0 d7		ldy #$d7			ldy #>Two_Store_YA
.d104	4c 25 df	jmp $df25			jmp Jsr_Comma_YA	; compile JSR Two_Store_YA; return
.d107	4c 4c d7	jmp $d74c	_2Value_runtime: jmp Two_Store
.d10a					_Test3:
.d10a	c9 07		cmp #$07			cmp #<FValue_runtime
.d10c	d0 11		bne $d11f			bne _Test4
.d10e	a5 0a		lda $0a				lda state		; check compile state
.d110	f0 0a		beq $d11c			beq _FValue_interpret
.d112	20 15 c9	jsr $c915			jsr ldya_immed_comma	; compile LDY #; LDA #  of xt+3
.d115	a9 06		lda #$06			lda #<FStore_YA
.d117	a0 87		ldy #$87			ldy #>FStore_YA
.d119	4c 25 df	jmp $df25			jmp Jsr_Comma_YA	; compile JSR FStore_YA; return
.d11c	4c 03 87	jmp $8703	_FValue_interpret: jmp FStore
.d11f					_Test4:
.d11f	c9 2a		cmp #$2a			cmp #<EValue_runtime
.d121	d0 11		bne $d134			bne _Err
.d123	a5 0a		lda $0a				lda state		; check compile state
.d125	f0 0a		beq $d131			beq _EValue_interpret
.d127	20 15 c9	jsr $c915			jsr ldya_immed_comma	; compile LDY #; LDA #  of xt+3
.d12a	a9 61		lda #$61			lda #<EStore_YA
.d12c	a0 9d		ldy #$9d			ldy #>EStore_YA
.d12e	4c 25 df	jmp $df25			jmp Jsr_Comma_YA	; compile JSR EStore_YA; return
.d131	4c 5e 9d	jmp $9d5e	_EValue_interpret: jmp EStore
.d134	a9 e0		lda #$e0	_Err:		lda #$100+err_InvalidName ; unrecognized type.
.d136	20 dc c5	jsr $c5dc			jsr ThrowA
=156					CodeLen	.var *-XtPtr1
=$d139					Here1 = *	; remember here
>d09b	9c					.byte CodeLen	;patch wh_CodeLength
>d139	44 4d 61 78			Name0:	.text "DMax"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=53437					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>d13d	04					.byte (("DMax"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=164					LinkDisplacement = Nt0-WordListLink
>d13e	10					.byte WordFlags	;wh_Flags
>d13f	03					.byte 3	;wh_CodeLength
>d140	a4					  .byte LinkDisplacement	; offset to previous nt
=$d141					XtPtr1 ::= *
=53437					WordListLink ::= Nt0 ; remember the nt of this word for later
.d141	a9 80		lda #$80	DMax:		lda #$80
.d143	d0 0d		bne $d152			bne DMin3
=4					CodeLen	.var *-XtPtr1
=$d145					Here1 = *	; remember here
>d13f	04					.byte CodeLen	;patch wh_CodeLength
.d145	4c ae c5	jmp $c5ae	Throw_Stack_23: jmp Throw_Stack
>d148	44 4d 69 6e			Name0:	.text "DMin"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=53452					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>d14c	c4					.byte (("DMin"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=15					LinkDisplacement = Nt0-WordListLink
>d14d	10					.byte WordFlags	;wh_Flags
>d14e	03					.byte 3	;wh_CodeLength
>d14f	0f					  .byte LinkDisplacement	; offset to previous nt
=$d150					XtPtr1 ::= *
=53452					WordListLink ::= Nt0 ; remember the nt of this word for later
.d150	a9 00		lda #$00	DMin:		lda #0
.d152	85 16		sta $16		DMin3:		sta tmp2	; save sign correction
.d154	e0 29		cpx #$29		cpx #(DSDim-4)*2+1	; far enough below end of data stack (& not negative)?
.d156	b0 ed		bcs $d145		bcs Throw_Stack_23
.d158	b5 28		lda $28,x			lda DStack+2,x	; compare
.d15a	d5 2c		cmp $2c,x			cmp DStack+6,x
.d15c	b5 29		lda $29,x			lda DStack+3,x
.d15e	f5 2d		sbc $2d,x			sbc DStack+7,x
.d160	b5 26		lda $26,x			lda DStack+0,x
.d162	f5 2a		sbc $2a,x			sbc DStack+4,x
.d164	b5 27		lda $27,x			lda DStack+1,x
.d166	f5 2b		sbc $2b,x			sbc DStack+5,x
.d168	50 02		bvc $d16c			bvc +
.d16a	49 80		eor #$80			eor #$80	; fix sign
.d16c	45 16		eor $16		+		eor tmp2
.d16e	30 0f		bmi $d17f			bmi TwoNip_nouf	; if negative, NOS is larger and needs to be kept
.d170	4c 04 d7	jmp $d704			jmp Two_Drop
=35					CodeLen	.var *-XtPtr1
=$d173					Here1 = *	; remember here
>d14e	23					.byte CodeLen	;patch wh_CodeLength
>d173	32 4e 69 70			Name0:	.text "2Nip"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=53495					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>d177	04					.byte (("2Nip"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=43					LinkDisplacement = Nt0-WordListLink
>d178	10					.byte WordFlags	;wh_Flags
>d179	03					.byte 3	;wh_CodeLength
>d17a	2b					  .byte LinkDisplacement	; offset to previous nt
=$d17b					XtPtr1 ::= *
=53495					WordListLink ::= Nt0 ; remember the nt of this word for later
.d17b					TwoNip:
.d17b	e0 29		cpx #$29		cpx #(DSDim-4)*2+1	; far enough below end of data stack (& not negative)?
.d17d	b0 62		bcs $d1e1		bcs Throw_Stack_25
.d17f	b5 26		lda $26,x	TwoNip_NoUf:	lda DStack+0,x	; copy dTOS to dNOS
.d181	95 2a		sta $2a,x			sta DStack+4,x
.d183	b5 27		lda $27,x			lda DStack+1,x
.d185	95 2b		sta $2b,x			sta DStack+5,x
.d187	b5 28		lda $28,x			lda DStack+2,x
.d189	95 2c		sta $2c,x			sta DStack+6,x
.d18b	b5 29		lda $29,x			lda DStack+3,x
.d18d	95 2d		sta $2d,x			sta DStack+7,x
.d18f	4c 04 d7	jmp $d704			jmp Two_Drop
=23					CodeLen	.var *-XtPtr1
=$d192					Here1 = *	; remember here
>d179	17					.byte CodeLen	;patch wh_CodeLength
>d192	53 3e 44			Name0:	.text "S>D"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=53525					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>d195	83					.byte (("S>D"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=30					LinkDisplacement = Nt0-WordListLink
>d196	10					.byte WordFlags	;wh_Flags
>d197	03					.byte 3	;wh_CodeLength
>d198	1e					  .byte LinkDisplacement	; offset to previous nt
=$d199					XtPtr1 ::= *
=53525					WordListLink ::= Nt0 ; remember the nt of this word for later
.d199					S_To_D:
.d199	e0 2f		cpx #$2f		cpx #(DSDim-1)*2+1	; far enough below end of data stack (& not negative)?
.d19b	b0 44		bcs $d1e1		bcs Throw_Stack_25
.d19d	a0 00		ldy #$00			ldy #0			; assume positive
.d19f	b5 27		lda $27,x			lda DStack+1,x		; test n
.d1a1	10 01		bpl $d1a4			bpl +
.d1a3	88		dey				dey			; make negative
.d1a4					+
.d1a4	ca		dex				dex			; push new hi cell
.d1a5	ca		dex				dex
.d1a6	94 26		sty $26,x			sty DStack+0,x
.d1a8	94 27		sty $27,x			sty DStack+1,x
=17					CodeLen	.var *-XtPtr1
=$d1aa					Here1 = *	; remember here
>d197	11					.byte CodeLen	;patch wh_CodeLength
.d1aa	60		rts				rts
>d1ab	44 3e 53			Name0:	.text "D>S"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=53550					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>d1ae	63					.byte (("D>S"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=25					LinkDisplacement = Nt0-WordListLink
>d1af	10					.byte WordFlags	;wh_Flags
>d1b0	03					.byte 3	;wh_CodeLength
>d1b1	19					  .byte LinkDisplacement	; offset to previous nt
=$d1b2					XtPtr1 ::= *
=53550					WordListLink ::= Nt0 ; remember the nt of this word for later
.d1b2					D_To_S:
.d1b2	e0 2d		cpx #$2d		cpx #(DSDim-2)*2+1	; far enough below end of data stack (& not negative)?
.d1b4	b0 2b		bcs $d1e1		bcs Throw_Stack_25
.d1b6	e8		inx				inx		; Drop hi cell
.d1b7	e8		inx				inx
=6					CodeLen	.var *-XtPtr1
=$d1b8					Here1 = *	; remember here
>d1b0	06					.byte CodeLen	;patch wh_CodeLength
.d1b8	60		rts				rts
>d1b9	44 2d				Name0:	.text "D-"	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=53563					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>d1bb	a2					.byte (("D-"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>d1bc	10					.byte WordFlags	;wh_Flags
>d1bd	03					.byte 3	;wh_CodeLength
>d1be	0d					  .byte LinkDisplacement	; offset to previous nt
=$d1bf					XtPtr1 ::= *
=53563					WordListLink ::= Nt0 ; remember the nt of this word for later
.d1bf					D_Minus:
.d1bf	e0 29		cpx #$29		cpx #(DSDim-4)*2+1	; far enough below end of data stack (& not negative)?
.d1c1	b0 1e		bcs $d1e1		bcs Throw_Stack_25
.d1c3	38		sec				sec
.d1c4	b5 2c		lda $2c,x			lda DStack+6,x	; LSB of lower word
.d1c6	f5 28		sbc $28,x			sbc DStack+2,x
.d1c8	95 2c		sta $2c,x			sta DStack+6,x
.d1ca	b5 2d		lda $2d,x			lda DStack+7,x	; MSB of lower word
.d1cc	f5 29		sbc $29,x			sbc DStack+3,x
.d1ce	95 2d		sta $2d,x			sta DStack+7,x
.d1d0	b5 2a		lda $2a,x			lda DStack+4,x	; LSB of upper word
.d1d2	f5 26		sbc $26,x			sbc DStack+0,x
.d1d4	95 2a		sta $2a,x			sta DStack+4,x
.d1d6	b5 2b		lda $2b,x			lda DStack+5,x	; MSB of upper word
.d1d8	f5 27		sbc $27,x			sbc DStack+1,x
.d1da	95 2b		sta $2b,x			sta DStack+5,x
.d1dc	e8		inx				inx
.d1dd	e8		inx				inx
.d1de	e8		inx				inx
.d1df	e8		inx				inx
=33					CodeLen	.var *-XtPtr1
=$d1e0					Here1 = *	; remember here
>d1bd	21					.byte CodeLen	;patch wh_CodeLength
.d1e0	60		rts				rts
.d1e1	4c ae c5	jmp $c5ae	Throw_Stack_25: jmp Throw_Stack
>d1e4	44 2b				Name0:	.text "D+"	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=53606					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>d1e6	62					.byte (("D+"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=43					LinkDisplacement = Nt0-WordListLink
>d1e7	10					.byte WordFlags	;wh_Flags
>d1e8	03					.byte 3	;wh_CodeLength
>d1e9	2b					  .byte LinkDisplacement	; offset to previous nt
=$d1ea					XtPtr1 ::= *
=53606					WordListLink ::= Nt0 ; remember the nt of this word for later
.d1ea					D_Plus:
.d1ea	e0 29		cpx #$29		cpx #(DSDim-4)*2+1	; far enough below end of data stack (& not negative)?
.d1ec	b0 f3		bcs $d1e1		bcs Throw_Stack_25
.d1ee	b5 28		lda $28,x			lda DStack+2,x	; LSB of lower word
.d1f0	75 2c		adc $2c,x			adc DStack+6,x
.d1f2	95 2c		sta $2c,x			sta DStack+6,x
.d1f4	b5 29		lda $29,x			lda DStack+3,x	; MSB of lower word
.d1f6	75 2d		adc $2d,x			adc DStack+7,x
.d1f8	95 2d		sta $2d,x			sta DStack+7,x
.d1fa	b5 26		lda $26,x			lda DStack+0,x	; LSB of upper word
.d1fc	75 2a		adc $2a,x			adc DStack+4,x
.d1fe	95 2a		sta $2a,x			sta DStack+4,x
.d200	b5 27		lda $27,x			lda DStack+1,x	; MSB of upper word
.d202	75 2b		adc $2b,x			adc DStack+5,x
.d204	95 2b		sta $2b,x			sta DStack+5,x
.d206	e8		inx				inx
.d207	e8		inx				inx
.d208	e8		inx				inx
.d209	e8		inx				inx
=32					CodeLen	.var *-XtPtr1
=$d20a					Here1 = *	; remember here
>d1e8	20					.byte CodeLen	;patch wh_CodeLength
.d20a	60		rts				rts
>d20b	44 31 2b			Name0:	.text "D1+"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=53646					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>d20e	63					.byte (("D1+"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=40					LinkDisplacement = Nt0-WordListLink
>d20f	10					.byte WordFlags	;wh_Flags
>d210	03					.byte 3	;wh_CodeLength
>d211	28					  .byte LinkDisplacement	; offset to previous nt
=$d212					XtPtr1 ::= *
=53646					WordListLink ::= Nt0 ; remember the nt of this word for later
.d212					D1Plus:
.d212	e0 29		cpx #$29		cpx #(DSDim-4)*2+1	; far enough below end of data stack (& not negative)?
.d214	b0 cb		bcs $d1e1		bcs Throw_Stack_25
.d216	f6 28		inc $28,x			inc DStack+2,x
.d218	d0 0a		bne $d224			bne +
.d21a	f6 29		inc $29,x			inc DStack+3,x
.d21c	d0 06		bne $d224			bne +
.d21e	f6 26		inc $26,x			inc DStack+0,x
.d220	d0 02		bne $d224			bne +
.d222	f6 27		inc $27,x			inc DStack+1,x
.d224					+
=18					CodeLen	.var *-XtPtr1
=$d224					Here1 = *	; remember here
>d210	12					.byte CodeLen	;patch wh_CodeLength
.d224	60		rts				rts
>d225	44 31 2d			Name0:	.text "D1-"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=53672					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>d228	a3					.byte (("D1-"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=26					LinkDisplacement = Nt0-WordListLink
>d229	10					.byte WordFlags	;wh_Flags
>d22a	03					.byte 3	;wh_CodeLength
>d22b	1a					  .byte LinkDisplacement	; offset to previous nt
=$d22c					XtPtr1 ::= *
=53672					WordListLink ::= Nt0 ; remember the nt of this word for later
.d22c					D1Minus:
.d22c	e0 29		cpx #$29		cpx #(DSDim-4)*2+1	; far enough below end of data stack (& not negative)?
.d22e	b0 b1		bcs $d1e1		bcs Throw_Stack_25
.d230	b5 28		lda $28,x			lda DStack+2,x
.d232	d0 0e		bne $d242			bne _1
.d234	b5 29		lda $29,x			lda DStack+3,x
.d236	d0 08		bne $d240			bne _2
.d238	b5 26		lda $26,x			lda DStack+0,x
.d23a	d0 02		bne $d23e			bne _3
.d23c	d6 27		dec $27,x			dec DStack+1,x
.d23e	d6 26		dec $26,x	_3:		dec DStack+0,x
.d240	d6 29		dec $29,x	_2:		dec DStack+3,x
.d242	d6 28		dec $28,x	_1:		dec DStack+2,x
=24					CodeLen	.var *-XtPtr1
=$d244					Here1 = *	; remember here
>d22a	18					.byte CodeLen	;patch wh_CodeLength
.d244	60		rts				rts
.d245	20 5d c9	jsr $c95d	Allot_ZA:	jsr PushZA
.d248	4c 54 d2	jmp $d254			jmp Allot
>d24b	41 6c 6c 6f 74			Name0:	.text "Allot"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=53712					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>d250	85					.byte (("Allot"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=40					LinkDisplacement = Nt0-WordListLink
>d251	10					.byte WordFlags	;wh_Flags
>d252	03					.byte 3	;wh_CodeLength
>d253	28					  .byte LinkDisplacement	; offset to previous nt
=$d254					XtPtr1 ::= *
=53712					WordListLink ::= Nt0 ; remember the nt of this word for later
.d254					Allot:
.d254	e0 2f		cpx #$2f		cpx #(DSDim-1)*2+1	; far enough below end of data stack (& not negative)?
.d256	b0 89		bcs $d1e1		bcs Throw_Stack_25
.d258	18		clc				clc			; adjust cp
.d259	b5 26		lda $26,x			lda DStack+0,x
.d25b	65 00		adc $00				adc cp+0
.d25d	85 00		sta $00				sta cp+0
.d25f	a8		tay				tay			;   save lo byte
.d260	b5 27		lda $27,x			lda DStack+1,x
.d262	85 14		sta $14				sta tmp1
.d264	65 01		adc $01				adc cp+1
.d266	85 01		sta $01				sta cp+1
.d268	24 14		bit $14				bit tmp1
.d26a	30 15		bmi $d281			bmi _release
.d26c	b0 06		bcs $d274			bcs _pos_err		; carry from the add is bad
=32600					_last = cp_end-2*PadOffset
.d26e	c0 58		cpy #$58			cpy #<_last		; cp < cp_end ?
.d270	e9 7f		sbc #$7f			sbc #>_last
.d272	90 2c		bcc $d2a0			bcc _done		; we're fine.
.d274					_pos_err:
.d274	a9 58		lda #$58			lda #<_last
.d276	85 00		sta $00				sta cp+0
.d278	a9 7f		lda #$7f			lda #>_last
.d27a	85 01		sta $01				sta cp+1
.d27c	a9 c5		lda #$c5			lda #$100+err_Allocate
.d27e	4c dc c5	jmp $c5dc			jmp ThrowA
.d281					_release:
.d281	90 06		bcc $d289			bcc _neg_err		; borrow indicates we've gone below 0
.d283	c0 66		cpy #$66			cpy #<cp0
.d285	e9 0b		sbc #$0b			sbc #>cp0
.d287	b0 17		bcs $d2a0			bcs _done
.d289					_neg_err:
.d289	a9 66		lda #$66			lda #<cp0		; Set CP to CP0
.d28b	85 00		sta $00				sta cp+0
.d28d	a9 0b		lda #$0b			lda #>cp0
.d28f	85 01		sta $01				sta cp+1
.d291	a9 46		lda #$46			lda #<forth_dictionary_start	; set WordLists[Forth] to the first
.d293	8d 12 03	sta $0312			sta WordlistsV+0		; word in ROM
.d296	a9 e1		lda #$e1			lda #>forth_dictionary_start
.d298	8d 13 03	sta $0313			sta WordlistsV+1
.d29b	a9 c4		lda #$c4			lda #$100+err_Free		; abort with an error
.d29d	4c dc c5	jmp $c5dc			jmp ThrowA
.d2a0					_done:
.d2a0	e8		inx				inx			; Drop n
.d2a1	e8		inx				inx
=78					CodeLen	.var *-XtPtr1
=$d2a2					Here1 = *	; remember here
>d252	4e					.byte CodeLen	;patch wh_CodeLength
.d2a2	60		rts				rts
>d2a3	57 6f 72 64 48 65 61 64		Name0:	.text "WordHeader,"	;  name of word as a string, ending at wh_NameLastChar
>d2ab	65 72 2c
=11					NameLength = *-Name0
=53806					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>d2ae	8b					.byte (("WordHeader,"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=94					LinkDisplacement = Nt0-WordListLink
>d2af	10					.byte WordFlags	;wh_Flags
>d2b0	03					.byte 3	;wh_CodeLength
>d2b1	5e					  .byte LinkDisplacement	; offset to previous nt
=$d2b2					XtPtr1 ::= *
=53806					WordListLink ::= Nt0 ; remember the nt of this word for later
.d2b2					WordHeader_Comma:
.d2b2	20 c0 d2	jsr $d2c0			jsr Header_Build
.d2b5					Header_Link:
.d2b5	a5 0e		lda $0e				lda WorkWord+0		; dp= WorkWord
.d2b7	85 10		sta $10				sta dp+0
.d2b9	a5 0f		lda $0f				lda WorkWord+1
.d2bb	85 11		sta $11				sta dp+1
.d2bd	4c f7 cb	jmp $cbf7			jmp dp_to_current	; Update the CURRENT wordlist with the new DP.
.d2c0					Header_Build:
.d2c0	20 46 cc	jsr $cc46			jsr parse_name_check	; get name string, throw error if empty string
.d2c3	20 97 de	jsr $de97			jsr Two_dup		; ( addr u addr u )
.d2c6	20 03 b2	jsr $b203			jsr Get_Current
.d2c9	20 1d b3	jsr $b31d			jsr Search_WordList	; ( addr u xt f ) or ( addr u 0 )
.d2cc	e8		inx				inx			; pop flag.
.d2cd	e8		inx				inx
.d2ce	b5 24		lda $24,x			lda DStack-2,x		; not found?
.d2d0	f0 21		beq $d2f3			beq _new_name		; We haven't seen this one before.
.d2d2	e8		inx				inx			; Drop xt
.d2d3	e8		inx				inx
.d2d4	24 0c		bit $0c				bit status		; Check bit 7
.d2d6	10 08		bpl $d2e0			bpl _redefined_name	; Bit 7 is zero, so print the message.
.d2d8	a9 80		lda #$80			lda #$80		; Set bit 7 to indicate dup
.d2da	05 0c		ora $0c				ora status
.d2dc	85 0c		sta $0c				sta status
.d2de	d0 19		bne $d2f9			bne _process_name
.d2e0					_redefined_name:
.d2e0	a9 7b		lda #$7b			lda #<str_redefined
.d2e2	a0 ec		ldy #$ec			ldy #>str_redefined
.d2e4	20 0d e0	jsr $e00d			jsr Print_ASCIIZ_YA_no_lf
.d2e7	20 97 de	jsr $de97			jsr Two_dup		 ; ( addr u addr u )
.d2ea	20 f1 df	jsr $dff1			jsr Type
.d2ed	20 e5 df	jsr $dfe5			jsr Space
.d2f0	4c f9 d2	jmp $d2f9			jmp _process_name
.d2f3					_new_name:
.d2f3	a9 7f		lda #$7f			lda #$7F		; Clear bit 0 of status to indicate new word.
.d2f5	25 0c		and $0c				and status
.d2f7	85 0c		sta $0c				sta status
.d2f9					_process_name:
.d2f9	20 97 de	jsr $de97			jsr Two_dup		; compile name string ending at wh_NameLastChar
.d2fc	20 04 dc	jsr $dc04			jsr Here
.d2ff	20 ad e1	jsr $e1ad			jsr Swap
.d302	20 44 bf	jsr $bf44			jsr CMove
.d305	b5 26		lda $26,x			lda DStack+0,x		;   save length
.d307	20 45 d2	jsr $d245			jsr Allot_ZA
.d30a	38		sec				sec
.d30b	a5 00		lda $00				lda cp+0		; WorkWord= nt
.d30d	e9 80		sbc #$80			sbc #wh_NameLastChar+1
.d30f	85 0e		sta $0e				sta WorkWord+0
.d311	a5 01		lda $01				lda cp+1
.d313	e9 00		sbc #$00			sbc #0
.d315	85 0f		sta $0f				sta WorkWord+1
.d317	a0 7f		ldy #$7f			ldy #wh_NameLastChar
.d319	b1 0e		lda ($0e),y			lda (WorkWord),y
.d31b	0a		asl a				asl a
.d31c	0a		asl a				asl a
.d31d	0a		asl a				asl a
.d31e	0a		asl a				asl a
.d31f	0a		asl a				asl a
.d320	15 26		ora $26,x			ora DStack+0,x
.d322	95 26		sta $26,x			sta DStack+0,x
.d324	20 dc de	jsr $dedc			jsr C_Comma		; compile wh_HashNameLen
.d327	e8		inx				inx			; drop name string addr
.d328	e8		inx				inx
.d329	a9 10		lda #$10			lda #NN			; compile wh_Flags
.d32b	20 df de	jsr $dedf			jsr C_Comma_A
.d32e	a9 03		lda #$03			lda #3			; compile wh_CodeLength (temporary value, see adjust_z)
.d330	20 df de	jsr $dedf			jsr C_Comma_A
.d333	20 e7 cb	jsr $cbe7			jsr current_to_dp	; Get the CURRENT dictionary pointer.
.d336	38		sec				sec
.d337	a5 0e		lda $0e				lda WorkWord+0
.d339	e5 10		sbc $10				sbc dp+0
.d33b	a8		tay				tay
.d33c	a5 0f		lda $0f				lda WorkWord+1
.d33e	e5 11		sbc $11				sbc dp+1
.d340	f0 0f		beq $d351			beq _LinkShort
.d342	a0 81		ldy #$81			ldy #wh_Flags		; set FP flag
.d344	b1 0e		lda ($0e),y			lda (WorkWord),y
.d346	09 01		ora #$01			ora #FP
.d348	91 0e		sta ($0e),y			sta (WorkWord),y
.d34a	a5 10		lda $10				lda dp+0		; compile wh_LinkNt ptr word
.d34c	a4 11		ldy $11				ldy dp+1
.d34e	4c f6 de	jmp $def6			jmp Comma_YA
.d351	98		tya		_LinkShort:	tya			; compile wh_LinkNt offset byte
.d352	4c df de	jmp $dedf			jmp C_Comma_A
=163					CodeLen	.var *-XtPtr1
=$d355					Here1 = *	; remember here
>d2b0	a3					.byte CodeLen	;patch wh_CodeLength
>d355	43 72 65 61 74 65		Name0:	.text "Create"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=53979					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>d35b	a6					.byte (("Create"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=173					LinkDisplacement = Nt0-WordListLink
>d35c	10					.byte WordFlags	;wh_Flags
>d35d	03					.byte 3	;wh_CodeLength
>d35e	ad					  .byte LinkDisplacement	; offset to previous nt
=$d35f					XtPtr1 ::= *
=53979					WordListLink ::= Nt0 ; remember the nt of this word for later
.d35f					Create:
.d35f	20 b2 d2	jsr $d2b2			jsr WordHeader_Comma	; compile word header
.d362	a9 6c		lda #$6c			lda #<DoVar		; compile JSR DoVar
.d364	a0 d3		ldy #$d3			ldy #>DoVar
.d366	20 25 df	jsr $df25			jsr Jsr_Comma_YA
.d369	4c 6e cd	jmp $cd6e			jmp adjust_z
=13					CodeLen	.var *-XtPtr1
=$d36c					Here1 = *	; remember here
>d35d	0d					.byte CodeLen	;patch wh_CodeLength
.d36c					DoVar:
.d36c	68		pla				pla		; Pull the return address off the machine's stack
.d36d	18		clc				clc		;   +1 because of the way the JSR works
.d36e	69 01		adc #$01			adc #1
.d370	ca		dex				dex		; push on data stack
.d371	ca		dex				dex
.d372	95 26		sta $26,x			sta DStack+0,x
.d374	68		pla				pla
.d375	69 00		adc #$00			adc #0
.d377	95 27		sta $27,x			sta DStack+1,x
.d379	60		rts				rts		; takes us to the original caller of the
>d37a	44 6f 65 73 3e			Name0:	.text "Does>"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=54015					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>d37f	c5					.byte (("Does>"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=28					WordFlags ::= CO+IM+NN	; modifiable copy, remember for later
=36					LinkDisplacement = Nt0-WordListLink
>d380	1c					.byte WordFlags	;wh_Flags
>d381	03					.byte 3	;wh_CodeLength
>d382	24					  .byte LinkDisplacement	; offset to previous nt
=$d383					XtPtr1 ::= *
=54015					WordListLink ::= Nt0 ; remember the nt of this word for later
.d383					Does:
.d383	a0 d3		ldy #$d3			ldy #>_runtime		; compile JSR _runtime
.d385	a9 9d		lda #$9d			lda #<_runtime
.d387	20 25 df	jsr $df25			jsr Jsr_Comma_YA
.d38a	a9 68		lda #$68			lda #$68		; compile PLA  to pop RTS addr (PFA-1) to AY
.d38c	a0 a8		ldy #$a8			ldy #$a8		;    & TAY
.d38e	20 f6 de	jsr $def6			jsr Comma_YA
.d391	a9 68		lda #$68			lda #$68		; compile PLA
.d393	20 df de	jsr $dedf			jsr C_Comma_A
.d396	a0 d3		ldy #$d3			ldy #>_DoDoes		; compile JSR _DoDoes
.d398	a9 ba		lda #$ba			lda #<_DoDoes
.d39a	4c 25 df	jmp $df25			jmp Jsr_Comma_YA
=26					CodeLen	.var *-XtPtr1
=$d39d					Here1 = *	; remember here
>d381	1a					.byte CodeLen	;patch wh_CodeLength
.d39d					_runtime:
.d39d	20 e7 cb	jsr $cbe7			jsr current_to_dp	; Grab the DP from the CURRENT wordlist.
.d3a0	a5 10		lda $10				lda dp+0		; tmp1= dp
.d3a2	a4 11		ldy $11				ldy dp+1
.d3a4	85 14		sta $14				sta tmp1+0
.d3a6	84 15		sty $15				sty tmp1+1
.d3a8	20 49 cf	jsr $cf49			jsr NameToIntTmp	; tmp2= xt
.d3ab	18		clc				clc
.d3ac	68		pla				pla		; RTS addr LSB
.d3ad	69 01		adc #$01			adc #1		;   +1 for JSR bahavior
.d3af	a0 01		ldy #$01			ldy #1
.d3b1	91 16		sta ($16),y			sta (tmp2),y
.d3b3	68		pla				pla		; RTS addr MSB
.d3b4	69 00		adc #$00			adc #0
.d3b6	c8		iny				iny
.d3b7	91 16		sta ($16),y			sta (tmp2),y
.d3b9	60		rts				rts
.d3ba					_DoDoes:
.d3ba	c8		iny				iny		; +1 for JSR behavior
.d3bb	d0 03		bne $d3c0			bne +
.d3bd	18		clc				clc
.d3be	69 01		adc #$01			adc #1
.d3c0					+
.d3c0	4c 99 e1	jmp $e199			jmp PushAY
>d3c3	43 70 45 6e 64			Name0:	.text "CpEnd"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=54088					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>d3c8	85					.byte (("CpEnd"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=73					LinkDisplacement = Nt0-WordListLink
>d3c9	10					.byte WordFlags	;wh_Flags
>d3ca	03					.byte 3	;wh_CodeLength
>d3cb	49					  .byte LinkDisplacement	; offset to previous nt
=$d3cc					XtPtr1 ::= *
=54088					WordListLink ::= Nt0 ; remember the nt of this word for later
.d3cc	a9 00		lda #$00			lda #<cp_end
.d3ce	a0 80		ldy #$80			ldy #>cp_end
.d3d0	4c 2e c9	jmp $c92e			jmp PushYA
=7					CodeLen	.var *-XtPtr1
=$d3d3					Here1 = *	; remember here
>d3ca	07					.byte CodeLen	;patch wh_CodeLength
>d3d3	55 6e 75 73 65 64		Name0:	.text "Unused"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=54105					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>d3d9	86					.byte (("Unused"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=17					LinkDisplacement = Nt0-WordListLink
>d3da	10					.byte WordFlags	;wh_Flags
>d3db	03					.byte 3	;wh_CodeLength
>d3dc	11					  .byte LinkDisplacement	; offset to previous nt
=$d3dd					XtPtr1 ::= *
=54105					WordListLink ::= Nt0 ; remember the nt of this word for later
.d3dd					Unused:
=32600					_last = cp_end-2*padoffset
.d3dd	38		sec				sec
.d3de	a9 58		lda #$58			lda #<_last
.d3e0	e5 00		sbc $00				sbc cp+0
.d3e2	a8		tay				tay
.d3e3	a9 7f		lda #$7f			lda #>_last
.d3e5	e5 01		sbc $01				sbc cp+1
.d3e7	4c 99 e1	jmp $e199			jmp PushAY
=13					CodeLen	.var *-XtPtr1
=$d3ea					Here1 = *	; remember here
>d3db	0d					.byte CodeLen	;patch wh_CodeLength
>d3ea	44 65 70 74 68			Name0:	.text "Depth"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=54127					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>d3ef	05					.byte (("Depth"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=22					LinkDisplacement = Nt0-WordListLink
>d3f0	10					.byte WordFlags	;wh_Flags
>d3f1	03					.byte 3	;wh_CodeLength
>d3f2	16					  .byte LinkDisplacement	; offset to previous nt
=$d3f3					XtPtr1 ::= *
=54127					WordListLink ::= Nt0 ; remember the nt of this word for later
.d3f3					Depth:
.d3f3	a9 30		lda #$30			lda #DSDim*2	; A= DSDim*2 - X
.d3f5	86 1a		stx $1a				stx tmp4
.d3f7	38		sec				sec
.d3f8	e5 1a		sbc $1a				sbc tmp4
.d3fa	4a		lsr a				lsr		; divide by two because each cell is two bytes
.d3fb	4c 5d c9	jmp $c95d			jmp PushZA
=11					CodeLen	.var *-XtPtr1
=$d3fe					Here1 = *	; remember here
>d3f1	0b					.byte CodeLen	;patch wh_CodeLength
>d3fe	4b 65 79			Name0:	.text "Key"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=54145					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>d401	23					.byte (("Key"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=18					LinkDisplacement = Nt0-WordListLink
>d402	10					.byte WordFlags	;wh_Flags
>d403	03					.byte 3	;wh_CodeLength
>d404	12					  .byte LinkDisplacement	; offset to previous nt
=$d405					XtPtr1 ::= *
=54145					WordListLink ::= Nt0 ; remember the nt of this word for later
.d405	20 0b d4	jsr $d40b	Key:		jsr key_a		; returns char in A
.d408	4c 5d c9	jmp $c95d			jmp PushZA
=6					CodeLen	.var *-XtPtr1
=$d40b					Here1 = *	; remember here
>d403	06					.byte CodeLen	;patch wh_CodeLength
.d40b					Key_A:
.d40b	6c 08 03	jmp ($0308)			jmp (input)		; JSR/RTS
>d40e	4b 65 79 3f			Name0:	.text "Key?"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=54162					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>d412	e4					.byte (("Key?"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=17					LinkDisplacement = Nt0-WordListLink
>d413	10					.byte WordFlags	;wh_Flags
>d414	03					.byte 3	;wh_CodeLength
>d415	11					  .byte LinkDisplacement	; offset to previous nt
=$d416					XtPtr1 ::= *
=54162					WordListLink ::= Nt0 ; remember the nt of this word for later
.d416	20 1c d4	jsr $d41c	KeyQ:		jsr KeyQ_A
.d419	4c 5d c9	jmp $c95d			jmp PushZA
.d41c	6c 0a 03	jmp ($030a)	KeyQ_A:		jmp (HaveKey)
>d41f	52 65 66 69 6c 6c		Name0:	.text "Refill"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=54181					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>d425	86					.byte (("Refill"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=19					LinkDisplacement = Nt0-WordListLink
>d426	10					.byte WordFlags	;wh_Flags
>d427	03					.byte 3	;wh_CodeLength
>d428	13					  .byte LinkDisplacement	; offset to previous nt
=$d429					XtPtr1 ::= *
=54181					WordListLink ::= Nt0 ; remember the nt of this word for later
.d429					Refill:
.d429	a9 00		lda #$00			lda #0			; show empty in case of error
.d42b	85 06		sta $06				sta ciblen+0
.d42d	85 07		sta $07				sta ciblen+1
.d42f	a5 02		lda $02				lda insrc		; cheat: We only check LSB
.d431	d0 24		bne $d457			bne _src_not_kbd
.d433	a5 04		lda $04				lda cib+0		; address of CIB is NOS
.d435	a4 05		ldy $05				ldy cib+1
.d437	20 2e c9	jsr $c92e			jsr PushYA
.d43a	a9 ff		lda #$ff			lda #bsize		; max number of chars is TOS
.d43c	20 5d c9	jsr $c95d			jsr PushZA		;  cheat: We only accept max 255
.d43f	20 70 d4	jsr $d470			jsr Accept		; ( addr n1 -- n2)
.d442	b5 26		lda $26,x			lda DStack+0,x
.d444	85 06		sta $06				sta ciblen+0
.d446	b5 27		lda $27,x			lda DStack+1,x
.d448	85 07		sta $07				sta ciblen+1		; though we only accept 255 chars
.d44a	a9 00		lda #$00			lda #0
.d44c	85 08		sta $08				sta toin+0
.d44e	85 09		sta $09				sta toin+1
.d450	a9 ff		lda #$ff			lda #$FF		; overwrite with TRUE flag
.d452	95 26		sta $26,x			sta DStack+0,x
.d454	95 27		sta $27,x			sta DStack+1,x
.d456	60		rts				rts
.d457					_src_not_kbd:
.d457	c9 ff		cmp #$ff			cmp #$ff
.d459	d0 03		bne $d45e			bne _src_not_string
.d45b	4c 4f c9	jmp $c94f			jmp False
.d45e					_src_not_string:
.d45e	a9 eb		lda #$eb			lda #$100+err_Unsupported
.d460	20 dc c5	jsr $c5dc			jsr ThrowA
=58					CodeLen	.var *-XtPtr1
=$d463					Here1 = *	; remember here
>d427	3a					.byte CodeLen	;patch wh_CodeLength
.d463	4c ae c5	jmp $c5ae	Throw_Stack_06: jmp Throw_Stack
>d466	41 63 63 65 70 74		Name0:	.text "Accept"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=54252					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>d46c	86					.byte (("Accept"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=71					LinkDisplacement = Nt0-WordListLink
>d46d	10					.byte WordFlags	;wh_Flags
>d46e	03					.byte 3	;wh_CodeLength
>d46f	47					  .byte LinkDisplacement	; offset to previous nt
=$d470					XtPtr1 ::= *
=54252					WordListLink ::= Nt0 ; remember the nt of this word for later
.d470					Accept:
.d470	e0 2d		cpx #$2d		cpx #(DSDim-2)*2+1	; far enough below end of data stack (& not negative)?
.d472	b0 ef		bcs $d463		bcs Throw_Stack_06
.d474	b5 26		lda $26,x			lda DStack+0,x		; Abort if we were asked to receive 0 chars
.d476	15 27		ora $27,x			ora DStack+1,x
.d478	d0 09		bne $d483			bne _not_zero
.d47a	e8		inx				inx			; drop n
.d47b	e8		inx				inx
.d47c	95 26		sta $26,x			sta DStack+0,x		; replace addr with 0
.d47e	95 27		sta $27,x			sta DStack+1,x
.d480	4c 58 d5	jmp $d558			jmp accept_done
.d483					_not_zero:
.d483	b5 26		lda $26,x			lda DStack+0,x	; number of chars to get in tmp2 ...
.d485	85 16		sta $16				sta tmp2
.d487	a9 00		lda #$00			lda #0
.d489	85 17		sta $17				sta tmp2+1	; ... but we only accept max 255 chars
.d48b	b5 28		lda $28,x			lda DStack+2,x	; address of buffer is NOS, to tmp1
.d48d	85 14		sta $14				sta tmp1
.d48f	b5 29		lda $29,x			lda DStack+3,x
.d491	85 15		sta $15				sta tmp1+1
.d493	e8		inx				inx
.d494	e8		inx				inx
.d495	a0 00		ldy #$00			ldy #0
.d497	a5 0c		lda $0c				lda status
.d499	29 f7		and #$f7			and #$f7
.d49b	18		clc				clc
.d49c	69 01		adc #$01			adc #1
.d49e	09 08		ora #$08			ora #$08
.d4a0	85 0c		sta $0c				sta status
.d4a2					accept_loop:
.d4a2	20 0b d4	jsr $d40b			jsr key_a
.d4a5	c9 0a		cmp #$0a			cmp #AscLF
.d4a7	f0 20		beq $d4c9			beq _eol
.d4a9	c9 0d		cmp #$0d			cmp #AscCR
.d4ab	f0 1c		beq $d4c9			beq _eol
.d4ad	c9 08		cmp #$08			cmp #AscBS
.d4af	f0 24		beq $d4d5			beq _backspace
.d4b1	c9 7f		cmp #$7f			cmp #AscDEL	; (CTRL-h)
.d4b3	f0 20		beq $d4d5			beq _backspace
.d4b5	c9 10		cmp #$10			cmp #AscCP
.d4b7	f0 37		beq $d4f0			beq _ctrl_p
.d4b9	c9 0e		cmp #$0e			cmp #AscCN
.d4bb	f0 46		beq $d503			beq _ctrl_n
.d4bd	91 14		sta ($14),y			sta (tmp1),y
.d4bf	c8		iny				iny
.d4c0	20 cd df	jsr $dfcd			jsr Emit_A
.d4c3	c4 16		cpy $16				cpy tmp2	; reached character limit?
.d4c5	d0 db		bne $d4a2			bne accept_loop	      ; fall through if buffer limit reached
.d4c7	f0 03		beq $d4cc			beq _buffer_full
.d4c9					_eol:
.d4c9	20 e5 df	jsr $dfe5			jsr Space	; print final space
.d4cc					_buffer_full:
.d4cc	94 26		sty $26,x			sty DStack+0,x	; Y contains number of chars accepted already
.d4ce	a9 00		lda #$00			lda #0
.d4d0	95 27		sta $27,x			sta DStack+1,x		; we only accept 256 chars
.d4d2	4c 58 d5	jmp $d558			jmp accept_done
.d4d5					_backspace:
.d4d5	c0 00		cpy #$00			cpy #0		; buffer empty?
.d4d7	d0 06		bne $d4df			bne +
.d4d9	a9 07		lda #$07			lda #AscBELL	; complain and don't delete beyond the start of line
.d4db	20 cd df	jsr $dfcd			jsr Emit_A
.d4de	c8		iny				iny
.d4df					+
.d4df	88		dey				dey
.d4e0	a9 08		lda #$08			lda #AscBS	; move back one
.d4e2	20 cd df	jsr $dfcd			jsr Emit_A
.d4e5	20 e5 df	jsr $dfe5			jsr Space	; print a space (rubout)
.d4e8	a9 08		lda #$08			lda #AscBS	; move back over space
.d4ea	20 cd df	jsr $dfcd			jsr Emit_A
.d4ed	4c a2 d4	jmp $d4a2			jmp accept_loop
.d4f0					_ctrl_p:
.d4f0	a5 0c		lda $0c				lda status
.d4f2	29 07		and #$07			and #7
.d4f4	d0 08		bne $d4fe			bne _ctrl_p_dec
.d4f6	a5 0c		lda $0c				lda status
.d4f8	09 07		ora #$07			ora #7
.d4fa	85 0c		sta $0c				sta status
.d4fc	d0 14		bne $d512			bne _recall_history
.d4fe					_ctrl_p_dec:
.d4fe	c6 0c		dec $0c				dec status
.d500	4c 12 d5	jmp $d512			jmp _recall_history
.d503					_ctrl_n:
.d503	a9 08		lda #$08			lda #$8
.d505	24 0c		bit $0c				bit status
.d507	d0 09		bne $d512			bne _recall_history
.d509	a5 0c		lda $0c				lda status
.d50b	29 f7		and #$f7			and #$f7
.d50d	18		clc				clc
.d50e	69 01		adc #$01			adc #1
.d510	85 0c		sta $0c				sta status
.d512					_recall_history:
.d512	a9 f7		lda #$f7			lda #$ff-%00001000
.d514	25 0c		and $0c				and status
.d516	85 0c		sta $0c				sta status
.d518	20 73 d5	jsr $d573			jsr accept_total_recall
.d51b	a9 0d		lda #$0d			lda #AscCR
.d51d	20 cd df	jsr $dfcd			jsr Emit_A
.d520					input_clear:
.d520	c0 00		cpy #$00			cpy #0
.d522	f0 07		beq $d52b			beq input_cleared
.d524	20 e5 df	jsr $dfe5			jsr Space
.d527	88		dey				dey
.d528	4c 20 d5	jmp $d520			jmp input_clear
.d52b					input_cleared:
.d52b	a9 0d		lda #$0d			lda #AscCR
.d52d	20 cd df	jsr $dfcd			jsr Emit_A
.d530	b1 18		lda ($18),y			lda (tmp3),y
.d532	85 0d		sta $0d				sta status+1
.d534	e6 18		inc $18				inc tmp3
.d536	d0 02		bne $d53a			bne +		; Increment the upper byte on carry.
.d538	e6 19		inc $19				inc tmp3+1
.d53a					+
.d53a	a9 0d		lda #$0d			lda #AscCR
.d53c	20 cd df	jsr $dfcd			jsr Emit_A
.d53f					_history_loop:
.d53f	c4 0d		cpy $0d				cpy status+1
.d541	d0 03		bne $d546			bne +
.d543	4c a2 d4	jmp $d4a2			jmp accept_loop	      ; Needs a long jump
.d546					+
.d546	c4 16		cpy $16				cpy tmp2
.d548	f0 0a		beq $d554			beq _hist_filled_buffer
.d54a	b1 18		lda ($18),y			lda (tmp3),y
.d54c	91 14		sta ($14),y			sta (tmp1),y
.d54e	20 cd df	jsr $dfcd			jsr Emit_A
.d551	c8		iny				iny
.d552	d0 eb		bne $d53f			bne _history_loop
.d554					_hist_filled_buffer:
.d554	88		dey				dey
.d555	4c a2 d4	jmp $d4a2			jmp accept_loop
.d558					accept_done:
.d558	20 73 d5	jsr $d573			jsr accept_total_recall
.d55b	85 0d		sta $0d				sta status+1
.d55d	a0 00		ldy #$00			ldy #0
.d55f	91 18		sta ($18),y			sta (tmp3),y
.d561	e6 18		inc $18				inc tmp3
.d563	d0 02		bne $d567			bne +		; Increment the upper byte on carry.
.d565	e6 19		inc $19				inc tmp3+1
.d567					+
.d567					_save_history_loop:
.d567	c4 0d		cpy $0d				cpy status+1
.d569	f0 07		beq $d572			beq _save_history_done
.d56b	b1 14		lda ($14),y			lda (tmp1),y
.d56d	91 18		sta ($18),y			sta (tmp3),y
.d56f	c8		iny				iny
.d570	d0 f5		bne $d567			bne _save_history_loop
.d572					_save_history_done:
=258					CodeLen	.var *-XtPtr1
=$ff					CodeLen	 .var $ff
=$d572					Here1 = *	; remember here
>d46e	ff					.byte CodeLen	;patch wh_CodeLength
.d572	60		rts				rts
.d573					accept_total_recall:
.d573	a9 66		lda #$66			lda #<hist_buff
.d575	85 18		sta $18				sta tmp3
.d577	a9 07		lda #$07			lda #>hist_buff
.d579	85 19		sta $19				sta tmp3+1
.d57b	a5 0c		lda $0c				lda status
.d57d	6a		ror a				ror
.d57e	29 03		and #$03			and #3
.d580	18		clc				clc
.d581	65 19		adc $19				adc tmp3+1
.d583	85 19		sta $19				sta tmp3+1
.d585	a5 0c		lda $0c				lda status
.d587	6a		ror a				ror		; Rotate through carry into msb.
.d588	6a		ror a				ror
.d589	29 80		and #$80			and #$80
.d58b	18		clc				clc
.d58c	65 18		adc $18				adc tmp3
.d58e	85 18		sta $18				sta tmp3
.d590	90 02		bcc $d594			bcc +		; Increment the upper byte on carry.
.d592	e6 19		inc $19				inc tmp3+1
.d594					+
.d594	98		tya				tya
.d595	c9 80		cmp #$80			cmp #$80
.d597	90 02		bcc $d59b			bcc +
.d599	a9 7f		lda #$7f			lda #$7F
.d59b					+
.d59b	60		rts				rts
>d59c	49 6e 70 75 74 3e 52		Name0:	.text "Input>R"	;  name of word as a string, ending at wh_NameLastChar
=7					NameLength = *-Name0
=54563					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>d5a3	47					.byte (("Input>R"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$30					WordFlags ::= NN|ST	; modifiable copy, remember for later
=311					LinkDisplacement = Nt0-WordListLink
=$31						  WordFlags ::= WordFlags | FP
>d5a4	31					.byte WordFlags	;wh_Flags
>d5a5	03					.byte 3	;wh_CodeLength
>d5a6	ec d3					  .word WordListLink
=$d5a8					XtPtr1 ::= *
=54563					WordListLink ::= Nt0 ; remember the nt of this word for later
.d5a8					Input_To_R:
.d5a8	68		pla				pla			; move it out of the way
.d5a9	85 14		sta $14				sta tmp1+0
.d5ab	68		pla				pla
.d5ac	85 15		sta $15				sta tmp1+1
.d5ae	a0 07		ldy #$07			ldy #7
.d5b0	b9 02 00	lda $0002,y	_loop:		lda InSrc,y	; insrc+7 is toin+1
.d5b3	48		pha				pha
.d5b4	88		dey				dey
.d5b5	10 f9		bpl $d5b0			bpl _loop
.d5b7	a5 15		lda $15				lda tmp1+1		; Restore address for return jump
.d5b9	48		pha				pha
.d5ba	a5 14		lda $14				lda tmp1+0
.d5bc	48		pha				pha
=21					CodeLen	.var *-XtPtr1
=$d5bd					Here1 = *	; remember here
>d5a5	15					.byte CodeLen	;patch wh_CodeLength
.d5bd	60		rts				rts
>d5be	52 3e 49 6e 70 75 74		Name0:	.text "R>Input"	;  name of word as a string, ending at wh_NameLastChar
=7					NameLength = *-Name0
=54597					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>d5c5	87					.byte (("R>Input"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$30					WordFlags ::= ST	; modifiable copy, remember for later
=34					LinkDisplacement = Nt0-WordListLink
>d5c6	30					.byte WordFlags	;wh_Flags
>d5c7	03					.byte 3	;wh_CodeLength
>d5c8	22					  .byte LinkDisplacement	; offset to previous nt
=$d5c9					XtPtr1 ::= *
=54597					WordListLink ::= Nt0 ; remember the nt of this word for later
.d5c9					R_To_Input:
.d5c9	68		pla				pla		 ; move RTS addr out of the way
.d5ca	85 14		sta $14				sta tmp1+0
.d5cc	68		pla				pla
.d5cd	85 15		sta $15				sta tmp1+1
.d5cf	a0 00		ldy #$00			ldy #0
.d5d1	68		pla		_loop:		pla
.d5d2	99 02 00	sta $0002,y			sta InSrc,y ; also cib ciblen toin
.d5d5	c8		iny				iny
.d5d6	c0 08		cpy #$08			cpy #8
.d5d8	d0 f7		bne $d5d1			bne _loop
.d5da	a5 15		lda $15				lda tmp1+1	; Restore RTS address
.d5dc	48		pha				pha
.d5dd	a5 14		lda $14				lda tmp1+0
.d5df	48		pha				pha
=23					CodeLen	.var *-XtPtr1
=$d5e0					Here1 = *	; remember here
>d5c7	17					.byte CodeLen	;patch wh_CodeLength
.d5e0	60		rts				rts
>d5e1	49 4b 65 79			Name0:	.text "IKey"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=54629					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>d5e5	24					.byte (("IKey"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=32					LinkDisplacement = Nt0-WordListLink
>d5e6	10					.byte WordFlags	;wh_Flags
>d5e7	03					.byte 3	;wh_CodeLength
>d5e8	20					  .byte LinkDisplacement	; offset to previous nt
=$d5e9					XtPtr1 ::= *
=54629					WordListLink ::= Nt0 ; remember the nt of this word for later
.d5e9					IKey:
.d5e9	20 6b c9	jsr $c96b	_again:		jsr Zero
.d5ec	20 6b c9	jsr $c96b			jsr Zero	; ( ud )
.d5ef	20 04 dc	jsr $dc04			jsr Here
.d5f2	20 8a e1	jsr $e18a			jsr Dup		; get text
.d5f5	a9 10		lda #$10			lda #16
.d5f7	20 5d c9	jsr $c95d			jsr PushZA
.d5fa	20 70 d4	jsr $d470			jsr Accept	; ( ud addr len )
.d5fd	a1 28		lda ($28,x)			lda (DStack+2,x) ; negative?
.d5ff	c9 2d		cmp #$2d			cmp #'-'
.d601	08		php				php		;  save sign
.d602	d0 06		bne $d60a			bne +
.d604	20 42 dc	jsr $dc42			jsr NOS_One_Plus ;   eat the '-'
.d607	20 11 dc	jsr $dc11			jsr One_Minus
.d60a					+
.d60a	20 b4 c1	jsr $c1b4			jsr To_Number ; ( ud addr u -- ud addr u )  Continue convert a string to an integer
.d60d	e8		inx				inx		; Drop len
.d60e	e8		inx				inx
.d60f	e8		inx				inx		; Drop addr
.d610	e8		inx				inx
.d611	e8		inx				inx		; UD>S
.d612	e8		inx				inx
.d613	b5 20		lda $20,x			lda DStack-6,x	; string all consumed?
.d615	f0 11		beq $d628			beq _ok
.d617	e8		inx		_err:		inx		; Drop u
.d618	e8		inx				inx
.d619	28		plp				plp		; RDrop saved sign
.d61a	20 e5 df	jsr $dfe5			jsr Space	; prompt again
.d61d	a9 3f		lda #$3f			lda #'?'
.d61f	20 cd df	jsr $dfcd			jsr Emit_A
.d622	20 e5 df	jsr $dfe5			jsr Space
.d625	4c e9 d5	jmp $d5e9			jmp _again	; try it again
.d628	28		plp		_ok:		plp		; apply sign
.d629	d0 03		bne $d62e			bne +
.d62b	20 7b d8	jsr $d87b			jsr Negate
.d62e					+
.d62e	60		rts				rts
=70					CodeLen	.var *-XtPtr1
=$d62f					Here1 = *	; remember here
>d5e7	46					.byte CodeLen	;patch wh_CodeLength
>d62f	42 6f 75 6e 64 73		Name0:	.text "Bounds"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=54709					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>d635	66					.byte (("Bounds"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=80					LinkDisplacement = Nt0-WordListLink
>d636	10					.byte WordFlags	;wh_Flags
>d637	03					.byte 3	;wh_CodeLength
>d638	50					  .byte LinkDisplacement	; offset to previous nt
=$d639					XtPtr1 ::= *
=54709					WordListLink ::= Nt0 ; remember the nt of this word for later
.d639					Bounds:
.d639	e0 2d		cpx #$2d		cpx #(DSDim-2)*2+1	; far enough below end of data stack (& not negative)?
.d63b	b0 14		bcs $d651		bcs Throw_Stack_22
.d63d	18		clc				clc
.d63e	b5 28		lda $28,x			lda DStack+2,x		; LSB addr
.d640	a8		tay				tay
.d641	75 26		adc $26,x			adc DStack+0,x		; LSB u
.d643	95 28		sta $28,x			sta DStack+2,x		; LSB addr+u
.d645	94 26		sty $26,x			sty DStack+0,x
.d647	b5 29		lda $29,x			lda DStack+3,x		; MSB addr
.d649	a8		tay				tay
.d64a	75 27		adc $27,x			adc DStack+1,x		; MSB u
.d64c	95 29		sta $29,x			sta DStack+3,x		; MSB addr+u
.d64e	94 27		sty $27,x			sty DStack+1,x
=23					CodeLen	.var *-XtPtr1
=$d650					Here1 = *	; remember here
>d637	17					.byte CodeLen	;patch wh_CodeLength
.d650	60		rts				rts
.d651	4c ae c5	jmp $c5ae	Throw_Stack_22: jmp Throw_Stack
>d654	53 70 61 63 65 73		Name0:	.text "Spaces"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=54746					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>d65a	66					.byte (("Spaces"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=37					LinkDisplacement = Nt0-WordListLink
>d65b	10					.byte WordFlags	;wh_Flags
>d65c	03					.byte 3	;wh_CodeLength
>d65d	25					  .byte LinkDisplacement	; offset to previous nt
=$d65e					XtPtr1 ::= *
=54746					WordListLink ::= Nt0 ; remember the nt of this word for later
.d65e					Spaces:
.d65e	e0 2f		cpx #$2f		cpx #(DSDim-1)*2+1	; far enough below end of data stack (& not negative)?
.d660	b0 ef		bcs $d651		bcs Throw_Stack_22
.d662	4c 68 d6	jmp $d668			jmp _test
.d665					_loop:
.d665	20 e5 df	jsr $dfe5			jsr Space		; print a space
.d668	d6 26		dec $26,x	_test:		dec DStack+0,x		; decrement & test
.d66a	10 f9		bpl $d665			bpl _loop
.d66c	e8		inx				inx			; Drop
.d66d	e8		inx				inx
=16					CodeLen	.var *-XtPtr1
=$d66e					Here1 = *	; remember here
>d65c	10					.byte CodeLen	;patch wh_CodeLength
.d66e	60		rts				rts
>d66f	2d 54 72 61 69 6c 69 6e		Name0:	.text "-Trailing"	;  name of word as a string, ending at wh_NameLastChar
>d677	67
=9					NameLength = *-Name0
=54776					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>d678	e9					.byte (("-Trailing"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=30					LinkDisplacement = Nt0-WordListLink
>d679	10					.byte WordFlags	;wh_Flags
>d67a	03					.byte 3	;wh_CodeLength
>d67b	1e					  .byte LinkDisplacement	; offset to previous nt
=$d67c					XtPtr1 ::= *
=54776					WordListLink ::= Nt0 ; remember the nt of this word for later
.d67c					Minus_trailing:
.d67c	e0 2d		cpx #$2d		cpx #(DSDim-2)*2+1	; far enough below end of data stack (& not negative)?
.d67e	b0 78		bcs $d6f8		bcs Throw_Stack_20
.d680	b5 28		lda $28,x			lda DStack+2,x		; tmp1= addr + (u1 & $ff00)
.d682	85 14		sta $14				sta tmp1+0
.d684	b5 29		lda $29,x			lda DStack+3,x
.d686	18		clc				clc
.d687	75 27		adc $27,x			adc DStack+1,x
.d689	85 15		sta $15				sta tmp1+1
.d68b	b4 26		ldy $26,x			ldy DStack+0,x
.d68d	88		dey		_loop:		dey			; back 1 char
.d68e	c0 ff		cpy #$ff			cpy #$ff
.d690	d0 06		bne $d698			bne +
.d692	c6 15		dec $15				dec tmp1+1		;   back 1 page
.d694	d6 27		dec $27,x			dec DStack+1,x
.d696	30 06		bmi $d69e			bmi _done
.d698					+
.d698	b1 14		lda ($14),y			lda (tmp1),y		; if blank, keep going
.d69a	c9 20		cmp #$20			cmp #AscSP
.d69c	f0 ef		beq $d68d			beq _loop
.d69e	c8		iny		_done:		iny			; forward 1 char
.d69f	d0 02		bne $d6a3			bne +
.d6a1	f6 27		inc $27,x			inc DStack+1,x
.d6a3	94 26		sty $26,x	+		sty DStack+0,x
=41					CodeLen	.var *-XtPtr1
=$d6a5					Here1 = *	; remember here
>d67a	29					.byte CodeLen	;patch wh_CodeLength
.d6a5	60		rts				rts
>d6a6	2d 4c 65 61 64 69 6e 67		Name0:	.text "-Leading"	;  name of word as a string, ending at wh_NameLastChar
=8					NameLength = *-Name0
=54830					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>d6ae	e8					.byte (("-Leading"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=54					LinkDisplacement = Nt0-WordListLink
>d6af	10					.byte WordFlags	;wh_Flags
>d6b0	03					.byte 3	;wh_CodeLength
>d6b1	36					  .byte LinkDisplacement	; offset to previous nt
=$d6b2					XtPtr1 ::= *
=54830					WordListLink ::= Nt0 ; remember the nt of this word for later
.d6b2					Minus_leading:
.d6b2	e0 2d		cpx #$2d		cpx #(DSDim-2)*2+1	; far enough below end of data stack (& not negative)?
.d6b4	b0 42		bcs $d6f8		bcs Throw_Stack_20
.d6b6					_loop:
.d6b6	b5 26		lda $26,x			lda DStack+0,x		; chars left?
.d6b8	15 27		ora $27,x			ora DStack+1,x
.d6ba	f0 0f		beq $d6cb			beq _done
.d6bc	a1 28		lda ($28,x)			lda (DStack+2,x)	; get first character
.d6be	c9 21		cmp #$21			cmp #AscSP+1		;   is_whitespace
.d6c0	b0 09		bcs $d6cb			bcs _done
.d6c2	20 42 dc	jsr $dc42			jsr NOS_One_Plus
.d6c5	20 15 dc	jsr $dc15			jsr One_Minus_NoUF
.d6c8	4c b6 d6	jmp $d6b6			jmp _loop
.d6cb					_done:
=25					CodeLen	.var *-XtPtr1
=$d6cb					Here1 = *	; remember here
>d6b0	19					.byte CodeLen	;patch wh_CodeLength
.d6cb	60		rts				rts
>d6cc	2f 53 74 72 69 6e 67		Name0:	.text "/String"	;  name of word as a string, ending at wh_NameLastChar
=7					NameLength = *-Name0
=54867					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>d6d3	e7					.byte (("/String"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=37					LinkDisplacement = Nt0-WordListLink
>d6d4	10					.byte WordFlags	;wh_Flags
>d6d5	03					.byte 3	;wh_CodeLength
>d6d6	25					  .byte LinkDisplacement	; offset to previous nt
=$d6d7					XtPtr1 ::= *
=54867					WordListLink ::= Nt0 ; remember the nt of this word for later
.d6d7					Slash_String:
.d6d7	e0 2b		cpx #$2b		cpx #(DSDim-3)*2+1	; far enough below end of data stack (& not negative)?
.d6d9	b0 1d		bcs $d6f8		bcs Throw_Stack_20
.d6db	18		clc				clc		; addr += n
.d6dc	b5 26		lda $26,x			lda DStack+0,x
.d6de	75 2a		adc $2a,x			adc DStack+4,x
.d6e0	95 2a		sta $2a,x			sta DStack+4,x
.d6e2	b5 27		lda $27,x			lda DStack+1,x
.d6e4	75 2b		adc $2b,x			adc DStack+5,x
.d6e6	95 2b		sta $2b,x			sta DStack+5,x
.d6e8	38		sec				sec		; u -= n
.d6e9	b5 28		lda $28,x			lda DStack+2,x
.d6eb	f5 26		sbc $26,x			sbc DStack+0,x
.d6ed	95 28		sta $28,x			sta DStack+2,x
.d6ef	b5 29		lda $29,x			lda DStack+3,x
.d6f1	f5 27		sbc $27,x			sbc DStack+1,x
.d6f3	95 29		sta $29,x			sta DStack+3,x
.d6f5	e8		inx				inx		; Drop n
.d6f6	e8		inx				inx
=32					CodeLen	.var *-XtPtr1
=$d6f7					Here1 = *	; remember here
>d6d5	20					.byte CodeLen	;patch wh_CodeLength
.d6f7	60		rts				rts
.d6f8	4c ae c5	jmp $c5ae	Throw_Stack_20: jmp Throw_Stack
>d6fb	32 44 72 6f 70			Name0:	.text "2Drop"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=54912					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>d700	05					.byte (("2Drop"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=45					LinkDisplacement = Nt0-WordListLink
>d701	10					.byte WordFlags	;wh_Flags
>d702	03					.byte 3	;wh_CodeLength
>d703	2d					  .byte LinkDisplacement	; offset to previous nt
=$d704					XtPtr1 ::= *
=54912					WordListLink ::= Nt0 ; remember the nt of this word for later
.d704					Two_drop:
.d704	e0 2d		cpx #$2d		cpx #(DSDim-2)*2+1	; far enough below end of data stack (& not negative)?
.d706	b0 f0		bcs $d6f8		bcs Throw_Stack_20
.d708	e8		inx				inx
.d709	e8		inx				inx
.d70a	e8		inx				inx
.d70b	e8		inx				inx
=8					CodeLen	.var *-XtPtr1
=$d70c					Here1 = *	; remember here
>d702	08					.byte CodeLen	;patch wh_CodeLength
.d70c	60		rts				rts
>d70d	32 53 77 61 70			Name0:	.text "2Swap"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=54930					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>d712	05					.byte (("2Swap"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=18					LinkDisplacement = Nt0-WordListLink
>d713	10					.byte WordFlags	;wh_Flags
>d714	03					.byte 3	;wh_CodeLength
>d715	12					  .byte LinkDisplacement	; offset to previous nt
=$d716					XtPtr1 ::= *
=54930					WordListLink ::= Nt0 ; remember the nt of this word for later
.d716					Two_Swap:
.d716	e0 29		cpx #$29		cpx #(DSDim-4)*2+1	; far enough below end of data stack (& not negative)?
.d718	b0 de		bcs $d6f8		bcs Throw_Stack_20
.d71a	86 14		stx $14				stx tmp1
.d71c	ca		dex				dex
.d71d	ca		dex				dex
.d71e	ca		dex				dex
.d71f	ca		dex				dex
.d720	e8		inx		_loop:		inx
.d721	b5 29		lda $29,x			lda DStack+3,x	; 3 <-> 7
.d723	b4 2d		ldy $2d,x			ldy DStack+7,x
.d725	95 2d		sta $2d,x			sta DStack+7,x
.d727	94 29		sty $29,x			sty DStack+3,x
.d729	e4 14		cpx $14				cpx tmp1
.d72b	90 f3		bcc $d720			bcc _loop
=23					CodeLen	.var *-XtPtr1
=$d72d					Here1 = *	; remember here
>d714	17					.byte CodeLen	;patch wh_CodeLength
.d72d	60		rts				rts
>d72e	32 4f 76 65 72			Name0:	.text "2Over"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=54963					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>d733	45					.byte (("2Over"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=33					LinkDisplacement = Nt0-WordListLink
>d734	10					.byte WordFlags	;wh_Flags
>d735	03					.byte 3	;wh_CodeLength
>d736	21					  .byte LinkDisplacement	; offset to previous nt
=$d737					XtPtr1 ::= *
=54963					WordListLink ::= Nt0 ; remember the nt of this word for later
.d737					Two_over:
.d737	e0 29		cpx #$29		cpx #(DSDim-4)*2+1	; far enough below end of data stack (& not negative)?
.d739	b0 bd		bcs $d6f8		bcs Throw_Stack_20
.d73b	a0 04		ldy #$04			ldy #4
.d73d	ca		dex		_loop:		dex
.d73e	b5 2e		lda $2e,x			lda DStack+8,x
.d740	95 26		sta $26,x			sta DStack+0,x
.d742	88		dey				dey
.d743	d0 f8		bne $d73d			bne _loop
=14					CodeLen	.var *-XtPtr1
=$d745					Here1 = *	; remember here
>d735	0e					.byte CodeLen	;patch wh_CodeLength
.d745	60		rts				rts
>d746	32 21				Name0:	.text "2!"	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=54984					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>d748	22					.byte (("2!"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=21					LinkDisplacement = Nt0-WordListLink
>d749	10					.byte WordFlags	;wh_Flags
>d74a	03					.byte 3	;wh_CodeLength
>d74b	15					  .byte LinkDisplacement	; offset to previous nt
=$d74c					XtPtr1 ::= *
=54984					WordListLink ::= Nt0 ; remember the nt of this word for later
.d74c	20 62 c5	jsr $c562	Two_Store:	jsr PopYA
.d74f	85 14		sta $14		Two_Store_YA:	sta tmp1+0	; save addr
.d751	84 15		sty $15				sty tmp1+1
.d753	e0 2d		cpx #$2d		cpx #(DSDim-2)*2+1	; far enough below end of data stack (& not negative)?
.d755	b0 a1		bcs $d6f8		bcs Throw_Stack_20
.d757	b5 26		lda $26,x			lda DStack+0,x	; copy MSB
.d759	a0 00		ldy #$00			ldy #0
.d75b	91 14		sta ($14),y			sta (tmp1),y
.d75d	b5 27		lda $27,x			lda DStack+1,x	; copy next
.d75f	c8		iny				iny
.d760	91 14		sta ($14),y			sta (tmp1),y
.d762	b5 28		lda $28,x			lda DStack+2,x	; copy next
.d764	c8		iny				iny
.d765	91 14		sta ($14),y			sta (tmp1),y
.d767	b5 29		lda $29,x			lda DStack+3,x	; copy MSB
.d769	c8		iny				iny
.d76a	91 14		sta ($14),y			sta (tmp1),y
.d76c	e8		inx				inx		; 2Drop
.d76d	e8		inx				inx
.d76e	e8		inx				inx
.d76f	e8		inx				inx
=36					CodeLen	.var *-XtPtr1
=$d770					Here1 = *	; remember here
>d74a	24					.byte CodeLen	;patch wh_CodeLength
.d770	60		rts				rts
>d771	32 40				Name0:	.text "2@"	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=55027					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>d773	02					.byte (("2@"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=0					WordFlags ::= 0	; modifiable copy, remember for later
=43					LinkDisplacement = Nt0-WordListLink
>d774	00					.byte WordFlags	;wh_Flags
>d775	03					.byte 3	;wh_CodeLength
>d776	2b					  .byte LinkDisplacement	; offset to previous nt
=$d777					XtPtr1 ::= *
=55027					WordListLink ::= Nt0 ; remember the nt of this word for later
.d777	20 62 c5	jsr $c562	Two_fetch:	jsr PopYA
.d77a	85 14		sta $14		Two_Fetch_YA:	sta tmp1+0	; save addr
.d77c	84 15		sty $15				sty tmp1+1
.d77e	a0 00		ldy #$00			ldy #0
.d780					Two_Fetch_Tmp1Y:
.d780	ca		dex				dex
.d781	ca		dex				dex
.d782	ca		dex				dex
.d783	ca		dex				dex
.d784	b1 14		lda ($14),y			lda (tmp1),y	; copy LSB
.d786	95 26		sta $26,x			sta DStack+0,x
.d788	c8		iny				iny		; copy next
.d789	b1 14		lda ($14),y			lda (tmp1),y
.d78b	95 27		sta $27,x			sta DStack+1,x
.d78d	c8		iny				iny		; copy next
.d78e	b1 14		lda ($14),y			lda (tmp1),y
.d790	95 28		sta $28,x			sta DStack+2,x
.d792	c8		iny				iny		; copy next
.d793	b1 14		lda ($14),y			lda (tmp1),y
.d795	95 29		sta $29,x			sta DStack+3,x
=32					CodeLen	.var *-XtPtr1
=$d797					Here1 = *	; remember here
>d775	20					.byte CodeLen	;patch wh_CodeLength
.d797	60		rts				rts
>d798	44 40				Name0:	.text "D@"	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=55066					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>d79a	02					.byte (("D@"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=39					LinkDisplacement = Nt0-WordListLink
>d79b	10					.byte WordFlags	;wh_Flags
>d79c	03					.byte 3	;wh_CodeLength
>d79d	27					  .byte LinkDisplacement	; offset to previous nt
=$d79e					XtPtr1 ::= *
=55066					WordListLink ::= Nt0 ; remember the nt of this word for later
.d79e	20 62 c5	jsr $c562	DFetch:		jsr PopYA
.d7a1	85 14		sta $14		DFetchYA:	sta tmp1+0	; save addr
.d7a3	84 15		sty $15				sty tmp1+1
.d7a5	ca		dex				dex
.d7a6	ca		dex				dex
.d7a7	ca		dex				dex
.d7a8	ca		dex				dex
.d7a9	a0 00		ldy #$00			ldy #0
.d7ab	b1 14		lda ($14),y			lda (tmp1),y
.d7ad	95 28		sta $28,x			sta DStack+2,x
.d7af	c8		iny				iny
.d7b0	b1 14		lda ($14),y			lda (tmp1),y
.d7b2	95 29		sta $29,x			sta DStack+3,x
.d7b4	c8		iny				iny
.d7b5	b1 14		lda ($14),y			lda (tmp1),y
.d7b7	95 26		sta $26,x			sta DStack+0,x
.d7b9	c8		iny				iny
.d7ba	b1 14		lda ($14),y			lda (tmp1),y
.d7bc	95 27		sta $27,x			sta DStack+1,x
=32					CodeLen	.var *-XtPtr1
=$d7be					Here1 = *	; remember here
>d79c	20					.byte CodeLen	;patch wh_CodeLength
.d7be	60		rts				rts
>d7bf	44 21				Name0:	.text "D!"	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=55105					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>d7c1	22					.byte (("D!"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=39					LinkDisplacement = Nt0-WordListLink
>d7c2	10					.byte WordFlags	;wh_Flags
>d7c3	03					.byte 3	;wh_CodeLength
>d7c4	27					  .byte LinkDisplacement	; offset to previous nt
=$d7c5					XtPtr1 ::= *
=55105					WordListLink ::= Nt0 ; remember the nt of this word for later
.d7c5	20 62 c5	jsr $c562	DStore:		jsr PopYA
.d7c8	85 14		sta $14		DStoreYA:	sta tmp1+0	; save addr
.d7ca	84 15		sty $15				sty tmp1+1
.d7cc	b5 28		lda $28,x			lda DStack+2,x	; LSB
.d7ce	a0 00		ldy #$00			ldy #0
.d7d0	91 14		sta ($14),y			sta (tmp1),y
.d7d2	b5 29		lda $29,x			lda DStack+3,x
.d7d4	c8		iny				iny
.d7d5	91 14		sta ($14),y			sta (tmp1),y
.d7d7	b5 26		lda $26,x			lda DStack+0,x
.d7d9	c8		iny				iny
.d7da	91 14		sta ($14),y			sta (tmp1),y
.d7dc	b5 27		lda $27,x			lda DStack+1,x	; MSB
.d7de	c8		iny				iny
.d7df	91 14		sta ($14),y			sta (tmp1),y
.d7e1	4c 04 d7	jmp $d704			jmp Two_Drop	; also check underflow, return
=31					CodeLen	.var *-XtPtr1
=$d7e4					Here1 = *	; remember here
>d7c3	1f					.byte CodeLen	;patch wh_CodeLength
>d7e4	32 52 40			Name0:	.text "2R@"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=55143					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>d7e7	03					.byte (("2R@"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=20					WordFlags ::= CO+NN	; modifiable copy, remember for later
=38					LinkDisplacement = Nt0-WordListLink
>d7e8	14					.byte WordFlags	;wh_Flags
>d7e9	03					.byte 3	;wh_CodeLength
>d7ea	26					  .byte LinkDisplacement	; offset to previous nt
=$d7eb					XtPtr1 ::= *
=55143					WordListLink ::= Nt0 ; remember the nt of this word for later
.d7eb					Two_r_fetch:
.d7eb	8a		txa				txa		; Y= return stack index
.d7ec	ba		tsx				tsx
.d7ed	86 14		stx $14				stx tmp1
.d7ef	a4 14		ldy $14				ldy tmp1
.d7f1	aa		tax				tax
.d7f2	ca		dex				dex		; make room on the Data Stack
.d7f3	ca		dex				dex
.d7f4	ca		dex				dex
.d7f5	ca		dex				dex
.d7f6	b9 03 01	lda $0103,y			lda RStack+3,y	; LSB of top entry
.d7f9	95 26		sta $26,x			sta DStack+0,x
.d7fb	b9 04 01	lda $0104,y			lda RStack+4,y	; MSB of top entry
.d7fe	95 27		sta $27,x			sta DStack+1,x
.d800	b9 05 01	lda $0105,y			lda RStack+5,y	; LSB of bottom entry
.d803	95 28		sta $28,x			sta DStack+2,x
.d805	b9 06 01	lda $0106,y			lda RStack+6,y	; MSB of bottom entry
.d808	95 29		sta $29,x			sta DStack+3,x
=31					CodeLen	.var *-XtPtr1
=$d80a					Here1 = *	; remember here
>d7e9	1f					.byte CodeLen	;patch wh_CodeLength
.d80a	60		rts				rts
>d80b	32 52 3e			Name0:	.text "2R>"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=55182					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>d80e	c3					.byte (("2R>"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=52					WordFlags ::= CO+ST	; modifiable copy, remember for later
=39					LinkDisplacement = Nt0-WordListLink
>d80f	34					.byte WordFlags	;wh_Flags
>d810	03					.byte 3	;wh_CodeLength
>d811	27					  .byte LinkDisplacement	; offset to previous nt
=$d812					XtPtr1 ::= *
=55182					WordListLink ::= Nt0 ; remember the nt of this word for later
.d812					Two_r_from:
.d812	68		pla				pla			; save the return address
.d813	85 14		sta $14				sta tmp1+0
.d815	68		pla				pla
.d816	85 15		sta $15				sta tmp1+1
.d818	ca		dex				dex			; make room on stack
.d819	ca		dex				dex
.d81a	ca		dex				dex
.d81b	ca		dex				dex
.d81c	68		pla				pla			; LSB
.d81d	95 26		sta $26,x			sta DStack+0,x
.d81f	68		pla				pla			; MSB
.d820	95 27		sta $27,x			sta DStack+1,x
.d822	68		pla				pla			; LSB
.d823	95 28		sta $28,x			sta DStack+2,x
.d825	68		pla				pla			; MSB
.d826	95 29		sta $29,x			sta DStack+3,x
.d828	a5 15		lda $15				lda tmp1+1		; restore return address
.d82a	48		pha				pha
.d82b	a5 14		lda $14				lda tmp1+0
.d82d	48		pha				pha
=28					CodeLen	.var *-XtPtr1
=$d82e					Here1 = *	; remember here
>d810	1c					.byte CodeLen	;patch wh_CodeLength
.d82e	60		rts				rts
>d82f	32 3e 52			Name0:	.text "2>R"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=55218					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>d832	43					.byte (("2>R"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=116					WordFlags ::= CO+UF+ST	; modifiable copy, remember for later
=36					LinkDisplacement = Nt0-WordListLink
>d833	74					.byte WordFlags	;wh_Flags
>d834	03					.byte 3	;wh_CodeLength
>d835	24					  .byte LinkDisplacement	; offset to previous nt
=$d836					XtPtr1 ::= *
=55218					WordListLink ::= Nt0 ; remember the nt of this word for later
.d836					Two_to_r:
.d836	68		pla				pla		; save the return address
.d837	85 14		sta $14				sta tmp1+0
.d839	68		pla				pla
.d83a	85 15		sta $15				sta tmp1+1
.d83c	20 9f c5	jsr $c59f			jsr underflow_2
.d83f	b5 29		lda $29,x			lda DStack+3,x	; MSB
.d841	48		pha				pha
.d842	b5 28		lda $28,x			lda DStack+2,x	; LSB
.d844	48		pha				pha
.d845	b5 27		lda $27,x			lda DStack+1,x	; MSB
.d847	48		pha				pha
.d848	b5 26		lda $26,x			lda DStack+0,x	; LSB
.d84a	48		pha				pha
.d84b	e8		inx				inx
.d84c	e8		inx				inx
.d84d	e8		inx				inx
.d84e	e8		inx				inx
.d84f	a5 15		lda $15				lda tmp1+1	; restore return address
.d851	48		pha				pha
.d852	a5 14		lda $14				lda tmp1+0
.d854	48		pha				pha
=31					CodeLen	.var *-XtPtr1
=$d855					Here1 = *	; remember here
>d834	1f					.byte CodeLen	;patch wh_CodeLength
.d855	60		rts				rts
>d856	49 6e 76 65 72 74		Name0:	.text "Invert"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=55260					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>d85c	86					.byte (("Invert"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$40					WordFlags ::= UF	; modifiable copy, remember for later
=42					LinkDisplacement = Nt0-WordListLink
>d85d	40					.byte WordFlags	;wh_Flags
>d85e	03					.byte 3	;wh_CodeLength
>d85f	2a					  .byte LinkDisplacement	; offset to previous nt
=$d860					XtPtr1 ::= *
=55260					WordListLink ::= Nt0 ; remember the nt of this word for later
.d860					Invert:
.d860	e0 2f		cpx #$2f		cpx #(DSDim-1)*2+1	; far enough below end of data stack (& not negative)?
.d862	b0 39		bcs $d89d		bcs Throw_Stack_17
.d864	a9 ff		lda #$ff			lda #$FF
.d866	55 26		eor $26,x			eor DStack+0,x	; LSB
.d868	95 26		sta $26,x			sta DStack+0,x
.d86a	a9 ff		lda #$ff			lda #$FF
.d86c	55 27		eor $27,x			eor DStack+1,x	; MSB
.d86e	95 27		sta $27,x			sta DStack+1,x
=16					CodeLen	.var *-XtPtr1
=$d870					Here1 = *	; remember here
>d85e	10					.byte CodeLen	;patch wh_CodeLength
.d870	60		rts				rts
>d871	4e 65 67 61 74 65		Name0:	.text "Negate"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=55287					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>d877	a6					.byte (("Negate"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=27					LinkDisplacement = Nt0-WordListLink
>d878	10					.byte WordFlags	;wh_Flags
>d879	03					.byte 3	;wh_CodeLength
>d87a	1b					  .byte LinkDisplacement	; offset to previous nt
=$d87b					XtPtr1 ::= *
=55287					WordListLink ::= Nt0 ; remember the nt of this word for later
.d87b					Negate:
.d87b	e0 2f		cpx #$2f		cpx #(DSDim-1)*2+1	; far enough below end of data stack (& not negative)?
.d87d	b0 1e		bcs $d89d		bcs Throw_Stack_17
.d87f	38		sec		Negate3:	sec
.d880	a9 00		lda #$00	Negate4:	lda #0
.d882	f5 26		sbc $26,x			sbc DStack+0,x	; LSB
.d884	95 26		sta $26,x			sta DStack+0,x
.d886	a9 00		lda #$00			lda #0
.d888	f5 27		sbc $27,x			sbc DStack+1,x	; MSB
.d88a	95 27		sta $27,x			sta DStack+1,x
=17					CodeLen	.var *-XtPtr1
=$d88c					Here1 = *	; remember here
>d879	11					.byte CodeLen	;patch wh_CodeLength
.d88c	60		rts				rts
>d88d	41 62 73			Name0:	.text "Abs"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=55312					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>d890	63					.byte (("Abs"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=25					LinkDisplacement = Nt0-WordListLink
>d891	10					.byte WordFlags	;wh_Flags
>d892	03					.byte 3	;wh_CodeLength
>d893	19					  .byte LinkDisplacement	; offset to previous nt
=$d894					XtPtr1 ::= *
=55312					WordListLink ::= Nt0 ; remember the nt of this word for later
.d894					Abs:
.d894	e0 2f		cpx #$2f		cpx #(DSDim-1)*2+1	; far enough below end of data stack (& not negative)?
.d896	b0 05		bcs $d89d		bcs Throw_Stack_17
.d898	b5 27		lda $27,x			lda DStack+1,x	; n negative?
.d89a	30 e3		bmi $d87f			bmi Negate3
=8					CodeLen	.var *-XtPtr1
=$d89c					Here1 = *	; remember here
>d892	08					.byte CodeLen	;patch wh_CodeLength
.d89c	60		rts				rts
.d89d	4c ae c5	jmp $c5ae	Throw_Stack_17: jmp Throw_Stack
>d8a0	44 4e 65 67 61 74 65		Name0:	.text "DNegate"	;  name of word as a string, ending at wh_NameLastChar
=7					NameLength = *-Name0
=55335					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>d8a7	a7					.byte (("DNegate"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=23					LinkDisplacement = Nt0-WordListLink
>d8a8	10					.byte WordFlags	;wh_Flags
>d8a9	03					.byte 3	;wh_CodeLength
>d8aa	17					  .byte LinkDisplacement	; offset to previous nt
=$d8ab					XtPtr1 ::= *
=55335					WordListLink ::= Nt0 ; remember the nt of this word for later
.d8ab					DNegate:
.d8ab	e0 2d		cpx #$2d		cpx #(DSDim-2)*2+1	; far enough below end of data stack (& not negative)?
.d8ad	b0 ee		bcs $d89d		bcs Throw_Stack_17
.d8af	38		sec		DNegate3:	sec
.d8b0	a9 00		lda #$00			lda #0
.d8b2	f5 28		sbc $28,x			sbc DStack+2,x	; LSB of low cell
.d8b4	95 28		sta $28,x			sta DStack+2,x
.d8b6	a9 00		lda #$00			lda #0
.d8b8	f5 29		sbc $29,x			sbc DStack+3,x	; MSB of low cell
.d8ba	95 29		sta $29,x			sta DStack+3,x
.d8bc	4c 80 d8	jmp $d880			jmp Negate4
=20					CodeLen	.var *-XtPtr1
=$d8bf					Here1 = *	; remember here
>d8a9	14					.byte CodeLen	;patch wh_CodeLength
>d8bf	44 41 62 73			Name0:	.text "DAbs"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=55363					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>d8c3	64					.byte (("DAbs"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=28					LinkDisplacement = Nt0-WordListLink
>d8c4	10					.byte WordFlags	;wh_Flags
>d8c5	03					.byte 3	;wh_CodeLength
>d8c6	1c					  .byte LinkDisplacement	; offset to previous nt
=$d8c7					XtPtr1 ::= *
=55363					WordListLink ::= Nt0 ; remember the nt of this word for later
.d8c7					DAbs:
.d8c7	e0 2d		cpx #$2d		cpx #(DSDim-2)*2+1	; far enough below end of data stack (& not negative)?
.d8c9	b0 d2		bcs $d89d		bcs Throw_Stack_17
.d8cb	b5 27		lda $27,x			lda DStack+1,x	; d negative?
.d8cd	30 e0		bmi $d8af			bmi DNegate3
=8					CodeLen	.var *-XtPtr1
=$d8cf					Here1 = *	; remember here
>d8c5	08					.byte CodeLen	;patch wh_CodeLength
.d8cf	60		rts				rts
>d8d0	44 3c 3e			Name0:	.text "D<>"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=55379					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>d8d3	c3					.byte (("D<>"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=16					LinkDisplacement = Nt0-WordListLink
>d8d4	10					.byte WordFlags	;wh_Flags
>d8d5	03					.byte 3	;wh_CodeLength
>d8d6	10					  .byte LinkDisplacement	; offset to previous nt
=$d8d7					XtPtr1 ::= *
=55379					WordListLink ::= Nt0 ; remember the nt of this word for later
.d8d7	20 e3 d8	jsr $d8e3	DNEq:		jsr DEqual
.d8da	4c ce da	jmp $dace			jmp ZEqA
=6					CodeLen	.var *-XtPtr1
=$d8dd					Here1 = *	; remember here
>d8d5	06					.byte CodeLen	;patch wh_CodeLength
>d8dd	44 3d				Name0:	.text "D="	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=55391					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>d8df	a2					.byte (("D="[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=12					LinkDisplacement = Nt0-WordListLink
>d8e0	10					.byte WordFlags	;wh_Flags
>d8e1	03					.byte 3	;wh_CodeLength
>d8e2	0c					  .byte LinkDisplacement	; offset to previous nt
=$d8e3					XtPtr1 ::= *
=55391					WordListLink ::= Nt0 ; remember the nt of this word for later
.d8e3	b5 2c		lda $2c,x	DEqual:		lda DStack+6,x
.d8e5	d5 28		cmp $28,x			cmp DStack+2,x
.d8e7	d0 4c		bne $d935			bne False3
.d8e9	b5 2d		lda $2d,x			lda DStack+7,x
.d8eb	d5 29		cmp $29,x			cmp DStack+3,x
.d8ed	d0 46		bne $d935			bne False3
.d8ef	b5 26		lda $26,x			lda DStack+0,x
.d8f1	d5 2a		cmp $2a,x			cmp DStack+4,x
.d8f3	d0 40		bne $d935			bne False3
.d8f5	b5 27		lda $27,x			lda DStack+1,x
.d8f7	d5 2b		cmp $2b,x			cmp DStack+5,x
.d8f9	d0 3a		bne $d935			bne False3
.d8fb	f0 5c		beq $d959			beq True3
=26					CodeLen	.var *-XtPtr1
=$d8fd					Here1 = *	; remember here
>d8e1	1a					.byte CodeLen	;patch wh_CodeLength
>d8fd	44 55 3e			Name0:	.text "DU>"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=55424					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>d900	c3					.byte (("DU>"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=33					LinkDisplacement = Nt0-WordListLink
>d901	10					.byte WordFlags	;wh_Flags
>d902	03					.byte 3	;wh_CodeLength
>d903	21					  .byte LinkDisplacement	; offset to previous nt
=$d904					XtPtr1 ::= *
=55424					WordListLink ::= Nt0 ; remember the nt of this word for later
.d904	20 9a d9	jsr $d99a	DUGt:		jsr DGtSub
.d907	90 50		bcc $d959			bcc True3
.d909	b0 2a		bcs $d935			bcs False3
=7					CodeLen	.var *-XtPtr1
=$d90b					Here1 = *	; remember here
>d902	07					.byte CodeLen	;patch wh_CodeLength
>d90b	44 55 3c 3d			Name0:	.text "DU<="	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=55439					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>d90f	a4					.byte (("DU<="[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=15					LinkDisplacement = Nt0-WordListLink
>d910	10					.byte WordFlags	;wh_Flags
>d911	03					.byte 3	;wh_CodeLength
>d912	0f					  .byte LinkDisplacement	; offset to previous nt
=$d913					XtPtr1 ::= *
=55439					WordListLink ::= Nt0 ; remember the nt of this word for later
.d913	20 9a d9	jsr $d99a	DULe:		jsr DGtSub
.d916	b0 41		bcs $d959			bcs True3
.d918	90 1b		bcc $d935			bcc False3
=7					CodeLen	.var *-XtPtr1
=$d91a					Here1 = *	; remember here
>d911	07					.byte CodeLen	;patch wh_CodeLength
>d91a	44 55 3e 3d			Name0:	.text "DU>="	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=55454					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>d91e	a4					.byte (("DU>="[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=15					LinkDisplacement = Nt0-WordListLink
>d91f	10					.byte WordFlags	;wh_Flags
>d920	03					.byte 3	;wh_CodeLength
>d921	0f					  .byte LinkDisplacement	; offset to previous nt
=$d922					XtPtr1 ::= *
=55454					WordListLink ::= Nt0 ; remember the nt of this word for later
.d922	20 6a d9	jsr $d96a	DUGe:		jsr DLessSub
.d925	b0 32		bcs $d959			bcs True3
.d927	90 0c		bcc $d935			bcc False3
=7					CodeLen	.var *-XtPtr1
=$d929					Here1 = *	; remember here
>d920	07					.byte CodeLen	;patch wh_CodeLength
>d929	44 55 3c			Name0:	.text "DU<"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=55468					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>d92c	83					.byte (("DU<"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=14					LinkDisplacement = Nt0-WordListLink
>d92d	10					.byte WordFlags	;wh_Flags
>d92e	03					.byte 3	;wh_CodeLength
>d92f	0e					  .byte LinkDisplacement	; offset to previous nt
=$d930					XtPtr1 ::= *
=55468					WordListLink ::= Nt0 ; remember the nt of this word for later
.d930	20 6a d9	jsr $d96a	DULess:		jsr DLessSub
.d933	90 24		bcc $d959			bcc True3
.d935	a9 00		lda #$00	False3:		lda #0
.d937	f0 22		beq $d95b			beq DReturn3
=9					CodeLen	.var *-XtPtr1
=$d939					Here1 = *	; remember here
>d92e	09					.byte CodeLen	;patch wh_CodeLength
.d939	4c ae c5	jmp $c5ae	Throw_Stack_09: jmp Throw_Stack
>d93c	44 3e 3d			Name0:	.text "D>="	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=55487					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>d93f	a3					.byte (("D>="[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=19					LinkDisplacement = Nt0-WordListLink
>d940	10					.byte WordFlags	;wh_Flags
>d941	03					.byte 3	;wh_CodeLength
>d942	13					  .byte LinkDisplacement	; offset to previous nt
=$d943					XtPtr1 ::= *
=55487					WordListLink ::= Nt0 ; remember the nt of this word for later
.d943	20 6a d9	jsr $d96a	DGEq:		jsr DLessSub
.d946	70 0f		bvs $d957			bvs DLess3
.d948	10 0f		bpl $d959	DGEq3:		bpl True3
.d94a	30 e9		bmi $d935			bmi False3
=9					CodeLen	.var *-XtPtr1
=$d94c					Here1 = *	; remember here
>d941	09					.byte CodeLen	;patch wh_CodeLength
>d94c	44 3c				Name0:	.text "D<"	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=55502					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>d94e	82					.byte (("D<"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=15					LinkDisplacement = Nt0-WordListLink
>d94f	10					.byte WordFlags	;wh_Flags
>d950	03					.byte 3	;wh_CodeLength
>d951	0f					  .byte LinkDisplacement	; offset to previous nt
=$d952					XtPtr1 ::= *
=55502					WordListLink ::= Nt0 ; remember the nt of this word for later
.d952	20 6a d9	jsr $d96a	DLess:		jsr DLessSub
.d955	70 f1		bvs $d948			bvs DGEq3
.d957	10 dc		bpl $d935	DLess3:		bpl False3
.d959	a9 ff		lda #$ff	True3:		lda #$ff
.d95b					DReturn3:
.d95b	e0 29		cpx #$29		cpx #(DSDim-4)*2+1	; far enough below end of data stack (& not negative)?
.d95d	b0 da		bcs $d939		bcs Throw_Stack_09
.d95f	95 2c		sta $2c,x			sta DStack+6,x
.d961	95 2d		sta $2d,x			sta DStack+7,x
.d963	e8		inx				inx			; preserve A, don't use ThreeDrop
.d964	e8		inx				inx
.d965	e8		inx				inx
.d966	e8		inx				inx
.d967	e8		inx				inx
.d968	e8		inx				inx
.d969	60		rts				rts
=24					CodeLen	.var *-XtPtr1
=$d96a					Here1 = *	; remember here
>d950	18					.byte CodeLen	;patch wh_CodeLength
.d96a	b5 2c		lda $2c,x	DLessSub:	lda DStack+6,x
.d96c	d5 28		cmp $28,x			cmp DStack+2,x
.d96e	b5 2d		lda $2d,x			lda DStack+7,x
.d970	f5 29		sbc $29,x			sbc DStack+3,x
.d972	b5 2a		lda $2a,x			lda DStack+4,x
.d974	f5 26		sbc $26,x			sbc DStack+0,x
.d976	b5 2b		lda $2b,x			lda DStack+5,x
.d978	f5 27		sbc $27,x			sbc DStack+1,x
.d97a	60		rts				rts
>d97b	44 3c 3d			Name0:	.text "D<="	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=55550					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>d97e	a3					.byte (("D<="[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=48					LinkDisplacement = Nt0-WordListLink
>d97f	10					.byte WordFlags	;wh_Flags
>d980	03					.byte 3	;wh_CodeLength
>d981	30					  .byte LinkDisplacement	; offset to previous nt
=$d982					XtPtr1 ::= *
=55550					WordListLink ::= Nt0 ; remember the nt of this word for later
.d982	20 9a d9	jsr $d99a	DLe:		jsr DGtSub
.d985	70 0f		bvs $d996			bvs DGt3
.d987	10 d0		bpl $d959	DLe3:		bpl True3
.d989	30 aa		bmi $d935			bmi False3
=9					CodeLen	.var *-XtPtr1
=$d98b					Here1 = *	; remember here
>d980	09					.byte CodeLen	;patch wh_CodeLength
>d98b	44 3e				Name0:	.text "D>"	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=55565					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>d98d	c2					.byte (("D>"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=15					LinkDisplacement = Nt0-WordListLink
>d98e	10					.byte WordFlags	;wh_Flags
>d98f	03					.byte 3	;wh_CodeLength
>d990	0f					  .byte LinkDisplacement	; offset to previous nt
=$d991					XtPtr1 ::= *
=55565					WordListLink ::= Nt0 ; remember the nt of this word for later
.d991	20 9a d9	jsr $d99a	DGt:		jsr DGtSub
.d994	70 f1		bvs $d987			bvs DLe3
.d996	30 c1		bmi $d959	DGt3:		bmi True3
.d998	10 9b		bpl $d935			bpl False3
=9					CodeLen	.var *-XtPtr1
=$d99a					Here1 = *	; remember here
>d98f	09					.byte CodeLen	;patch wh_CodeLength
.d99a	b5 28		lda $28,x	DGtSub:		lda DStack+2,x
.d99c	d5 2c		cmp $2c,x			cmp DStack+6,x
.d99e	b5 29		lda $29,x			lda DStack+3,x
.d9a0	f5 2d		sbc $2d,x			sbc DStack+7,x
.d9a2	b5 26		lda $26,x			lda DStack+0,x
.d9a4	f5 2a		sbc $2a,x			sbc DStack+4,x
.d9a6	b5 27		lda $27,x			lda DStack+1,x
.d9a8	f5 2b		sbc $2b,x			sbc DStack+5,x
.d9aa	60		rts				rts
>d9ab	44 30 3c 3d			Name0:	.text "D0<="	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=55599					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>d9af	a4					.byte (("D0<="[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=34					LinkDisplacement = Nt0-WordListLink
>d9b0	10					.byte WordFlags	;wh_Flags
>d9b1	03					.byte 3	;wh_CodeLength
>d9b2	22					  .byte LinkDisplacement	; offset to previous nt
=$d9b3					XtPtr1 ::= *
=55599					WordListLink ::= Nt0 ; remember the nt of this word for later
.d9b3	b5 27		lda $27,x	D0Le:		lda DStack+1,x	; test sign
.d9b5	30 65		bmi $da1c			bmi True1
.d9b7	10 24		bpl $d9dd			bpl D0Equal
=6					CodeLen	.var *-XtPtr1
=$d9b9					Here1 = *	; remember here
>d9b1	06					.byte CodeLen	;patch wh_CodeLength
>d9b9	44 30 3e			Name0:	.text "D0>"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=55612					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>d9bc	c3					.byte (("D0>"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>d9bd	10					.byte WordFlags	;wh_Flags
>d9be	03					.byte 3	;wh_CodeLength
>d9bf	0d					  .byte LinkDisplacement	; offset to previous nt
=$d9c0					XtPtr1 ::= *
=55612					WordListLink ::= Nt0 ; remember the nt of this word for later
.d9c0	b5 27		lda $27,x	D0Gt:		lda DStack+1,x	; test sign
.d9c2	10 0b		bpl $d9cf			bpl D0Ne
.d9c4	4c 3b da	jmp $da3b			jmp False1
>d9c7	44 30 3c 3e			Name0:	.text "D0<>"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=55627					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>d9cb	c4					.byte (("D0<>"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=15					LinkDisplacement = Nt0-WordListLink
>d9cc	10					.byte WordFlags	;wh_Flags
>d9cd	03					.byte 3	;wh_CodeLength
>d9ce	0f					  .byte LinkDisplacement	; offset to previous nt
=$d9cf					XtPtr1 ::= *
=55627					WordListLink ::= Nt0 ; remember the nt of this word for later
.d9cf	20 e4 d9	jsr $d9e4	D0Ne:		jsr D0EqSub
.d9d2	d0 48		bne $da1c			bne True1
.d9d4	f0 65		beq $da3b			beq False1
=7					CodeLen	.var *-XtPtr1
=$d9d6					Here1 = *	; remember here
>d9cd	07					.byte CodeLen	;patch wh_CodeLength
>d9d6	44 30 3d			Name0:	.text "D0="	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=55641					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>d9d9	a3					.byte (("D0="[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=14					LinkDisplacement = Nt0-WordListLink
>d9da	10					.byte WordFlags	;wh_Flags
>d9db	03					.byte 3	;wh_CodeLength
>d9dc	0e					  .byte LinkDisplacement	; offset to previous nt
=$d9dd					XtPtr1 ::= *
=55641					WordListLink ::= Nt0 ; remember the nt of this word for later
.d9dd	20 e4 d9	jsr $d9e4	D0Equal:	jsr D0EqSub
.d9e0	d0 59		bne $da3b			bne False1
.d9e2	f0 38		beq $da1c			beq True1
=7					CodeLen	.var *-XtPtr1
=$d9e4					Here1 = *	; remember here
>d9db	07					.byte CodeLen	;patch wh_CodeLength
.d9e4	b5 28		lda $28,x	D0EqSub:	lda DStack+2,x
.d9e6	15 29		ora $29,x			ora DStack+3,x
.d9e8	15 26		ora $26,x			ora DStack+0,x
.d9ea	15 27		ora $27,x			ora DStack+1,x
.d9ec	60		rts				rts
>d9ed	44 30 3c			Name0:	.text "D0<"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=55664					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>d9f0	83					.byte (("D0<"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=23					LinkDisplacement = Nt0-WordListLink
>d9f1	10					.byte WordFlags	;wh_Flags
>d9f2	03					.byte 3	;wh_CodeLength
>d9f3	17					  .byte LinkDisplacement	; offset to previous nt
=$d9f4					XtPtr1 ::= *
=55664					WordListLink ::= Nt0 ; remember the nt of this word for later
.d9f4	b5 27		lda $27,x	D0Less:		lda DStack+1,x	; test sign
.d9f6	30 24		bmi $da1c			bmi True1
.d9f8	10 41		bpl $da3b			bpl False1
=6					CodeLen	.var *-XtPtr1
=$d9fa					Here1 = *	; remember here
>d9f2	06					.byte CodeLen	;patch wh_CodeLength
>d9fa	44 30 3e 3d			Name0:	.text "D0>="	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=55678					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>d9fe	a4					.byte (("D0>="[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=14					LinkDisplacement = Nt0-WordListLink
>d9ff	10					.byte WordFlags	;wh_Flags
>da00	03					.byte 3	;wh_CodeLength
>da01	0e					  .byte LinkDisplacement	; offset to previous nt
=$da02					XtPtr1 ::= *
=55678					WordListLink ::= Nt0 ; remember the nt of this word for later
.da02	b5 27		lda $27,x	D0Ge:		lda DStack+1,x	; test sign
.da04	10 16		bpl $da1c			bpl True1
.da06	30 33		bmi $da3b			bmi False1
=6					CodeLen	.var *-XtPtr1
=$da08					Here1 = *	; remember here
>da00	06					.byte CodeLen	;patch wh_CodeLength
.da08	4c ae c5	jmp $c5ae	Throw_Stack_08: jmp Throw_Stack
>da0b	3d				Name0:	.text "="	;  name of word as a string, ending at wh_NameLastChar
=1					NameLength = *-Name0
=55692					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>da0c	a1					.byte (("="[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=14					LinkDisplacement = Nt0-WordListLink
>da0d	10					.byte WordFlags	;wh_Flags
>da0e	03					.byte 3	;wh_CodeLength
>da0f	0e					  .byte LinkDisplacement	; offset to previous nt
=$da10					XtPtr1 ::= *
=55692					WordListLink ::= Nt0 ; remember the nt of this word for later
.da10	b5 26		lda $26,x	Equal:		lda DStack+0,x		; LSB
.da12	d5 28		cmp $28,x			cmp DStack+2,x
.da14	d0 25		bne $da3b			bne False1
.da16	b5 27		lda $27,x			lda DStack+1,x		; MSB
.da18	d5 29		cmp $29,x			cmp DStack+3,x
.da1a	d0 1f		bne $da3b			bne False1
.da1c	a9 ff		lda #$ff	True1:		lda #$ff	; return TRUE
.da1e					Return1:
.da1e	e0 2d		cpx #$2d		cpx #(DSDim-2)*2+1	; far enough below end of data stack (& not negative)?
.da20	b0 e6		bcs $da08		bcs Throw_Stack_08
.da22	e8		inx				inx		; Drop
.da23	e8		inx				inx
.da24	95 26		sta $26,x			sta DStack+0,x	; store f
.da26	95 27		sta $27,x			sta DStack+1,x
.da28	60		rts				rts
=25					CodeLen	.var *-XtPtr1
=$da29					Here1 = *	; remember here
>da0e	19					.byte CodeLen	;patch wh_CodeLength
>da29	3c 3e				Name0:	.text "<>"	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=55723					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>da2b	c2					.byte (("<>"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=31					LinkDisplacement = Nt0-WordListLink
>da2c	10					.byte WordFlags	;wh_Flags
>da2d	03					.byte 3	;wh_CodeLength
>da2e	1f					  .byte LinkDisplacement	; offset to previous nt
=$da2f					XtPtr1 ::= *
=55723					WordListLink ::= Nt0 ; remember the nt of this word for later
.da2f	b5 26		lda $26,x	Not_Equals:	lda DStack+0,x		; LSB
.da31	d5 28		cmp $28,x			cmp DStack+2,x
.da33	d0 e7		bne $da1c			bne True1
.da35	b5 27		lda $27,x			lda DStack+1,x		; MSB
.da37	d5 29		cmp $29,x			cmp DStack+3,x
.da39	d0 e1		bne $da1c			bne True1
.da3b	a9 00		lda #$00	False1:		lda #0		; return FALSE
.da3d	f0 df		beq $da1e			beq Return1
=16					CodeLen	.var *-XtPtr1
=$da3f					Here1 = *	; remember here
>da2d	10					.byte CodeLen	;patch wh_CodeLength
>da3f	3c				Name0:	.text "<"	;  name of word as a string, ending at wh_NameLastChar
=1					NameLength = *-Name0
=55744					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>da40	81					.byte (("<"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=21					LinkDisplacement = Nt0-WordListLink
>da41	10					.byte WordFlags	;wh_Flags
>da42	03					.byte 3	;wh_CodeLength
>da43	15					  .byte LinkDisplacement	; offset to previous nt
=$da44					XtPtr1 ::= *
=55744					WordListLink ::= Nt0 ; remember the nt of this word for later
.da44	b5 28		lda $28,x	Less_Than:	lda DStack+2,x	; compare
.da46	d5 26		cmp $26,x			cmp DStack+0,x
.da48	b5 29		lda $29,x			lda DStack+3,x
.da4a	f5 27		sbc $27,x			sbc DStack+1,x
.da4c	50 02		bvc $da50			bvc _c
.da4e	49 80		eor #$80			eor #$80	; fix sign
.da50	10 e9		bpl $da3b	_c:		bpl False1
.da52	30 c8		bmi $da1c			bmi True1
=16					CodeLen	.var *-XtPtr1
=$da54					Here1 = *	; remember here
>da42	10					.byte CodeLen	;patch wh_CodeLength
>da54	3e 3d				Name0:	.text ">="	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=55766					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>da56	a2					.byte ((">="[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=22					LinkDisplacement = Nt0-WordListLink
>da57	10					.byte WordFlags	;wh_Flags
>da58	03					.byte 3	;wh_CodeLength
>da59	16					  .byte LinkDisplacement	; offset to previous nt
=$da5a					XtPtr1 ::= *
=55766					WordListLink ::= Nt0 ; remember the nt of this word for later
.da5a	20 44 da	jsr $da44	Ge:		jsr Less_Than
.da5d	4c ce da	jmp $dace			jmp ZEqA
=6					CodeLen	.var *-XtPtr1
=$da60					Here1 = *	; remember here
>da58	06					.byte CodeLen	;patch wh_CodeLength
>da60	55 3c				Name0:	.text "U<"	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=55778					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>da62	82					.byte (("U<"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=12					LinkDisplacement = Nt0-WordListLink
>da63	10					.byte WordFlags	;wh_Flags
>da64	03					.byte 3	;wh_CodeLength
>da65	0c					  .byte LinkDisplacement	; offset to previous nt
=$da66					XtPtr1 ::= *
=55778					WordListLink ::= Nt0 ; remember the nt of this word for later
.da66	b5 28		lda $28,x	U_Less_Than:	lda DStack+2,x
.da68	d5 26		cmp $26,x			cmp DStack+0,x
.da6a	b5 29		lda $29,x			lda DStack+3,x
.da6c	f5 27		sbc $27,x			sbc DStack+1,x
.da6e	b0 cb		bcs $da3b			bcs False1
.da70	90 aa		bcc $da1c			bcc True1
=12					CodeLen	.var *-XtPtr1
=$da72					Here1 = *	; remember here
>da64	0c					.byte CodeLen	;patch wh_CodeLength
>da72	55 3e				Name0:	.text "U>"	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=55796					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>da74	c2					.byte (("U>"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=18					LinkDisplacement = Nt0-WordListLink
>da75	10					.byte WordFlags	;wh_Flags
>da76	03					.byte 3	;wh_CodeLength
>da77	12					  .byte LinkDisplacement	; offset to previous nt
=$da78					XtPtr1 ::= *
=55796					WordListLink ::= Nt0 ; remember the nt of this word for later
.da78	b5 26		lda $26,x	U_Greater_Than:	lda DStack+0,x
.da7a	d5 28		cmp $28,x			cmp DStack+2,x
.da7c	b5 27		lda $27,x			lda DStack+1,x
.da7e	f5 29		sbc $29,x			sbc DStack+3,x
.da80	b0 b9		bcs $da3b			bcs False1
.da82	90 98		bcc $da1c			bcc True1
=12					CodeLen	.var *-XtPtr1
=$da84					Here1 = *	; remember here
>da76	0c					.byte CodeLen	;patch wh_CodeLength
>da84	3e				Name0:	.text ">"	;  name of word as a string, ending at wh_NameLastChar
=1					NameLength = *-Name0
=55813					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>da85	c1					.byte ((">"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=17					LinkDisplacement = Nt0-WordListLink
>da86	10					.byte WordFlags	;wh_Flags
>da87	03					.byte 3	;wh_CodeLength
>da88	11					  .byte LinkDisplacement	; offset to previous nt
=$da89					XtPtr1 ::= *
=55813					WordListLink ::= Nt0 ; remember the nt of this word for later
.da89	b5 26		lda $26,x	Greater_Than:	lda DStack+0,x	; compare
.da8b	d5 28		cmp $28,x			cmp DStack+2,x
.da8d	b5 27		lda $27,x			lda DStack+1,x
.da8f	f5 29		sbc $29,x			sbc DStack+3,x
.da91	50 02		bvc $da95			bvc _c
.da93	49 80		eor #$80			eor #$80	; fix sign
.da95	10 a4		bpl $da3b	_c:		bpl False1
.da97	4c 1c da	jmp $da1c			jmp True1
=17					CodeLen	.var *-XtPtr1
=$da9a					Here1 = *	; remember here
>da87	11					.byte CodeLen	;patch wh_CodeLength
>da9a	3c 3d				Name0:	.text "<="	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=55836					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>da9c	a2					.byte (("<="[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=23					LinkDisplacement = Nt0-WordListLink
>da9d	10					.byte WordFlags	;wh_Flags
>da9e	03					.byte 3	;wh_CodeLength
>da9f	17					  .byte LinkDisplacement	; offset to previous nt
=$daa0					XtPtr1 ::= *
=55836					WordListLink ::= Nt0 ; remember the nt of this word for later
.daa0	20 89 da	jsr $da89	Le:		jsr Greater_Than
.daa3	4c ce da	jmp $dace			jmp ZEqA
=6					CodeLen	.var *-XtPtr1
=$daa6					Here1 = *	; remember here
>da9e	06					.byte CodeLen	;patch wh_CodeLength
>daa6	55 3e 3d			Name0:	.text "U>="	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=55849					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>daa9	a3					.byte (("U>="[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>daaa	10					.byte WordFlags	;wh_Flags
>daab	03					.byte 3	;wh_CodeLength
>daac	0d					  .byte LinkDisplacement	; offset to previous nt
=$daad					XtPtr1 ::= *
=55849					WordListLink ::= Nt0 ; remember the nt of this word for later
.daad	20 66 da	jsr $da66	UGe:		jsr U_Less_Than
.dab0	4c ce da	jmp $dace			jmp ZEqA
=6					CodeLen	.var *-XtPtr1
=$dab3					Here1 = *	; remember here
>daab	06					.byte CodeLen	;patch wh_CodeLength
>dab3	55 3c 3d			Name0:	.text "U<="	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=55862					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>dab6	a3					.byte (("U<="[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>dab7	10					.byte WordFlags	;wh_Flags
>dab8	03					.byte 3	;wh_CodeLength
>dab9	0d					  .byte LinkDisplacement	; offset to previous nt
=$daba					XtPtr1 ::= *
=55862					WordListLink ::= Nt0 ; remember the nt of this word for later
.daba	20 78 da	jsr $da78	ULe:		jsr U_Greater_Than
.dabd	4c ce da	jmp $dace			jmp ZEqA
=6					CodeLen	.var *-XtPtr1
=$dac0					Here1 = *	; remember here
>dab8	06					.byte CodeLen	;patch wh_CodeLength
>dac0	30 3d				Name0:	.text "0="	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=55874					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>dac2	a2					.byte (("0="[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=12					LinkDisplacement = Nt0-WordListLink
>dac3	10					.byte WordFlags	;wh_Flags
>dac4	03					.byte 3	;wh_CodeLength
>dac5	0c					  .byte LinkDisplacement	; offset to previous nt
=$dac6					XtPtr1 ::= *
=55874					WordListLink ::= Nt0 ; remember the nt of this word for later
.dac6	b5 27		lda $27,x	Zero_Equal:	lda DStack+1,x
.dac8	15 26		ora $26,x	ZEq3:		ora DStack+0,x
.daca	d0 2b		bne $daf7			bne False0
.dacc	f0 14		beq $dae2			beq True0
=8					CodeLen	.var *-XtPtr1
=$dace					Here1 = *	; remember here
>dac4	08					.byte CodeLen	;patch wh_CodeLength
.dace					ZEqA:
.dace	49 ff		eor #$ff			eor #$ff
.dad0	95 26		sta $26,x			sta DStack+0,x
.dad2	95 27		sta $27,x			sta DStack+1,x
.dad4	60		rts				rts
>dad5	30 3c 3e			Name0:	.text "0<>"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=55896					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>dad8	c3					.byte (("0<>"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=22					LinkDisplacement = Nt0-WordListLink
>dad9	10					.byte WordFlags	;wh_Flags
>dada	03					.byte 3	;wh_CodeLength
>dadb	16					  .byte LinkDisplacement	; offset to previous nt
=$dadc					XtPtr1 ::= *
=55896					WordListLink ::= Nt0 ; remember the nt of this word for later
.dadc	b5 27		lda $27,x	Zero_Unequal:	lda DStack+1,x
.dade	15 26		ora $26,x	ZNe3:		ora DStack+0,x
.dae0	f0 15		beq $daf7			beq False0
.dae2	a9 ff		lda #$ff	True0:		lda #$ff	; return TRUE
.dae4	95 26		sta $26,x	Return0:	sta DStack+0,x
.dae6	95 27		sta $27,x			sta DStack+1,x
.dae8	e0 2f		cpx #$2f		cpx #(DSDim-1)*2+1	; far enough below end of data stack (& not negative)?
.daea	b0 35		bcs $db21		bcs Throw_Stack_05
.daec	60		rts				rts
=17					CodeLen	.var *-XtPtr1
=$daed					Here1 = *	; remember here
>dada	11					.byte CodeLen	;patch wh_CodeLength
>daed	30 3e				Name0:	.text "0>"	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=55919					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>daef	c2					.byte (("0>"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=23					LinkDisplacement = Nt0-WordListLink
>daf0	10					.byte WordFlags	;wh_Flags
>daf1	03					.byte 3	;wh_CodeLength
>daf2	17					  .byte LinkDisplacement	; offset to previous nt
=$daf3					XtPtr1 ::= *
=55919					WordListLink ::= Nt0 ; remember the nt of this word for later
.daf3	b5 27		lda $27,x	Zero_Greater:	lda DStack+1,x	; MSB
.daf5	10 e7		bpl $dade			bpl ZNe3	; >= 0 ?
.daf7	a9 00		lda #$00	False0:		lda #0		; return FALSE
.daf9	f0 e9		beq $dae4			beq Return0
=8					CodeLen	.var *-XtPtr1
=$dafb					Here1 = *	; remember here
>daf1	08					.byte CodeLen	;patch wh_CodeLength
>dafb	30 3c 3d			Name0:	.text "0<="	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=55934					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>dafe	a3					.byte (("0<="[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=15					LinkDisplacement = Nt0-WordListLink
>daff	10					.byte WordFlags	;wh_Flags
>db00	03					.byte 3	;wh_CodeLength
>db01	0f					  .byte LinkDisplacement	; offset to previous nt
=$db02					XtPtr1 ::= *
=55934					WordListLink ::= Nt0 ; remember the nt of this word for later
.db02	b5 27		lda $27,x	ZLe:		lda DStack+1,x	; < 0 ?
.db04	30 dc		bmi $dae2			bmi True0
.db06	10 c0		bpl $dac8			bpl ZEq3
=6					CodeLen	.var *-XtPtr1
=$db08					Here1 = *	; remember here
>db00	06					.byte CodeLen	;patch wh_CodeLength
>db08	30 3e 3d			Name0:	.text "0>="	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=55947					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>db0b	a3					.byte (("0>="[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>db0c	10					.byte WordFlags	;wh_Flags
>db0d	03					.byte 3	;wh_CodeLength
>db0e	0d					  .byte LinkDisplacement	; offset to previous nt
=$db0f					XtPtr1 ::= *
=55947					WordListLink ::= Nt0 ; remember the nt of this word for later
.db0f	b5 27		lda $27,x	ZGe:		lda DStack+1,x
.db11	10 cf		bpl $dae2			bpl True0
.db13	30 e2		bmi $daf7			bmi False0
=6					CodeLen	.var *-XtPtr1
=$db15					Here1 = *	; remember here
>db0d	06					.byte CodeLen	;patch wh_CodeLength
>db15	30 3c				Name0:	.text "0<"	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=55959					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>db17	82					.byte (("0<"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=12					LinkDisplacement = Nt0-WordListLink
>db18	10					.byte WordFlags	;wh_Flags
>db19	03					.byte 3	;wh_CodeLength
>db1a	0c					  .byte LinkDisplacement	; offset to previous nt
=$db1b					XtPtr1 ::= *
=55959					WordListLink ::= Nt0 ; remember the nt of this word for later
.db1b	b5 27		lda $27,x	Zero_Less:	lda DStack+1,x	; MSB
.db1d	10 d8		bpl $daf7			bpl False0
.db1f	30 c1		bmi $dae2			bmi True0
=6					CodeLen	.var *-XtPtr1
=$db21					Here1 = *	; remember here
>db19	06					.byte CodeLen	;patch wh_CodeLength
.db21	4c ae c5	jmp $c5ae	Throw_Stack_05: jmp Throw_Stack
>db24	4d 69 6e			Name0:	.text "Min"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=55975					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>db27	c3					.byte (("Min"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=16					LinkDisplacement = Nt0-WordListLink
>db28	10					.byte WordFlags	;wh_Flags
>db29	03					.byte 3	;wh_CodeLength
>db2a	10					  .byte LinkDisplacement	; offset to previous nt
=$db2b					XtPtr1 ::= *
=55975					WordListLink ::= Nt0 ; remember the nt of this word for later
.db2b					Min:
.db2b	e0 2d		cpx #$2d		cpx #(DSDim-2)*2+1	; far enough below end of data stack (& not negative)?
.db2d	b0 f2		bcs $db21		bcs Throw_Stack_05
.db2f	b5 26		lda $26,x			lda DStack+0,x	; compare n1 & n2; sets V & N but not Z
.db31	d5 28		cmp $28,x			cmp DStack+2,x
.db33	b5 27		lda $27,x			lda DStack+1,x
.db35	f5 29		sbc $29,x			sbc DStack+3,x
.db37	70 1a		bvs $db53			bvs Max_3	; if overflow, the sign is backwards
.db39	30 28		bmi $db63	Min_3:		bmi Nip_NoUf	; if negative, NOS is larger and needs to be dumped
.db3b	e8		inx				inx		; Drop n2
.db3c	e8		inx				inx
=18					CodeLen	.var *-XtPtr1
=$db3d					Here1 = *	; remember here
>db29	12					.byte CodeLen	;patch wh_CodeLength
.db3d	60		rts				rts
>db3e	4d 61 78			Name0:	.text "Max"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=56001					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>db41	03					.byte (("Max"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=26					LinkDisplacement = Nt0-WordListLink
>db42	10					.byte WordFlags	;wh_Flags
>db43	03					.byte 3	;wh_CodeLength
>db44	1a					  .byte LinkDisplacement	; offset to previous nt
=$db45					XtPtr1 ::= *
=56001					WordListLink ::= Nt0 ; remember the nt of this word for later
.db45					Max:
.db45	e0 2d		cpx #$2d		cpx #(DSDim-2)*2+1	; far enough below end of data stack (& not negative)?
.db47	b0 d8		bcs $db21		bcs Throw_Stack_05
.db49	b5 26		lda $26,x			lda DStack+0,x	; Compare n1 & n2; sets V & N but not Z
.db4b	d5 28		cmp $28,x			cmp DStack+2,x
.db4d	b5 27		lda $27,x			lda DStack+1,x
.db4f	f5 29		sbc $29,x			sbc DStack+3,x
.db51	70 e6		bvs $db39			bvs Min_3	; if overflow, the sign is backwards
.db53	10 0e		bpl $db63	Max_3:		bpl Nip_NoUf	; if negative, NOS is larger and needs to be kept
.db55	e8		inx				inx		; Drop n2
.db56	e8		inx				inx
=18					CodeLen	.var *-XtPtr1
=$db57					Here1 = *	; remember here
>db43	12					.byte CodeLen	;patch wh_CodeLength
.db57	60		rts				rts
>db58	4e 69 70			Name0:	.text "Nip"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=56027					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>db5b	03					.byte (("Nip"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=26					LinkDisplacement = Nt0-WordListLink
>db5c	10					.byte WordFlags	;wh_Flags
>db5d	03					.byte 3	;wh_CodeLength
>db5e	1a					  .byte LinkDisplacement	; offset to previous nt
=$db5f					XtPtr1 ::= *
=56027					WordListLink ::= Nt0 ; remember the nt of this word for later
.db5f					Nip:
.db5f	e0 2d		cpx #$2d		cpx #(DSDim-2)*2+1	; far enough below end of data stack (& not negative)?
.db61	b0 be		bcs $db21		bcs Throw_Stack_05
.db63	b5 26		lda $26,x	Nip_NoUf:	lda DStack+0,x	; PopYA
.db65	b4 27		ldy $27,x			ldy DStack+1,x
.db67	e8		inx				inx
.db68	e8		inx				inx
.db69	95 26		sta $26,x			sta DStack+0,x	; store over n1
.db6b	94 27		sty $27,x			sty DStack+1,x
=14					CodeLen	.var *-XtPtr1
=$db6d					Here1 = *	; remember here
>db5d	0e					.byte CodeLen	;patch wh_CodeLength
.db6d	60		rts				rts
>db6e	50 69 63 6b			Name0:	.text "Pick"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=56050					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>db72	64					.byte (("Pick"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=0					WordFlags ::= 0	; modifiable copy, remember for later
=23					LinkDisplacement = Nt0-WordListLink
>db73	00					.byte WordFlags	;wh_Flags
>db74	03					.byte 3	;wh_CodeLength
>db75	17					  .byte LinkDisplacement	; offset to previous nt
=$db76					XtPtr1 ::= *
=56050					WordListLink ::= Nt0 ; remember the nt of this word for later
.db76					Pick:
.db76	16 26		asl $26,x			asl DStack+0,x	; we assume u < 128 (stack is small)
.db78	8a		txa				txa
.db79	75 26		adc $26,x			adc DStack+0,x
.db7b	a8		tay				tay
.db7c	b9 28 00	lda $0028,y			lda DStack+2,y
.db7f	95 26		sta $26,x			sta DStack+0,x
.db81	b9 29 00	lda $0029,y			lda DStack+3,y
.db84	95 27		sta $27,x			sta DStack+1,x
=16					CodeLen	.var *-XtPtr1
=$db86					Here1 = *	; remember here
>db74	10					.byte CodeLen	;patch wh_CodeLength
.db86	60		rts				rts
>db87	43 68 61 72			Name0:	.text "Char"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=56075					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>db8b	44					.byte (("Char"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=25					LinkDisplacement = Nt0-WordListLink
>db8c	10					.byte WordFlags	;wh_Flags
>db8d	03					.byte 3	;wh_CodeLength
>db8e	19					  .byte LinkDisplacement	; offset to previous nt
=$db8f					XtPtr1 ::= *
=56075					WordListLink ::= Nt0 ; remember the nt of this word for later
.db8f					Char:
.db8f	20 46 cc	jsr $cc46			jsr parse_name_check
.db92	e8		inx				inx		; Drop number of characters, leave addr
.db93	e8		inx				inx
.db94	4c 51 df	jmp $df51			jmp C_Fetch	; get character ( C@ )
=8					CodeLen	.var *-XtPtr1
=$db97					Here1 = *	; remember here
>db8d	08					.byte CodeLen	;patch wh_CodeLength
>db97	5b 43 68 61 72 5d		Name0:	.text "[Char]"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=56093					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>db9d	a6					.byte (("[Char]"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=28					WordFlags ::= CO+IM+NN	; modifiable copy, remember for later
=18					LinkDisplacement = Nt0-WordListLink
>db9e	1c					.byte WordFlags	;wh_Flags
>db9f	03					.byte 3	;wh_CodeLength
>dba0	12					  .byte LinkDisplacement	; offset to previous nt
=$dba1					XtPtr1 ::= *
=56093					WordListLink ::= Nt0 ; remember the nt of this word for later
.dba1	20 8f db	jsr $db8f	Bracket_Char:	jsr Char
.dba4	4c cb c8	jmp $c8cb			jmp Literal
=6					CodeLen	.var *-XtPtr1
=$dba7					Here1 = *	; remember here
>db9f	06					.byte CodeLen	;patch wh_CodeLength
>dba7	43 68 61 72 2b			Name0:	.text "Char+"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=56108					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>dbac	65					.byte (("Char+"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=15					LinkDisplacement = Nt0-WordListLink
>dbad	10					.byte WordFlags	;wh_Flags
>dbae	03					.byte 3	;wh_CodeLength
>dbaf	0f					  .byte LinkDisplacement	; offset to previous nt
=$dbb0					XtPtr1 ::= *
=56108					WordListLink ::= Nt0 ; remember the nt of this word for later
.dbb0	4c 37 dc	jmp $dc37	Char_Plus:	jmp One_Plus
=3					CodeLen	.var *-XtPtr1
=$dbb3					Here1 = *	; remember here
>dbae	03					.byte CodeLen	;patch wh_CodeLength
>dbb3	43 68 61 72 73			Name0:	.text "Chars"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=56120					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>dbb8	65					.byte (("Chars"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$20					WordFlags ::= AN	; modifiable copy, remember for later
=12					LinkDisplacement = Nt0-WordListLink
>dbb9	20					.byte WordFlags	;wh_Flags
>dbba	03					.byte 3	;wh_CodeLength
>dbbb	0c					  .byte LinkDisplacement	; offset to previous nt
=$dbbc					XtPtr1 ::= *
=56120					WordListLink ::= Nt0 ; remember the nt of this word for later
.dbbc					Chars:
=0					CodeLen	.var *-XtPtr1
=$dbbc					Here1 = *	; remember here
>dbba	00					.byte CodeLen	;patch wh_CodeLength
.dbbc	60		rts				rts
>dbbd	43 65 6c 6c 73			Name0:	.text "Cells"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=56130					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>dbc2	65					.byte (("Cells"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=10					LinkDisplacement = Nt0-WordListLink
>dbc3	10					.byte WordFlags	;wh_Flags
>dbc4	03					.byte 3	;wh_CodeLength
>dbc5	0a					  .byte LinkDisplacement	; offset to previous nt
=$dbc6					XtPtr1 ::= *
=56130					WordListLink ::= Nt0 ; remember the nt of this word for later
.dbc6					Cells:
.dbc6	e0 2f		cpx #$2f		cpx #(DSDim-1)*2+1	; far enough below end of data stack (& not negative)?
.dbc8	b0 7f		bcs $dc49		bcs Throw_Stack_19
.dbca	16 26		asl $26,x			asl DStack+0,x		; 2*
.dbcc	36 27		rol $27,x			rol DStack+1,x
=8					CodeLen	.var *-XtPtr1
=$dbce					Here1 = *	; remember here
>dbc4	08					.byte CodeLen	;patch wh_CodeLength
.dbce	60		rts				rts
>dbcf	43 65 6c 6c 2b			Name0:	.text "Cell+"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=56148					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>dbd4	65					.byte (("Cell+"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$40					WordFlags ::= UF	; modifiable copy, remember for later
=18					LinkDisplacement = Nt0-WordListLink
>dbd5	40					.byte WordFlags	;wh_Flags
>dbd6	03					.byte 3	;wh_CodeLength
>dbd7	12					  .byte LinkDisplacement	; offset to previous nt
=$dbd8					XtPtr1 ::= *
=56148					WordListLink ::= Nt0 ; remember the nt of this word for later
.dbd8	a9 02		lda #$02	Cell_Plus:	lda #2		; our cells are 2 bytes
.dbda					Plus_A:
.dbda	e0 2f		cpx #$2f		cpx #(DSDim-1)*2+1	; far enough below end of data stack (& not negative)?
.dbdc	b0 6b		bcs $dc49		bcs Throw_Stack_19
.dbde	75 26		adc $26,x			adc DStack+0,x
.dbe0	95 26		sta $26,x			sta DStack+0,x
.dbe2	90 02		bcc $dbe6			bcc +
.dbe4	f6 27		inc $27,x			inc DStack+1,x
.dbe6					+
=14					CodeLen	.var *-XtPtr1
=$dbe6					Here1 = *	; remember here
>dbd6	0e					.byte CodeLen	;patch wh_CodeLength
.dbe6	60		rts				rts
.dbe7					Nos_Plus_A:
.dbe7	18		clc				clc
.dbe8	75 28		adc $28,x			adc DStack+2,x
.dbea	95 28		sta $28,x			sta DStack+2,x
.dbec	90 02		bcc $dbf0			bcc +
.dbee	f6 29		inc $29,x			inc DStack+3,x
.dbf0	60		rts		+		rts
>dbf1	63 70				Name0:	.text "cp"	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=56179					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>dbf3	02					.byte (("cp"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=31					LinkDisplacement = Nt0-WordListLink
>dbf4	10					.byte WordFlags	;wh_Flags
>dbf5	03					.byte 3	;wh_CodeLength
>dbf6	1f					  .byte LinkDisplacement	; offset to previous nt
=$dbf7					XtPtr1 ::= *
=56179					WordListLink ::= Nt0 ; remember the nt of this word for later
.dbf7	a9 00		lda #$00			lda #cp
.dbf9	4c 5d c9	jmp $c95d			jmp PushZA
=5					CodeLen	.var *-XtPtr1
=$dbfc					Here1 = *	; remember here
>dbf5	05					.byte CodeLen	;patch wh_CodeLength
>dbfc	48 65 72 65			Name0:	.text "Here"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=56192					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>dc00	a4					.byte (("Here"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>dc01	10					.byte WordFlags	;wh_Flags
>dc02	03					.byte 3	;wh_CodeLength
>dc03	0d					  .byte LinkDisplacement	; offset to previous nt
=$dc04					XtPtr1 ::= *
=56192					WordListLink ::= Nt0 ; remember the nt of this word for later
.dc04	a5 00		lda $00		Here:		lda cp+0
.dc06	a4 01		ldy $01				ldy cp+1
.dc08	4c 2e c9	jmp $c92e			jmp PushYA
=7					CodeLen	.var *-XtPtr1
=$dc0b					Here1 = *	; remember here
>dc02	07					.byte CodeLen	;patch wh_CodeLength
>dc0b	31 2d				Name0:	.text "1-"	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=56205					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>dc0d	a2					.byte (("1-"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>dc0e	10					.byte WordFlags	;wh_Flags
>dc0f	03					.byte 3	;wh_CodeLength
>dc10	0d					  .byte LinkDisplacement	; offset to previous nt
=$dc11					XtPtr1 ::= *
=56205					WordListLink ::= Nt0 ; remember the nt of this word for later
.dc11					One_Minus:
.dc11	e0 2f		cpx #$2f		cpx #(DSDim-1)*2+1	; far enough below end of data stack (& not negative)?
.dc13	b0 34		bcs $dc49		bcs Throw_Stack_19
.dc15					One_Minus_NoUf:
.dc15	b5 26		lda $26,x			lda DStack+0,x
.dc17	d0 02		bne $dc1b			bne +
.dc19	d6 27		dec $27,x			dec DStack+1,x
.dc1b	d6 26		dec $26,x	+		dec DStack+0,x
=12					CodeLen	.var *-XtPtr1
=$dc1d					Here1 = *	; remember here
>dc0f	0c					.byte CodeLen	;patch wh_CodeLength
.dc1d	60		rts				rts
.dc1e					NOS_One_Minus:
.dc1e	b5 28		lda $28,x			lda DStack+2,x
.dc20	d0 02		bne $dc24			bne +
.dc22	d6 29		dec $29,x			dec DStack+3,x
.dc24	d6 28		dec $28,x	+		dec DStack+2,x
.dc26	60		rts				rts
.dc27					Minus_A:
.dc27	18		clc				clc
.dc28	75 26		adc $26,x			adc DStack+0,x
.dc2a	95 26		sta $26,x			sta DStack+0,x
.dc2c	b0 02		bcs $dc30			bcs +
.dc2e	d6 27		dec $27,x			dec DStack+1,x
.dc30	60		rts		+		rts
>dc31	31 2b				Name0:	.text "1+"	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=56243					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>dc33	62					.byte (("1+"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=38					LinkDisplacement = Nt0-WordListLink
>dc34	10					.byte WordFlags	;wh_Flags
>dc35	03					.byte 3	;wh_CodeLength
>dc36	26					  .byte LinkDisplacement	; offset to previous nt
=$dc37					XtPtr1 ::= *
=56243					WordListLink ::= Nt0 ; remember the nt of this word for later
.dc37					One_Plus:
.dc37	e0 2f		cpx #$2f		cpx #(DSDim-1)*2+1	; far enough below end of data stack (& not negative)?
.dc39	b0 0e		bcs $dc49		bcs Throw_Stack_19
.dc3b	f6 26		inc $26,x			inc DStack+0,x
.dc3d	d0 02		bne $dc41			bne +
.dc3f	f6 27		inc $27,x			inc DStack+1,x
.dc41					+
=10					CodeLen	.var *-XtPtr1
=$dc41					Here1 = *	; remember here
>dc35	0a					.byte CodeLen	;patch wh_CodeLength
.dc41	60		rts				rts
.dc42					NOS_One_Plus:
.dc42	f6 28		inc $28,x			inc DStack+2,x
.dc44	d0 02		bne $dc48			bne +
.dc46	f6 29		inc $29,x			inc DStack+3,x
.dc48	60		rts		+		rts
.dc49	4c ae c5	jmp $c5ae	Throw_Stack_19: jmp Throw_Stack
>dc4c	55 4d 2b			Name0:	.text "UM+"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=56271					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>dc4f	63					.byte (("UM+"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=0					WordFlags ::= 0	; modifiable copy, remember for later
=28					LinkDisplacement = Nt0-WordListLink
>dc50	00					.byte WordFlags	;wh_Flags
>dc51	03					.byte 3	;wh_CodeLength
>dc52	1c					  .byte LinkDisplacement	; offset to previous nt
=$dc53					XtPtr1 ::= *
=56271					WordListLink ::= Nt0 ; remember the nt of this word for later
.dc53	20 62 c5	jsr $c562	UMPlus:		jsr PopYA
.dc56	18		clc				clc		; add n to d1.lo
.dc57	75 28		adc $28,x			adc DStack+2,x
.dc59	95 28		sta $28,x			sta DStack+2,x
.dc5b	98		tya				tya
.dc5c	75 29		adc $29,x			adc DStack+3,x
.dc5e	95 29		sta $29,x			sta DStack+3,x
.dc60	90 06		bcc $dc68			bcc +		; propagate carry thru d1.hi
.dc62	f6 26		inc $26,x			inc DStack+0,x
.dc64	d0 02		bne $dc68			bne +
.dc66	f6 27		inc $27,x			inc DStack+1,x
.dc68					+
=21					CodeLen	.var *-XtPtr1
=$dc68					Here1 = *	; remember here
>dc51	15					.byte CodeLen	;patch wh_CodeLength
.dc68	60		rts				rts
>dc69	4d 2b				Name0:	.text "M+"	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=56299					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>dc6b	62					.byte (("M+"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=28					LinkDisplacement = Nt0-WordListLink
>dc6c	10					.byte WordFlags	;wh_Flags
>dc6d	03					.byte 3	;wh_CodeLength
>dc6e	1c					  .byte LinkDisplacement	; offset to previous nt
=$dc6f					XtPtr1 ::= *
=56299					WordListLink ::= Nt0 ; remember the nt of this word for later
.dc6f	20 53 dc	jsr $dc53	MPlus:		jsr UMPlus
.dc72	98		tya				tya		; if n negative
.dc73	30 a0		bmi $dc15			bmi One_Minus_NoUf ;   decrement d1.hi
=6					CodeLen	.var *-XtPtr1
=$dc75					Here1 = *	; remember here
>dc6d	06					.byte CodeLen	;patch wh_CodeLength
.dc75	60		rts				rts
>dc76	44 32 2a			Name0:	.text "D2*"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=56313					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>dc79	43					.byte (("D2*"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=14					LinkDisplacement = Nt0-WordListLink
>dc7a	10					.byte WordFlags	;wh_Flags
>dc7b	03					.byte 3	;wh_CodeLength
>dc7c	0e					  .byte LinkDisplacement	; offset to previous nt
=$dc7d					XtPtr1 ::= *
=56313					WordListLink ::= Nt0 ; remember the nt of this word for later
.dc7d					D2Star:
.dc7d	e0 2d		cpx #$2d		cpx #(DSDim-2)*2+1	; far enough below end of data stack (& not negative)?
.dc7f	b0 c8		bcs $dc49		bcs Throw_Stack_19
.dc81	16 28		asl $28,x			asl DStack+2,x
.dc83	36 29		rol $29,x			rol DStack+3,x
.dc85	36 26		rol $26,x			rol DStack+0,x
.dc87	36 27		rol $27,x			rol DStack+1,x
=12					CodeLen	.var *-XtPtr1
=$dc89					Here1 = *	; remember here
>dc7b	0c					.byte CodeLen	;patch wh_CodeLength
.dc89	60		rts				rts
>dc8a	44 32 2f			Name0:	.text "D2/"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=56333					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>dc8d	e3					.byte (("D2/"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=20					LinkDisplacement = Nt0-WordListLink
>dc8e	10					.byte WordFlags	;wh_Flags
>dc8f	03					.byte 3	;wh_CodeLength
>dc90	14					  .byte LinkDisplacement	; offset to previous nt
=$dc91					XtPtr1 ::= *
=56333					WordListLink ::= Nt0 ; remember the nt of this word for later
.dc91					D2Slash:
.dc91	e0 2d		cpx #$2d		cpx #(DSDim-2)*2+1	; far enough below end of data stack (& not negative)?
.dc93	b0 b4		bcs $dc49		bcs Throw_Stack_19
.dc95	b5 27		lda $27,x			lda DStack+1,x		; setup for sign-extended shift right
.dc97	0a		asl a				asl a
.dc98	76 27		ror $27,x	D2SlashU:	ror DStack+1,x
.dc9a	76 26		ror $26,x			ror DStack+0,x
.dc9c	76 29		ror $29,x			ror DStack+3,x
.dc9e	76 28		ror $28,x			ror DStack+2,x
=15					CodeLen	.var *-XtPtr1
=$dca0					Here1 = *	; remember here
>dc8f	0f					.byte CodeLen	;patch wh_CodeLength
.dca0	60		rts				rts
>dca1	55 44 32 2f			Name0:	.text "UD2/"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=56357					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>dca5	e4					.byte (("UD2/"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=24					LinkDisplacement = Nt0-WordListLink
>dca6	10					.byte WordFlags	;wh_Flags
>dca7	03					.byte 3	;wh_CodeLength
>dca8	18					  .byte LinkDisplacement	; offset to previous nt
=$dca9					XtPtr1 ::= *
=56357					WordListLink ::= Nt0 ; remember the nt of this word for later
.dca9					DU2Slash:
.dca9	e0 2d		cpx #$2d		cpx #(DSDim-2)*2+1	; far enough below end of data stack (& not negative)?
.dcab	b0 9c		bcs $dc49		bcs Throw_Stack_19
.dcad	18		clc				clc
.dcae	90 e8		bcc $dc98			bcc D2SlashU
=7					CodeLen	.var *-XtPtr1
=$dcb0					Here1 = *	; remember here
>dca7	07					.byte CodeLen	;patch wh_CodeLength
>dcb0	32 2a				Name0:	.text "2*"	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=56370					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>dcb2	42					.byte (("2*"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>dcb3	10					.byte WordFlags	;wh_Flags
>dcb4	03					.byte 3	;wh_CodeLength
>dcb5	0d					  .byte LinkDisplacement	; offset to previous nt
=$dcb6					XtPtr1 ::= *
=56370					WordListLink ::= Nt0 ; remember the nt of this word for later
.dcb6					Two_Star:
.dcb6	e0 2f		cpx #$2f		cpx #(DSDim-1)*2+1	; far enough below end of data stack (& not negative)?
.dcb8	b0 8f		bcs $dc49		bcs Throw_Stack_19
.dcba	16 26		asl $26,x			asl DStack+0,x
.dcbc	36 27		rol $27,x			rol DStack+1,x
=8					CodeLen	.var *-XtPtr1
=$dcbe					Here1 = *	; remember here
>dcb4	08					.byte CodeLen	;patch wh_CodeLength
.dcbe	60		rts				rts
>dcbf	32 2f				Name0:	.text "2/"	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=56385					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>dcc1	e2					.byte (("2/"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=15					LinkDisplacement = Nt0-WordListLink
>dcc2	10					.byte WordFlags	;wh_Flags
>dcc3	03					.byte 3	;wh_CodeLength
>dcc4	0f					  .byte LinkDisplacement	; offset to previous nt
=$dcc5					XtPtr1 ::= *
=56385					WordListLink ::= Nt0 ; remember the nt of this word for later
.dcc5					Two_Slash:
.dcc5	e0 2f		cpx #$2f		cpx #(DSDim-1)*2+1	; far enough below end of data stack (& not negative)?
.dcc7	b0 80		bcs $dc49		bcs Throw_Stack_19
.dcc9	b5 27		lda $27,x			lda DStack+1,x		; load sign into carry, for signed shift
.dccb	0a		asl a				asl
.dccc	76 27		ror $27,x			ror DStack+1,x
.dcce	76 26		ror $26,x			ror DStack+0,x
=11					CodeLen	.var *-XtPtr1
=$dcd0					Here1 = *	; remember here
>dcc3	0b					.byte CodeLen	;patch wh_CodeLength
.dcd0	60		rts				rts
>dcd1	55 32 2f			Name0:	.text "U2/"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=56404					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>dcd4	e3					.byte (("U2/"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$40					WordFlags ::= UF	; modifiable copy, remember for later
=19					LinkDisplacement = Nt0-WordListLink
>dcd5	40					.byte WordFlags	;wh_Flags
>dcd6	03					.byte 3	;wh_CodeLength
>dcd7	13					  .byte LinkDisplacement	; offset to previous nt
=$dcd8					XtPtr1 ::= *
=56404					WordListLink ::= Nt0 ; remember the nt of this word for later
.dcd8					UTwo_Slash:
.dcd8	e0 2f		cpx #$2f		cpx #(DSDim-1)*2+1	; far enough below end of data stack (& not negative)?
.dcda	b0 79		bcs $dd55		bcs Throw_Stack_18
.dcdc	56 27		lsr $27,x			lsr DStack+1,x
.dcde	76 26		ror $26,x			ror DStack+0,x
=8					CodeLen	.var *-XtPtr1
=$dce0					Here1 = *	; remember here
>dcd6	08					.byte CodeLen	;patch wh_CodeLength
.dce0	60		rts				rts
>dce1	44 52 53 68 69 66 74		Name0:	.text "DRShift"	;  name of word as a string, ending at wh_NameLastChar
=7					NameLength = *-Name0
=56424					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>dce8	87					.byte (("DRShift"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=0					WordFlags ::= 0	; modifiable copy, remember for later
=20					LinkDisplacement = Nt0-WordListLink
>dce9	00					.byte WordFlags	;wh_Flags
>dcea	03					.byte 3	;wh_CodeLength
>dceb	14					  .byte LinkDisplacement	; offset to previous nt
=$dcec					XtPtr1 ::= *
=56424					WordListLink ::= Nt0 ; remember the nt of this word for later
.dcec	20 47 c5	jsr $c547	DRShift:	jsr PopA	; pop u
.dcef					DRShiftA:
.dcef	e0 2d		cpx #$2d		cpx #(DSDim-2)*2+1	; far enough below end of data stack (& not negative)?
.dcf1	b0 62		bcs $dd55		bcs Throw_Stack_18
.dcf3	a8		tay				tay
.dcf4	f0 0e		beq $dd04			beq _9
.dcf6	b5 27		lda $27,x			lda DStack+1,x
.dcf8	4a		lsr a		_2:		lsr a
.dcf9	76 26		ror $26,x			ror DStack+0,x
.dcfb	76 29		ror $29,x			ror DStack+3,x
.dcfd	76 28		ror $28,x			ror DStack+2,x
.dcff	88		dey				dey
.dd00	d0 f6		bne $dcf8			bne _2
.dd02	95 27		sta $27,x			sta DStack+1,x
.dd04					_9:
=24					CodeLen	.var *-XtPtr1
=$dd04					Here1 = *	; remember here
>dcea	18					.byte CodeLen	;patch wh_CodeLength
.dd04	60		rts				rts
>dd05	52 53 68 69 66 74		Name0:	.text "RShift"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=56459					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>dd0b	86					.byte (("RShift"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=0					WordFlags ::= 0	; modifiable copy, remember for later
=35					LinkDisplacement = Nt0-WordListLink
>dd0c	00					.byte WordFlags	;wh_Flags
>dd0d	03					.byte 3	;wh_CodeLength
>dd0e	23					  .byte LinkDisplacement	; offset to previous nt
=$dd0f					XtPtr1 ::= *
=56459					WordListLink ::= Nt0 ; remember the nt of this word for later
.dd0f	20 50 c5	jsr $c550	RShift:		jsr PopA2	; pop u, check for 2 params
.dd12	a8		tay		RShift_A:	tay		; get shift count
.dd13	f0 0a		beq $dd1f			beq _done
.dd15	b5 27		lda $27,x			lda DStack+1,x
.dd17	4a		lsr a		_loop:		lsr a
.dd18	76 26		ror $26,x			ror DStack+0,x
.dd1a	88		dey				dey
.dd1b	d0 fa		bne $dd17			bne _loop
.dd1d	95 27		sta $27,x			sta DStack+1,x
.dd1f					_done:
=16					CodeLen	.var *-XtPtr1
=$dd1f					Here1 = *	; remember here
>dd0d	10					.byte CodeLen	;patch wh_CodeLength
.dd1f	60		rts				rts
>dd20	4c 53 68 69 66 74		Name0:	.text "LShift"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=56486					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>dd26	86					.byte (("LShift"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=0					WordFlags ::= 0	; modifiable copy, remember for later
=27					LinkDisplacement = Nt0-WordListLink
>dd27	00					.byte WordFlags	;wh_Flags
>dd28	03					.byte 3	;wh_CodeLength
>dd29	1b					  .byte LinkDisplacement	; offset to previous nt
=$dd2a					XtPtr1 ::= *
=56486					WordListLink ::= Nt0 ; remember the nt of this word for later
.dd2a	20 50 c5	jsr $c550	LShift:		jsr PopA2	; pop u, check for 2 params
.dd2d	a8		tay		LShift_A:	tay		; get shift count
.dd2e	f0 0a		beq $dd3a			beq _done
.dd30	b5 27		lda $27,x			lda DStack+1,x
.dd32	16 26		asl $26,x	_loop:		asl DStack+0,x
.dd34	2a		rol a				rol a
.dd35	88		dey				dey
.dd36	d0 fa		bne $dd32			bne _loop
.dd38	95 27		sta $27,x			sta DStack+1,x
.dd3a					_done:
=16					CodeLen	.var *-XtPtr1
=$dd3a					Here1 = *	; remember here
>dd28	10					.byte CodeLen	;patch wh_CodeLength
.dd3a	60		rts				rts
>dd3b	41 6e 64			Name0:	.text "And"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=56510					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>dd3e	83					.byte (("And"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=24					LinkDisplacement = Nt0-WordListLink
>dd3f	10					.byte WordFlags	;wh_Flags
>dd40	03					.byte 3	;wh_CodeLength
>dd41	18					  .byte LinkDisplacement	; offset to previous nt
=$dd42					XtPtr1 ::= *
=56510					WordListLink ::= Nt0 ; remember the nt of this word for later
.dd42					And2:
.dd42	e0 2d		cpx #$2d		cpx #(DSDim-2)*2+1	; far enough below end of data stack (& not negative)?
.dd44	b0 0f		bcs $dd55		bcs Throw_Stack_18
.dd46	b5 26		lda $26,x			lda DStack+0,x
.dd48	35 28		and $28,x			and DStack+2,x
.dd4a	95 28		sta $28,x			sta DStack+2,x
.dd4c	b5 27		lda $27,x			lda DStack+1,x
.dd4e	35 29		and $29,x			and DStack+3,x
.dd50	95 29		sta $29,x			sta DStack+3,x
.dd52	e8		inx				inx		; Drop n2
.dd53	e8		inx				inx
=18					CodeLen	.var *-XtPtr1
=$dd54					Here1 = *	; remember here
>dd40	12					.byte CodeLen	;patch wh_CodeLength
.dd54	60		rts				rts
.dd55	4c ae c5	jmp $c5ae	Throw_Stack_18: jmp Throw_Stack
>dd58	4f 72				Name0:	.text "Or"	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=56538					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>dd5a	42					.byte (("Or"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=28					LinkDisplacement = Nt0-WordListLink
>dd5b	10					.byte WordFlags	;wh_Flags
>dd5c	03					.byte 3	;wh_CodeLength
>dd5d	1c					  .byte LinkDisplacement	; offset to previous nt
=$dd5e					XtPtr1 ::= *
=56538					WordListLink ::= Nt0 ; remember the nt of this word for later
.dd5e					Or:
.dd5e	e0 2d		cpx #$2d		cpx #(DSDim-2)*2+1	; far enough below end of data stack (& not negative)?
.dd60	b0 f3		bcs $dd55		bcs Throw_Stack_18
.dd62	b5 26		lda $26,x			lda DStack+0,x
.dd64	15 28		ora $28,x			ora DStack+2,x
.dd66	95 28		sta $28,x			sta DStack+2,x
.dd68	b5 27		lda $27,x			lda DStack+1,x
.dd6a	15 29		ora $29,x			ora DStack+3,x
.dd6c	95 29		sta $29,x			sta DStack+3,x
.dd6e	e8		inx				inx		; Drop n2
.dd6f	e8		inx				inx
=18					CodeLen	.var *-XtPtr1
=$dd70					Here1 = *	; remember here
>dd5c	12					.byte CodeLen	;patch wh_CodeLength
.dd70	60		rts				rts
>dd71	58 6f 72			Name0:	.text "Xor"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=56564					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>dd74	43					.byte (("Xor"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=26					LinkDisplacement = Nt0-WordListLink
>dd75	10					.byte WordFlags	;wh_Flags
>dd76	03					.byte 3	;wh_CodeLength
>dd77	1a					  .byte LinkDisplacement	; offset to previous nt
=$dd78					XtPtr1 ::= *
=56564					WordListLink ::= Nt0 ; remember the nt of this word for later
.dd78					Xor:
.dd78	e0 2d		cpx #$2d		cpx #(DSDim-2)*2+1	; far enough below end of data stack (& not negative)?
.dd7a	b0 d9		bcs $dd55		bcs Throw_Stack_18
.dd7c	b5 26		lda $26,x			lda DStack+0,x
.dd7e	55 28		eor $28,x			eor DStack+2,x
.dd80	95 28		sta $28,x			sta DStack+2,x
.dd82	b5 27		lda $27,x			lda DStack+1,x
.dd84	55 29		eor $29,x			eor DStack+3,x
.dd86	95 29		sta $29,x			sta DStack+3,x
.dd88	e8		inx				inx		; Drop n2
.dd89	e8		inx				inx
=18					CodeLen	.var *-XtPtr1
=$dd8a					Here1 = *	; remember here
>dd76	12					.byte CodeLen	;patch wh_CodeLength
.dd8a	60		rts				rts
>dd8b	2b				Name0:	.text "+"	;  name of word as a string, ending at wh_NameLastChar
=1					NameLength = *-Name0
=56588					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>dd8c	61					.byte (("+"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=24					LinkDisplacement = Nt0-WordListLink
>dd8d	10					.byte WordFlags	;wh_Flags
>dd8e	03					.byte 3	;wh_CodeLength
>dd8f	18					  .byte LinkDisplacement	; offset to previous nt
=$dd90					XtPtr1 ::= *
=56588					WordListLink ::= Nt0 ; remember the nt of this word for later
.dd90					Plus:
.dd90	e0 2d		cpx #$2d		cpx #(DSDim-2)*2+1	; far enough below end of data stack (& not negative)?
.dd92	b0 c1		bcs $dd55		bcs Throw_Stack_18
.dd94	18		clc				clc
.dd95	b5 26		lda $26,x			lda DStack+0,x		; LSB
.dd97	75 28		adc $28,x			adc DStack+2,x
.dd99	95 28		sta $28,x			sta DStack+2,x
.dd9b	b5 27		lda $27,x			lda DStack+1,x		; MSB. No CLC, conserve carry bit
.dd9d	75 29		adc $29,x			adc DStack+3,x
.dd9f	95 29		sta $29,x			sta DStack+3,x
.dda1	e8		inx				inx
.dda2	e8		inx				inx
=19					CodeLen	.var *-XtPtr1
=$dda3					Here1 = *	; remember here
>dd8e	13					.byte CodeLen	;patch wh_CodeLength
.dda3	60		rts				rts
>dda4	2d				Name0:	.text "-"	;  name of word as a string, ending at wh_NameLastChar
=1					NameLength = *-Name0
=56613					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>dda5	a1					.byte (("-"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=25					LinkDisplacement = Nt0-WordListLink
>dda6	10					.byte WordFlags	;wh_Flags
>dda7	03					.byte 3	;wh_CodeLength
>dda8	19					  .byte LinkDisplacement	; offset to previous nt
=$dda9					XtPtr1 ::= *
=56613					WordListLink ::= Nt0 ; remember the nt of this word for later
.dda9					Minus:
.dda9	e0 2d		cpx #$2d		cpx #(DSDim-2)*2+1	; far enough below end of data stack (& not negative)?
.ddab	b0 a8		bcs $dd55		bcs Throw_Stack_18
.ddad	38		sec				sec
.ddae	b5 28		lda $28,x			lda DStack+2,x	; LSB
.ddb0	f5 26		sbc $26,x			sbc DStack+0,x
.ddb2	95 28		sta $28,x			sta DStack+2,x
.ddb4	b5 29		lda $29,x			lda DStack+3,x	; MSB
.ddb6	f5 27		sbc $27,x			sbc DStack+1,x
.ddb8	95 29		sta $29,x			sta DStack+3,x
.ddba	e8		inx				inx		; Drop n2
.ddbb	e8		inx				inx
=19					CodeLen	.var *-XtPtr1
=$ddbc					Here1 = *	; remember here
>dda7	13					.byte CodeLen	;patch wh_CodeLength
.ddbc	60		rts				rts
>ddbd	2e				Name0:	.text "."	;  name of word as a string, ending at wh_NameLastChar
=1					NameLength = *-Name0
=56638					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>ddbe	c1					.byte (("."[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=25					LinkDisplacement = Nt0-WordListLink
>ddbf	10					.byte WordFlags	;wh_Flags
>ddc0	03					.byte 3	;wh_CodeLength
>ddc1	19					  .byte LinkDisplacement	; offset to previous nt
=$ddc2					XtPtr1 ::= *
=56638					WordListLink ::= Nt0 ; remember the nt of this word for later
.ddc2	b5 27		lda $27,x	Dot:		lda DStack+1,x		; ( n )	save sign
.ddc4	08		php				php
.ddc5	20 94 d8	jsr $d894			jsr Abs			; ( u )
.ddc8	20 6b c9	jsr $c96b			jsr Zero		; ( ud )	u>d  cvt u to ud
.ddcb	4c da dd	jmp $ddda			jmp fmt_d3
=12					CodeLen	.var *-XtPtr1
=$ddce					Here1 = *	; remember here
>ddc0	0c					.byte CodeLen	;patch wh_CodeLength
>ddce	44 2e				Name0:	.text "D."	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=56656					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>ddd0	c2					.byte (("D."[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=18					LinkDisplacement = Nt0-WordListLink
>ddd1	10					.byte WordFlags	;wh_Flags
>ddd2	03					.byte 3	;wh_CodeLength
>ddd3	12					  .byte LinkDisplacement	; offset to previous nt
=$ddd4					XtPtr1 ::= *
=56656					WordListLink ::= Nt0 ; remember the nt of this word for later
.ddd4	b5 27		lda $27,x	D_Dot:		lda DStack+1,x		; save sign
.ddd6	08		php				php
.ddd7	20 c7 d8	jsr $d8c7			jsr DAbs
.ddda	20 30 bd	jsr $bd30	fmt_d3:		jsr Less_Number_Sign	; ( ud )	start formatting
.dddd	20 af bd	jsr $bdaf			jsr Number_sign_s	; ( ud )	do all digits
.dde0	28		plp				plp			; ( ud )	do sign
.dde1	20 c9 bd	jsr $bdc9			jsr Sign_P		; ( ud )
.dde4	20 3c bd	jsr $bd3c			jsr Number_sign_greater	; ( addr u )	end formatting
.dde7	20 f1 df	jsr $dff1			jsr Type
.ddea	4c e5 df	jmp $dfe5			jmp Space
=25					CodeLen	.var *-XtPtr1
=$dded					Here1 = *	; remember here
>ddd2	19					.byte CodeLen	;patch wh_CodeLength
>dded	55 2e				Name0:	.text "U."	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=56687					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>ddef	c2					.byte (("U."[-1]&7)<<5)+NameLength	;wh_HashNameLen
=80					WordFlags ::= UF+NN	; modifiable copy, remember for later
=31					LinkDisplacement = Nt0-WordListLink
>ddf0	50					.byte WordFlags	;wh_Flags
>ddf1	03					.byte 3	;wh_CodeLength
>ddf2	1f					  .byte LinkDisplacement	; offset to previous nt
=$ddf3					XtPtr1 ::= *
=56687					WordListLink ::= Nt0 ; remember the nt of this word for later
.ddf3	20 8b c5	jsr $c58b	U_Dot:		jsr underflow_1
.ddf6	20 0c de	jsr $de0c			jsr print_u
.ddf9	4c e5 df	jmp $dfe5			jmp Space
=9					CodeLen	.var *-XtPtr1
=$ddfc					Here1 = *	; remember here
>ddf1	09					.byte CodeLen	;patch wh_CodeLength
>ddfc	55 44 2e			Name0:	.text "UD."	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=56703					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>ddff	c3					.byte (("UD."[-1]&7)<<5)+NameLength	;wh_HashNameLen
=80					WordFlags ::= UF+NN	; modifiable copy, remember for later
=16					LinkDisplacement = Nt0-WordListLink
>de00	50					.byte WordFlags	;wh_Flags
>de01	03					.byte 3	;wh_CodeLength
>de02	10					  .byte LinkDisplacement	; offset to previous nt
=$de03					XtPtr1 ::= *
=56703					WordListLink ::= Nt0 ; remember the nt of this word for later
.de03	20 9f c5	jsr $c59f	UD_Dot:		jsr underflow_2 ; double number
.de06	20 0f de	jsr $de0f			jsr print_ud
.de09	4c e5 df	jmp $dfe5			jmp Space
=9					CodeLen	.var *-XtPtr1
=$de0c					Here1 = *	; remember here
>de01	09					.byte CodeLen	;patch wh_CodeLength
.de0c					print_u:
.de0c	20 6b c9	jsr $c96b			jsr Zero			; convert to ud
.de0f					print_ud:
.de0f	20 30 bd	jsr $bd30			jsr Less_Number_Sign		; <#	start formatting
.de12	20 af bd	jsr $bdaf			jsr Number_sign_s		; #S	do all digits
.de15	20 3c bd	jsr $bd3c			jsr Number_sign_greater		; #>	end formatting
.de18	4c f1 df	jmp $dff1			jmp Type
>de1b	55 2e 52			Name0:	.text "U.R"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=56734					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>de1e	43					.byte (("U.R"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=31					LinkDisplacement = Nt0-WordListLink
>de1f	10					.byte WordFlags	;wh_Flags
>de20	03					.byte 3	;wh_CodeLength
>de21	1f					  .byte LinkDisplacement	; offset to previous nt
=$de22					XtPtr1 ::= *
=56734					WordListLink ::= Nt0 ; remember the nt of this word for later
.de22	20 47 c5	jsr $c547	U_Dot_R:	jsr PopA		; save field width
.de25	48		pha		U_Dot_R_A:	pha
.de26	20 6b c9	jsr $c96b			jsr Zero		; u>d  cvt u to ud
.de29	4c 38 de	jmp $de38			jmp fmt_udr3
=10					CodeLen	.var *-XtPtr1
=$de2c					Here1 = *	; remember here
>de20	0a					.byte CodeLen	;patch wh_CodeLength
>de2c	55 44 2e 52			Name0:	.text "UD.R"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=56752					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>de30	44					.byte (("UD.R"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=18					LinkDisplacement = Nt0-WordListLink
>de31	10					.byte WordFlags	;wh_Flags
>de32	03					.byte 3	;wh_CodeLength
>de33	12					  .byte LinkDisplacement	; offset to previous nt
=$de34					XtPtr1 ::= *
=56752					WordListLink ::= Nt0 ; remember the nt of this word for later
.de34	20 47 c5	jsr $c547	UD_Dot_R:	jsr PopA			; save field width
.de37	48		pha		UD_Dot_R_A:	pha
.de38	20 30 bd	jsr $bd30	fmt_udr3:	jsr Less_Number_Sign		; start formatted
.de3b	20 af bd	jsr $bdaf			jsr Number_sign_s		; do all digits
.de3e	20 3c bd	jsr $bd3c	fmt_r:		jsr Number_sign_greater		; finish formatted
.de41	68		pla				pla				; recover field width
.de42	38		sec				sec				; do leading spaces
.de43	f5 26		sbc $26,x			sbc DStack+0,x
.de45	90 06		bcc $de4d			bcc +
.de47	20 5d c9	jsr $c95d			jsr PushZA
.de4a	20 5e d6	jsr $d65e			jsr Spaces
.de4d	4c f1 df	jmp $dff1	+		jmp Type			; type formatted
=28					CodeLen	.var *-XtPtr1
=$de50					Here1 = *	; remember here
>de32	1c					.byte CodeLen	;patch wh_CodeLength
>de50	2e 52				Name0:	.text ".R"	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=56786					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>de52	42					.byte ((".R"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=34					LinkDisplacement = Nt0-WordListLink
>de53	10					.byte WordFlags	;wh_Flags
>de54	03					.byte 3	;wh_CodeLength
>de55	22					  .byte LinkDisplacement	; offset to previous nt
=$de56					XtPtr1 ::= *
=56786					WordListLink ::= Nt0 ; remember the nt of this word for later
.de56	20 47 c5	jsr $c547	Dot_R:		jsr PopA		; save field width
.de59	48		pha		Dot_R_A:	pha
.de5a	b5 27		lda $27,x			lda DStack+1,x		; save sign
.de5c	08		php				php
.de5d	20 94 d8	jsr $d894			jsr Abs
.de60	20 6b c9	jsr $c96b			jsr Zero		; u>d  cvt u to ud
.de63	4c 77 de	jmp $de77			jmp fmt_dr3
=16					CodeLen	.var *-XtPtr1
=$de66					Here1 = *	; remember here
>de54	10					.byte CodeLen	;patch wh_CodeLength
>de66	44 2e 52			Name0:	.text "D.R"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=56809					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>de69	43					.byte (("D.R"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=23					LinkDisplacement = Nt0-WordListLink
>de6a	10					.byte WordFlags	;wh_Flags
>de6b	03					.byte 3	;wh_CodeLength
>de6c	17					  .byte LinkDisplacement	; offset to previous nt
=$de6d					XtPtr1 ::= *
=56809					WordListLink ::= Nt0 ; remember the nt of this word for later
.de6d	20 47 c5	jsr $c547	D_Dot_R:	jsr PopA		; save field width
.de70	48		pha		D_Dot_R_A:	pha
.de71	b5 27		lda $27,x			lda DStack+1,x		; save sign
.de73	08		php				php
.de74	20 c7 d8	jsr $d8c7			jsr DAbs
.de77	20 30 bd	jsr $bd30	fmt_dr3:	jsr Less_Number_Sign	; start formatted output
.de7a	20 af bd	jsr $bdaf			jsr Number_sign_s	; do all digits
.de7d	28		plp				plp			; do the sign
.de7e	20 c9 bd	jsr $bdc9			jsr Sign_P
.de81	4c 3e de	jmp $de3e			jmp fmt_r
=23					CodeLen	.var *-XtPtr1
=$de84					Here1 = *	; remember here
>de6b	17					.byte CodeLen	;patch wh_CodeLength
>de84	3f				Name0:	.text "?"	;  name of word as a string, ending at wh_NameLastChar
=1					NameLength = *-Name0
=56837					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>de85	e1					.byte (("?"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=28					LinkDisplacement = Nt0-WordListLink
>de86	10					.byte WordFlags	;wh_Flags
>de87	03					.byte 3	;wh_CodeLength
>de88	1c					  .byte LinkDisplacement	; offset to previous nt
=$de89					XtPtr1 ::= *
=56837					WordListLink ::= Nt0 ; remember the nt of this word for later
.de89					Question:
.de89	20 b2 e0	jsr $e0b2			jsr Fetch
.de8c	4c c2 dd	jmp $ddc2			jmp Dot
=6					CodeLen	.var *-XtPtr1
=$de8f					Here1 = *	; remember here
>de87	06					.byte CodeLen	;patch wh_CodeLength
>de8f	32 44 75 70			Name0:	.text "2Dup"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=56851					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>de93	04					.byte (("2Dup"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=14					LinkDisplacement = Nt0-WordListLink
>de94	10					.byte WordFlags	;wh_Flags
>de95	03					.byte 3	;wh_CodeLength
>de96	0e					  .byte LinkDisplacement	; offset to previous nt
=$de97					XtPtr1 ::= *
=56851					WordListLink ::= Nt0 ; remember the nt of this word for later
.de97	ca		dex		Two_Dup:	dex		; alloc DStack space
.de98	ca		dex				dex
.de99	ca		dex				dex
.de9a	ca		dex				dex
.de9b	e0 29		cpx #$29		cpx #(DSDim-4)*2+1	; far enough below end of data stack (& not negative)?
.de9d	b0 11		bcs $deb0		bcs Throw_Stack_13
.de9f	b5 2a		lda $2a,x			lda DStack+4,x	; copy n2
.dea1	95 26		sta $26,x			sta DStack+0,x
.dea3	b5 2b		lda $2b,x			lda DStack+5,x
.dea5	95 27		sta $27,x			sta DStack+1,x
.dea7	b5 2c		lda $2c,x			lda DStack+6,x	; copy n1
.dea9	95 28		sta $28,x			sta DStack+2,x
.deab	b5 2d		lda $2d,x			lda DStack+7,x
.dead	95 29		sta $29,x			sta DStack+3,x
=24					CodeLen	.var *-XtPtr1
=$deaf					Here1 = *	; remember here
>de95	18					.byte CodeLen	;patch wh_CodeLength
.deaf	60		rts				rts
.deb0	4c ae c5	jmp $c5ae	Throw_Stack_13: jmp Throw_Stack
>deb3	54 75 63 6b			Name0:	.text "Tuck"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=56887					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>deb7	64					.byte (("Tuck"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=36					LinkDisplacement = Nt0-WordListLink
>deb8	10					.byte WordFlags	;wh_Flags
>deb9	03					.byte 3	;wh_CodeLength
>deba	24					  .byte LinkDisplacement	; offset to previous nt
=$debb					XtPtr1 ::= *
=56887					WordListLink ::= Nt0 ; remember the nt of this word for later
.debb	ca		dex		Tuck:		dex		; alloc DStack space
.debc	ca		dex				dex
.debd	e0 2b		cpx #$2b		cpx #(DSDim-3)*2+1	; far enough below end of data stack (& not negative)?
.debf	b0 ef		bcs $deb0		bcs Throw_Stack_13
.dec1	b4 2a		ldy $2a,x			ldy DStack+4,x	; LSB
.dec3	b5 28		lda $28,x			lda DStack+2,x
.dec5	95 2a		sta $2a,x			sta DStack+4,x
.dec7	94 28		sty $28,x			sty DStack+2,x
.dec9	95 26		sta $26,x			sta DStack+0,x
.decb	b4 2b		ldy $2b,x			ldy DStack+5,x	; MSB
.decd	b5 29		lda $29,x			lda DStack+3,x
.decf	95 2b		sta $2b,x			sta DStack+5,x
.ded1	94 29		sty $29,x			sty DStack+3,x
.ded3	95 27		sta $27,x			sta DStack+1,x
=26					CodeLen	.var *-XtPtr1
=$ded5					Here1 = *	; remember here
>deb9	1a					.byte CodeLen	;patch wh_CodeLength
.ded5	60		rts				rts
>ded6	43 2c				Name0:	.text "C,"	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=56920					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>ded8	82					.byte (("C,"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=33					LinkDisplacement = Nt0-WordListLink
>ded9	10					.byte WordFlags	;wh_Flags
>deda	03					.byte 3	;wh_CodeLength
>dedb	21					  .byte LinkDisplacement	; offset to previous nt
=$dedc					XtPtr1 ::= *
=56920					WordListLink ::= Nt0 ; remember the nt of this word for later
.dedc	20 47 c5	jsr $c547	C_Comma:	jsr PopA	; pop c, with underflow check
.dedf					C_Comma_A:
.dedf	94 25		sty $25,x			sty DStack-1,x	; save Y
.dee1	a0 00		ldy #$00			ldy #0		; store A
.dee3	91 00		sta ($00),y			sta (cp),y
.dee5	e6 00		inc $00				inc cp+0	; increment cp
.dee7	d0 02		bne $deeb			bne +
.dee9	e6 01		inc $01				inc cp+1
.deeb					+
.deeb	b4 25		ldy $25,x			ldy DStack-1,x	; restore Y
=17					CodeLen	.var *-XtPtr1
=$deed					Here1 = *	; remember here
>deda	11					.byte CodeLen	;patch wh_CodeLength
.deed	60		rts				rts
>deee	2c				Name0:	.text ","	;  name of word as a string, ending at wh_NameLastChar
=1					NameLength = *-Name0
=56943					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>deef	81					.byte ((","[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=23					LinkDisplacement = Nt0-WordListLink
>def0	10					.byte WordFlags	;wh_Flags
>def1	03					.byte 3	;wh_CodeLength
>def2	17					  .byte LinkDisplacement	; offset to previous nt
=$def3					XtPtr1 ::= *
=56943					WordListLink ::= Nt0 ; remember the nt of this word for later
.def3	20 62 c5	jsr $c562	Comma:		jsr PopYA	; pop n, with underflow check
.def6					Comma_YA:
.def6	20 df de	jsr $dedf			jsr C_Comma_A	; compile LSB
.def9	98		tya				tya		; compile MSB
.defa	4c df de	jmp $dedf			jmp C_Comma_A
=10					CodeLen	.var *-XtPtr1
=$defd					Here1 = *	; remember here
>def1	0a					.byte CodeLen	;patch wh_CodeLength
>defd	32 2c				Name0:	.text "2,"	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=56959					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>deff	82					.byte (("2,"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=16					LinkDisplacement = Nt0-WordListLink
>df00	10					.byte WordFlags	;wh_Flags
>df01	03					.byte 3	;wh_CodeLength
>df02	10					  .byte LinkDisplacement	; offset to previous nt
=$df03					XtPtr1 ::= *
=56959					WordListLink ::= Nt0 ; remember the nt of this word for later
.df03	20 f3 de	jsr $def3	Two_Comma:	jsr Comma
.df06	4c f3 de	jmp $def3			jmp Comma
=6					CodeLen	.var *-XtPtr1
=$df09					Here1 = *	; remember here
>df01	06					.byte CodeLen	;patch wh_CodeLength
.df09	a9 e8		lda #$e8	Drop_Comma:	lda #$e8	;inx
.df0b	a8		tay				tay
.df0c	d0 e8		bne $def6			bne Comma_YA
=11					CodeLen	.var *-XtPtr1
=$df0e					Here1 = *	; remember here
>df01	0b					.byte CodeLen	;patch wh_CodeLength
>df0e	4a 73 72 2c 59 41		Name0:	.text "Jsr,YA"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=56980					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>df14	26					.byte (("Jsr,YA"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=21					LinkDisplacement = Nt0-WordListLink
=$12						  WordFlags ::= WordFlags | DB
>df15	12					.byte WordFlags	;wh_Flags
>df16	03					.byte 3	;wh_CodeLength
>df17	15					  .byte LinkDisplacement	; offset to previous nt
>df18	25 df					  .word Jsr_Comma_YA		; pointer to xt
=0					XtPtr1 ::= 0
=56980					WordListLink ::= Nt0 ; remember the nt of this word for later
>df1a	4a 73 72 2c			Name0:	.text "Jsr,"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=56990					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>df1e	84					.byte (("Jsr,"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=10					LinkDisplacement = Nt0-WordListLink
>df1f	10					.byte WordFlags	;wh_Flags
>df20	03					.byte 3	;wh_CodeLength
>df21	0a					  .byte LinkDisplacement	; offset to previous nt
=$df22					XtPtr1 ::= *
=56990					WordListLink ::= Nt0 ; remember the nt of this word for later
.df22	20 62 c5	jsr $c562	Jsr_Comma:	jsr PopYA	; pop addr (optimize can skip)
.df25	20 2e c9	jsr $c92e	Jsr_Comma_YA:	jsr PushYA	; push addr
.df28	a9 20		lda #$20			lda #$20	; JSR abs opcode
.df2a	20 df de	jsr $dedf	Jsr_Comma_3:	jsr C_Comma_A
.df2d	4c f3 de	jmp $def3			jmp Comma	; compile addr
=14					CodeLen	.var *-XtPtr1
=$df30					Here1 = *	; remember here
>df20	0e					.byte CodeLen	;patch wh_CodeLength
>df30	4a 6d 70 2c			Name0:	.text "Jmp,"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=57012					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>df34	84					.byte (("Jmp,"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=22					LinkDisplacement = Nt0-WordListLink
>df35	10					.byte WordFlags	;wh_Flags
>df36	03					.byte 3	;wh_CodeLength
>df37	16					  .byte LinkDisplacement	; offset to previous nt
=$df38					XtPtr1 ::= *
=57012					WordListLink ::= Nt0 ; remember the nt of this word for later
.df38	20 62 c5	jsr $c562	Jmp_Comma:	jsr PopYA	; pop addr (optimize can skip)
.df3b	20 2e c9	jsr $c92e	Jmp_Comma_YA:	jsr PushYA	; push addr
.df3e	a9 4c		lda #$4c			lda #$4c	; JMP abs opcode
.df40	d0 e8		bne $df2a			bne Jsr_Comma_3
.df42					Jmp_Comma_NT_YA:
.df42	20 2e c9	jsr $c92e			jsr PushYA
.df45	20 3c cf	jsr $cf3c			jsr Name_To_Int	; convert nt to xt
.df48	4c 38 df	jmp $df38			jmp Jmp_Comma
=19					CodeLen	.var *-XtPtr1
=$df4b					Here1 = *	; remember here
>df36	13					.byte CodeLen	;patch wh_CodeLength
>df4b	43 40				Name0:	.text "C@"	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=57037					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>df4d	02					.byte (("C@"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=25					LinkDisplacement = Nt0-WordListLink
>df4e	10					.byte WordFlags	;wh_Flags
>df4f	03					.byte 3	;wh_CodeLength
>df50	19					  .byte LinkDisplacement	; offset to previous nt
=$df51					XtPtr1 ::= *
=57037					WordListLink ::= Nt0 ; remember the nt of this word for later
.df51					C_Fetch:
.df51	e0 2f		cpx #$2f		cpx #(DSDim-1)*2+1	; far enough below end of data stack (& not negative)?
.df53	b0 1c		bcs $df71		bcs Throw_Stack_16
.df55	a1 26		lda ($26,x)			lda (DStack+0,x)
.df57	95 26		sta $26,x			sta DStack+0,x
.df59	a9 00		lda #$00			lda #0
.df5b	95 27		sta $27,x			sta DStack+1,x	; zero MSB
=12					CodeLen	.var *-XtPtr1
=$df5d					Here1 = *	; remember here
>df4f	0c					.byte CodeLen	;patch wh_CodeLength
.df5d	60		rts				rts
>df5e	43 21				Name0:	.text "C!"	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=57056					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>df60	22					.byte (("C!"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=19					LinkDisplacement = Nt0-WordListLink
>df61	10					.byte WordFlags	;wh_Flags
>df62	03					.byte 3	;wh_CodeLength
>df63	13					  .byte LinkDisplacement	; offset to previous nt
=$df64					XtPtr1 ::= *
=57056					WordListLink ::= Nt0 ; remember the nt of this word for later
.df64					C_Store:
.df64	e0 2d		cpx #$2d		cpx #(DSDim-2)*2+1	; far enough below end of data stack (& not negative)?
.df66	b0 09		bcs $df71		bcs Throw_Stack_16
.df68	b5 28		lda $28,x			lda DStack+2,x
.df6a	81 26		sta ($26,x)			sta (DStack+0,x)
.df6c	e8		inx				inx
.df6d	e8		inx				inx
.df6e	e8		inx				inx
.df6f	e8		inx				inx
=12					CodeLen	.var *-XtPtr1
=$df70					Here1 = *	; remember here
>df62	0c					.byte CodeLen	;patch wh_CodeLength
.df70	60		rts				rts
.df71	4c ae c5	jmp $c5ae	Throw_Stack_16: jmp Throw_Stack
>df74	31 2b 21			Name0:	.text "1+!"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=57079					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>df77	23					.byte (("1+!"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=0					WordFlags ::= 0	; modifiable copy, remember for later
=23					LinkDisplacement = Nt0-WordListLink
>df78	00					.byte WordFlags	;wh_Flags
>df79	03					.byte 3	;wh_CodeLength
>df7a	17					  .byte LinkDisplacement	; offset to previous nt
=$df7b					XtPtr1 ::= *
=57079					WordListLink ::= Nt0 ; remember the nt of this word for later
.df7b	a9 01		lda #$01	OnePlusStore:	lda #1
.df7d	e0 2f		cpx #$2f		cpx #(DSDim-1)*2+1	; far enough below end of data stack (& not negative)?
.df7f	b0 f0		bcs $df71		bcs Throw_Stack_16
.df81	18		clc				clc
.df82	61 26		adc ($26,x)			adc (DStack+0,x)	; increment lo byte
.df84	81 26		sta ($26,x)			sta (DStack+0,x)
.df86	90 0c		bcc $df94			bcc _7			; if carry
.df88	f6 26		inc $26,x			inc DStack+0,x		;   point at hi byte
.df8a	d0 02		bne $df8e			bne +
.df8c	f6 27		inc $27,x			inc DStack+1,x
.df8e					+
.df8e	a1 26		lda ($26,x)			lda (DStack+0,x)	;   increment hi byte
.df90	69 00		adc #$00			adc #0
.df92	81 26		sta ($26,x)			sta (Dstack+0,x)
.df94					_7:
.df94	e8		inx				inx			; Drop addr
.df95	e8		inx				inx
=27					CodeLen	.var *-XtPtr1
=$df96					Here1 = *	; remember here
>df79	1b					.byte CodeLen	;patch wh_CodeLength
.df96	60		rts				rts
>df97	2b 21				Name0:	.text "+!"	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=57113					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>df99	22					.byte (("+!"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=34					LinkDisplacement = Nt0-WordListLink
>df9a	10					.byte WordFlags	;wh_Flags
>df9b	03					.byte 3	;wh_CodeLength
>df9c	22					  .byte LinkDisplacement	; offset to previous nt
=$df9d					XtPtr1 ::= *
=57113					WordListLink ::= Nt0 ; remember the nt of this word for later
.df9d					Plus_store:
.df9d	e0 2d		cpx #$2d		cpx #(DSDim-2)*2+1	; far enough below end of data stack (& not negative)?
.df9f	b0 d0		bcs $df71		bcs Throw_Stack_16
.dfa1	18		clc				clc
.dfa2	b5 28		lda $28,x			lda DStack+2,x
.dfa4	61 26		adc ($26,x)			adc (DStack+0,x)
.dfa6	81 26		sta ($26,x)			sta (DStack+0,x)
.dfa8	f6 26		inc $26,x			inc DStack+0,x
.dfaa	d0 02		bne $dfae			bne +
.dfac	f6 27		inc $27,x			inc DStack+1,x
.dfae					+
.dfae	b5 29		lda $29,x			lda DStack+3,x
.dfb0	61 26		adc ($26,x)			adc (DStack+0,x)
.dfb2	81 26		sta ($26,x)			sta (DStack+0,x)
.dfb4	4c 04 d7	jmp $d704			jmp Two_Drop
=26					CodeLen	.var *-XtPtr1
=$dfb7					Here1 = *	; remember here
>df9b	1a					.byte CodeLen	;patch wh_CodeLength
>dfb7	45 6d 69 74 41			Name0:	.text "EmitA"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=57148					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>dfbc	25					.byte (("EmitA"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=35					LinkDisplacement = Nt0-WordListLink
=$12						  WordFlags ::= WordFlags | DB
>dfbd	12					.byte WordFlags	;wh_Flags
>dfbe	03					.byte 3	;wh_CodeLength
>dfbf	23					  .byte LinkDisplacement	; offset to previous nt
>dfc0	cd df					  .word Emit_A		; pointer to xt
=0					XtPtr1 ::= 0
=57148					WordListLink ::= Nt0 ; remember the nt of this word for later
>dfc2	45 6d 69 74			Name0:	.text "Emit"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=57158					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>dfc6	84					.byte (("Emit"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=10					LinkDisplacement = Nt0-WordListLink
>dfc7	10					.byte WordFlags	;wh_Flags
>dfc8	03					.byte 3	;wh_CodeLength
>dfc9	0a					  .byte LinkDisplacement	; offset to previous nt
=$dfca					XtPtr1 ::= *
=57158					WordListLink ::= Nt0 ; remember the nt of this word for later
.dfca	20 47 c5	jsr $c547	Emit:		jsr PopA		; pop char, with underflow check
.dfcd					Emit_A:
.dfcd	6c 06 03	jmp ($0306)			jmp (output)		; JSR/RTS
=6					CodeLen	.var *-XtPtr1
=$dfd0					Here1 = *	; remember here
>dfc8	06					.byte CodeLen	;patch wh_CodeLength
>dfd0	42 65 6c 6c			Name0:	.text "Bell"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=57172					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>dfd4	84					.byte (("Bell"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=14					LinkDisplacement = Nt0-WordListLink
>dfd5	10					.byte WordFlags	;wh_Flags
>dfd6	03					.byte 3	;wh_CodeLength
>dfd7	0e					  .byte LinkDisplacement	; offset to previous nt
=$dfd8					XtPtr1 ::= *
=57172					WordListLink ::= Nt0 ; remember the nt of this word for later
.dfd8	a9 07		lda #$07	Bell:		lda #7		; ASCII value for BELL
.dfda	d0 f1		bne $dfcd			bne Emit_A
=4					CodeLen	.var *-XtPtr1
=$dfdc					Here1 = *	; remember here
>dfd6	04					.byte CodeLen	;patch wh_CodeLength
>dfdc	53 70 61 63 65			Name0:	.text "Space"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=57185					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>dfe1	a5					.byte (("Space"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>dfe2	10					.byte WordFlags	;wh_Flags
>dfe3	03					.byte 3	;wh_CodeLength
>dfe4	0d					  .byte LinkDisplacement	; offset to previous nt
=$dfe5					XtPtr1 ::= *
=57185					WordListLink ::= Nt0 ; remember the nt of this word for later
.dfe5	a9 20		lda #$20	Space:		lda #AscSP
.dfe7	d0 e4		bne $dfcd			bne Emit_A
=4					CodeLen	.var *-XtPtr1
=$dfe9					Here1 = *	; remember here
>dfe3	04					.byte CodeLen	;patch wh_CodeLength
>dfe9	54 79 70 65			Name0:	.text "Type"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=57197					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>dfed	a4					.byte (("Type"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=80					WordFlags ::= UF+NN	; modifiable copy, remember for later
=12					LinkDisplacement = Nt0-WordListLink
>dfee	50					.byte WordFlags	;wh_Flags
>dfef	03					.byte 3	;wh_CodeLength
>dff0	0c					  .byte LinkDisplacement	; offset to previous nt
=$dff1					XtPtr1 ::= *
=57197					WordListLink ::= Nt0 ; remember the nt of this word for later
.dff1					Type:
.dff1	e0 2d		cpx #$2d		cpx #(DSDim-2)*2+1	; far enough below end of data stack (& not negative)?
.dff3	b0 6c		bcs $e061		bcs Throw_Stack_03
.dff5	4c 02 e0	jmp $e002			jmp _test
.dff8					_loop:
.dff8	d6 26		dec $26,x			dec DStack+0,x		; finish length decrement
.dffa	a1 28		lda ($28,x)			lda (DStack+2,x)	; Send the current character
.dffc	20 cd df	jsr $dfcd			jsr Emit_A
.dfff	20 42 dc	jsr $dc42			jsr NOS_One_Plus	; increment address
.e002	b5 26		lda $26,x	_test:		lda DStack+0,x		; decrement length & test for <0
.e004	d0 f2		bne $dff8			bne _loop
.e006	d6 27		dec $27,x			dec DStack+1,x
.e008	10 ee		bpl $dff8			bpl _loop
.e00a	4c 04 d7	jmp $d704			jmp Two_drop
=28					CodeLen	.var *-XtPtr1
=$e00d					Here1 = *	; remember here
>dfef	1c					.byte CodeLen	;patch wh_CodeLength
.e00d					Print_ASCIIZ_YA_no_lf:
.e00d	85 18		sta $18				sta tmp3+0		; save string address
.e00f	84 19		sty $19				sty tmp3+1
.e011	a0 00		ldy #$00			ldy #0
.e013					Print_ASCIIZ_tmp3_no_lf:
.e013	b1 18		lda ($18),y			lda (tmp3),y
.e015	f0 06		beq $e01d			beq _done		; end of string?
.e017	20 cd df	jsr $dfcd			jsr emit_a
.e01a	c8		iny				iny
.e01b	d0 f6		bne $e013			bne Print_ASCIIZ_tmp3_no_lf
.e01d					_done:
.e01d	60		rts				rts
.e01e					Print_ASCIIZ_YA:
.e01e	20 0d e0	jsr $e00d			jsr Print_ASCIIZ_YA_no_lf
.e021	4c b7 bc	jmp $bcb7	                jmp CR
>e024	45 78 65 63 75 74 65		Name0:	.text "Execute"	;  name of word as a string, ending at wh_NameLastChar
=7					NameLength = *-Name0
=57259					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e02b	a7					.byte (("Execute"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=62					LinkDisplacement = Nt0-WordListLink
>e02c	10					.byte WordFlags	;wh_Flags
>e02d	03					.byte 3	;wh_CodeLength
>e02e	3e					  .byte LinkDisplacement	; offset to previous nt
=$e02f					XtPtr1 ::= *
=57259					WordListLink ::= Nt0 ; remember the nt of this word for later
.e02f					Execute:
.e02f	e0 2f		cpx #$2f		cpx #(DSDim-1)*2+1	; far enough below end of data stack (& not negative)?
.e031	b0 2e		bcs $e061		bcs Throw_Stack_03
.e033	b5 27		lda $27,x			lda DStack+1,x	; addr for RTI
.e035	48		pha				pha
.e036	b5 26		lda $26,x			lda DStack+0,x
.e038	48		pha				pha
.e039	e8		inx				inx		; drop addr
.e03a	e8		inx				inx
.e03b	08		php				php		; flags for RTI
.e03c	40		rti				rti
=14					CodeLen	.var *-XtPtr1
=$e03d					Here1 = *	; remember here
>e02d	0e					.byte CodeLen	;patch wh_CodeLength
>e03d	32 52 6f 74			Name0:	.text "2Rot"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=57281					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e041	84					.byte (("2Rot"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=22					LinkDisplacement = Nt0-WordListLink
>e042	10					.byte WordFlags	;wh_Flags
>e043	03					.byte 3	;wh_CodeLength
>e044	16					  .byte LinkDisplacement	; offset to previous nt
=$e045					XtPtr1 ::= *
=57281					WordListLink ::= Nt0 ; remember the nt of this word for later
.e045					TwoRot:
.e045	e0 25		cpx #$25		cpx #(DSDim-6)*2+1	; far enough below end of data stack (& not negative)?
.e047	b0 18		bcs $e061		bcs Throw_Stack_03
.e049	86 14		stx $14				stx tmp1+0
.e04b	e8		inx				inx		; do 4 times
.e04c	e8		inx				inx
.e04d	e8		inx				inx
.e04e	e8		inx				inx
.e04f	ca		dex		-		dex
.e050	b4 2e		ldy $2e,x			ldy DStack+8,x	; do a byte
.e052	b5 2a		lda $2a,x			lda DStack+4,x
.e054	95 2e		sta $2e,x			sta DStack+8,x
.e056	b5 26		lda $26,x			lda DStack+0,x
.e058	95 2a		sta $2a,x			sta DStack+4,x
.e05a	94 26		sty $26,x			sty DStack+0,x
.e05c	e4 14		cpx $14				cpx tmp1+0
.e05e	d0 ef		bne $e04f			bne -
=27					CodeLen	.var *-XtPtr1
=$e060					Here1 = *	; remember here
>e043	1b					.byte CodeLen	;patch wh_CodeLength
.e060	60		rts				rts
.e061	4c ae c5	jmp $c5ae	Throw_Stack_03: jmp Throw_Stack
>e064	52 6f 74			Name0:	.text "Rot"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=57319					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e067	83					.byte (("Rot"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=38					LinkDisplacement = Nt0-WordListLink
>e068	10					.byte WordFlags	;wh_Flags
>e069	03					.byte 3	;wh_CodeLength
>e06a	26					  .byte LinkDisplacement	; offset to previous nt
=$e06b					XtPtr1 ::= *
=57319					WordListLink ::= Nt0 ; remember the nt of this word for later
.e06b					Rot:
.e06b	e0 2b		cpx #$2b		cpx #(DSDim-3)*2+1	; far enough below end of data stack (& not negative)?
.e06d	b0 f2		bcs $e061		bcs Throw_Stack_03
.e06f	b4 2b		ldy $2b,x			ldy DStack+5,x	; do MSB
.e071	b5 29		lda $29,x			lda DStack+3,x
.e073	95 2b		sta $2b,x			sta DStack+5,x
.e075	b5 27		lda $27,x			lda DStack+1,x
.e077	95 29		sta $29,x			sta DStack+3,x
.e079	94 27		sty $27,x			sty DStack+1,x
.e07b	b4 2a		ldy $2a,x			ldy DStack+4,x	; do LSB
.e07d	b5 28		lda $28,x			lda DStack+2,x
.e07f	95 2a		sta $2a,x			sta DStack+4,x
.e081	b5 26		lda $26,x			lda DStack+0,x
.e083	95 28		sta $28,x			sta DStack+2,x
.e085	94 26		sty $26,x			sty DStack+0,x
=28					CodeLen	.var *-XtPtr1
=$e087					Here1 = *	; remember here
>e069	1c					.byte CodeLen	;patch wh_CodeLength
.e087	60		rts				rts
>e088	2d 52 6f 74			Name0:	.text "-Rot"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=57356					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e08c	84					.byte (("-Rot"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=37					LinkDisplacement = Nt0-WordListLink
>e08d	10					.byte WordFlags	;wh_Flags
>e08e	03					.byte 3	;wh_CodeLength
>e08f	25					  .byte LinkDisplacement	; offset to previous nt
=$e090					XtPtr1 ::= *
=57356					WordListLink ::= Nt0 ; remember the nt of this word for later
.e090					Not_Rot:
.e090	e0 2b		cpx #$2b		cpx #(DSDim-3)*2+1	; far enough below end of data stack (& not negative)?
.e092	b0 cd		bcs $e061		bcs Throw_Stack_03
.e094	b4 27		ldy $27,x			ldy DStack+1,x	; do MSB
.e096	b5 29		lda $29,x			lda DStack+3,x
.e098	95 27		sta $27,x			sta DStack+1,x
.e09a	b5 2b		lda $2b,x			lda DStack+5,x
.e09c	95 29		sta $29,x			sta DStack+3,x
.e09e	94 2b		sty $2b,x			sty DStack+5,x
.e0a0	b4 26		ldy $26,x			ldy DStack+0,x	; do LSB
.e0a2	b5 28		lda $28,x			lda DStack+2,x
.e0a4	95 26		sta $26,x			sta DStack+0,x
.e0a6	b5 2a		lda $2a,x			lda DStack+4,x
.e0a8	95 28		sta $28,x			sta DStack+2,x
.e0aa	94 2a		sty $2a,x			sty DStack+4,x
=28					CodeLen	.var *-XtPtr1
=$e0ac					Here1 = *	; remember here
>e08e	1c					.byte CodeLen	;patch wh_CodeLength
.e0ac	60		rts				rts
>e0ad	40				Name0:	.text "@"	;  name of word as a string, ending at wh_NameLastChar
=1					NameLength = *-Name0
=57390					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e0ae	01					.byte (("@"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=34					LinkDisplacement = Nt0-WordListLink
>e0af	10					.byte WordFlags	;wh_Flags
>e0b0	03					.byte 3	;wh_CodeLength
>e0b1	22					  .byte LinkDisplacement	; offset to previous nt
=$e0b2					XtPtr1 ::= *
=57390					WordListLink ::= Nt0 ; remember the nt of this word for later
.e0b2					Fetch:
.e0b2	e0 2f		cpx #$2f		cpx #(DSDim-1)*2+1	; far enough below end of data stack (& not negative)?
.e0b4	b0 ab		bcs $e061		bcs Throw_Stack_03
.e0b6	a1 26		lda ($26,x)			lda (DStack+0,x)		; LSB
.e0b8	a8		tay				tay
.e0b9	f6 26		inc $26,x			inc DStack+0,x
.e0bb	d0 02		bne $e0bf			bne +
.e0bd	f6 27		inc $27,x			inc DStack+1,x
.e0bf					+
.e0bf	a1 26		lda ($26,x)			lda (DStack+0,x)		; MSB
.e0c1	95 27		sta $27,x			sta DStack+1,x
.e0c3	94 26		sty $26,x			sty DStack+0,x
=19					CodeLen	.var *-XtPtr1
=$e0c5					Here1 = *	; remember here
>e0b0	13					.byte CodeLen	;patch wh_CodeLength
.e0c5	60		rts				rts
>e0c6	21				Name0:	.text "!"	;  name of word as a string, ending at wh_NameLastChar
=1					NameLength = *-Name0
=57415					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e0c7	21					.byte (("!"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=25					LinkDisplacement = Nt0-WordListLink
>e0c8	10					.byte WordFlags	;wh_Flags
>e0c9	03					.byte 3	;wh_CodeLength
>e0ca	19					  .byte LinkDisplacement	; offset to previous nt
=$e0cb					XtPtr1 ::= *
=57415					WordListLink ::= Nt0 ; remember the nt of this word for later
.e0cb					Store:
.e0cb	e0 2d		cpx #$2d		cpx #(DSDim-2)*2+1	; far enough below end of data stack (& not negative)?
.e0cd	b0 92		bcs $e061		bcs Throw_Stack_03
.e0cf	b5 28		lda $28,x			lda DStack+2,x	; LSB
.e0d1	81 26		sta ($26,x)			sta (DStack+0,x)
.e0d3	f6 26		inc $26,x			inc DStack+0,x
.e0d5	d0 02		bne $e0d9			bne +
.e0d7	f6 27		inc $27,x			inc DStack+1,x
.e0d9					+
.e0d9	b5 29		lda $29,x			lda DStack+3,x	; MSB
.e0db	81 26		sta ($26,x)			sta (DStack+0,x)
.e0dd	e8		inx				inx		; 2Drop
.e0de	e8		inx				inx
.e0df	e8		inx				inx
.e0e0	e8		inx				inx
=22					CodeLen	.var *-XtPtr1
=$e0e1					Here1 = *	; remember here
>e0c9	16					.byte CodeLen	;patch wh_CodeLength
.e0e1	60		rts				rts
>e0e2	30 21				Name0:	.text "0!"	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=57444					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e0e4	22					.byte (("0!"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=0					WordFlags ::= 0	; modifiable copy, remember for later
=29					LinkDisplacement = Nt0-WordListLink
>e0e5	00					.byte WordFlags	;wh_Flags
>e0e6	03					.byte 3	;wh_CodeLength
>e0e7	1d					  .byte LinkDisplacement	; offset to previous nt
=$e0e8					XtPtr1 ::= *
=57444					WordListLink ::= Nt0 ; remember the nt of this word for later
.e0e8	20 6d c5	jsr $c56d	ZStore:		jsr PopTmp1	; pop addr, check underflow
.e0eb	a9 00		lda #$00			lda #0
.e0ed	a8		tay				tay		; clear LSB
.e0ee	91 14		sta ($14),y			sta (tmp1),y
.e0f0	c8		iny				iny		; clear MSB
.e0f1	91 14		sta ($14),y			sta (tmp1),y
=11					CodeLen	.var *-XtPtr1
=$e0f3					Here1 = *	; remember here
>e0e6	0b					.byte CodeLen	;patch wh_CodeLength
.e0f3	60		rts				rts
>e0f4	3e 52				Name0:	.text ">R"	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=57462					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e0f6	42					.byte ((">R"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=52					WordFlags ::= CO+ST	; modifiable copy, remember for later
=18					LinkDisplacement = Nt0-WordListLink
>e0f7	34					.byte WordFlags	;wh_Flags
>e0f8	03					.byte 3	;wh_CodeLength
>e0f9	12					  .byte LinkDisplacement	; offset to previous nt
=$e0fa					XtPtr1 ::= *
=57462					WordListLink ::= Nt0 ; remember the nt of this word for later
.e0fa					To_R:
.e0fa	68		pla				pla		; move the RTS address out of the way
.e0fb	85 1c		sta $1c				sta tmp5+0
.e0fd	68		pla				pla
.e0fe	85 1d		sta $1d				sta tmp5+1
.e100	20 8b c5	jsr $c58b			jsr underflow_1
.e103	b5 27		lda $27,x			lda DStack+1,x	; MSB
.e105	48		pha				pha
.e106	b5 26		lda $26,x			lda DStack+0,x	; LSB
.e108	48		pha				pha
.e109	e8		inx				inx
.e10a	e8		inx				inx
.e10b	a5 1d		lda $1d				lda tmp5+1	; move the RTS address back in
.e10d	48		pha				pha
.e10e	a5 1c		lda $1c				lda tmp5+0
.e110	48		pha				pha
=23					CodeLen	.var *-XtPtr1
=$e111					Here1 = *	; remember here
>e0f8	17					.byte CodeLen	;patch wh_CodeLength
.e111	60		rts				rts
>e112	52 3e				Name0:	.text "R>"	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=57492					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e114	c2					.byte (("R>"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=52					WordFlags ::= CO+ST	; modifiable copy, remember for later
=30					LinkDisplacement = Nt0-WordListLink
>e115	34					.byte WordFlags	;wh_Flags
>e116	03					.byte 3	;wh_CodeLength
>e117	1e					  .byte LinkDisplacement	; offset to previous nt
=$e118					XtPtr1 ::= *
=57492					WordListLink ::= Nt0 ; remember the nt of this word for later
.e118					R_From:
.e118	68		pla				pla		; Move the RTS addr out of the way
.e119	85 1c		sta $1c				sta tmp5+0
.e11b	68		pla				pla
.e11c	85 1d		sta $1d				sta tmp5+1
.e11e	ca		dex				dex
.e11f	ca		dex				dex
.e120	68		pla				pla		; LSB
.e121	95 26		sta $26,x			sta DStack+0,x
.e123	68		pla				pla		; MSB
.e124	95 27		sta $27,x			sta DStack+1,x
.e126	a5 1d		lda $1d				lda tmp5+1	; Restore the RTS addr
.e128	48		pha				pha
.e129	a5 1c		lda $1c				lda tmp5+0
.e12b	48		pha				pha
=20					CodeLen	.var *-XtPtr1
=$e12c					Here1 = *	; remember here
>e116	14					.byte CodeLen	;patch wh_CodeLength
.e12c	60		rts				rts
>e12d	52 40				Name0:	.text "R@"	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=57519					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e12f	02					.byte (("R@"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=20					WordFlags ::= NN+CO	; modifiable copy, remember for later
=27					LinkDisplacement = Nt0-WordListLink
>e130	14					.byte WordFlags	;wh_Flags
>e131	03					.byte 3	;wh_CodeLength
>e132	1b					  .byte LinkDisplacement	; offset to previous nt
=$e133					XtPtr1 ::= *
=57519					WordListLink ::= Nt0 ; remember the nt of this word for later
.e133					R_Fetch:
.e133	86 14		stx $14				stx tmp1	; save data stack index
.e135	ba		tsx				tsx		; X= return stack index
.e136	bd 03 01	lda $0103,x			lda RStack+3,x
.e139	bc 04 01	ldy $0104,x			ldy RStack+4,x
.e13c	a6 14		ldx $14				ldx tmp1	; restore data stack index
.e13e	4c 2e c9	jmp $c92e			jmp PushYA
=14					CodeLen	.var *-XtPtr1
=$e141					Here1 = *	; remember here
>e131	0e					.byte CodeLen	;patch wh_CodeLength
>e141	52 44 72 6f 70			Name0:	.text "RDrop"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=57542					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e146	05					.byte (("RDrop"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=52					WordFlags ::= CO+ST	; modifiable copy, remember for later
=23					LinkDisplacement = Nt0-WordListLink
>e147	34					.byte WordFlags	;wh_Flags
>e148	03					.byte 3	;wh_CodeLength
>e149	17					  .byte LinkDisplacement	; offset to previous nt
=$e14a					XtPtr1 ::= *
=57542					WordListLink ::= Nt0 ; remember the nt of this word for later
.e14a					RDrop:
.e14a	68		pla				pla		; Move the RTS addr out of the way
.e14b	85 1c		sta $1c				sta tmp5+0
.e14d	68		pla				pla
.e14e	85 1d		sta $1d				sta tmp5+1
.e150	68		pla				pla		; LSB
.e151	68		pla				pla		; MSB
.e152	a5 1d		lda $1d				lda tmp5+1	; Restore the RTS addr
.e154	48		pha				pha
.e155	a5 1c		lda $1c				lda tmp5+0
.e157	48		pha				pha
=14					CodeLen	.var *-XtPtr1
=$e158					Here1 = *	; remember here
>e148	0e					.byte CodeLen	;patch wh_CodeLength
.e158	60		rts				rts
>e159	4f 76 65 72			Name0:	.text "Over"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=57565					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e15d	44					.byte (("Over"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=23					LinkDisplacement = Nt0-WordListLink
>e15e	10					.byte WordFlags	;wh_Flags
>e15f	03					.byte 3	;wh_CodeLength
>e160	17					  .byte LinkDisplacement	; offset to previous nt
=$e161					XtPtr1 ::= *
=57565					WordListLink ::= Nt0 ; remember the nt of this word for later
.e161	b5 28		lda $28,x	Over:		lda DStack+2,x	; LSB
.e163	b4 29		ldy $29,x			ldy DStack+3,x	; MSB
.e165	ca		dex				dex		; PushYA
.e166	ca		dex				dex
.e167	e0 2b		cpx #$2b		cpx #(DSDim-3)*2+1	; far enough below end of data stack (& not negative)?
.e169	b0 37		bcs $e1a2		bcs Throw_Stack_04
.e16b	95 26		sta $26,x			sta DStack+0,x
.e16d	94 27		sty $27,x			sty DStack+1,x
=14					CodeLen	.var *-XtPtr1
=$e16f					Here1 = *	; remember here
>e15f	0e					.byte CodeLen	;patch wh_CodeLength
.e16f	60		rts				rts
>e170	3f 44 75 70			Name0:	.text "?Dup"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=57588					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e174	04					.byte (("?Dup"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=23					LinkDisplacement = Nt0-WordListLink
>e175	10					.byte WordFlags	;wh_Flags
>e176	03					.byte 3	;wh_CodeLength
>e177	17					  .byte LinkDisplacement	; offset to previous nt
=$e178					XtPtr1 ::= *
=57588					WordListLink ::= Nt0 ; remember the nt of this word for later
.e178					Question_Dup:
.e178	e0 2f		cpx #$2f		cpx #(DSDim-1)*2+1	; far enough below end of data stack (& not negative)?
.e17a	b0 26		bcs $e1a2		bcs Throw_Stack_04
.e17c	b5 26		lda $26,x			lda DStack+0,x	; Check if TOS is zero
.e17e	15 27		ora $27,x			ora DStack+1,x
.e180	d0 08		bne $e18a			bne Dup
=10					CodeLen	.var *-XtPtr1
=$e182					Here1 = *	; remember here
>e176	0a					.byte CodeLen	;patch wh_CodeLength
.e182	60		rts				rts
>e183	44 75 70			Name0:	.text "Dup"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=57606					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e186	03					.byte (("Dup"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=18					LinkDisplacement = Nt0-WordListLink
>e187	10					.byte WordFlags	;wh_Flags
>e188	03					.byte 3	;wh_CodeLength
>e189	12					  .byte LinkDisplacement	; offset to previous nt
=$e18a					XtPtr1 ::= *
=57606					WordListLink ::= Nt0 ; remember the nt of this word for later
.e18a	b5 26		lda $26,x	Dup:		lda DStack+0,x	; LSB
.e18c	b4 27		ldy $27,x			ldy DStack+1,x	; MSB
.e18e	ca		dex				dex		; PushYA
.e18f	ca		dex				dex
.e190	e0 2d		cpx #$2d		cpx #(DSDim-2)*2+1	; far enough below end of data stack (& not negative)?
.e192	b0 0e		bcs $e1a2		bcs Throw_Stack_04
.e194	95 26		sta $26,x			sta DStack+0,x
.e196	94 27		sty $27,x			sty DStack+1,x
=14					CodeLen	.var *-XtPtr1
=$e198					Here1 = *	; remember here
>e188	0e					.byte CodeLen	;patch wh_CodeLength
.e198	60		rts				rts
.e199					PushAY:
.e199	ca		dex				dex
.e19a	ca		dex				dex
.e19b	30 05		bmi $e1a2			bmi Throw_Stack_04	; DStack overflow?
.e19d	94 26		sty $26,x			sty DStack+0,x
.e19f	95 27		sta $27,x			sta DStack+1,x
=23					CodeLen	.var *-XtPtr1
=$e1a1					Here1 = *	; remember here
>e188	17					.byte CodeLen	;patch wh_CodeLength
.e1a1	60		rts				rts
.e1a2	4c ae c5	jmp $c5ae	Throw_Stack_04: jmp Throw_Stack
>e1a5	53 77 61 70			Name0:	.text "Swap"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=57641					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e1a9	04					.byte (("Swap"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=35					LinkDisplacement = Nt0-WordListLink
>e1aa	10					.byte WordFlags	;wh_Flags
>e1ab	03					.byte 3	;wh_CodeLength
>e1ac	23					  .byte LinkDisplacement	; offset to previous nt
=$e1ad					XtPtr1 ::= *
=57641					WordListLink ::= Nt0 ; remember the nt of this word for later
.e1ad					Swap:
.e1ad	e0 2d		cpx #$2d		cpx #(DSDim-2)*2+1	; far enough below end of data stack (& not negative)?
.e1af	b0 f1		bcs $e1a2		bcs Throw_Stack_04
.e1b1	b5 26		lda $26,x			lda DStack+0,x	; do LSB
.e1b3	b4 28		ldy $28,x			ldy DStack+2,x
.e1b5	95 28		sta $28,x			sta DStack+2,x
.e1b7	94 26		sty $26,x			sty DStack+0,x
.e1b9	b5 27		lda $27,x			lda DStack+1,x	; do MSB
.e1bb	b4 29		ldy $29,x			ldy DStack+3,x
.e1bd	95 29		sta $29,x			sta DStack+3,x
.e1bf	94 27		sty $27,x			sty DStack+1,x
=20					CodeLen	.var *-XtPtr1
=$e1c1					Here1 = *	; remember here
>e1ab	14					.byte CodeLen	;patch wh_CodeLength
.e1c1	60		rts				rts
>e1c2	44 72 6f 70			Name0:	.text "Drop"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=57670					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e1c6	04					.byte (("Drop"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=29					LinkDisplacement = Nt0-WordListLink
>e1c7	10					.byte WordFlags	;wh_Flags
>e1c8	03					.byte 3	;wh_CodeLength
>e1c9	1d					  .byte LinkDisplacement	; offset to previous nt
=$e1ca					XtPtr1 ::= *
=57670					WordListLink ::= Nt0 ; remember the nt of this word for later
.e1ca					Drop:
.e1ca	e0 2f		cpx #$2f		cpx #(DSDim-1)*2+1	; far enough below end of data stack (& not negative)?
.e1cc	b0 d4		bcs $e1a2		bcs Throw_Stack_04
.e1ce	e8		inx				inx
.e1cf	e8		inx				inx
=6					CodeLen	.var *-XtPtr1
=$e1d0					Here1 = *	; remember here
>e1c8	06					.byte CodeLen	;patch wh_CodeLength
.e1d0	60		rts				rts
=57670					forth_dictionary_start = WordListLink ; END of FORTH-WORDLIST
=0					WordListLink .var 0
>e1d1	57 6f 72 64 73			Name0:	.text "Words"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=57686					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e1d6	65					.byte (("Words"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=57686					LinkDisplacement = Nt0-WordListLink
=$11						  WordFlags ::= WordFlags | FP
=$13						  WordFlags ::= WordFlags | DB
>e1d7	13					.byte WordFlags	;wh_Flags
>e1d8	08					.byte 8	;wh_CodeLength
>e1d9	00 00					  .word WordListLink
>e1db	0a bc					  .word Words		; pointer to xt
=0					XtPtr1 ::= 0
=57686					WordListLink ::= Nt0 ; remember the nt of this word for later
>e1dd	46 6f 72 74 68 2d 57 6f		Name0:	.text "Forth-Wordlist"	;  name of word as a string, ending at wh_NameLastChar
>e1e5	72 64 6c 69 73 74
=14					NameLength = *-Name0
=57707					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e1eb	8e					.byte (("Forth-Wordlist"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=21					LinkDisplacement = Nt0-WordListLink
=$12						  WordFlags ::= WordFlags | DB
>e1ec	12					.byte WordFlags	;wh_Flags
>e1ed	08					.byte 8	;wh_CodeLength
>e1ee	15					  .byte LinkDisplacement	; offset to previous nt
>e1ef	62 b1					  .word Forth_WordList		; pointer to xt
=0					XtPtr1 ::= 0
=57707					WordListLink ::= Nt0 ; remember the nt of this word for later
>e1f1	46 6f 72 74 68			Name0:	.text "Forth"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=57718					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e1f6	05					.byte (("Forth"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=11					LinkDisplacement = Nt0-WordListLink
=$12						  WordFlags ::= WordFlags | DB
>e1f7	12					.byte WordFlags	;wh_Flags
>e1f8	08					.byte 8	;wh_CodeLength
>e1f9	0b					  .byte LinkDisplacement	; offset to previous nt
>e1fa	66 b2					  .word Forth		; pointer to xt
=0					XtPtr1 ::= 0
=57718					WordListLink ::= Nt0 ; remember the nt of this word for later
>e1fc	53 65 74 2d 4f 72 64 65		Name0:	.text "Set-Order"	;  name of word as a string, ending at wh_NameLastChar
>e204	72
=9					NameLength = *-Name0
=57733					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e205	49					.byte (("Set-Order"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=15					LinkDisplacement = Nt0-WordListLink
=$12						  WordFlags ::= WordFlags | DB
>e206	12					.byte WordFlags	;wh_Flags
>e207	08					.byte 8	;wh_CodeLength
>e208	0f					  .byte LinkDisplacement	; offset to previous nt
>e209	cf b2					  .word Set_Order		; pointer to xt
=0					XtPtr1 ::= 0
=57733					WordListLink ::= Nt0 ; remember the nt of this word for later
=57733					root_dictionary_start = WordListLink ; END of ROOT-WORDLIST
=0					WordListLink .var 0
>e20b	61 64 63			Name0:	.text "adc"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=57742					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e20e	63					.byte (("adc"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=57742					LinkDisplacement = Nt0-WordListLink
=$11						  WordFlags ::= WordFlags | FP
>e20f	11					.byte WordFlags	;wh_Flags
>e210	03					.byte 3	;wh_CodeLength
>e211	00 00					  .word WordListLink
=$e213					XtPtr1 ::= *
=57742					WordListLink ::= Nt0 ; remember the nt of this word for later
.e213	20 c6 e9	jsr $e9c6		jsr asm_2
=3					CodeLen	.var *-XtPtr1
=$e216					Here1 = *	; remember here
>e210	03					.byte CodeLen	;patch wh_CodeLength
>e216	6d					.byte $6d
>e217	61 64 63 2e 23			Name0:	.text "adc.#"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=57756					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e21c	65					.byte (("adc.#"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=14					LinkDisplacement = Nt0-WordListLink
>e21d	10					.byte WordFlags	;wh_Flags
>e21e	03					.byte 3	;wh_CodeLength
>e21f	0e					  .byte LinkDisplacement	; offset to previous nt
=$e220					XtPtr1 ::= *
=57756					WordListLink ::= Nt0 ; remember the nt of this word for later
.e220	20 b4 e9	jsr $e9b4		jsr asm_1
=3					CodeLen	.var *-XtPtr1
=$e223					Here1 = *	; remember here
>e21e	03					.byte CodeLen	;patch wh_CodeLength
>e223	69					.byte $69
>e224	61 64 63 2e 78			Name0:	.text "adc.x"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=57769					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e229	05					.byte (("adc.x"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>e22a	10					.byte WordFlags	;wh_Flags
>e22b	03					.byte 3	;wh_CodeLength
>e22c	0d					  .byte LinkDisplacement	; offset to previous nt
=$e22d					XtPtr1 ::= *
=57769					WordListLink ::= Nt0 ; remember the nt of this word for later
.e22d	20 c6 e9	jsr $e9c6		jsr asm_2
=3					CodeLen	.var *-XtPtr1
=$e230					Here1 = *	; remember here
>e22b	03					.byte CodeLen	;patch wh_CodeLength
>e230	7d					.byte $7d
>e231	61 64 63 2e 79			Name0:	.text "adc.y"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=57782					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e236	25					.byte (("adc.y"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>e237	10					.byte WordFlags	;wh_Flags
>e238	03					.byte 3	;wh_CodeLength
>e239	0d					  .byte LinkDisplacement	; offset to previous nt
=$e23a					XtPtr1 ::= *
=57782					WordListLink ::= Nt0 ; remember the nt of this word for later
.e23a	20 c6 e9	jsr $e9c6		jsr asm_2
=3					CodeLen	.var *-XtPtr1
=$e23d					Here1 = *	; remember here
>e238	03					.byte CodeLen	;patch wh_CodeLength
>e23d	79					.byte $79
>e23e	61 64 63 2e 7a			Name0:	.text "adc.z"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=57795					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e243	45					.byte (("adc.z"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>e244	10					.byte WordFlags	;wh_Flags
>e245	03					.byte 3	;wh_CodeLength
>e246	0d					  .byte LinkDisplacement	; offset to previous nt
=$e247					XtPtr1 ::= *
=57795					WordListLink ::= Nt0 ; remember the nt of this word for later
.e247	20 b4 e9	jsr $e9b4		jsr asm_1
=3					CodeLen	.var *-XtPtr1
=$e24a					Here1 = *	; remember here
>e245	03					.byte CodeLen	;patch wh_CodeLength
>e24a	65					.byte $65
>e24b	61 64 63 2e 7a 69 79		Name0:	.text "adc.ziy"	;  name of word as a string, ending at wh_NameLastChar
=7					NameLength = *-Name0
=57810					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e252	27					.byte (("adc.ziy"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=15					LinkDisplacement = Nt0-WordListLink
>e253	10					.byte WordFlags	;wh_Flags
>e254	03					.byte 3	;wh_CodeLength
>e255	0f					  .byte LinkDisplacement	; offset to previous nt
=$e256					XtPtr1 ::= *
=57810					WordListLink ::= Nt0 ; remember the nt of this word for later
.e256	20 b4 e9	jsr $e9b4		jsr asm_1
=3					CodeLen	.var *-XtPtr1
=$e259					Here1 = *	; remember here
>e254	03					.byte CodeLen	;patch wh_CodeLength
>e259	71					.byte $71
>e25a	61 64 63 2e 7a 78		Name0:	.text "adc.zx"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=57824					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e260	06					.byte (("adc.zx"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=14					LinkDisplacement = Nt0-WordListLink
>e261	10					.byte WordFlags	;wh_Flags
>e262	03					.byte 3	;wh_CodeLength
>e263	0e					  .byte LinkDisplacement	; offset to previous nt
=$e264					XtPtr1 ::= *
=57824					WordListLink ::= Nt0 ; remember the nt of this word for later
.e264	20 b4 e9	jsr $e9b4		jsr asm_1
=3					CodeLen	.var *-XtPtr1
=$e267					Here1 = *	; remember here
>e262	03					.byte CodeLen	;patch wh_CodeLength
>e267	75					.byte $75
>e268	61 64 63 2e 7a 78 69		Name0:	.text "adc.zxi"	;  name of word as a string, ending at wh_NameLastChar
=7					NameLength = *-Name0
=57839					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e26f	27					.byte (("adc.zxi"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=15					LinkDisplacement = Nt0-WordListLink
>e270	10					.byte WordFlags	;wh_Flags
>e271	03					.byte 3	;wh_CodeLength
>e272	0f					  .byte LinkDisplacement	; offset to previous nt
=$e273					XtPtr1 ::= *
=57839					WordListLink ::= Nt0 ; remember the nt of this word for later
.e273	20 b4 e9	jsr $e9b4		jsr asm_1
=3					CodeLen	.var *-XtPtr1
=$e276					Here1 = *	; remember here
>e271	03					.byte CodeLen	;patch wh_CodeLength
>e276	61					.byte $61
>e277	61 6e 64 2e			Name0:	.text "and."	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=57851					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e27b	c4					.byte (("and."[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=12					LinkDisplacement = Nt0-WordListLink
>e27c	10					.byte WordFlags	;wh_Flags
>e27d	03					.byte 3	;wh_CodeLength
>e27e	0c					  .byte LinkDisplacement	; offset to previous nt
=$e27f					XtPtr1 ::= *
=57851					WordListLink ::= Nt0 ; remember the nt of this word for later
.e27f	20 c6 e9	jsr $e9c6		jsr asm_2
=3					CodeLen	.var *-XtPtr1
=$e282					Here1 = *	; remember here
>e27d	03					.byte CodeLen	;patch wh_CodeLength
>e282	2d					.byte $2d
>e283	61 6e 64 2e 23			Name0:	.text "and.#"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=57864					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e288	65					.byte (("and.#"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>e289	10					.byte WordFlags	;wh_Flags
>e28a	03					.byte 3	;wh_CodeLength
>e28b	0d					  .byte LinkDisplacement	; offset to previous nt
=$e28c					XtPtr1 ::= *
=57864					WordListLink ::= Nt0 ; remember the nt of this word for later
.e28c	20 b4 e9	jsr $e9b4		jsr asm_1
=3					CodeLen	.var *-XtPtr1
=$e28f					Here1 = *	; remember here
>e28a	03					.byte CodeLen	;patch wh_CodeLength
>e28f	29					.byte $29
>e290	61 6e 64 2e 78			Name0:	.text "and.x"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=57877					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e295	05					.byte (("and.x"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>e296	10					.byte WordFlags	;wh_Flags
>e297	03					.byte 3	;wh_CodeLength
>e298	0d					  .byte LinkDisplacement	; offset to previous nt
=$e299					XtPtr1 ::= *
=57877					WordListLink ::= Nt0 ; remember the nt of this word for later
.e299	20 c6 e9	jsr $e9c6		jsr asm_2
=3					CodeLen	.var *-XtPtr1
=$e29c					Here1 = *	; remember here
>e297	03					.byte CodeLen	;patch wh_CodeLength
>e29c	3d					.byte $3d
>e29d	61 6e 64 2e 79			Name0:	.text "and.y"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=57890					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e2a2	25					.byte (("and.y"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>e2a3	10					.byte WordFlags	;wh_Flags
>e2a4	03					.byte 3	;wh_CodeLength
>e2a5	0d					  .byte LinkDisplacement	; offset to previous nt
=$e2a6					XtPtr1 ::= *
=57890					WordListLink ::= Nt0 ; remember the nt of this word for later
.e2a6	20 c6 e9	jsr $e9c6		jsr asm_2
=3					CodeLen	.var *-XtPtr1
=$e2a9					Here1 = *	; remember here
>e2a4	03					.byte CodeLen	;patch wh_CodeLength
>e2a9	39					.byte $39
>e2aa	61 6e 64 2e 7a			Name0:	.text "and.z"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=57903					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e2af	45					.byte (("and.z"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>e2b0	10					.byte WordFlags	;wh_Flags
>e2b1	03					.byte 3	;wh_CodeLength
>e2b2	0d					  .byte LinkDisplacement	; offset to previous nt
=$e2b3					XtPtr1 ::= *
=57903					WordListLink ::= Nt0 ; remember the nt of this word for later
.e2b3	20 b4 e9	jsr $e9b4		jsr asm_1
=3					CodeLen	.var *-XtPtr1
=$e2b6					Here1 = *	; remember here
>e2b1	03					.byte CodeLen	;patch wh_CodeLength
>e2b6	25					.byte $25
>e2b7	61 6e 64 2e 7a 69 79		Name0:	.text "and.ziy"	;  name of word as a string, ending at wh_NameLastChar
=7					NameLength = *-Name0
=57918					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e2be	27					.byte (("and.ziy"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=15					LinkDisplacement = Nt0-WordListLink
>e2bf	10					.byte WordFlags	;wh_Flags
>e2c0	03					.byte 3	;wh_CodeLength
>e2c1	0f					  .byte LinkDisplacement	; offset to previous nt
=$e2c2					XtPtr1 ::= *
=57918					WordListLink ::= Nt0 ; remember the nt of this word for later
.e2c2	20 b4 e9	jsr $e9b4		jsr asm_1
=3					CodeLen	.var *-XtPtr1
=$e2c5					Here1 = *	; remember here
>e2c0	03					.byte CodeLen	;patch wh_CodeLength
>e2c5	31					.byte $31
>e2c6	61 6e 64 2e 7a 78		Name0:	.text "and.zx"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=57932					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e2cc	06					.byte (("and.zx"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=14					LinkDisplacement = Nt0-WordListLink
>e2cd	10					.byte WordFlags	;wh_Flags
>e2ce	03					.byte 3	;wh_CodeLength
>e2cf	0e					  .byte LinkDisplacement	; offset to previous nt
=$e2d0					XtPtr1 ::= *
=57932					WordListLink ::= Nt0 ; remember the nt of this word for later
.e2d0	20 b4 e9	jsr $e9b4		jsr asm_1
=3					CodeLen	.var *-XtPtr1
=$e2d3					Here1 = *	; remember here
>e2ce	03					.byte CodeLen	;patch wh_CodeLength
>e2d3	35					.byte $35
>e2d4	61 6e 64 2e 7a 78 69		Name0:	.text "and.zxi"	;  name of word as a string, ending at wh_NameLastChar
=7					NameLength = *-Name0
=57947					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e2db	27					.byte (("and.zxi"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=15					LinkDisplacement = Nt0-WordListLink
>e2dc	10					.byte WordFlags	;wh_Flags
>e2dd	03					.byte 3	;wh_CodeLength
>e2de	0f					  .byte LinkDisplacement	; offset to previous nt
=$e2df					XtPtr1 ::= *
=57947					WordListLink ::= Nt0 ; remember the nt of this word for later
.e2df	20 b4 e9	jsr $e9b4		jsr asm_1
=3					CodeLen	.var *-XtPtr1
=$e2e2					Here1 = *	; remember here
>e2dd	03					.byte CodeLen	;patch wh_CodeLength
>e2e2	21					.byte $21
>e2e3	61 73 6c			Name0:	.text "asl"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=57958					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e2e6	83					.byte (("asl"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=11					LinkDisplacement = Nt0-WordListLink
>e2e7	10					.byte WordFlags	;wh_Flags
>e2e8	03					.byte 3	;wh_CodeLength
>e2e9	0b					  .byte LinkDisplacement	; offset to previous nt
=$e2ea					XtPtr1 ::= *
=57958					WordListLink ::= Nt0 ; remember the nt of this word for later
.e2ea	20 c6 e9	jsr $e9c6		jsr asm_2
=3					CodeLen	.var *-XtPtr1
=$e2ed					Here1 = *	; remember here
>e2e8	03					.byte CodeLen	;patch wh_CodeLength
>e2ed	0e					.byte $0e
>e2ee	61 73 6c 2e 61			Name0:	.text "asl.a"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=57971					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e2f3	25					.byte (("asl.a"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>e2f4	10					.byte WordFlags	;wh_Flags
>e2f5	03					.byte 3	;wh_CodeLength
>e2f6	0d					  .byte LinkDisplacement	; offset to previous nt
=$e2f7					XtPtr1 ::= *
=57971					WordListLink ::= Nt0 ; remember the nt of this word for later
.e2f7	20 cf e9	jsr $e9cf		jsr asm_0
=3					CodeLen	.var *-XtPtr1
=$e2fa					Here1 = *	; remember here
>e2f5	03					.byte CodeLen	;patch wh_CodeLength
>e2fa	0a					.byte $0a
>e2fb	61 73 6c 2e 78			Name0:	.text "asl.x"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=57984					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e300	05					.byte (("asl.x"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>e301	10					.byte WordFlags	;wh_Flags
>e302	03					.byte 3	;wh_CodeLength
>e303	0d					  .byte LinkDisplacement	; offset to previous nt
=$e304					XtPtr1 ::= *
=57984					WordListLink ::= Nt0 ; remember the nt of this word for later
.e304	20 c6 e9	jsr $e9c6		jsr asm_2
=3					CodeLen	.var *-XtPtr1
=$e307					Here1 = *	; remember here
>e302	03					.byte CodeLen	;patch wh_CodeLength
>e307	1e					.byte $1e
>e308	61 73 6c 2e 7a			Name0:	.text "asl.z"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=57997					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e30d	45					.byte (("asl.z"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>e30e	10					.byte WordFlags	;wh_Flags
>e30f	03					.byte 3	;wh_CodeLength
>e310	0d					  .byte LinkDisplacement	; offset to previous nt
=$e311					XtPtr1 ::= *
=57997					WordListLink ::= Nt0 ; remember the nt of this word for later
.e311	20 b4 e9	jsr $e9b4		jsr asm_1
=3					CodeLen	.var *-XtPtr1
=$e314					Here1 = *	; remember here
>e30f	03					.byte CodeLen	;patch wh_CodeLength
>e314	06					.byte $06
>e315	61 73 6c 2e 7a 78		Name0:	.text "asl.zx"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=58011					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e31b	06					.byte (("asl.zx"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=14					LinkDisplacement = Nt0-WordListLink
>e31c	10					.byte WordFlags	;wh_Flags
>e31d	03					.byte 3	;wh_CodeLength
>e31e	0e					  .byte LinkDisplacement	; offset to previous nt
=$e31f					XtPtr1 ::= *
=58011					WordListLink ::= Nt0 ; remember the nt of this word for later
.e31f	20 b4 e9	jsr $e9b4		jsr asm_1
=3					CodeLen	.var *-XtPtr1
=$e322					Here1 = *	; remember here
>e31d	03					.byte CodeLen	;patch wh_CodeLength
>e322	16					.byte $16
>e323	62 63 63			Name0:	.text "bcc"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=58022					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e326	63					.byte (("bcc"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=11					LinkDisplacement = Nt0-WordListLink
>e327	10					.byte WordFlags	;wh_Flags
>e328	03					.byte 3	;wh_CodeLength
>e329	0b					  .byte LinkDisplacement	; offset to previous nt
=$e32a					XtPtr1 ::= *
=58022					WordListLink ::= Nt0 ; remember the nt of this word for later
.e32a	20 94 e9	jsr $e994		jsr asm_r
=3					CodeLen	.var *-XtPtr1
=$e32d					Here1 = *	; remember here
>e328	03					.byte CodeLen	;patch wh_CodeLength
>e32d	90					.byte $90
>e32e	62 63 73			Name0:	.text "bcs"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=58033					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e331	63					.byte (("bcs"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=11					LinkDisplacement = Nt0-WordListLink
>e332	10					.byte WordFlags	;wh_Flags
>e333	03					.byte 3	;wh_CodeLength
>e334	0b					  .byte LinkDisplacement	; offset to previous nt
=$e335					XtPtr1 ::= *
=58033					WordListLink ::= Nt0 ; remember the nt of this word for later
.e335	20 94 e9	jsr $e994		jsr asm_r
=3					CodeLen	.var *-XtPtr1
=$e338					Here1 = *	; remember here
>e333	03					.byte CodeLen	;patch wh_CodeLength
>e338	b0					.byte $b0
>e339	62 65 71			Name0:	.text "beq"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=58044					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e33c	23					.byte (("beq"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=11					LinkDisplacement = Nt0-WordListLink
>e33d	10					.byte WordFlags	;wh_Flags
>e33e	03					.byte 3	;wh_CodeLength
>e33f	0b					  .byte LinkDisplacement	; offset to previous nt
=$e340					XtPtr1 ::= *
=58044					WordListLink ::= Nt0 ; remember the nt of this word for later
.e340	20 94 e9	jsr $e994		jsr asm_r
=3					CodeLen	.var *-XtPtr1
=$e343					Here1 = *	; remember here
>e33e	03					.byte CodeLen	;patch wh_CodeLength
>e343	f0					.byte $f0
>e344	62 69 74			Name0:	.text "bit"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=58055					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e347	83					.byte (("bit"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=11					LinkDisplacement = Nt0-WordListLink
>e348	10					.byte WordFlags	;wh_Flags
>e349	03					.byte 3	;wh_CodeLength
>e34a	0b					  .byte LinkDisplacement	; offset to previous nt
=$e34b					XtPtr1 ::= *
=58055					WordListLink ::= Nt0 ; remember the nt of this word for later
.e34b	20 c6 e9	jsr $e9c6		jsr asm_2
=3					CodeLen	.var *-XtPtr1
=$e34e					Here1 = *	; remember here
>e349	03					.byte CodeLen	;patch wh_CodeLength
>e34e	2c					.byte $2c
>e34f	62 69 74 2e 7a			Name0:	.text "bit.z"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=58068					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e354	45					.byte (("bit.z"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>e355	10					.byte WordFlags	;wh_Flags
>e356	03					.byte 3	;wh_CodeLength
>e357	0d					  .byte LinkDisplacement	; offset to previous nt
=$e358					XtPtr1 ::= *
=58068					WordListLink ::= Nt0 ; remember the nt of this word for later
.e358	20 b4 e9	jsr $e9b4		jsr asm_1
=3					CodeLen	.var *-XtPtr1
=$e35b					Here1 = *	; remember here
>e356	03					.byte CodeLen	;patch wh_CodeLength
>e35b	24					.byte $24
>e35c	62 6d 69			Name0:	.text "bmi"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=58079					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e35f	23					.byte (("bmi"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=11					LinkDisplacement = Nt0-WordListLink
>e360	10					.byte WordFlags	;wh_Flags
>e361	03					.byte 3	;wh_CodeLength
>e362	0b					  .byte LinkDisplacement	; offset to previous nt
=$e363					XtPtr1 ::= *
=58079					WordListLink ::= Nt0 ; remember the nt of this word for later
.e363	20 94 e9	jsr $e994		jsr asm_r
=3					CodeLen	.var *-XtPtr1
=$e366					Here1 = *	; remember here
>e361	03					.byte CodeLen	;patch wh_CodeLength
>e366	30					.byte $30
>e367	62 6e 65			Name0:	.text "bne"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=58090					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e36a	a3					.byte (("bne"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=11					LinkDisplacement = Nt0-WordListLink
>e36b	10					.byte WordFlags	;wh_Flags
>e36c	03					.byte 3	;wh_CodeLength
>e36d	0b					  .byte LinkDisplacement	; offset to previous nt
=$e36e					XtPtr1 ::= *
=58090					WordListLink ::= Nt0 ; remember the nt of this word for later
.e36e	20 94 e9	jsr $e994		jsr asm_r
=3					CodeLen	.var *-XtPtr1
=$e371					Here1 = *	; remember here
>e36c	03					.byte CodeLen	;patch wh_CodeLength
>e371	d0					.byte $d0
>e372	62 70 6c			Name0:	.text "bpl"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=58101					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e375	83					.byte (("bpl"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=11					LinkDisplacement = Nt0-WordListLink
>e376	10					.byte WordFlags	;wh_Flags
>e377	03					.byte 3	;wh_CodeLength
>e378	0b					  .byte LinkDisplacement	; offset to previous nt
=$e379					XtPtr1 ::= *
=58101					WordListLink ::= Nt0 ; remember the nt of this word for later
.e379	20 94 e9	jsr $e994		jsr asm_r
=3					CodeLen	.var *-XtPtr1
=$e37c					Here1 = *	; remember here
>e377	03					.byte CodeLen	;patch wh_CodeLength
>e37c	10					.byte $10
>e37d	62 72 6b			Name0:	.text "brk"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=58112					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e380	63					.byte (("brk"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=11					LinkDisplacement = Nt0-WordListLink
>e381	10					.byte WordFlags	;wh_Flags
>e382	03					.byte 3	;wh_CodeLength
>e383	0b					  .byte LinkDisplacement	; offset to previous nt
=$e384					XtPtr1 ::= *
=58112					WordListLink ::= Nt0 ; remember the nt of this word for later
.e384	20 b4 e9	jsr $e9b4		jsr asm_1
=3					CodeLen	.var *-XtPtr1
=$e387					Here1 = *	; remember here
>e382	03					.byte CodeLen	;patch wh_CodeLength
>e387	00					.byte $00
>e388	62 76 63			Name0:	.text "bvc"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=58123					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e38b	63					.byte (("bvc"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=11					LinkDisplacement = Nt0-WordListLink
>e38c	10					.byte WordFlags	;wh_Flags
>e38d	03					.byte 3	;wh_CodeLength
>e38e	0b					  .byte LinkDisplacement	; offset to previous nt
=$e38f					XtPtr1 ::= *
=58123					WordListLink ::= Nt0 ; remember the nt of this word for later
.e38f	20 94 e9	jsr $e994		jsr asm_r
=3					CodeLen	.var *-XtPtr1
=$e392					Here1 = *	; remember here
>e38d	03					.byte CodeLen	;patch wh_CodeLength
>e392	50					.byte $50
>e393	62 76 73			Name0:	.text "bvs"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=58134					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e396	63					.byte (("bvs"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=11					LinkDisplacement = Nt0-WordListLink
>e397	10					.byte WordFlags	;wh_Flags
>e398	03					.byte 3	;wh_CodeLength
>e399	0b					  .byte LinkDisplacement	; offset to previous nt
=$e39a					XtPtr1 ::= *
=58134					WordListLink ::= Nt0 ; remember the nt of this word for later
.e39a	20 94 e9	jsr $e994		jsr asm_r
=3					CodeLen	.var *-XtPtr1
=$e39d					Here1 = *	; remember here
>e398	03					.byte CodeLen	;patch wh_CodeLength
>e39d	70					.byte $70
>e39e	63 6c 63			Name0:	.text "clc"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=58145					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e3a1	63					.byte (("clc"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=11					LinkDisplacement = Nt0-WordListLink
>e3a2	10					.byte WordFlags	;wh_Flags
>e3a3	03					.byte 3	;wh_CodeLength
>e3a4	0b					  .byte LinkDisplacement	; offset to previous nt
=$e3a5					XtPtr1 ::= *
=58145					WordListLink ::= Nt0 ; remember the nt of this word for later
.e3a5	20 cf e9	jsr $e9cf		jsr asm_0
=3					CodeLen	.var *-XtPtr1
=$e3a8					Here1 = *	; remember here
>e3a3	03					.byte CodeLen	;patch wh_CodeLength
>e3a8	18					.byte $18
>e3a9	63 6c 64			Name0:	.text "cld"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=58156					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e3ac	83					.byte (("cld"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=11					LinkDisplacement = Nt0-WordListLink
>e3ad	10					.byte WordFlags	;wh_Flags
>e3ae	03					.byte 3	;wh_CodeLength
>e3af	0b					  .byte LinkDisplacement	; offset to previous nt
=$e3b0					XtPtr1 ::= *
=58156					WordListLink ::= Nt0 ; remember the nt of this word for later
.e3b0	20 cf e9	jsr $e9cf		jsr asm_0
=3					CodeLen	.var *-XtPtr1
=$e3b3					Here1 = *	; remember here
>e3ae	03					.byte CodeLen	;patch wh_CodeLength
>e3b3	d8					.byte $d8
>e3b4	63 6c 69			Name0:	.text "cli"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=58167					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e3b7	23					.byte (("cli"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=11					LinkDisplacement = Nt0-WordListLink
>e3b8	10					.byte WordFlags	;wh_Flags
>e3b9	03					.byte 3	;wh_CodeLength
>e3ba	0b					  .byte LinkDisplacement	; offset to previous nt
=$e3bb					XtPtr1 ::= *
=58167					WordListLink ::= Nt0 ; remember the nt of this word for later
.e3bb	20 cf e9	jsr $e9cf		jsr asm_0
=3					CodeLen	.var *-XtPtr1
=$e3be					Here1 = *	; remember here
>e3b9	03					.byte CodeLen	;patch wh_CodeLength
>e3be	58					.byte $58
>e3bf	63 6c 76			Name0:	.text "clv"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=58178					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e3c2	c3					.byte (("clv"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=11					LinkDisplacement = Nt0-WordListLink
>e3c3	10					.byte WordFlags	;wh_Flags
>e3c4	03					.byte 3	;wh_CodeLength
>e3c5	0b					  .byte LinkDisplacement	; offset to previous nt
=$e3c6					XtPtr1 ::= *
=58178					WordListLink ::= Nt0 ; remember the nt of this word for later
.e3c6	20 cf e9	jsr $e9cf		jsr asm_0
=3					CodeLen	.var *-XtPtr1
=$e3c9					Here1 = *	; remember here
>e3c4	03					.byte CodeLen	;patch wh_CodeLength
>e3c9	b8					.byte $b8
>e3ca	63 6d 70			Name0:	.text "cmp"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=58189					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e3cd	03					.byte (("cmp"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=11					LinkDisplacement = Nt0-WordListLink
>e3ce	10					.byte WordFlags	;wh_Flags
>e3cf	03					.byte 3	;wh_CodeLength
>e3d0	0b					  .byte LinkDisplacement	; offset to previous nt
=$e3d1					XtPtr1 ::= *
=58189					WordListLink ::= Nt0 ; remember the nt of this word for later
.e3d1	20 c6 e9	jsr $e9c6		jsr asm_2
=3					CodeLen	.var *-XtPtr1
=$e3d4					Here1 = *	; remember here
>e3cf	03					.byte CodeLen	;patch wh_CodeLength
>e3d4	cd					.byte $cd
>e3d5	63 6d 70 2e 23			Name0:	.text "cmp.#"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=58202					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e3da	65					.byte (("cmp.#"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>e3db	10					.byte WordFlags	;wh_Flags
>e3dc	03					.byte 3	;wh_CodeLength
>e3dd	0d					  .byte LinkDisplacement	; offset to previous nt
=$e3de					XtPtr1 ::= *
=58202					WordListLink ::= Nt0 ; remember the nt of this word for later
.e3de	20 b4 e9	jsr $e9b4		jsr asm_1
=3					CodeLen	.var *-XtPtr1
=$e3e1					Here1 = *	; remember here
>e3dc	03					.byte CodeLen	;patch wh_CodeLength
>e3e1	c9					.byte $c9
>e3e2	63 6d 70 2e 78			Name0:	.text "cmp.x"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=58215					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e3e7	05					.byte (("cmp.x"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>e3e8	10					.byte WordFlags	;wh_Flags
>e3e9	03					.byte 3	;wh_CodeLength
>e3ea	0d					  .byte LinkDisplacement	; offset to previous nt
=$e3eb					XtPtr1 ::= *
=58215					WordListLink ::= Nt0 ; remember the nt of this word for later
.e3eb	20 c6 e9	jsr $e9c6		jsr asm_2
=3					CodeLen	.var *-XtPtr1
=$e3ee					Here1 = *	; remember here
>e3e9	03					.byte CodeLen	;patch wh_CodeLength
>e3ee	dd					.byte $dd
>e3ef	63 6d 70 2e 79			Name0:	.text "cmp.y"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=58228					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e3f4	25					.byte (("cmp.y"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>e3f5	10					.byte WordFlags	;wh_Flags
>e3f6	03					.byte 3	;wh_CodeLength
>e3f7	0d					  .byte LinkDisplacement	; offset to previous nt
=$e3f8					XtPtr1 ::= *
=58228					WordListLink ::= Nt0 ; remember the nt of this word for later
.e3f8	20 c6 e9	jsr $e9c6		jsr asm_2
=3					CodeLen	.var *-XtPtr1
=$e3fb					Here1 = *	; remember here
>e3f6	03					.byte CodeLen	;patch wh_CodeLength
>e3fb	d9					.byte $d9
>e3fc	63 6d 70 2e 7a			Name0:	.text "cmp.z"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=58241					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e401	45					.byte (("cmp.z"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>e402	10					.byte WordFlags	;wh_Flags
>e403	03					.byte 3	;wh_CodeLength
>e404	0d					  .byte LinkDisplacement	; offset to previous nt
=$e405					XtPtr1 ::= *
=58241					WordListLink ::= Nt0 ; remember the nt of this word for later
.e405	20 b4 e9	jsr $e9b4		jsr asm_1
=3					CodeLen	.var *-XtPtr1
=$e408					Here1 = *	; remember here
>e403	03					.byte CodeLen	;patch wh_CodeLength
>e408	c5					.byte $c5
>e409	63 6d 70 2e 7a 69 79		Name0:	.text "cmp.ziy"	;  name of word as a string, ending at wh_NameLastChar
=7					NameLength = *-Name0
=58256					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e410	27					.byte (("cmp.ziy"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=15					LinkDisplacement = Nt0-WordListLink
>e411	10					.byte WordFlags	;wh_Flags
>e412	03					.byte 3	;wh_CodeLength
>e413	0f					  .byte LinkDisplacement	; offset to previous nt
=$e414					XtPtr1 ::= *
=58256					WordListLink ::= Nt0 ; remember the nt of this word for later
.e414	20 b4 e9	jsr $e9b4		jsr asm_1
=3					CodeLen	.var *-XtPtr1
=$e417					Here1 = *	; remember here
>e412	03					.byte CodeLen	;patch wh_CodeLength
>e417	d1					.byte $d1
>e418	63 6d 70 2e 7a 78		Name0:	.text "cmp.zx"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=58270					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e41e	06					.byte (("cmp.zx"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=14					LinkDisplacement = Nt0-WordListLink
>e41f	10					.byte WordFlags	;wh_Flags
>e420	03					.byte 3	;wh_CodeLength
>e421	0e					  .byte LinkDisplacement	; offset to previous nt
=$e422					XtPtr1 ::= *
=58270					WordListLink ::= Nt0 ; remember the nt of this word for later
.e422	20 b4 e9	jsr $e9b4		jsr asm_1
=3					CodeLen	.var *-XtPtr1
=$e425					Here1 = *	; remember here
>e420	03					.byte CodeLen	;patch wh_CodeLength
>e425	d5					.byte $d5
>e426	63 6d 70 2e 7a 78 69		Name0:	.text "cmp.zxi"	;  name of word as a string, ending at wh_NameLastChar
=7					NameLength = *-Name0
=58285					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e42d	27					.byte (("cmp.zxi"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=15					LinkDisplacement = Nt0-WordListLink
>e42e	10					.byte WordFlags	;wh_Flags
>e42f	03					.byte 3	;wh_CodeLength
>e430	0f					  .byte LinkDisplacement	; offset to previous nt
=$e431					XtPtr1 ::= *
=58285					WordListLink ::= Nt0 ; remember the nt of this word for later
.e431	20 b4 e9	jsr $e9b4		jsr asm_1
=3					CodeLen	.var *-XtPtr1
=$e434					Here1 = *	; remember here
>e42f	03					.byte CodeLen	;patch wh_CodeLength
>e434	c1					.byte $c1
>e435	63 70 78			Name0:	.text "cpx"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=58296					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e438	03					.byte (("cpx"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=11					LinkDisplacement = Nt0-WordListLink
>e439	10					.byte WordFlags	;wh_Flags
>e43a	03					.byte 3	;wh_CodeLength
>e43b	0b					  .byte LinkDisplacement	; offset to previous nt
=$e43c					XtPtr1 ::= *
=58296					WordListLink ::= Nt0 ; remember the nt of this word for later
.e43c	20 c6 e9	jsr $e9c6		jsr asm_2
=3					CodeLen	.var *-XtPtr1
=$e43f					Here1 = *	; remember here
>e43a	03					.byte CodeLen	;patch wh_CodeLength
>e43f	ec					.byte $ec
>e440	63 70 78 2e 23			Name0:	.text "cpx.#"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=58309					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e445	65					.byte (("cpx.#"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>e446	10					.byte WordFlags	;wh_Flags
>e447	03					.byte 3	;wh_CodeLength
>e448	0d					  .byte LinkDisplacement	; offset to previous nt
=$e449					XtPtr1 ::= *
=58309					WordListLink ::= Nt0 ; remember the nt of this word for later
.e449	20 b4 e9	jsr $e9b4		jsr asm_1
=3					CodeLen	.var *-XtPtr1
=$e44c					Here1 = *	; remember here
>e447	03					.byte CodeLen	;patch wh_CodeLength
>e44c	e0					.byte $e0
>e44d	63 70 78 2e 7a			Name0:	.text "cpx.z"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=58322					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e452	45					.byte (("cpx.z"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>e453	10					.byte WordFlags	;wh_Flags
>e454	03					.byte 3	;wh_CodeLength
>e455	0d					  .byte LinkDisplacement	; offset to previous nt
=$e456					XtPtr1 ::= *
=58322					WordListLink ::= Nt0 ; remember the nt of this word for later
.e456	20 b4 e9	jsr $e9b4		jsr asm_1
=3					CodeLen	.var *-XtPtr1
=$e459					Here1 = *	; remember here
>e454	03					.byte CodeLen	;patch wh_CodeLength
>e459	e4					.byte $e4
>e45a	63 70 79			Name0:	.text "cpy"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=58333					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e45d	23					.byte (("cpy"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=11					LinkDisplacement = Nt0-WordListLink
>e45e	10					.byte WordFlags	;wh_Flags
>e45f	03					.byte 3	;wh_CodeLength
>e460	0b					  .byte LinkDisplacement	; offset to previous nt
=$e461					XtPtr1 ::= *
=58333					WordListLink ::= Nt0 ; remember the nt of this word for later
.e461	20 c6 e9	jsr $e9c6		jsr asm_2
=3					CodeLen	.var *-XtPtr1
=$e464					Here1 = *	; remember here
>e45f	03					.byte CodeLen	;patch wh_CodeLength
>e464	cc					.byte $cc
>e465	63 70 79 2e 23			Name0:	.text "cpy.#"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=58346					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e46a	65					.byte (("cpy.#"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>e46b	10					.byte WordFlags	;wh_Flags
>e46c	03					.byte 3	;wh_CodeLength
>e46d	0d					  .byte LinkDisplacement	; offset to previous nt
=$e46e					XtPtr1 ::= *
=58346					WordListLink ::= Nt0 ; remember the nt of this word for later
.e46e	20 b4 e9	jsr $e9b4		jsr asm_1
=3					CodeLen	.var *-XtPtr1
=$e471					Here1 = *	; remember here
>e46c	03					.byte CodeLen	;patch wh_CodeLength
>e471	c0					.byte $c0
>e472	63 70 79 2e 7a			Name0:	.text "cpy.z"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=58359					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e477	45					.byte (("cpy.z"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>e478	10					.byte WordFlags	;wh_Flags
>e479	03					.byte 3	;wh_CodeLength
>e47a	0d					  .byte LinkDisplacement	; offset to previous nt
=$e47b					XtPtr1 ::= *
=58359					WordListLink ::= Nt0 ; remember the nt of this word for later
.e47b	20 b4 e9	jsr $e9b4		jsr asm_1
=3					CodeLen	.var *-XtPtr1
=$e47e					Here1 = *	; remember here
>e479	03					.byte CodeLen	;patch wh_CodeLength
>e47e	c4					.byte $c4
>e47f	64 65 63			Name0:	.text "dec"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=58370					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e482	63					.byte (("dec"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=11					LinkDisplacement = Nt0-WordListLink
>e483	10					.byte WordFlags	;wh_Flags
>e484	03					.byte 3	;wh_CodeLength
>e485	0b					  .byte LinkDisplacement	; offset to previous nt
=$e486					XtPtr1 ::= *
=58370					WordListLink ::= Nt0 ; remember the nt of this word for later
.e486	20 c6 e9	jsr $e9c6		jsr asm_2
=3					CodeLen	.var *-XtPtr1
=$e489					Here1 = *	; remember here
>e484	03					.byte CodeLen	;patch wh_CodeLength
>e489	ce					.byte $ce
>e48a	64 65 63 2e 61			Name0:	.text "dec.a"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=58383					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e48f	25					.byte (("dec.a"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>e490	10					.byte WordFlags	;wh_Flags
>e491	03					.byte 3	;wh_CodeLength
>e492	0d					  .byte LinkDisplacement	; offset to previous nt
=$e493					XtPtr1 ::= *
=58383					WordListLink ::= Nt0 ; remember the nt of this word for later
.e493	20 cf e9	jsr $e9cf		jsr asm_0
=3					CodeLen	.var *-XtPtr1
=$e496					Here1 = *	; remember here
>e491	03					.byte CodeLen	;patch wh_CodeLength
>e496	3a					.byte $3a
>e497	64 65 63 2e 78			Name0:	.text "dec.x"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=58396					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e49c	05					.byte (("dec.x"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>e49d	10					.byte WordFlags	;wh_Flags
>e49e	03					.byte 3	;wh_CodeLength
>e49f	0d					  .byte LinkDisplacement	; offset to previous nt
=$e4a0					XtPtr1 ::= *
=58396					WordListLink ::= Nt0 ; remember the nt of this word for later
.e4a0	20 c6 e9	jsr $e9c6		jsr asm_2
=3					CodeLen	.var *-XtPtr1
=$e4a3					Here1 = *	; remember here
>e49e	03					.byte CodeLen	;patch wh_CodeLength
>e4a3	de					.byte $de
>e4a4	64 65 63 2e 7a			Name0:	.text "dec.z"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=58409					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e4a9	45					.byte (("dec.z"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>e4aa	10					.byte WordFlags	;wh_Flags
>e4ab	03					.byte 3	;wh_CodeLength
>e4ac	0d					  .byte LinkDisplacement	; offset to previous nt
=$e4ad					XtPtr1 ::= *
=58409					WordListLink ::= Nt0 ; remember the nt of this word for later
.e4ad	20 b4 e9	jsr $e9b4		jsr asm_1
=3					CodeLen	.var *-XtPtr1
=$e4b0					Here1 = *	; remember here
>e4ab	03					.byte CodeLen	;patch wh_CodeLength
>e4b0	c6					.byte $c6
>e4b1	64 65 63 2e 7a 78		Name0:	.text "dec.zx"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=58423					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e4b7	06					.byte (("dec.zx"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=14					LinkDisplacement = Nt0-WordListLink
>e4b8	10					.byte WordFlags	;wh_Flags
>e4b9	03					.byte 3	;wh_CodeLength
>e4ba	0e					  .byte LinkDisplacement	; offset to previous nt
=$e4bb					XtPtr1 ::= *
=58423					WordListLink ::= Nt0 ; remember the nt of this word for later
.e4bb	20 b4 e9	jsr $e9b4		jsr asm_1
=3					CodeLen	.var *-XtPtr1
=$e4be					Here1 = *	; remember here
>e4b9	03					.byte CodeLen	;patch wh_CodeLength
>e4be	d6					.byte $d6
>e4bf	64 65 78			Name0:	.text "dex"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=58434					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e4c2	03					.byte (("dex"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=11					LinkDisplacement = Nt0-WordListLink
>e4c3	10					.byte WordFlags	;wh_Flags
>e4c4	03					.byte 3	;wh_CodeLength
>e4c5	0b					  .byte LinkDisplacement	; offset to previous nt
=$e4c6					XtPtr1 ::= *
=58434					WordListLink ::= Nt0 ; remember the nt of this word for later
.e4c6	20 cf e9	jsr $e9cf		jsr asm_0
=3					CodeLen	.var *-XtPtr1
=$e4c9					Here1 = *	; remember here
>e4c4	03					.byte CodeLen	;patch wh_CodeLength
>e4c9	ca					.byte $ca
>e4ca	64 65 79			Name0:	.text "dey"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=58445					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e4cd	23					.byte (("dey"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=11					LinkDisplacement = Nt0-WordListLink
>e4ce	10					.byte WordFlags	;wh_Flags
>e4cf	03					.byte 3	;wh_CodeLength
>e4d0	0b					  .byte LinkDisplacement	; offset to previous nt
=$e4d1					XtPtr1 ::= *
=58445					WordListLink ::= Nt0 ; remember the nt of this word for later
.e4d1	20 cf e9	jsr $e9cf		jsr asm_0
=3					CodeLen	.var *-XtPtr1
=$e4d4					Here1 = *	; remember here
>e4cf	03					.byte CodeLen	;patch wh_CodeLength
>e4d4	88					.byte $88
>e4d5	65 6f 72			Name0:	.text "eor"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=58456					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e4d8	43					.byte (("eor"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=11					LinkDisplacement = Nt0-WordListLink
>e4d9	10					.byte WordFlags	;wh_Flags
>e4da	03					.byte 3	;wh_CodeLength
>e4db	0b					  .byte LinkDisplacement	; offset to previous nt
=$e4dc					XtPtr1 ::= *
=58456					WordListLink ::= Nt0 ; remember the nt of this word for later
.e4dc	20 c6 e9	jsr $e9c6		jsr asm_2
=3					CodeLen	.var *-XtPtr1
=$e4df					Here1 = *	; remember here
>e4da	03					.byte CodeLen	;patch wh_CodeLength
>e4df	4d					.byte $4d
>e4e0	65 6f 72 2e 23			Name0:	.text "eor.#"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=58469					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e4e5	65					.byte (("eor.#"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>e4e6	10					.byte WordFlags	;wh_Flags
>e4e7	03					.byte 3	;wh_CodeLength
>e4e8	0d					  .byte LinkDisplacement	; offset to previous nt
=$e4e9					XtPtr1 ::= *
=58469					WordListLink ::= Nt0 ; remember the nt of this word for later
.e4e9	20 b4 e9	jsr $e9b4		jsr asm_1
=3					CodeLen	.var *-XtPtr1
=$e4ec					Here1 = *	; remember here
>e4e7	03					.byte CodeLen	;patch wh_CodeLength
>e4ec	49					.byte $49
>e4ed	65 6f 72 2e 78			Name0:	.text "eor.x"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=58482					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e4f2	05					.byte (("eor.x"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>e4f3	10					.byte WordFlags	;wh_Flags
>e4f4	03					.byte 3	;wh_CodeLength
>e4f5	0d					  .byte LinkDisplacement	; offset to previous nt
=$e4f6					XtPtr1 ::= *
=58482					WordListLink ::= Nt0 ; remember the nt of this word for later
.e4f6	20 c6 e9	jsr $e9c6		jsr asm_2
=3					CodeLen	.var *-XtPtr1
=$e4f9					Here1 = *	; remember here
>e4f4	03					.byte CodeLen	;patch wh_CodeLength
>e4f9	5d					.byte $5d
>e4fa	65 6f 72 2e 79			Name0:	.text "eor.y"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=58495					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e4ff	25					.byte (("eor.y"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>e500	10					.byte WordFlags	;wh_Flags
>e501	03					.byte 3	;wh_CodeLength
>e502	0d					  .byte LinkDisplacement	; offset to previous nt
=$e503					XtPtr1 ::= *
=58495					WordListLink ::= Nt0 ; remember the nt of this word for later
.e503	20 c6 e9	jsr $e9c6		jsr asm_2
=3					CodeLen	.var *-XtPtr1
=$e506					Here1 = *	; remember here
>e501	03					.byte CodeLen	;patch wh_CodeLength
>e506	59					.byte $59
>e507	65 6f 72 2e 7a			Name0:	.text "eor.z"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=58508					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e50c	45					.byte (("eor.z"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>e50d	10					.byte WordFlags	;wh_Flags
>e50e	03					.byte 3	;wh_CodeLength
>e50f	0d					  .byte LinkDisplacement	; offset to previous nt
=$e510					XtPtr1 ::= *
=58508					WordListLink ::= Nt0 ; remember the nt of this word for later
.e510	20 b4 e9	jsr $e9b4		jsr asm_1
=3					CodeLen	.var *-XtPtr1
=$e513					Here1 = *	; remember here
>e50e	03					.byte CodeLen	;patch wh_CodeLength
>e513	45					.byte $45
>e514	65 6f 72 2e 7a 69 79		Name0:	.text "eor.ziy"	;  name of word as a string, ending at wh_NameLastChar
=7					NameLength = *-Name0
=58523					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e51b	27					.byte (("eor.ziy"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=15					LinkDisplacement = Nt0-WordListLink
>e51c	10					.byte WordFlags	;wh_Flags
>e51d	03					.byte 3	;wh_CodeLength
>e51e	0f					  .byte LinkDisplacement	; offset to previous nt
=$e51f					XtPtr1 ::= *
=58523					WordListLink ::= Nt0 ; remember the nt of this word for later
.e51f	20 b4 e9	jsr $e9b4		jsr asm_1
=3					CodeLen	.var *-XtPtr1
=$e522					Here1 = *	; remember here
>e51d	03					.byte CodeLen	;patch wh_CodeLength
>e522	51					.byte $51
>e523	65 6f 72 2e 7a 78		Name0:	.text "eor.zx"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=58537					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e529	06					.byte (("eor.zx"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=14					LinkDisplacement = Nt0-WordListLink
>e52a	10					.byte WordFlags	;wh_Flags
>e52b	03					.byte 3	;wh_CodeLength
>e52c	0e					  .byte LinkDisplacement	; offset to previous nt
=$e52d					XtPtr1 ::= *
=58537					WordListLink ::= Nt0 ; remember the nt of this word for later
.e52d	20 b4 e9	jsr $e9b4		jsr asm_1
=3					CodeLen	.var *-XtPtr1
=$e530					Here1 = *	; remember here
>e52b	03					.byte CodeLen	;patch wh_CodeLength
>e530	55					.byte $55
>e531	65 6f 72 2e 7a 78 69		Name0:	.text "eor.zxi"	;  name of word as a string, ending at wh_NameLastChar
=7					NameLength = *-Name0
=58552					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e538	27					.byte (("eor.zxi"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=15					LinkDisplacement = Nt0-WordListLink
>e539	10					.byte WordFlags	;wh_Flags
>e53a	03					.byte 3	;wh_CodeLength
>e53b	0f					  .byte LinkDisplacement	; offset to previous nt
=$e53c					XtPtr1 ::= *
=58552					WordListLink ::= Nt0 ; remember the nt of this word for later
.e53c	20 b4 e9	jsr $e9b4		jsr asm_1
=3					CodeLen	.var *-XtPtr1
=$e53f					Here1 = *	; remember here
>e53a	03					.byte CodeLen	;patch wh_CodeLength
>e53f	41					.byte $41
>e540	69 6e 63			Name0:	.text "inc"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=58563					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e543	63					.byte (("inc"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=11					LinkDisplacement = Nt0-WordListLink
>e544	10					.byte WordFlags	;wh_Flags
>e545	03					.byte 3	;wh_CodeLength
>e546	0b					  .byte LinkDisplacement	; offset to previous nt
=$e547					XtPtr1 ::= *
=58563					WordListLink ::= Nt0 ; remember the nt of this word for later
.e547	20 c6 e9	jsr $e9c6		jsr asm_2
=3					CodeLen	.var *-XtPtr1
=$e54a					Here1 = *	; remember here
>e545	03					.byte CodeLen	;patch wh_CodeLength
>e54a	ee					.byte $ee
>e54b	69 6e 63 2e 61			Name0:	.text "inc.a"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=58576					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e550	25					.byte (("inc.a"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>e551	10					.byte WordFlags	;wh_Flags
>e552	03					.byte 3	;wh_CodeLength
>e553	0d					  .byte LinkDisplacement	; offset to previous nt
=$e554					XtPtr1 ::= *
=58576					WordListLink ::= Nt0 ; remember the nt of this word for later
.e554	20 cf e9	jsr $e9cf		jsr asm_0
=3					CodeLen	.var *-XtPtr1
=$e557					Here1 = *	; remember here
>e552	03					.byte CodeLen	;patch wh_CodeLength
>e557	1a					.byte $1a
>e558	69 6e 63 2e 78			Name0:	.text "inc.x"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=58589					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e55d	05					.byte (("inc.x"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>e55e	10					.byte WordFlags	;wh_Flags
>e55f	03					.byte 3	;wh_CodeLength
>e560	0d					  .byte LinkDisplacement	; offset to previous nt
=$e561					XtPtr1 ::= *
=58589					WordListLink ::= Nt0 ; remember the nt of this word for later
.e561	20 c6 e9	jsr $e9c6		jsr asm_2
=3					CodeLen	.var *-XtPtr1
=$e564					Here1 = *	; remember here
>e55f	03					.byte CodeLen	;patch wh_CodeLength
>e564	fe					.byte $fe
>e565	69 6e 63 2e 7a			Name0:	.text "inc.z"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=58602					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e56a	45					.byte (("inc.z"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>e56b	10					.byte WordFlags	;wh_Flags
>e56c	03					.byte 3	;wh_CodeLength
>e56d	0d					  .byte LinkDisplacement	; offset to previous nt
=$e56e					XtPtr1 ::= *
=58602					WordListLink ::= Nt0 ; remember the nt of this word for later
.e56e	20 b4 e9	jsr $e9b4		jsr asm_1
=3					CodeLen	.var *-XtPtr1
=$e571					Here1 = *	; remember here
>e56c	03					.byte CodeLen	;patch wh_CodeLength
>e571	e6					.byte $e6
>e572	69 6e 63 2e 7a 78		Name0:	.text "inc.zx"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=58616					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e578	06					.byte (("inc.zx"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=14					LinkDisplacement = Nt0-WordListLink
>e579	10					.byte WordFlags	;wh_Flags
>e57a	03					.byte 3	;wh_CodeLength
>e57b	0e					  .byte LinkDisplacement	; offset to previous nt
=$e57c					XtPtr1 ::= *
=58616					WordListLink ::= Nt0 ; remember the nt of this word for later
.e57c	20 b4 e9	jsr $e9b4		jsr asm_1
=3					CodeLen	.var *-XtPtr1
=$e57f					Here1 = *	; remember here
>e57a	03					.byte CodeLen	;patch wh_CodeLength
>e57f	f6					.byte $f6
>e580	69 6e 78			Name0:	.text "inx"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=58627					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e583	03					.byte (("inx"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=11					LinkDisplacement = Nt0-WordListLink
>e584	10					.byte WordFlags	;wh_Flags
>e585	03					.byte 3	;wh_CodeLength
>e586	0b					  .byte LinkDisplacement	; offset to previous nt
=$e587					XtPtr1 ::= *
=58627					WordListLink ::= Nt0 ; remember the nt of this word for later
.e587	20 cf e9	jsr $e9cf		jsr asm_0
=3					CodeLen	.var *-XtPtr1
=$e58a					Here1 = *	; remember here
>e585	03					.byte CodeLen	;patch wh_CodeLength
>e58a	e8					.byte $e8
>e58b	69 6e 79			Name0:	.text "iny"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=58638					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e58e	23					.byte (("iny"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=11					LinkDisplacement = Nt0-WordListLink
>e58f	10					.byte WordFlags	;wh_Flags
>e590	03					.byte 3	;wh_CodeLength
>e591	0b					  .byte LinkDisplacement	; offset to previous nt
=$e592					XtPtr1 ::= *
=58638					WordListLink ::= Nt0 ; remember the nt of this word for later
.e592	20 cf e9	jsr $e9cf		jsr asm_0
=3					CodeLen	.var *-XtPtr1
=$e595					Here1 = *	; remember here
>e590	03					.byte CodeLen	;patch wh_CodeLength
>e595	c8					.byte $c8
>e596	6a 6d 70			Name0:	.text "jmp"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=58649					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e599	03					.byte (("jmp"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=11					LinkDisplacement = Nt0-WordListLink
>e59a	10					.byte WordFlags	;wh_Flags
>e59b	03					.byte 3	;wh_CodeLength
>e59c	0b					  .byte LinkDisplacement	; offset to previous nt
=$e59d					XtPtr1 ::= *
=58649					WordListLink ::= Nt0 ; remember the nt of this word for later
.e59d	20 c6 e9	jsr $e9c6		jsr asm_2
=3					CodeLen	.var *-XtPtr1
=$e5a0					Here1 = *	; remember here
>e59b	03					.byte CodeLen	;patch wh_CodeLength
>e5a0	4c					.byte $4c
>e5a1	6a 6d 70 2e 69			Name0:	.text "jmp.i"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=58662					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e5a6	25					.byte (("jmp.i"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>e5a7	10					.byte WordFlags	;wh_Flags
>e5a8	03					.byte 3	;wh_CodeLength
>e5a9	0d					  .byte LinkDisplacement	; offset to previous nt
=$e5aa					XtPtr1 ::= *
=58662					WordListLink ::= Nt0 ; remember the nt of this word for later
.e5aa	20 c6 e9	jsr $e9c6		jsr asm_2
=3					CodeLen	.var *-XtPtr1
=$e5ad					Here1 = *	; remember here
>e5a8	03					.byte CodeLen	;patch wh_CodeLength
>e5ad	6c					.byte $6c
>e5ae	6a 73 72			Name0:	.text "jsr"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=58673					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e5b1	43					.byte (("jsr"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=11					LinkDisplacement = Nt0-WordListLink
>e5b2	10					.byte WordFlags	;wh_Flags
>e5b3	03					.byte 3	;wh_CodeLength
>e5b4	0b					  .byte LinkDisplacement	; offset to previous nt
=$e5b5					XtPtr1 ::= *
=58673					WordListLink ::= Nt0 ; remember the nt of this word for later
.e5b5	20 c6 e9	jsr $e9c6		jsr asm_2
=3					CodeLen	.var *-XtPtr1
=$e5b8					Here1 = *	; remember here
>e5b3	03					.byte CodeLen	;patch wh_CodeLength
>e5b8	20					.byte $20
>e5b9	6c 64 61			Name0:	.text "lda"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=58684					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e5bc	23					.byte (("lda"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=11					LinkDisplacement = Nt0-WordListLink
>e5bd	10					.byte WordFlags	;wh_Flags
>e5be	03					.byte 3	;wh_CodeLength
>e5bf	0b					  .byte LinkDisplacement	; offset to previous nt
=$e5c0					XtPtr1 ::= *
=58684					WordListLink ::= Nt0 ; remember the nt of this word for later
.e5c0	20 c6 e9	jsr $e9c6		jsr asm_2
=3					CodeLen	.var *-XtPtr1
=$e5c3					Here1 = *	; remember here
>e5be	03					.byte CodeLen	;patch wh_CodeLength
>e5c3	ad					.byte $ad
>e5c4	6c 64 61 2e 23			Name0:	.text "lda.#"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=58697					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e5c9	65					.byte (("lda.#"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>e5ca	10					.byte WordFlags	;wh_Flags
>e5cb	03					.byte 3	;wh_CodeLength
>e5cc	0d					  .byte LinkDisplacement	; offset to previous nt
=$e5cd					XtPtr1 ::= *
=58697					WordListLink ::= Nt0 ; remember the nt of this word for later
.e5cd	20 b4 e9	jsr $e9b4		jsr asm_1
=3					CodeLen	.var *-XtPtr1
=$e5d0					Here1 = *	; remember here
>e5cb	03					.byte CodeLen	;patch wh_CodeLength
>e5d0	a9					.byte $a9
>e5d1	6c 64 61 2e 78			Name0:	.text "lda.x"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=58710					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e5d6	05					.byte (("lda.x"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>e5d7	10					.byte WordFlags	;wh_Flags
>e5d8	03					.byte 3	;wh_CodeLength
>e5d9	0d					  .byte LinkDisplacement	; offset to previous nt
=$e5da					XtPtr1 ::= *
=58710					WordListLink ::= Nt0 ; remember the nt of this word for later
.e5da	20 c6 e9	jsr $e9c6		jsr asm_2
=3					CodeLen	.var *-XtPtr1
=$e5dd					Here1 = *	; remember here
>e5d8	03					.byte CodeLen	;patch wh_CodeLength
>e5dd	bd					.byte $bd
>e5de	6c 64 61 2e 79			Name0:	.text "lda.y"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=58723					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e5e3	25					.byte (("lda.y"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>e5e4	10					.byte WordFlags	;wh_Flags
>e5e5	03					.byte 3	;wh_CodeLength
>e5e6	0d					  .byte LinkDisplacement	; offset to previous nt
=$e5e7					XtPtr1 ::= *
=58723					WordListLink ::= Nt0 ; remember the nt of this word for later
.e5e7	20 c6 e9	jsr $e9c6		jsr asm_2
=3					CodeLen	.var *-XtPtr1
=$e5ea					Here1 = *	; remember here
>e5e5	03					.byte CodeLen	;patch wh_CodeLength
>e5ea	b9					.byte $b9
>e5eb	6c 64 61 2e 7a			Name0:	.text "lda.z"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=58736					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e5f0	45					.byte (("lda.z"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>e5f1	10					.byte WordFlags	;wh_Flags
>e5f2	03					.byte 3	;wh_CodeLength
>e5f3	0d					  .byte LinkDisplacement	; offset to previous nt
=$e5f4					XtPtr1 ::= *
=58736					WordListLink ::= Nt0 ; remember the nt of this word for later
.e5f4	20 b4 e9	jsr $e9b4		jsr asm_1
=3					CodeLen	.var *-XtPtr1
=$e5f7					Here1 = *	; remember here
>e5f2	03					.byte CodeLen	;patch wh_CodeLength
>e5f7	a5					.byte $a5
>e5f8	6c 64 61 2e 7a 69 79		Name0:	.text "lda.ziy"	;  name of word as a string, ending at wh_NameLastChar
=7					NameLength = *-Name0
=58751					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e5ff	27					.byte (("lda.ziy"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=15					LinkDisplacement = Nt0-WordListLink
>e600	10					.byte WordFlags	;wh_Flags
>e601	03					.byte 3	;wh_CodeLength
>e602	0f					  .byte LinkDisplacement	; offset to previous nt
=$e603					XtPtr1 ::= *
=58751					WordListLink ::= Nt0 ; remember the nt of this word for later
.e603	20 b4 e9	jsr $e9b4		jsr asm_1
=3					CodeLen	.var *-XtPtr1
=$e606					Here1 = *	; remember here
>e601	03					.byte CodeLen	;patch wh_CodeLength
>e606	b1					.byte $b1
>e607	6c 64 61 2e 7a 78		Name0:	.text "lda.zx"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=58765					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e60d	06					.byte (("lda.zx"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=14					LinkDisplacement = Nt0-WordListLink
>e60e	10					.byte WordFlags	;wh_Flags
>e60f	03					.byte 3	;wh_CodeLength
>e610	0e					  .byte LinkDisplacement	; offset to previous nt
=$e611					XtPtr1 ::= *
=58765					WordListLink ::= Nt0 ; remember the nt of this word for later
.e611	20 b4 e9	jsr $e9b4		jsr asm_1
=3					CodeLen	.var *-XtPtr1
=$e614					Here1 = *	; remember here
>e60f	03					.byte CodeLen	;patch wh_CodeLength
>e614	b5					.byte $b5
>e615	6c 64 61 2e 7a 78 69		Name0:	.text "lda.zxi"	;  name of word as a string, ending at wh_NameLastChar
=7					NameLength = *-Name0
=58780					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e61c	27					.byte (("lda.zxi"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=15					LinkDisplacement = Nt0-WordListLink
>e61d	10					.byte WordFlags	;wh_Flags
>e61e	03					.byte 3	;wh_CodeLength
>e61f	0f					  .byte LinkDisplacement	; offset to previous nt
=$e620					XtPtr1 ::= *
=58780					WordListLink ::= Nt0 ; remember the nt of this word for later
.e620	20 b4 e9	jsr $e9b4		jsr asm_1
=3					CodeLen	.var *-XtPtr1
=$e623					Here1 = *	; remember here
>e61e	03					.byte CodeLen	;patch wh_CodeLength
>e623	a1					.byte $a1
>e624	6c 64 78			Name0:	.text "ldx"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=58791					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e627	03					.byte (("ldx"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=11					LinkDisplacement = Nt0-WordListLink
>e628	10					.byte WordFlags	;wh_Flags
>e629	03					.byte 3	;wh_CodeLength
>e62a	0b					  .byte LinkDisplacement	; offset to previous nt
=$e62b					XtPtr1 ::= *
=58791					WordListLink ::= Nt0 ; remember the nt of this word for later
.e62b	20 c6 e9	jsr $e9c6		jsr asm_2
=3					CodeLen	.var *-XtPtr1
=$e62e					Here1 = *	; remember here
>e629	03					.byte CodeLen	;patch wh_CodeLength
>e62e	ae					.byte $ae
>e62f	6c 64 78 2e 23			Name0:	.text "ldx.#"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=58804					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e634	65					.byte (("ldx.#"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>e635	10					.byte WordFlags	;wh_Flags
>e636	03					.byte 3	;wh_CodeLength
>e637	0d					  .byte LinkDisplacement	; offset to previous nt
=$e638					XtPtr1 ::= *
=58804					WordListLink ::= Nt0 ; remember the nt of this word for later
.e638	20 b4 e9	jsr $e9b4		jsr asm_1
=3					CodeLen	.var *-XtPtr1
=$e63b					Here1 = *	; remember here
>e636	03					.byte CodeLen	;patch wh_CodeLength
>e63b	a2					.byte $a2
>e63c	6c 64 78 2e 79			Name0:	.text "ldx.y"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=58817					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e641	25					.byte (("ldx.y"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>e642	10					.byte WordFlags	;wh_Flags
>e643	03					.byte 3	;wh_CodeLength
>e644	0d					  .byte LinkDisplacement	; offset to previous nt
=$e645					XtPtr1 ::= *
=58817					WordListLink ::= Nt0 ; remember the nt of this word for later
.e645	20 c6 e9	jsr $e9c6		jsr asm_2
=3					CodeLen	.var *-XtPtr1
=$e648					Here1 = *	; remember here
>e643	03					.byte CodeLen	;patch wh_CodeLength
>e648	be					.byte $be
>e649	6c 64 78 2e 7a			Name0:	.text "ldx.z"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=58830					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e64e	45					.byte (("ldx.z"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>e64f	10					.byte WordFlags	;wh_Flags
>e650	03					.byte 3	;wh_CodeLength
>e651	0d					  .byte LinkDisplacement	; offset to previous nt
=$e652					XtPtr1 ::= *
=58830					WordListLink ::= Nt0 ; remember the nt of this word for later
.e652	20 b4 e9	jsr $e9b4		jsr asm_1
=3					CodeLen	.var *-XtPtr1
=$e655					Here1 = *	; remember here
>e650	03					.byte CodeLen	;patch wh_CodeLength
>e655	a6					.byte $a6
>e656	6c 64 78 2e 7a 79		Name0:	.text "ldx.zy"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=58844					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e65c	26					.byte (("ldx.zy"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=14					LinkDisplacement = Nt0-WordListLink
>e65d	10					.byte WordFlags	;wh_Flags
>e65e	03					.byte 3	;wh_CodeLength
>e65f	0e					  .byte LinkDisplacement	; offset to previous nt
=$e660					XtPtr1 ::= *
=58844					WordListLink ::= Nt0 ; remember the nt of this word for later
.e660	20 b4 e9	jsr $e9b4		jsr asm_1
=3					CodeLen	.var *-XtPtr1
=$e663					Here1 = *	; remember here
>e65e	03					.byte CodeLen	;patch wh_CodeLength
>e663	b6					.byte $b6
>e664	6c 64 79			Name0:	.text "ldy"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=58855					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e667	23					.byte (("ldy"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=11					LinkDisplacement = Nt0-WordListLink
>e668	10					.byte WordFlags	;wh_Flags
>e669	03					.byte 3	;wh_CodeLength
>e66a	0b					  .byte LinkDisplacement	; offset to previous nt
=$e66b					XtPtr1 ::= *
=58855					WordListLink ::= Nt0 ; remember the nt of this word for later
.e66b	20 c6 e9	jsr $e9c6		jsr asm_2
=3					CodeLen	.var *-XtPtr1
=$e66e					Here1 = *	; remember here
>e669	03					.byte CodeLen	;patch wh_CodeLength
>e66e	ac					.byte $ac
>e66f	6c 64 79 2e 23			Name0:	.text "ldy.#"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=58868					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e674	65					.byte (("ldy.#"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>e675	10					.byte WordFlags	;wh_Flags
>e676	03					.byte 3	;wh_CodeLength
>e677	0d					  .byte LinkDisplacement	; offset to previous nt
=$e678					XtPtr1 ::= *
=58868					WordListLink ::= Nt0 ; remember the nt of this word for later
.e678	20 b4 e9	jsr $e9b4		jsr asm_1
=3					CodeLen	.var *-XtPtr1
=$e67b					Here1 = *	; remember here
>e676	03					.byte CodeLen	;patch wh_CodeLength
>e67b	a0					.byte $a0
>e67c	6c 64 79 2e 78			Name0:	.text "ldy.x"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=58881					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e681	05					.byte (("ldy.x"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>e682	10					.byte WordFlags	;wh_Flags
>e683	03					.byte 3	;wh_CodeLength
>e684	0d					  .byte LinkDisplacement	; offset to previous nt
=$e685					XtPtr1 ::= *
=58881					WordListLink ::= Nt0 ; remember the nt of this word for later
.e685	20 c6 e9	jsr $e9c6		jsr asm_2
=3					CodeLen	.var *-XtPtr1
=$e688					Here1 = *	; remember here
>e683	03					.byte CodeLen	;patch wh_CodeLength
>e688	bc					.byte $bc
>e689	6c 64 79 2e 7a			Name0:	.text "ldy.z"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=58894					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e68e	45					.byte (("ldy.z"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>e68f	10					.byte WordFlags	;wh_Flags
>e690	03					.byte 3	;wh_CodeLength
>e691	0d					  .byte LinkDisplacement	; offset to previous nt
=$e692					XtPtr1 ::= *
=58894					WordListLink ::= Nt0 ; remember the nt of this word for later
.e692	20 b4 e9	jsr $e9b4		jsr asm_1
=3					CodeLen	.var *-XtPtr1
=$e695					Here1 = *	; remember here
>e690	03					.byte CodeLen	;patch wh_CodeLength
>e695	a4					.byte $a4
>e696	6c 64 79 2e 7a 78		Name0:	.text "ldy.zx"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=58908					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e69c	06					.byte (("ldy.zx"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=14					LinkDisplacement = Nt0-WordListLink
>e69d	10					.byte WordFlags	;wh_Flags
>e69e	03					.byte 3	;wh_CodeLength
>e69f	0e					  .byte LinkDisplacement	; offset to previous nt
=$e6a0					XtPtr1 ::= *
=58908					WordListLink ::= Nt0 ; remember the nt of this word for later
.e6a0	20 b4 e9	jsr $e9b4		jsr asm_1
=3					CodeLen	.var *-XtPtr1
=$e6a3					Here1 = *	; remember here
>e69e	03					.byte CodeLen	;patch wh_CodeLength
>e6a3	b4					.byte $b4
>e6a4	6c 73 72			Name0:	.text "lsr"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=58919					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e6a7	43					.byte (("lsr"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=11					LinkDisplacement = Nt0-WordListLink
>e6a8	10					.byte WordFlags	;wh_Flags
>e6a9	03					.byte 3	;wh_CodeLength
>e6aa	0b					  .byte LinkDisplacement	; offset to previous nt
=$e6ab					XtPtr1 ::= *
=58919					WordListLink ::= Nt0 ; remember the nt of this word for later
.e6ab	20 c6 e9	jsr $e9c6		jsr asm_2
=3					CodeLen	.var *-XtPtr1
=$e6ae					Here1 = *	; remember here
>e6a9	03					.byte CodeLen	;patch wh_CodeLength
>e6ae	4e					.byte $4e
>e6af	6c 73 72 2e 61			Name0:	.text "lsr.a"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=58932					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e6b4	25					.byte (("lsr.a"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>e6b5	10					.byte WordFlags	;wh_Flags
>e6b6	03					.byte 3	;wh_CodeLength
>e6b7	0d					  .byte LinkDisplacement	; offset to previous nt
=$e6b8					XtPtr1 ::= *
=58932					WordListLink ::= Nt0 ; remember the nt of this word for later
.e6b8	20 cf e9	jsr $e9cf		jsr asm_0
=3					CodeLen	.var *-XtPtr1
=$e6bb					Here1 = *	; remember here
>e6b6	03					.byte CodeLen	;patch wh_CodeLength
>e6bb	4a					.byte $4a
>e6bc	6c 73 72 2e 78			Name0:	.text "lsr.x"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=58945					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e6c1	05					.byte (("lsr.x"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>e6c2	10					.byte WordFlags	;wh_Flags
>e6c3	03					.byte 3	;wh_CodeLength
>e6c4	0d					  .byte LinkDisplacement	; offset to previous nt
=$e6c5					XtPtr1 ::= *
=58945					WordListLink ::= Nt0 ; remember the nt of this word for later
.e6c5	20 c6 e9	jsr $e9c6		jsr asm_2
=3					CodeLen	.var *-XtPtr1
=$e6c8					Here1 = *	; remember here
>e6c3	03					.byte CodeLen	;patch wh_CodeLength
>e6c8	5e					.byte $5e
>e6c9	6c 73 72 2e 7a			Name0:	.text "lsr.z"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=58958					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e6ce	45					.byte (("lsr.z"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>e6cf	10					.byte WordFlags	;wh_Flags
>e6d0	03					.byte 3	;wh_CodeLength
>e6d1	0d					  .byte LinkDisplacement	; offset to previous nt
=$e6d2					XtPtr1 ::= *
=58958					WordListLink ::= Nt0 ; remember the nt of this word for later
.e6d2	20 b4 e9	jsr $e9b4		jsr asm_1
=3					CodeLen	.var *-XtPtr1
=$e6d5					Here1 = *	; remember here
>e6d0	03					.byte CodeLen	;patch wh_CodeLength
>e6d5	46					.byte $46
>e6d6	6c 73 72 2e 7a 78		Name0:	.text "lsr.zx"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=58972					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e6dc	06					.byte (("lsr.zx"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=14					LinkDisplacement = Nt0-WordListLink
>e6dd	10					.byte WordFlags	;wh_Flags
>e6de	03					.byte 3	;wh_CodeLength
>e6df	0e					  .byte LinkDisplacement	; offset to previous nt
=$e6e0					XtPtr1 ::= *
=58972					WordListLink ::= Nt0 ; remember the nt of this word for later
.e6e0	20 b4 e9	jsr $e9b4		jsr asm_1
=3					CodeLen	.var *-XtPtr1
=$e6e3					Here1 = *	; remember here
>e6de	03					.byte CodeLen	;patch wh_CodeLength
>e6e3	56					.byte $56
>e6e4	6e 6f 70			Name0:	.text "nop"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=58983					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e6e7	03					.byte (("nop"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=11					LinkDisplacement = Nt0-WordListLink
>e6e8	10					.byte WordFlags	;wh_Flags
>e6e9	03					.byte 3	;wh_CodeLength
>e6ea	0b					  .byte LinkDisplacement	; offset to previous nt
=$e6eb					XtPtr1 ::= *
=58983					WordListLink ::= Nt0 ; remember the nt of this word for later
.e6eb	20 cf e9	jsr $e9cf		jsr asm_0
=3					CodeLen	.var *-XtPtr1
=$e6ee					Here1 = *	; remember here
>e6e9	03					.byte CodeLen	;patch wh_CodeLength
>e6ee	ea					.byte $ea
>e6ef	6f 72 61			Name0:	.text "ora"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=58994					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e6f2	23					.byte (("ora"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=11					LinkDisplacement = Nt0-WordListLink
>e6f3	10					.byte WordFlags	;wh_Flags
>e6f4	03					.byte 3	;wh_CodeLength
>e6f5	0b					  .byte LinkDisplacement	; offset to previous nt
=$e6f6					XtPtr1 ::= *
=58994					WordListLink ::= Nt0 ; remember the nt of this word for later
.e6f6	20 c6 e9	jsr $e9c6		jsr asm_2
=3					CodeLen	.var *-XtPtr1
=$e6f9					Here1 = *	; remember here
>e6f4	03					.byte CodeLen	;patch wh_CodeLength
>e6f9	0d					.byte $0d
>e6fa	6f 72 61 2e 23			Name0:	.text "ora.#"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=59007					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e6ff	65					.byte (("ora.#"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>e700	10					.byte WordFlags	;wh_Flags
>e701	03					.byte 3	;wh_CodeLength
>e702	0d					  .byte LinkDisplacement	; offset to previous nt
=$e703					XtPtr1 ::= *
=59007					WordListLink ::= Nt0 ; remember the nt of this word for later
.e703	20 b4 e9	jsr $e9b4		jsr asm_1
=3					CodeLen	.var *-XtPtr1
=$e706					Here1 = *	; remember here
>e701	03					.byte CodeLen	;patch wh_CodeLength
>e706	09					.byte $09
>e707	6f 72 61 2e 78			Name0:	.text "ora.x"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=59020					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e70c	05					.byte (("ora.x"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>e70d	10					.byte WordFlags	;wh_Flags
>e70e	03					.byte 3	;wh_CodeLength
>e70f	0d					  .byte LinkDisplacement	; offset to previous nt
=$e710					XtPtr1 ::= *
=59020					WordListLink ::= Nt0 ; remember the nt of this word for later
.e710	20 c6 e9	jsr $e9c6		jsr asm_2
=3					CodeLen	.var *-XtPtr1
=$e713					Here1 = *	; remember here
>e70e	03					.byte CodeLen	;patch wh_CodeLength
>e713	1d					.byte $1d
>e714	6f 72 61 2e 79			Name0:	.text "ora.y"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=59033					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e719	25					.byte (("ora.y"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>e71a	10					.byte WordFlags	;wh_Flags
>e71b	03					.byte 3	;wh_CodeLength
>e71c	0d					  .byte LinkDisplacement	; offset to previous nt
=$e71d					XtPtr1 ::= *
=59033					WordListLink ::= Nt0 ; remember the nt of this word for later
.e71d	20 c6 e9	jsr $e9c6		jsr asm_2
=3					CodeLen	.var *-XtPtr1
=$e720					Here1 = *	; remember here
>e71b	03					.byte CodeLen	;patch wh_CodeLength
>e720	19					.byte $19
>e721	6f 72 61 2e 7a			Name0:	.text "ora.z"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=59046					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e726	45					.byte (("ora.z"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>e727	10					.byte WordFlags	;wh_Flags
>e728	03					.byte 3	;wh_CodeLength
>e729	0d					  .byte LinkDisplacement	; offset to previous nt
=$e72a					XtPtr1 ::= *
=59046					WordListLink ::= Nt0 ; remember the nt of this word for later
.e72a	20 b4 e9	jsr $e9b4		jsr asm_1
=3					CodeLen	.var *-XtPtr1
=$e72d					Here1 = *	; remember here
>e728	03					.byte CodeLen	;patch wh_CodeLength
>e72d	05					.byte $05
>e72e	6f 72 61 2e 7a 69 79		Name0:	.text "ora.ziy"	;  name of word as a string, ending at wh_NameLastChar
=7					NameLength = *-Name0
=59061					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e735	27					.byte (("ora.ziy"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=15					LinkDisplacement = Nt0-WordListLink
>e736	10					.byte WordFlags	;wh_Flags
>e737	03					.byte 3	;wh_CodeLength
>e738	0f					  .byte LinkDisplacement	; offset to previous nt
=$e739					XtPtr1 ::= *
=59061					WordListLink ::= Nt0 ; remember the nt of this word for later
.e739	20 b4 e9	jsr $e9b4		jsr asm_1
=3					CodeLen	.var *-XtPtr1
=$e73c					Here1 = *	; remember here
>e737	03					.byte CodeLen	;patch wh_CodeLength
>e73c	11					.byte $11
>e73d	6f 72 61 2e 7a 78		Name0:	.text "ora.zx"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=59075					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e743	06					.byte (("ora.zx"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=14					LinkDisplacement = Nt0-WordListLink
>e744	10					.byte WordFlags	;wh_Flags
>e745	03					.byte 3	;wh_CodeLength
>e746	0e					  .byte LinkDisplacement	; offset to previous nt
=$e747					XtPtr1 ::= *
=59075					WordListLink ::= Nt0 ; remember the nt of this word for later
.e747	20 b4 e9	jsr $e9b4		jsr asm_1
=3					CodeLen	.var *-XtPtr1
=$e74a					Here1 = *	; remember here
>e745	03					.byte CodeLen	;patch wh_CodeLength
>e74a	15					.byte $15
>e74b	6f 72 61 2e 7a 78 69		Name0:	.text "ora.zxi"	;  name of word as a string, ending at wh_NameLastChar
=7					NameLength = *-Name0
=59090					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e752	27					.byte (("ora.zxi"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=15					LinkDisplacement = Nt0-WordListLink
>e753	10					.byte WordFlags	;wh_Flags
>e754	03					.byte 3	;wh_CodeLength
>e755	0f					  .byte LinkDisplacement	; offset to previous nt
=$e756					XtPtr1 ::= *
=59090					WordListLink ::= Nt0 ; remember the nt of this word for later
.e756	20 b4 e9	jsr $e9b4		jsr asm_1
=3					CodeLen	.var *-XtPtr1
=$e759					Here1 = *	; remember here
>e754	03					.byte CodeLen	;patch wh_CodeLength
>e759	01					.byte $01
>e75a	70 68 61			Name0:	.text "pha"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=59101					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e75d	23					.byte (("pha"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=11					LinkDisplacement = Nt0-WordListLink
>e75e	10					.byte WordFlags	;wh_Flags
>e75f	03					.byte 3	;wh_CodeLength
>e760	0b					  .byte LinkDisplacement	; offset to previous nt
=$e761					XtPtr1 ::= *
=59101					WordListLink ::= Nt0 ; remember the nt of this word for later
.e761	20 cf e9	jsr $e9cf		jsr asm_0
=3					CodeLen	.var *-XtPtr1
=$e764					Here1 = *	; remember here
>e75f	03					.byte CodeLen	;patch wh_CodeLength
>e764	48					.byte $48
>e765	70 68 70			Name0:	.text "php"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=59112					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e768	03					.byte (("php"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=11					LinkDisplacement = Nt0-WordListLink
>e769	10					.byte WordFlags	;wh_Flags
>e76a	03					.byte 3	;wh_CodeLength
>e76b	0b					  .byte LinkDisplacement	; offset to previous nt
=$e76c					XtPtr1 ::= *
=59112					WordListLink ::= Nt0 ; remember the nt of this word for later
.e76c	20 cf e9	jsr $e9cf		jsr asm_0
=3					CodeLen	.var *-XtPtr1
=$e76f					Here1 = *	; remember here
>e76a	03					.byte CodeLen	;patch wh_CodeLength
>e76f	08					.byte $08
>e770	70 6c 61			Name0:	.text "pla"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=59123					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e773	23					.byte (("pla"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=11					LinkDisplacement = Nt0-WordListLink
>e774	10					.byte WordFlags	;wh_Flags
>e775	03					.byte 3	;wh_CodeLength
>e776	0b					  .byte LinkDisplacement	; offset to previous nt
=$e777					XtPtr1 ::= *
=59123					WordListLink ::= Nt0 ; remember the nt of this word for later
.e777	20 cf e9	jsr $e9cf		jsr asm_0
=3					CodeLen	.var *-XtPtr1
=$e77a					Here1 = *	; remember here
>e775	03					.byte CodeLen	;patch wh_CodeLength
>e77a	68					.byte $68
>e77b	70 6c 70			Name0:	.text "plp"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=59134					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e77e	03					.byte (("plp"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=11					LinkDisplacement = Nt0-WordListLink
>e77f	10					.byte WordFlags	;wh_Flags
>e780	03					.byte 3	;wh_CodeLength
>e781	0b					  .byte LinkDisplacement	; offset to previous nt
=$e782					XtPtr1 ::= *
=59134					WordListLink ::= Nt0 ; remember the nt of this word for later
.e782	20 cf e9	jsr $e9cf		jsr asm_0
=3					CodeLen	.var *-XtPtr1
=$e785					Here1 = *	; remember here
>e780	03					.byte CodeLen	;patch wh_CodeLength
>e785	28					.byte $28
>e786	72 6f 6c			Name0:	.text "rol"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=59145					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e789	83					.byte (("rol"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=11					LinkDisplacement = Nt0-WordListLink
>e78a	10					.byte WordFlags	;wh_Flags
>e78b	03					.byte 3	;wh_CodeLength
>e78c	0b					  .byte LinkDisplacement	; offset to previous nt
=$e78d					XtPtr1 ::= *
=59145					WordListLink ::= Nt0 ; remember the nt of this word for later
.e78d	20 c6 e9	jsr $e9c6		jsr asm_2
=3					CodeLen	.var *-XtPtr1
=$e790					Here1 = *	; remember here
>e78b	03					.byte CodeLen	;patch wh_CodeLength
>e790	2e					.byte $2e
>e791	72 6f 6c 2e 61			Name0:	.text "rol.a"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=59158					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e796	25					.byte (("rol.a"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>e797	10					.byte WordFlags	;wh_Flags
>e798	03					.byte 3	;wh_CodeLength
>e799	0d					  .byte LinkDisplacement	; offset to previous nt
=$e79a					XtPtr1 ::= *
=59158					WordListLink ::= Nt0 ; remember the nt of this word for later
.e79a	20 cf e9	jsr $e9cf		jsr asm_0
=3					CodeLen	.var *-XtPtr1
=$e79d					Here1 = *	; remember here
>e798	03					.byte CodeLen	;patch wh_CodeLength
>e79d	2a					.byte $2a
>e79e	72 6f 6c 2e 78			Name0:	.text "rol.x"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=59171					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e7a3	05					.byte (("rol.x"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>e7a4	10					.byte WordFlags	;wh_Flags
>e7a5	03					.byte 3	;wh_CodeLength
>e7a6	0d					  .byte LinkDisplacement	; offset to previous nt
=$e7a7					XtPtr1 ::= *
=59171					WordListLink ::= Nt0 ; remember the nt of this word for later
.e7a7	20 c6 e9	jsr $e9c6		jsr asm_2
=3					CodeLen	.var *-XtPtr1
=$e7aa					Here1 = *	; remember here
>e7a5	03					.byte CodeLen	;patch wh_CodeLength
>e7aa	3e					.byte $3e
>e7ab	72 6f 6c 2e 7a			Name0:	.text "rol.z"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=59184					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e7b0	45					.byte (("rol.z"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>e7b1	10					.byte WordFlags	;wh_Flags
>e7b2	03					.byte 3	;wh_CodeLength
>e7b3	0d					  .byte LinkDisplacement	; offset to previous nt
=$e7b4					XtPtr1 ::= *
=59184					WordListLink ::= Nt0 ; remember the nt of this word for later
.e7b4	20 b4 e9	jsr $e9b4		jsr asm_1
=3					CodeLen	.var *-XtPtr1
=$e7b7					Here1 = *	; remember here
>e7b2	03					.byte CodeLen	;patch wh_CodeLength
>e7b7	26					.byte $26
>e7b8	72 6f 6c 2e 7a 78		Name0:	.text "rol.zx"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=59198					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e7be	06					.byte (("rol.zx"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=14					LinkDisplacement = Nt0-WordListLink
>e7bf	10					.byte WordFlags	;wh_Flags
>e7c0	03					.byte 3	;wh_CodeLength
>e7c1	0e					  .byte LinkDisplacement	; offset to previous nt
=$e7c2					XtPtr1 ::= *
=59198					WordListLink ::= Nt0 ; remember the nt of this word for later
.e7c2	20 b4 e9	jsr $e9b4		jsr asm_1
=3					CodeLen	.var *-XtPtr1
=$e7c5					Here1 = *	; remember here
>e7c0	03					.byte CodeLen	;patch wh_CodeLength
>e7c5	36					.byte $36
>e7c6	72 6f 72			Name0:	.text "ror"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=59209					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e7c9	43					.byte (("ror"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=11					LinkDisplacement = Nt0-WordListLink
>e7ca	10					.byte WordFlags	;wh_Flags
>e7cb	03					.byte 3	;wh_CodeLength
>e7cc	0b					  .byte LinkDisplacement	; offset to previous nt
=$e7cd					XtPtr1 ::= *
=59209					WordListLink ::= Nt0 ; remember the nt of this word for later
.e7cd	20 c6 e9	jsr $e9c6		jsr asm_2
=3					CodeLen	.var *-XtPtr1
=$e7d0					Here1 = *	; remember here
>e7cb	03					.byte CodeLen	;patch wh_CodeLength
>e7d0	6e					.byte $6e
>e7d1	72 6f 72 2e 61			Name0:	.text "ror.a"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=59222					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e7d6	25					.byte (("ror.a"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>e7d7	10					.byte WordFlags	;wh_Flags
>e7d8	03					.byte 3	;wh_CodeLength
>e7d9	0d					  .byte LinkDisplacement	; offset to previous nt
=$e7da					XtPtr1 ::= *
=59222					WordListLink ::= Nt0 ; remember the nt of this word for later
.e7da	20 cf e9	jsr $e9cf		jsr asm_0
=3					CodeLen	.var *-XtPtr1
=$e7dd					Here1 = *	; remember here
>e7d8	03					.byte CodeLen	;patch wh_CodeLength
>e7dd	6a					.byte $6a
>e7de	72 6f 72 2e 78			Name0:	.text "ror.x"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=59235					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e7e3	05					.byte (("ror.x"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>e7e4	10					.byte WordFlags	;wh_Flags
>e7e5	03					.byte 3	;wh_CodeLength
>e7e6	0d					  .byte LinkDisplacement	; offset to previous nt
=$e7e7					XtPtr1 ::= *
=59235					WordListLink ::= Nt0 ; remember the nt of this word for later
.e7e7	20 c6 e9	jsr $e9c6		jsr asm_2
=3					CodeLen	.var *-XtPtr1
=$e7ea					Here1 = *	; remember here
>e7e5	03					.byte CodeLen	;patch wh_CodeLength
>e7ea	7e					.byte $7e
>e7eb	72 6f 72 2e 7a			Name0:	.text "ror.z"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=59248					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e7f0	45					.byte (("ror.z"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>e7f1	10					.byte WordFlags	;wh_Flags
>e7f2	03					.byte 3	;wh_CodeLength
>e7f3	0d					  .byte LinkDisplacement	; offset to previous nt
=$e7f4					XtPtr1 ::= *
=59248					WordListLink ::= Nt0 ; remember the nt of this word for later
.e7f4	20 b4 e9	jsr $e9b4		jsr asm_1
=3					CodeLen	.var *-XtPtr1
=$e7f7					Here1 = *	; remember here
>e7f2	03					.byte CodeLen	;patch wh_CodeLength
>e7f7	66					.byte $66
>e7f8	72 6f 72 2e 7a 78		Name0:	.text "ror.zx"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=59262					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e7fe	06					.byte (("ror.zx"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=14					LinkDisplacement = Nt0-WordListLink
>e7ff	10					.byte WordFlags	;wh_Flags
>e800	03					.byte 3	;wh_CodeLength
>e801	0e					  .byte LinkDisplacement	; offset to previous nt
=$e802					XtPtr1 ::= *
=59262					WordListLink ::= Nt0 ; remember the nt of this word for later
.e802	20 b4 e9	jsr $e9b4		jsr asm_1
=3					CodeLen	.var *-XtPtr1
=$e805					Here1 = *	; remember here
>e800	03					.byte CodeLen	;patch wh_CodeLength
>e805	76					.byte $76
>e806	72 74 69			Name0:	.text "rti"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=59273					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e809	23					.byte (("rti"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=11					LinkDisplacement = Nt0-WordListLink
>e80a	10					.byte WordFlags	;wh_Flags
>e80b	03					.byte 3	;wh_CodeLength
>e80c	0b					  .byte LinkDisplacement	; offset to previous nt
=$e80d					XtPtr1 ::= *
=59273					WordListLink ::= Nt0 ; remember the nt of this word for later
.e80d	20 cf e9	jsr $e9cf		jsr asm_0
=3					CodeLen	.var *-XtPtr1
=$e810					Here1 = *	; remember here
>e80b	03					.byte CodeLen	;patch wh_CodeLength
>e810	40					.byte $40
>e811	72 74 73			Name0:	.text "rts"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=59284					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e814	63					.byte (("rts"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=11					LinkDisplacement = Nt0-WordListLink
>e815	10					.byte WordFlags	;wh_Flags
>e816	03					.byte 3	;wh_CodeLength
>e817	0b					  .byte LinkDisplacement	; offset to previous nt
=$e818					XtPtr1 ::= *
=59284					WordListLink ::= Nt0 ; remember the nt of this word for later
.e818	20 cf e9	jsr $e9cf		jsr asm_0
=3					CodeLen	.var *-XtPtr1
=$e81b					Here1 = *	; remember here
>e816	03					.byte CodeLen	;patch wh_CodeLength
>e81b	60					.byte $60
>e81c	73 62 63			Name0:	.text "sbc"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=59295					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e81f	63					.byte (("sbc"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=11					LinkDisplacement = Nt0-WordListLink
>e820	10					.byte WordFlags	;wh_Flags
>e821	03					.byte 3	;wh_CodeLength
>e822	0b					  .byte LinkDisplacement	; offset to previous nt
=$e823					XtPtr1 ::= *
=59295					WordListLink ::= Nt0 ; remember the nt of this word for later
.e823	20 c6 e9	jsr $e9c6		jsr asm_2
=3					CodeLen	.var *-XtPtr1
=$e826					Here1 = *	; remember here
>e821	03					.byte CodeLen	;patch wh_CodeLength
>e826	ed					.byte $ed
>e827	73 62 63 2e 23			Name0:	.text "sbc.#"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=59308					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e82c	65					.byte (("sbc.#"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>e82d	10					.byte WordFlags	;wh_Flags
>e82e	03					.byte 3	;wh_CodeLength
>e82f	0d					  .byte LinkDisplacement	; offset to previous nt
=$e830					XtPtr1 ::= *
=59308					WordListLink ::= Nt0 ; remember the nt of this word for later
.e830	20 b4 e9	jsr $e9b4		jsr asm_1
=3					CodeLen	.var *-XtPtr1
=$e833					Here1 = *	; remember here
>e82e	03					.byte CodeLen	;patch wh_CodeLength
>e833	e9					.byte $e9
>e834	73 62 63 2e 78			Name0:	.text "sbc.x"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=59321					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e839	05					.byte (("sbc.x"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>e83a	10					.byte WordFlags	;wh_Flags
>e83b	03					.byte 3	;wh_CodeLength
>e83c	0d					  .byte LinkDisplacement	; offset to previous nt
=$e83d					XtPtr1 ::= *
=59321					WordListLink ::= Nt0 ; remember the nt of this word for later
.e83d	20 c6 e9	jsr $e9c6		jsr asm_2
=3					CodeLen	.var *-XtPtr1
=$e840					Here1 = *	; remember here
>e83b	03					.byte CodeLen	;patch wh_CodeLength
>e840	fd					.byte $fd
>e841	73 62 63 2e 79			Name0:	.text "sbc.y"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=59334					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e846	25					.byte (("sbc.y"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>e847	10					.byte WordFlags	;wh_Flags
>e848	03					.byte 3	;wh_CodeLength
>e849	0d					  .byte LinkDisplacement	; offset to previous nt
=$e84a					XtPtr1 ::= *
=59334					WordListLink ::= Nt0 ; remember the nt of this word for later
.e84a	20 c6 e9	jsr $e9c6		jsr asm_2
=3					CodeLen	.var *-XtPtr1
=$e84d					Here1 = *	; remember here
>e848	03					.byte CodeLen	;patch wh_CodeLength
>e84d	f9					.byte $f9
>e84e	73 62 63 2e 7a			Name0:	.text "sbc.z"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=59347					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e853	45					.byte (("sbc.z"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>e854	10					.byte WordFlags	;wh_Flags
>e855	03					.byte 3	;wh_CodeLength
>e856	0d					  .byte LinkDisplacement	; offset to previous nt
=$e857					XtPtr1 ::= *
=59347					WordListLink ::= Nt0 ; remember the nt of this word for later
.e857	20 b4 e9	jsr $e9b4		jsr asm_1
=3					CodeLen	.var *-XtPtr1
=$e85a					Here1 = *	; remember here
>e855	03					.byte CodeLen	;patch wh_CodeLength
>e85a	e5					.byte $e5
>e85b	73 62 63 2e 7a 69 79		Name0:	.text "sbc.ziy"	;  name of word as a string, ending at wh_NameLastChar
=7					NameLength = *-Name0
=59362					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e862	27					.byte (("sbc.ziy"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=15					LinkDisplacement = Nt0-WordListLink
>e863	10					.byte WordFlags	;wh_Flags
>e864	03					.byte 3	;wh_CodeLength
>e865	0f					  .byte LinkDisplacement	; offset to previous nt
=$e866					XtPtr1 ::= *
=59362					WordListLink ::= Nt0 ; remember the nt of this word for later
.e866	20 b4 e9	jsr $e9b4		jsr asm_1
=3					CodeLen	.var *-XtPtr1
=$e869					Here1 = *	; remember here
>e864	03					.byte CodeLen	;patch wh_CodeLength
>e869	f1					.byte $f1
>e86a	73 62 63 2e 7a 78		Name0:	.text "sbc.zx"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=59376					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e870	06					.byte (("sbc.zx"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=14					LinkDisplacement = Nt0-WordListLink
>e871	10					.byte WordFlags	;wh_Flags
>e872	03					.byte 3	;wh_CodeLength
>e873	0e					  .byte LinkDisplacement	; offset to previous nt
=$e874					XtPtr1 ::= *
=59376					WordListLink ::= Nt0 ; remember the nt of this word for later
.e874	20 b4 e9	jsr $e9b4		jsr asm_1
=3					CodeLen	.var *-XtPtr1
=$e877					Here1 = *	; remember here
>e872	03					.byte CodeLen	;patch wh_CodeLength
>e877	f5					.byte $f5
>e878	73 62 63 2e 7a 78 69		Name0:	.text "sbc.zxi"	;  name of word as a string, ending at wh_NameLastChar
=7					NameLength = *-Name0
=59391					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e87f	27					.byte (("sbc.zxi"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=15					LinkDisplacement = Nt0-WordListLink
>e880	10					.byte WordFlags	;wh_Flags
>e881	03					.byte 3	;wh_CodeLength
>e882	0f					  .byte LinkDisplacement	; offset to previous nt
=$e883					XtPtr1 ::= *
=59391					WordListLink ::= Nt0 ; remember the nt of this word for later
.e883	20 b4 e9	jsr $e9b4		jsr asm_1
=3					CodeLen	.var *-XtPtr1
=$e886					Here1 = *	; remember here
>e881	03					.byte CodeLen	;patch wh_CodeLength
>e886	e1					.byte $e1
>e887	73 65 63			Name0:	.text "sec"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=59402					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e88a	63					.byte (("sec"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=11					LinkDisplacement = Nt0-WordListLink
>e88b	10					.byte WordFlags	;wh_Flags
>e88c	03					.byte 3	;wh_CodeLength
>e88d	0b					  .byte LinkDisplacement	; offset to previous nt
=$e88e					XtPtr1 ::= *
=59402					WordListLink ::= Nt0 ; remember the nt of this word for later
.e88e	20 cf e9	jsr $e9cf		jsr asm_0
=3					CodeLen	.var *-XtPtr1
=$e891					Here1 = *	; remember here
>e88c	03					.byte CodeLen	;patch wh_CodeLength
>e891	38					.byte $38
>e892	73 65 64			Name0:	.text "sed"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=59413					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e895	83					.byte (("sed"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=11					LinkDisplacement = Nt0-WordListLink
>e896	10					.byte WordFlags	;wh_Flags
>e897	03					.byte 3	;wh_CodeLength
>e898	0b					  .byte LinkDisplacement	; offset to previous nt
=$e899					XtPtr1 ::= *
=59413					WordListLink ::= Nt0 ; remember the nt of this word for later
.e899	20 cf e9	jsr $e9cf		jsr asm_0
=3					CodeLen	.var *-XtPtr1
=$e89c					Here1 = *	; remember here
>e897	03					.byte CodeLen	;patch wh_CodeLength
>e89c	f8					.byte $f8
>e89d	73 65 69			Name0:	.text "sei"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=59424					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e8a0	23					.byte (("sei"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=11					LinkDisplacement = Nt0-WordListLink
>e8a1	10					.byte WordFlags	;wh_Flags
>e8a2	03					.byte 3	;wh_CodeLength
>e8a3	0b					  .byte LinkDisplacement	; offset to previous nt
=$e8a4					XtPtr1 ::= *
=59424					WordListLink ::= Nt0 ; remember the nt of this word for later
.e8a4	20 cf e9	jsr $e9cf		jsr asm_0
=3					CodeLen	.var *-XtPtr1
=$e8a7					Here1 = *	; remember here
>e8a2	03					.byte CodeLen	;patch wh_CodeLength
>e8a7	78					.byte $78
>e8a8	73 74 61			Name0:	.text "sta"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=59435					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e8ab	23					.byte (("sta"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=11					LinkDisplacement = Nt0-WordListLink
>e8ac	10					.byte WordFlags	;wh_Flags
>e8ad	03					.byte 3	;wh_CodeLength
>e8ae	0b					  .byte LinkDisplacement	; offset to previous nt
=$e8af					XtPtr1 ::= *
=59435					WordListLink ::= Nt0 ; remember the nt of this word for later
.e8af	20 c6 e9	jsr $e9c6		jsr asm_2
=3					CodeLen	.var *-XtPtr1
=$e8b2					Here1 = *	; remember here
>e8ad	03					.byte CodeLen	;patch wh_CodeLength
>e8b2	8d					.byte $8d
>e8b3	73 74 61 2e 78			Name0:	.text "sta.x"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=59448					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e8b8	05					.byte (("sta.x"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>e8b9	10					.byte WordFlags	;wh_Flags
>e8ba	03					.byte 3	;wh_CodeLength
>e8bb	0d					  .byte LinkDisplacement	; offset to previous nt
=$e8bc					XtPtr1 ::= *
=59448					WordListLink ::= Nt0 ; remember the nt of this word for later
.e8bc	20 c6 e9	jsr $e9c6		jsr asm_2
=3					CodeLen	.var *-XtPtr1
=$e8bf					Here1 = *	; remember here
>e8ba	03					.byte CodeLen	;patch wh_CodeLength
>e8bf	9d					.byte $9d
>e8c0	73 74 61 2e 79			Name0:	.text "sta.y"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=59461					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e8c5	25					.byte (("sta.y"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>e8c6	10					.byte WordFlags	;wh_Flags
>e8c7	03					.byte 3	;wh_CodeLength
>e8c8	0d					  .byte LinkDisplacement	; offset to previous nt
=$e8c9					XtPtr1 ::= *
=59461					WordListLink ::= Nt0 ; remember the nt of this word for later
.e8c9	20 c6 e9	jsr $e9c6		jsr asm_2
=3					CodeLen	.var *-XtPtr1
=$e8cc					Here1 = *	; remember here
>e8c7	03					.byte CodeLen	;patch wh_CodeLength
>e8cc	99					.byte $99
>e8cd	73 74 61 2e 7a			Name0:	.text "sta.z"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=59474					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e8d2	45					.byte (("sta.z"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>e8d3	10					.byte WordFlags	;wh_Flags
>e8d4	03					.byte 3	;wh_CodeLength
>e8d5	0d					  .byte LinkDisplacement	; offset to previous nt
=$e8d6					XtPtr1 ::= *
=59474					WordListLink ::= Nt0 ; remember the nt of this word for later
.e8d6	20 b4 e9	jsr $e9b4		jsr asm_1
=3					CodeLen	.var *-XtPtr1
=$e8d9					Here1 = *	; remember here
>e8d4	03					.byte CodeLen	;patch wh_CodeLength
>e8d9	85					.byte $85
>e8da	73 74 61 2e 7a 69 79		Name0:	.text "sta.ziy"	;  name of word as a string, ending at wh_NameLastChar
=7					NameLength = *-Name0
=59489					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e8e1	27					.byte (("sta.ziy"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=15					LinkDisplacement = Nt0-WordListLink
>e8e2	10					.byte WordFlags	;wh_Flags
>e8e3	03					.byte 3	;wh_CodeLength
>e8e4	0f					  .byte LinkDisplacement	; offset to previous nt
=$e8e5					XtPtr1 ::= *
=59489					WordListLink ::= Nt0 ; remember the nt of this word for later
.e8e5	20 b4 e9	jsr $e9b4		jsr asm_1
=3					CodeLen	.var *-XtPtr1
=$e8e8					Here1 = *	; remember here
>e8e3	03					.byte CodeLen	;patch wh_CodeLength
>e8e8	91					.byte $91
>e8e9	73 74 61 2e 7a 78		Name0:	.text "sta.zx"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=59503					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e8ef	06					.byte (("sta.zx"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=14					LinkDisplacement = Nt0-WordListLink
>e8f0	10					.byte WordFlags	;wh_Flags
>e8f1	03					.byte 3	;wh_CodeLength
>e8f2	0e					  .byte LinkDisplacement	; offset to previous nt
=$e8f3					XtPtr1 ::= *
=59503					WordListLink ::= Nt0 ; remember the nt of this word for later
.e8f3	20 b4 e9	jsr $e9b4		jsr asm_1
=3					CodeLen	.var *-XtPtr1
=$e8f6					Here1 = *	; remember here
>e8f1	03					.byte CodeLen	;patch wh_CodeLength
>e8f6	95					.byte $95
>e8f7	73 74 61 2e 7a 78 69		Name0:	.text "sta.zxi"	;  name of word as a string, ending at wh_NameLastChar
=7					NameLength = *-Name0
=59518					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e8fe	27					.byte (("sta.zxi"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=15					LinkDisplacement = Nt0-WordListLink
>e8ff	10					.byte WordFlags	;wh_Flags
>e900	03					.byte 3	;wh_CodeLength
>e901	0f					  .byte LinkDisplacement	; offset to previous nt
=$e902					XtPtr1 ::= *
=59518					WordListLink ::= Nt0 ; remember the nt of this word for later
.e902	20 b4 e9	jsr $e9b4		jsr asm_1
=3					CodeLen	.var *-XtPtr1
=$e905					Here1 = *	; remember here
>e900	03					.byte CodeLen	;patch wh_CodeLength
>e905	81					.byte $81
>e906	73 74 78			Name0:	.text "stx"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=59529					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e909	03					.byte (("stx"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=11					LinkDisplacement = Nt0-WordListLink
>e90a	10					.byte WordFlags	;wh_Flags
>e90b	03					.byte 3	;wh_CodeLength
>e90c	0b					  .byte LinkDisplacement	; offset to previous nt
=$e90d					XtPtr1 ::= *
=59529					WordListLink ::= Nt0 ; remember the nt of this word for later
.e90d	20 c6 e9	jsr $e9c6		jsr asm_2
=3					CodeLen	.var *-XtPtr1
=$e910					Here1 = *	; remember here
>e90b	03					.byte CodeLen	;patch wh_CodeLength
>e910	8e					.byte $8e
>e911	73 74 78 2e 7a			Name0:	.text "stx.z"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=59542					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e916	45					.byte (("stx.z"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>e917	10					.byte WordFlags	;wh_Flags
>e918	03					.byte 3	;wh_CodeLength
>e919	0d					  .byte LinkDisplacement	; offset to previous nt
=$e91a					XtPtr1 ::= *
=59542					WordListLink ::= Nt0 ; remember the nt of this word for later
.e91a	20 b4 e9	jsr $e9b4		jsr asm_1
=3					CodeLen	.var *-XtPtr1
=$e91d					Here1 = *	; remember here
>e918	03					.byte CodeLen	;patch wh_CodeLength
>e91d	86					.byte $86
>e91e	73 74 78 2e 7a 79		Name0:	.text "stx.zy"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=59556					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e924	26					.byte (("stx.zy"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=14					LinkDisplacement = Nt0-WordListLink
>e925	10					.byte WordFlags	;wh_Flags
>e926	03					.byte 3	;wh_CodeLength
>e927	0e					  .byte LinkDisplacement	; offset to previous nt
=$e928					XtPtr1 ::= *
=59556					WordListLink ::= Nt0 ; remember the nt of this word for later
.e928	20 b4 e9	jsr $e9b4		jsr asm_1
=3					CodeLen	.var *-XtPtr1
=$e92b					Here1 = *	; remember here
>e926	03					.byte CodeLen	;patch wh_CodeLength
>e92b	96					.byte $96
>e92c	73 74 79			Name0:	.text "sty"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=59567					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e92f	23					.byte (("sty"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=11					LinkDisplacement = Nt0-WordListLink
>e930	10					.byte WordFlags	;wh_Flags
>e931	03					.byte 3	;wh_CodeLength
>e932	0b					  .byte LinkDisplacement	; offset to previous nt
=$e933					XtPtr1 ::= *
=59567					WordListLink ::= Nt0 ; remember the nt of this word for later
.e933	20 c6 e9	jsr $e9c6		jsr asm_2
=3					CodeLen	.var *-XtPtr1
=$e936					Here1 = *	; remember here
>e931	03					.byte CodeLen	;patch wh_CodeLength
>e936	8c					.byte $8c
>e937	73 74 79 2e 7a			Name0:	.text "sty.z"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=59580					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e93c	45					.byte (("sty.z"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>e93d	10					.byte WordFlags	;wh_Flags
>e93e	03					.byte 3	;wh_CodeLength
>e93f	0d					  .byte LinkDisplacement	; offset to previous nt
=$e940					XtPtr1 ::= *
=59580					WordListLink ::= Nt0 ; remember the nt of this word for later
.e940	20 b4 e9	jsr $e9b4		jsr asm_1
=3					CodeLen	.var *-XtPtr1
=$e943					Here1 = *	; remember here
>e93e	03					.byte CodeLen	;patch wh_CodeLength
>e943	84					.byte $84
>e944	73 74 79 2e 7a 78		Name0:	.text "sty.zx"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=59594					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e94a	06					.byte (("sty.zx"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=14					LinkDisplacement = Nt0-WordListLink
>e94b	10					.byte WordFlags	;wh_Flags
>e94c	03					.byte 3	;wh_CodeLength
>e94d	0e					  .byte LinkDisplacement	; offset to previous nt
=$e94e					XtPtr1 ::= *
=59594					WordListLink ::= Nt0 ; remember the nt of this word for later
.e94e	20 b4 e9	jsr $e9b4		jsr asm_1
=3					CodeLen	.var *-XtPtr1
=$e951					Here1 = *	; remember here
>e94c	03					.byte CodeLen	;patch wh_CodeLength
>e951	94					.byte $94
>e952	74 61 78			Name0:	.text "tax"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=59605					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e955	03					.byte (("tax"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=11					LinkDisplacement = Nt0-WordListLink
>e956	10					.byte WordFlags	;wh_Flags
>e957	03					.byte 3	;wh_CodeLength
>e958	0b					  .byte LinkDisplacement	; offset to previous nt
=$e959					XtPtr1 ::= *
=59605					WordListLink ::= Nt0 ; remember the nt of this word for later
.e959	20 cf e9	jsr $e9cf		jsr asm_0
=3					CodeLen	.var *-XtPtr1
=$e95c					Here1 = *	; remember here
>e957	03					.byte CodeLen	;patch wh_CodeLength
>e95c	aa					.byte $aa
>e95d	74 61 79			Name0:	.text "tay"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=59616					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e960	23					.byte (("tay"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=11					LinkDisplacement = Nt0-WordListLink
>e961	10					.byte WordFlags	;wh_Flags
>e962	03					.byte 3	;wh_CodeLength
>e963	0b					  .byte LinkDisplacement	; offset to previous nt
=$e964					XtPtr1 ::= *
=59616					WordListLink ::= Nt0 ; remember the nt of this word for later
.e964	20 cf e9	jsr $e9cf		jsr asm_0
=3					CodeLen	.var *-XtPtr1
=$e967					Here1 = *	; remember here
>e962	03					.byte CodeLen	;patch wh_CodeLength
>e967	a8					.byte $a8
>e968	74 73 78			Name0:	.text "tsx"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=59627					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e96b	03					.byte (("tsx"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=11					LinkDisplacement = Nt0-WordListLink
>e96c	10					.byte WordFlags	;wh_Flags
>e96d	03					.byte 3	;wh_CodeLength
>e96e	0b					  .byte LinkDisplacement	; offset to previous nt
=$e96f					XtPtr1 ::= *
=59627					WordListLink ::= Nt0 ; remember the nt of this word for later
.e96f	20 cf e9	jsr $e9cf		jsr asm_0
=3					CodeLen	.var *-XtPtr1
=$e972					Here1 = *	; remember here
>e96d	03					.byte CodeLen	;patch wh_CodeLength
>e972	ba					.byte $BA
>e973	74 78 61			Name0:	.text "txa"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=59638					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e976	23					.byte (("txa"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=11					LinkDisplacement = Nt0-WordListLink
>e977	10					.byte WordFlags	;wh_Flags
>e978	03					.byte 3	;wh_CodeLength
>e979	0b					  .byte LinkDisplacement	; offset to previous nt
=$e97a					XtPtr1 ::= *
=59638					WordListLink ::= Nt0 ; remember the nt of this word for later
.e97a	20 cf e9	jsr $e9cf		jsr asm_0
=3					CodeLen	.var *-XtPtr1
=$e97d					Here1 = *	; remember here
>e978	03					.byte CodeLen	;patch wh_CodeLength
>e97d	8a					.byte $8a
>e97e	74 78 73			Name0:	.text "txs"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=59649					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e981	63					.byte (("txs"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=11					LinkDisplacement = Nt0-WordListLink
>e982	10					.byte WordFlags	;wh_Flags
>e983	03					.byte 3	;wh_CodeLength
>e984	0b					  .byte LinkDisplacement	; offset to previous nt
=$e985					XtPtr1 ::= *
=59649					WordListLink ::= Nt0 ; remember the nt of this word for later
.e985	20 cf e9	jsr $e9cf		jsr asm_0
=3					CodeLen	.var *-XtPtr1
=$e988					Here1 = *	; remember here
>e983	03					.byte CodeLen	;patch wh_CodeLength
>e988	9a					.byte $9a
>e989	74 79 61			Name0:	.text "tya"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=59660					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e98c	23					.byte (("tya"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=11					LinkDisplacement = Nt0-WordListLink
>e98d	10					.byte WordFlags	;wh_Flags
>e98e	03					.byte 3	;wh_CodeLength
>e98f	0b					  .byte LinkDisplacement	; offset to previous nt
=$e990					XtPtr1 ::= *
=59660					WordListLink ::= Nt0 ; remember the nt of this word for later
.e990	20 cf e9	jsr $e9cf		jsr asm_0
=3					CodeLen	.var *-XtPtr1
=$e993					Here1 = *	; remember here
>e98e	03					.byte CodeLen	;patch wh_CodeLength
>e993	98					.byte $98
=59660					asm_table = WordListLink ; head of instruction word list for disassembler
.e994					asm_r:
.e994	68		pla			pla		; pop RTS addr
.e995	a8		tay			tay
.e996	68		pla			pla
.e997	20 d2 e9	jsr $e9d2		jsr asm_op	; compile opcode
.e99a	b5 27		lda $27,x		lda DStack+1,x	; check range
.e99c	f0 09		beq $e9a7		beq _plus
.e99e	c9 ff		cmp #$ff		cmp #$ff
.e9a0	f0 0b		beq $e9ad		beq _minus
.e9a2	a9 f5		lda #$f5	_err:	lda #$100+err_OutOfRange
.e9a4	4c dc c5	jmp $c5dc		jmp ThrowA
.e9a7	b5 26		lda $26,x	_plus:	lda DStack+0,x
.e9a9	30 f7		bmi $e9a2		bmi _err
.e9ab	10 04		bpl $e9b1		bpl _store
.e9ad	b5 26		lda $26,x	_minus:	lda DStack+0,x
.e9af	10 f1		bpl $e9a2		bpl _err
.e9b1	4c dc de	jmp $dedc	_store:	jmp C_Comma
.e9b4					asm_1:
.e9b4	68		pla			pla		; pop RTS addr
.e9b5	a8		tay			tay
.e9b6	68		pla			pla
.e9b7	20 d2 e9	jsr $e9d2		jsr asm_op	; compile opcode
.e9ba	b5 27		lda $27,x		lda DStack+1,x	; compile operand
.e9bc	d0 03		bne $e9c1		bne _err
.e9be	4c dc de	jmp $dedc	_store:	jmp C_Comma
.e9c1	a9 f5		lda #$f5	_err:	lda #$100+err_OutOfRange
.e9c3	4c dc c5	jmp $c5dc		jmp ThrowA
.e9c6					asm_2:
.e9c6	68		pla			pla		; pop RTS addr
.e9c7	a8		tay			tay
.e9c8	68		pla			pla
.e9c9	20 d2 e9	jsr $e9d2		jsr asm_op	; compile opcode
.e9cc	4c f3 de	jmp $def3		jmp Comma	; compile operand
.e9cf					asm_0:
.e9cf	68		pla			pla		; pop RTS addr
.e9d0	a8		tay			tay
.e9d1	68		pla			pla
.e9d2	84 14		sty $14		asm_op:	sty tmp1+0	; save RTS addr
.e9d4	85 15		sta $15			sta tmp1+1
.e9d6	a0 01		ldy #$01		ldy #1		; get opcode byte
.e9d8	b1 14		lda ($14),y		lda (tmp1),y
.e9da	4c df de	jmp $dedf		jmp C_Comma_A	; compile opcode
>e9dd	70 75 73 68 2d 61		Name0:	.text "push-a"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=59747					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e9e3	26					.byte (("push-a"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=24					WordFlags ::= IM+NN	; modifiable copy, remember for later
=87					LinkDisplacement = Nt0-WordListLink
>e9e4	18					.byte WordFlags	;wh_Flags
>e9e5	03					.byte 3	;wh_CodeLength
>e9e6	57					  .byte LinkDisplacement	; offset to previous nt
=$e9e7					XtPtr1 ::= *
=59747					WordListLink ::= Nt0 ; remember the nt of this word for later
.e9e7	a9 5d		lda #$5d			lda #<PushZA
.e9e9	a0 c9		ldy #$c9			ldy #>PushZA
.e9eb	4c 25 df	jmp $df25			jmp Jsr_Comma_YA
=7					CodeLen	.var *-XtPtr1
=$e9ee					Here1 = *	; remember here
>e9e5	07					.byte CodeLen	;patch wh_CodeLength
>e9ee	2d 2d 3e			Name0:	.text "-->"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=59761					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e9f1	c3					.byte (("-->"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=24					WordFlags ::= IM+NN	; modifiable copy, remember for later
=14					LinkDisplacement = Nt0-WordListLink
=26						  WordFlags ::= WordFlags | DB
>e9f2	1a					.byte WordFlags	;wh_Flags
>e9f3	08					.byte 8	;wh_CodeLength
>e9f4	0e					  .byte LinkDisplacement	; offset to previous nt
>e9f5	04 dc					  .word Here		; pointer to xt
=0					XtPtr1 ::= 0
=59761					WordListLink ::= Nt0 ; remember the nt of this word for later
>e9f7	3c 6a				Name0:	.text "<j"	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=59769					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e9f9	42					.byte (("<j"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$08					WordFlags ::= IM	; modifiable copy, remember for later
=8					LinkDisplacement = Nt0-WordListLink
>e9fa	08					.byte WordFlags	;wh_Flags
>e9fb	03					.byte 3	;wh_CodeLength
>e9fc	08					  .byte LinkDisplacement	; offset to previous nt
=$e9fd					XtPtr1 ::= *
=59769					WordListLink ::= Nt0 ; remember the nt of this word for later
=0					CodeLen	.var *-XtPtr1
=$e9fd					Here1 = *	; remember here
>e9fb	00					.byte CodeLen	;patch wh_CodeLength
.e9fd	60		rts				rts
>e9fe	3c 62				Name0:	.text "<b"	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=59776					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>ea00	42					.byte (("<b"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=24					WordFlags ::= IM+NN	; modifiable copy, remember for later
=7					LinkDisplacement = Nt0-WordListLink
>ea01	18					.byte WordFlags	;wh_Flags
>ea02	03					.byte 3	;wh_CodeLength
>ea03	07					  .byte LinkDisplacement	; offset to previous nt
=$ea04					XtPtr1 ::= *
=59776					WordListLink ::= Nt0 ; remember the nt of this word for later
.ea04					asm_back_branch:
.ea04	20 04 dc	jsr $dc04			jsr Here		; ( addr-l addr-h )
.ea07	20 a9 dd	jsr $dda9			jsr Minus		; ( offset )
.ea0a	a9 fe		lda #$fe			lda #$fe
.ea0c	4c 27 dc	jmp $dc27			jmp Minus_A
=11					CodeLen	.var *-XtPtr1
=$ea0f					Here1 = *	; remember here
>ea02	0b					.byte CodeLen	;patch wh_CodeLength
>ea0f	44 69 73 41 73 6d		Name0:	.text "DisAsm"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=59797					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>ea15	a6					.byte (("DisAsm"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=21					LinkDisplacement = Nt0-WordListLink
>ea16	10					.byte WordFlags	;wh_Flags
>ea17	03					.byte 3	;wh_CodeLength
>ea18	15					  .byte LinkDisplacement	; offset to previous nt
=$ea19					XtPtr1 ::= *
=59797					WordListLink ::= Nt0 ; remember the nt of this word for later
.ea19	20 39 d6	jsr $d639	DisAsm:		jsr Bounds		; ( addr_end addr )
.ea1c					_instr:
.ea1c	b5 26		lda $26,x			lda DStack+0,x		; addr >= addr_end?
.ea1e	d5 28		cmp $28,x			cmp DStack+2,x
.ea20	b5 27		lda $27,x			lda DStack+1,x
.ea22	f5 29		sbc $29,x			sbc DStack+3,x
.ea24	90 03		bcc $ea29			bcc +
.ea26	4c 04 d7	jmp $d704			jmp Two_drop		; discard parms & return
.ea29					+
.ea29	20 b7 bc	jsr $bcb7			jsr CR			; new line
.ea2c	20 8a e1	jsr $e18a			jsr Dup			; print address
.ea2f	20 57 ba	jsr $ba57			jsr Dot_Hex
.ea32	20 e5 df	jsr $dfe5			jsr Space
.ea35	a1 26		lda ($26,x)			lda (DStack+0,x)	; print opcode byte
.ea37	20 97 eb	jsr $eb97			jsr _print_a
.ea3a	a1 26		lda ($26,x)			lda (DStack+0,x)	; save opcode
.ea3c	85 18		sta $18				sta tmp3
.ea3e	20 37 dc	jsr $dc37			jsr One_plus
.ea41	a9 0c		lda #$0c			lda #<asm_table		; for each asm opcode word
.ea43	a0 e9		ldy #$e9			ldy #>asm_table
.ea45	85 14		sta $14				sta tmp1+0
.ea47	84 15		sty $15				sty tmp1+1
.ea49	d0 05		bne $ea50			bne _WTest
.ea4b	20 95 82	jsr $8295	_WNext:		jsr LinkNext		;   next entry
.ea4e	f0 2b		beq $ea7b			beq _unknown2
.ea50	20 49 cf	jsr $cf49	_WTest:		jsr NameToIntTmp	; tmp2= xt
.ea53	a0 03		ldy #$03			ldy #3			;   opcode match?
.ea55	b1 16		lda ($16),y			lda (tmp2),y
.ea57	c5 18		cmp $18				cmp tmp3
.ea59	d0 f0		bne $ea4b			bne _WNext
.ea5b	a5 18		lda $18				lda tmp3		; save opcode
.ea5d	48		pha				pha
.ea5e	a5 15		lda $15				lda tmp1+1		; save its nt
.ea60	48		pha				pha
.ea61	a5 14		lda $14				lda tmp1+0
.ea63	48		pha				pha
.ea64	a0 01		ldy #$01			ldy #1			; get processor routine addr lo byte from JSR
.ea66	b1 16		lda ($16),y			lda (tmp2),y
.ea68	c9 cf		cmp #$cf			cmp #<asm_0		; goto disasm processor
.ea6a	f0 1a		beq $ea86			beq _c0
.ea6c	c9 b4		cmp #$b4			cmp #<asm_1
.ea6e	f0 4c		beq $eabc			beq _c1
.ea70	c9 c6		cmp #$c6			cmp #<asm_2
.ea72	f0 64		beq $ead8			beq _c2
.ea74	c9 94		cmp #$94			cmp #<asm_r
.ea76	f0 1b		beq $ea93			beq _cr
.ea78					_unknown:
.ea78	68		pla				pla			; RDrop nt
.ea79	68		pla				pla
.ea7a	68		pla				pla			; RDrop opcode
.ea7b	20 78 eb	jsr $eb78	_unknown2:	jsr _tab		; to source area
.ea7e	a9 3f		lda #$3f			lda #'?'
.ea80	20 cd df	jsr $dfcd			jsr Emit_A
.ea83	4c 1c ea	jmp $ea1c			jmp _instr
.ea86					_c0:
.ea86	20 78 eb	jsr $eb78			jsr _tab		; to source area
.ea89	68		pla				pla			; get opcode word nt
.ea8a	a8		tay				tay
.ea8b	68		pla				pla
.ea8c	20 7d eb	jsr $eb7d			jsr _print_opcode
.ea8f	68		pla				pla			; discard opcode
.ea90	4c 1c ea	jmp $ea1c			jmp _instr
.ea93					_cr:
.ea93	20 8e eb	jsr $eb8e			jsr _get_byte		; get displacement byte
.ea96	a0 00		ldy #$00			ldy #0			; sign extend displacement
.ea98	09 00		ora #$00			ora #0
.ea9a	10 01		bpl $ea9d			bpl +
.ea9c	88		dey				dey
.ea9d	20 2e c9	jsr $c92e	+		jsr PushYA
.eaa0	20 8a e1	jsr $e18a			jsr Dup			; save for TypeSymbol
.eaa3	20 78 eb	jsr $eb78			jsr _tab		; to source area
.eaa6	20 c2 dd	jsr $ddc2			jsr Dot			; print dest address
.eaa9	68		pla				pla			; get opcode word nt
.eaaa	a8		tay				tay
.eaab	68		pla				pla
.eaac	20 7d eb	jsr $eb7d			jsr _print_opcode
.eaaf	68		pla				pla			; discard opcode
.eab0	20 61 e1	jsr $e161			jsr Over		; calc dest addr
.eab3	20 90 dd	jsr $dd90			jsr Plus
.eab6	20 98 81	jsr $8198			jsr TypeSymbol		; print dest addr symbolic
.eab9	4c 1c ea	jmp $ea1c			jmp _instr
.eabc					_c1:
.eabc	20 8e eb	jsr $eb8e			jsr _get_byte		; get operand
.eabf	20 5d c9	jsr $c95d			jsr PushZA
.eac2	20 78 eb	jsr $eb78			jsr _tab		; to source area
.eac5	20 8a e1	jsr $e18a			jsr Dup
.eac8	20 f3 dd	jsr $ddf3			jsr U_Dot		; print operand
.eacb	68		pla				pla			; get opcode word nt
.eacc	a8		tay				tay
.eacd	68		pla				pla
.eace	20 7d eb	jsr $eb7d			jsr _print_opcode
.ead1	68		pla				pla			; discard opcode
.ead2	20 98 81	jsr $8198			jsr TypeSymbol
.ead5	4c 1c ea	jmp $ea1c			jmp _instr
.ead8					_c2:
.ead8	20 8e eb	jsr $eb8e			jsr _get_byte		; get operand lo byte
.eadb	48		pha				pha
.eadc	20 8e eb	jsr $eb8e			jsr _get_byte		; get operand hi byte
.eadf	ca		dex				dex			; push operand bytes
.eae0	ca		dex				dex
.eae1	95 27		sta $27,x			sta DStack+1,x
.eae3	68		pla				pla
.eae4	95 26		sta $26,x			sta DStack+0,x
.eae6	20 78 eb	jsr $eb78			jsr _tab		; to source area
.eae9	20 8a e1	jsr $e18a			jsr Dup
.eaec	20 f3 dd	jsr $ddf3			jsr U_Dot		; print operand
.eaef	68		pla				pla			; AY= opcode word nt
.eaf0	a8		tay				tay
.eaf1	68		pla				pla
.eaf2	20 7d eb	jsr $eb7d			jsr _print_opcode
.eaf5	20 8a e1	jsr $e18a			jsr Dup
.eaf8	20 98 81	jsr $8198			jsr TypeSymbol		; print operand as symbol
.eafb	68		pla				pla			; get opcode
.eafc	c9 20		cmp #$20			cmp #$20		;  JSR
.eafe	f0 09		beq $eb09			beq _jsr
.eb00	e8		inx		_jdrop:		inx			; Drop operand
.eb01	e8		inx				inx
.eb02	4c 1c ea	jmp $ea1c			jmp _instr		; ( addr_end addr )
.eb05	e8		inx		_2drop:		inx			; Drop jsr_nt
.eb06	e8		inx				inx
.eb07	d0 f7		bne $eb00			bne _jdrop
.eb09					_jsr:
.eb09	20 62 c5	jsr $c562			jsr PopYA		; pop JSR operand
.eb0c	c9 4b		cmp #$4b			cmp #<sliteral_runtime	; string literal?
.eb0e	d0 42		bne $eb52			bne _not_sliteral
.eb10	c0 ca		cpy #$ca			cpy #>sliteral_runtime
.eb12	d0 3e		bne $eb52			bne _not_sliteral
.eb14	20 b7 bc	jsr $bcb7			jsr CR
.eb17	20 8a e1	jsr $e18a			jsr Dup			; ( addr_end addr addr )
.eb1a	20 57 ba	jsr $ba57			jsr Dot_Hex
.eb1d	20 e5 df	jsr $dfe5			jsr Space
.eb20	20 8a e1	jsr $e18a			jsr Dup			; ( addr_end ? addr )
.eb23	20 8e eb	jsr $eb8e			jsr _get_byte		; get JMP opcode
.eb26	20 8e eb	jsr $eb8e			jsr _get_byte		; get JMP addr lo byte
.eb29	95 28		sta $28,x			sta DStack+2,x
.eb2b	20 8e eb	jsr $eb8e			jsr _get_byte		; get JMP addr hi byte
.eb2e	95 29		sta $29,x			sta DStack+3,x		; ( addr_end string_end addr )
.eb30	20 b7 bc	jsr $bcb7			jsr CR
.eb33	20 8a e1	jsr $e18a			jsr Dup
.eb36	20 57 ba	jsr $ba57			jsr Dot_Hex
.eb39	20 e5 df	jsr $dfe5			jsr Space
.eb3c	b5 26		lda $26,x	_slit_11:	lda DStack+0,x		; done with string data?
.eb3e	d5 28		cmp $28,x			cmp DStack+2,x
.eb40	b5 27		lda $27,x			lda DStack+1,x
.eb42	f5 29		sbc $29,x			sbc DStack+3,x
.eb44	b0 06		bcs $eb4c			bcs _slit_19
.eb46	20 8e eb	jsr $eb8e			jsr _get_byte
.eb49	4c 3c eb	jmp $eb3c			jmp _slit_11
.eb4c					_slit_19:
.eb4c	20 5f db	jsr $db5f			jsr Nip			; ( addr_end addr )
.eb4f	4c 1c ea	jmp $ea1c			jmp _instr
.eb52					_not_sliteral:
.eb52	c9 e9		cmp #$e9			cmp #<FLiti		; float literal?
.eb54	d0 1f		bne $eb75			bne _not_FLiti
.eb56	c0 88		cpy #$88			cpy #>FLiti
.eb58	d0 1b		bne $eb75			bne _not_FLiti
.eb5a	20 b7 bc	jsr $bcb7			jsr CR
.eb5d	20 8a e1	jsr $e18a			jsr Dup			; ( addr_end addr addr )
.eb60	20 57 ba	jsr $ba57			jsr Dot_Hex
.eb63	20 e5 df	jsr $dfe5			jsr Space
.eb66	20 8e eb	jsr $eb8e			jsr _get_byte
.eb69	20 8e eb	jsr $eb8e			jsr _get_byte
.eb6c	20 8e eb	jsr $eb8e			jsr _get_byte
.eb6f	20 8e eb	jsr $eb8e			jsr _get_byte
.eb72	20 8e eb	jsr $eb8e			jsr _get_byte
.eb75					_not_FLiti:
.eb75	4c 1c ea	jmp $ea1c			jmp _instr
.eb78					_tab:
.eb78	a9 09		lda #$09			lda #9
.eb7a	4c cd df	jmp $dfcd			jmp Emit_A
.eb7d					_print_opcode:
.eb7d	20 99 e1	jsr $e199			jsr PushAY		; save opcode word nt
.eb80	20 e5 df	jsr $dfe5			jsr Space
.eb83	20 85 cf	jsr $cf85			jsr Name_To_String	; get name string
.eb86	4c f1 df	jmp $dff1			jmp Type		; type word name
.eb89					_get_byte_silent:
.eb89	a1 26		lda ($26,x)			lda (DStack+0,x)
.eb8b	4c 37 dc	jmp $dc37			jmp One_plus
.eb8e					_get_byte:
.eb8e	20 89 eb	jsr $eb89			jsr _get_byte_silent
.eb91	48		pha				pha
.eb92	20 97 eb	jsr $eb97			jsr _print_a
.eb95	68		pla				pla
.eb96	60		rts				rts
.eb97					_print_a:
.eb97	20 5d c9	jsr $c95d			jsr PushZA
.eb9a	20 36 ba	jsr $ba36			jsr C_Dot_Hex
.eb9d	4c e5 df	jmp $dfe5			jmp Space
=59797					assembler_dictionary_start = WordListLink ; END of ASSEMBLER-WORDLIST
=0					WordListLink .var 0	; start wordlist
>eba0	6c				Name0:	.text "l"	;  name of word as a string, ending at wh_NameLastChar
=1					NameLength = *-Name0
=60193					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>eba1	81					.byte (("l"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=60193					LinkDisplacement = Nt0-WordListLink
=$11						  WordFlags ::= WordFlags | FP
>eba2	11					.byte WordFlags	;wh_Flags
>eba3	03					.byte 3	;wh_CodeLength
>eba4	00 00					  .word WordListLink
=$eba6					XtPtr1 ::= *
=60193					WordListLink ::= Nt0 ; remember the nt of this word for later
.eba6	4c 10 b6	jmp $b610	Editor_l:	jmp ListScr
=3					CodeLen	.var *-XtPtr1
=$eba9					Here1 = *	; remember here
>eba3	03					.byte CodeLen	;patch wh_CodeLength
.eba9					Editor_Screen_Helper:
.eba9	20 8a e1	jsr $e18a			jsr Dup
.ebac	20 22 b4	jsr $b422			jsr Scr
.ebaf	20 cb e0	jsr $e0cb			jsr Store
.ebb2	4c 2d b5	jmp $b52d			jmp Buffer
>ebb5	65 6e 74 65 72 2d 73 63		Name0:	.text "enter-screen"	;  name of word as a string, ending at wh_NameLastChar
>ebbd	72 65 65 6e
=12					NameLength = *-Name0
=60225					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>ebc1	cc					.byte (("enter-screen"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=32					LinkDisplacement = Nt0-WordListLink
>ebc2	10					.byte WordFlags	;wh_Flags
>ebc3	03					.byte 3	;wh_CodeLength
>ebc4	20					  .byte LinkDisplacement	; offset to previous nt
=$ebc5					XtPtr1 ::= *
=60225					WordListLink ::= Nt0 ; remember the nt of this word for later
.ebc5					Editor_Enter_Screen:
.ebc5	20 a9 eb	jsr $eba9			jsr Editor_Screen_Helper
.ebc8	a9 00		lda #$00			lda #0			; Overwrite the lines one at a time.
.ebca	95 26		sta $26,x	_loop:		sta DStack+0,x
.ebcc	20 5d c9	jsr $c95d			jsr PushZA		; Put the current line number on the stack.
.ebcf	20 2f ec	jsr $ec2f			jsr Editor_o		; prompt for overwrite.
.ebd2	f6 26		inc $26,x			inc DStack+0,x		; Move on to the next line.
.ebd4	b5 26		lda $26,x			lda DStack+0,x
.ebd6	c9 10		cmp #$10			cmp #16
.ebd8	90 f0		bcc $ebca			bcc _loop
.ebda	e8		inx				inx			; Drop work area
.ebdb	e8		inx				inx
=23					CodeLen	.var *-XtPtr1
=$ebdc					Here1 = *	; remember here
>ebc3	17					.byte CodeLen	;patch wh_CodeLength
.ebdc	60		rts				rts
>ebdd	6c 69 6e 65			Name0:	.text "line"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=60257					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>ebe1	a4					.byte (("line"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=32					LinkDisplacement = Nt0-WordListLink
>ebe2	10					.byte WordFlags	;wh_Flags
>ebe3	03					.byte 3	;wh_CodeLength
>ebe4	20					  .byte LinkDisplacement	; offset to previous nt
=$ebe5					XtPtr1 ::= *
=60257					WordListLink ::= Nt0 ; remember the nt of this word for later
.ebe5					Editor_line:
.ebe5	a9 06		lda #$06			lda #6		; Multiply the TOS by 64 (chars/line) to compute offset.
.ebe7	20 2d dd	jsr $dd2d			jsr LShift_A	; *64 is same as left shift 6 times.
.ebea	20 22 b4	jsr $b422			jsr Scr
.ebed	20 b2 e0	jsr $e0b2			jsr Fetch
.ebf0	20 c5 b4	jsr $b4c5			jsr Block
.ebf3	4c 90 dd	jmp $dd90			jmp Plus
=17					CodeLen	.var *-XtPtr1
=$ebf6					Here1 = *	; remember here
>ebe3	11					.byte CodeLen	;patch wh_CodeLength
>ebf6	65 72 61 73 65 2d 73 63		Name0:	.text "erase-screen"	;  name of word as a string, ending at wh_NameLastChar
>ebfe	72 65 65 6e
=12					NameLength = *-Name0
=60290					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>ec02	cc					.byte (("erase-screen"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=33					LinkDisplacement = Nt0-WordListLink
>ec03	10					.byte WordFlags	;wh_Flags
>ec04	03					.byte 3	;wh_CodeLength
>ec05	21					  .byte LinkDisplacement	; offset to previous nt
=$ec06					XtPtr1 ::= *
=60290					WordListLink ::= Nt0 ; remember the nt of this word for later
.ec06					Editor_Erase_Screen:
.ec06	20 a9 eb	jsr $eba9			jsr Editor_Screen_Helper
.ec09	a9 00		lda #$00			lda #<1024
.ec0b	a0 04		ldy #$04			ldy #>1024
.ec0d	20 2e c9	jsr $c92e			jsr PushYA
.ec10	20 cb cf	jsr $cfcb			jsr Blank		; Erase the entire block (fill with spaces).
.ec13	4c 1a b5	jmp $b51a			jmp Update		; Mark buffer as updated.
=16					CodeLen	.var *-XtPtr1
=$ec16					Here1 = *	; remember here
>ec04	10					.byte CodeLen	;patch wh_CodeLength
>ec16	65 6c				Name0:	.text "el"	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=60312					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>ec18	82					.byte (("el"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=22					LinkDisplacement = Nt0-WordListLink
>ec19	10					.byte WordFlags	;wh_Flags
>ec1a	03					.byte 3	;wh_CodeLength
>ec1b	16					  .byte LinkDisplacement	; offset to previous nt
=$ec1c					XtPtr1 ::= *
=60312					WordListLink ::= Nt0 ; remember the nt of this word for later
.ec1c					Editor_el:
.ec1c	20 e5 eb	jsr $ebe5			jsr Editor_line
.ec1f	a9 40		lda #$40			lda #64			;(# of chars/line)
.ec21	20 5d c9	jsr $c95d			jsr PushZA
.ec24	20 cb cf	jsr $cfcb			jsr Blank		; Fill with spaces.
.ec27	4c 1a b5	jmp $b51a			jmp Update		; Mark buffer as updated.
=14					CodeLen	.var *-XtPtr1
=$ec2a					Here1 = *	; remember here
>ec1a	0e					.byte CodeLen	;patch wh_CodeLength
>ec2a	6f				Name0:	.text "o"	;  name of word as a string, ending at wh_NameLastChar
=1					NameLength = *-Name0
=60331					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>ec2b	e1					.byte (("o"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=19					LinkDisplacement = Nt0-WordListLink
>ec2c	10					.byte WordFlags	;wh_Flags
>ec2d	03					.byte 3	;wh_CodeLength
>ec2e	13					  .byte LinkDisplacement	; offset to previous nt
=$ec2f					XtPtr1 ::= *
=60331					WordListLink ::= Nt0 ; remember the nt of this word for later
.ec2f					Editor_o:
.ec2f	20 b7 bc	jsr $bcb7			jsr CR
.ec32	20 8a e1	jsr $e18a			jsr Dup
.ec35	a9 02		lda #$02			lda #2
.ec37	20 25 de	jsr $de25			jsr U_Dot_R_A
.ec3a	20 e5 df	jsr $dfe5			jsr Space
.ec3d	a9 2a		lda #$2a			lda #'*'
.ec3f	20 cd df	jsr $dfcd			jsr Emit_A
.ec42	20 e5 df	jsr $dfe5			jsr Space
.ec45	20 e5 eb	jsr $ebe5			jsr Editor_line
.ec48	20 8a e1	jsr $e18a			jsr Dup		; Save a copy of the line address for later.
.ec4b	a9 40		lda #$40			lda #64		; chars/line
.ec4d	20 5d c9	jsr $c95d			jsr PushZA
.ec50	20 70 d4	jsr $d470			jsr Accept
.ec53	20 8a e1	jsr $e18a			jsr Dup
.ec56	20 90 e0	jsr $e090			jsr Not_Rot
.ec59	20 90 dd	jsr $dd90			jsr Plus
.ec5c	a9 40		lda #$40			lda #64		; chars/line
.ec5e	20 5d c9	jsr $c95d			jsr PushZA
.ec61	20 6b e0	jsr $e06b			jsr Rot
.ec64	20 a9 dd	jsr $dda9			jsr Minus
.ec67	20 cb cf	jsr $cfcb			jsr Blank
.ec6a	4c 1a b5	jmp $b51a			jmp Update
=62					CodeLen	.var *-XtPtr1
=$ec6d					Here1 = *	; remember here
>ec2d	3e					.byte CodeLen	;patch wh_CodeLength
=60331					editor_dictionary_start = WordListLink ; END of EDITOR-WORDLIST

;******  Processing file: platform/../strings.asm

>ec6d	20 6f 6b 00			str_ok:         .text " ok", 0         ; note space at beginning
>ec71	20 63 6f 6d 70 69 6c 65		str_compiled:   .text " compiled", 0   ; note space at beginning
>ec79	64 00
>ec7b	72 65 64 65 66 69 6e 65		str_redefined:  .text "redefined ", 0  ; note space at end
>ec83	64 20 00
>ec86	66 6c 61 67 73 3a 00		str_see_flags:  .text "flags:", 0
>ec8d	6e 74 3a 20 24 00		str_see_nt:     .text "nt: $", 0
>ec93	78 74 3a 20 24 00		str_see_xt:     .text "xt: $", 0
>ec99	73 69 7a 65 3a 20 23 00		str_see_size:   .text "size: #", 0
.eca1					Exception_Text_List:
>eca1	ff 00					.text $100+err_Abort,0
>eca3	fe 00					.text $100+err_AbortQuote,0
>eca5	fd 53 74 61 63 6b 20 4f			.text $100+err_Stack_Overflow,"Stack Overflow",0
>ecad	76 65 72 66 6c 6f 77 00
>ecb5	fc 53 74 61 63 6b 20 55			.text $100+err_Stack_Underflow,"Stack Underflow",0
>ecbd	6e 64 65 72 66 6c 6f 77 00
>ecc6	f9 64 6f 2d 6c 6f 6f 70			.text $100+err_DoLoop_TooDeep,"do-loops nested too deeply during execution",0
>ecce	73 20 6e 65 73 74 65 64 20 74 6f 6f 20 64 65 65
>ecde	70 6c 79 20 64 75 72 69 6e 67 20 65 78 65 63 75
>ecee	74 69 6f 6e 00
>ecf3	f6 44 69 76 69 64 65 20			.text $100+err_DivideBy0,"Divide by 0",0
>ecfb	62 79 20 30 00
>ed00	f5 6f 75 74 20 6f 66 20			.text $100+err_OutOfRange,"out of range",0
>ed08	72 61 6e 67 65 00
>ed0e	f4 61 72 67 75 6d 65 6e			.text $100+err_ArgTypeMismatch,"argument type mismatch",0
>ed16	74 20 74 79 70 65 20 6d 69 73 6d 61 74 63 68 00
>ed26	f3 55 6e 64 65 66 69 6e			.text $100+err_UndefinedWord,"Undefined word",0
>ed2e	65 64 20 77 6f 72 64 00
>ed36	f2 49 6e 74 65 72 70 72			.text $100+err_CompileOnly,"Interpreting a Compile-only word",0
>ed3e	65 74 69 6e 67 20 61 20 43 6f 6d 70 69 6c 65 2d
>ed4e	6f 6e 6c 79 20 77 6f 72 64 00
>ed58	eb 75 6e 73 75 70 70 6f			.text $100+err_Unsupported,"unsupported operation",0 ;  (e.g., AT-XY on a too-dumb terminal)
>ed60	72 74 65 64 20 6f 70 65 72 61 74 69 6f 6e 00
>ed6f	ea 63 6f 6e 74 72 6f 6c			.text $100+err_ControlMismatch,"control structure mismatch",0
>ed77	20 73 74 72 75 63 74 75 72 65 20 6d 69 73 6d 61
>ed87	74 63 68 00
>ed8b	e0 69 6e 76 61 6c 69 64			.text $100+err_InvalidName,"invalid name",0 ; argument (e.g., TO name)
>ed93	20 6e 61 6d 65 00
>ed99	df 62 6c 6f 63 6b 20 72			.text $100+err_BlockRead,"block read",0
>eda1	65 61 64 00
>eda5	de 62 6c 6f 63 6b 20 77			.text $100+err_BlockWrite,"block write",0
>edad	72 69 74 65 00
>edb2	d6 46 50 20 64 69 76 69			.text $100+err_FPDivideBy0,"FP divide by zero",0
>edba	64 65 20 62 79 20 7a 65 72 6f 00
>edc5	d5 46 50 20 72 65 73 75			.text $100+err_FPOutOfRange,"FP result out of range",0
>edcd	6c 74 20 6f 75 74 20 6f 66 20 72 61 6e 67 65 00
>eddd	d4 46 50 20 73 74 61 63			.text $100+err_FPStackOverflow,"FP stack overflow",0
>ede5	6b 20 6f 76 65 72 66 6c 6f 77 00
>edf0	d3 46 50 20 73 74 61 63			.text $100+err_FPStackUnderflow,"FP stack underflow",0
>edf8	6b 20 75 6e 64 65 72 66 6c 6f 77 00
>ee04	d2 46 50 20 69 6e 76 61			.text $100+err_FPInvalidArg,"FP invalid argument",0
>ee0c	6c 69 64 20 61 72 67 75 6d 65 6e 74 00
>ee19	ca 46 50 20 75 6e 64 65			.text $100+err_FPUnderflow,"FP underflow",0
>ee21	72 66 6c 6f 77 00
>ee27	c5 41 4c 4c 4f 43 41 54			.text $100+err_Allocate,"ALLOCATE",0
>ee2f	45 00
>ee31	c4 46 52 45 45 00			.text $100+err_Free,"FREE",0
>ee37	6b 52 65 66 69 6c 6c 00			.text $100+err_Refill,"Refill",0
>ee3f	6a 44 65 66 65 72 20 6e			.text $100+err_Defer,"Defer not set",0
>ee47	6f 74 20 73 65 74 00
>ee4e	69 41 6c 72 65 61 64 79			.text $100+err_AlreadyInterpreting,"Already interpreting",0
>ee56	20 69 6e 74 65 72 70 72 65 74 69 6e 67 00
>ee64	68 41 6c 72 65 61 64 79			.text $100+err_AlreadyCompiling,"Already compiling",0
>ee6c	20 63 6f 6d 70 69 6c 69 6e 67 00
>ee77	66 4e 6f 20 77 6f 72 64			.text $100+err_TooManyWordlists,"No wordlists available",0
>ee7f	6c 69 73 74 73 20 61 76 61 69 6c 61 62 6c 65 00
>ee8f	00					.text 0 ; end of list

;******  Return to file: platform/../taliforth.asm


;******  Return to file: platform/platform-65816S.asm

>0766					hist_buff: .fill 8*128	; Input History for ACCEPT
.0b66					cp0:
>f100	db				v_nmi:	.byte $db ; stp
.f101	ea		nop			nop		; resync after illegal instruction
.f102	ea		nop			nop
.f103	e0 01		cpx #$01		cpx #1		; for easy code id
.f105	4c 10 f1	jmp $f110		jmp kernel_init
>f108	db				v_irq:	.byte $db ; stp
.f109	ea		nop			nop		; resync after illegal instruction
.f10a	ea		nop			nop
.f10b	c0 02		cpy #$02		cpy #2		; for easy code id
.f10d	4c 10 f1	jmp $f110		jmp kernel_init
.f110					v_reset:
.f110					kernel_init:
.f110	78		sei		                sei             ; Disable interrupts
.f111	a2 00		ldx #$00	                ldx #0
.f113	bd 45 f1	lda $f145,x	-               lda s_kernel_id,x
.f116	f0 06		beq $f11e	                beq _done
.f118	20 30 f1	jsr $f130	                jsr kernel_putc
.f11b	e8		inx		                inx
.f11c	d0 f5		bne $f113	                bne -
.f11e					_done:
.f11e	4c 4c 80	jmp $804c	                jmp Cold
.f121					kernel_getc:
.f121	ee 35 03	inc $0335	-		inc RndState+0	; randomize
>f124	22						.byte $22	; jsl GET_BYTE_FROM_PC
>f125	33 e0						.word $e033
>f127	00						.byte 0
.f128	b0 f7		bcs $f121			bcs -
.f12a	60		rts				rts
.f12b					kernel_havekey:
.f12b	a9 eb		lda #$eb			lda #$100+err_unsupported
.f12d	4c dc c5	jmp $c5dc			jmp ThrowA
.f130					kernel_putc:
>f130	22				-		.byte $22	; jsl SEND_BYTE_TO_PC
>f131	63 e0						.word $e063
>f133	00						.byte 0
.f134	b0 fa		bcs $f130			bcs -
.f136	60		rts				rts
.f137					platform_bye:
.f137	00		brk #		                brk
.f138					platform_CCAt:
.f138	ca		dex				dex
.f139	ca		dex				dex
.f13a	ca		dex				dex
.f13b	ca		dex				dex
>f13c	02 f4 26					.byte $02,$F4,DStack ; cop $f4	get 65816s simulator cycle count in DStack,x
.f13f	60		rts				rts
.f140					Platform_Block_Read:
.f140					Platform_Block_Write:
.f140	a9 eb		lda #$eb			lda #$100+err_Unsupported
.f142	20 dc c5	jsr $c5dc			jsr ThrowA
.f145					s_kernel_id:
>f145	54 61 6c 69 20 46 6f 72		        .text "Tali Forth 2 kernel for 65816s (31. May 2024)", AscCR,AscLF, 0
>f14d	74 68 20 32 20 6b 65 72 6e 65 6c 20 66 6f 72 20
>f15d	36 35 38 31 36 73 20 28 33 31 2e 20 4d 61 79 20
>f16d	32 30 32 34 29 0d 0a 00
>fffa	00 f1				.word v_nmi
>fffc	10 f1				.word v_reset
>fffe	08 f1				.word v_irq

;******  End of listing
