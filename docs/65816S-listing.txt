
; 64tass Turbo Assembler Macro V1.59.3120 listing file
; 64tass --nostart --list=docs/65816S-listing.txt --labels=docs/65816S-labelmap.txt --output TaliForth-65816S.bin platform/platform-65816S.asm
; Sat Jun 07 15:13:04 2025

;Offset	;Hex		;Monitor	;Source

;******  Processing input file: platform/platform-65816S.asm

=$0100					RStack = $0100	; begin of 6502 Return Stack
=$ff					rsp0      = $ff		; initial Return Stack Pointer (6502 stack)
=$8000					cp_end    = $8000	; Last RAM byte available for code
=84					PadOffset = 84	; offset from CP to PAD (holds number strings)
=79					MAX_LINE_LENGTH  = 79      ; output line size
=24					DDim = 24	; # of cells in data stack
=10					FDim = 10	; # of entries in floating-point stack
=8					DoStkDim = 8	; # of entries in Do stack
=					TALI_OPTIONAL_WORDS := ["fp","fpe","fpe2","fptrancendentals", "ed", "editor", "ramdrive", "block", "environment?", "assembler", "wordlist" ]
=["cr","lf"]				TALI_OPTION_CR_EOL := [ "cr", "lf" ]
=$ff					bsize     = $ff		; size of input/output buffers
>0200					buffer0: .fill bsize	; input buffer

;******  Processing file: platform/../taliforth.asm

=					TALI_OPTIONAL_WORDS := ["fp","fpe","fpe2", "fpieee","fptrancendentals", "fphyperbolic", "ed", "editor", "ramdrive", "block", "environment?", "assembler", "wordlist" ]
=-1					err_Abort		= -1
=-2					err_AbortQuote		= -2
=-3					err_Stack_Overflow	= -3
=-4					err_Stack_Underflow	= -4
=-5					err_Return_Stack_Overflow = -5
=-6					err_Return_Stack_Underflow = -6
=-7					err_DoLoop_TooDeep	= -7	; do-loops nested too deeply during execution
=-8					err_Dictionary_Overflow	= -8
=-9					err_InvalidMemoryAddr	= -9	; invalid memory address
=-10					err_DivideBy0		= -10	; division by zero
=-11					err_OutOfRange		= -11	; result out of range
=-12					err_ArgTypeMismatch	= -12	; argument type mismatch
=-13					err_UndefinedWord	= -13
=-14					err_CompileOnly		= -14	; interpreting a compile-only word
=-15					err_Forget		= -15	; invalid FORGET
=-16					err_EmptyName		= -16	; attempt to use zero-length string as a name
=-17					err_PicStringOverflow	= -17	; pictured numeric output string overflow
=-18					err_ParsedStringOverflow = -18	; parsed string overflow
=-19					err_NameTooLong		= -19	; definition name too long
=-20					err_WriteToRO		= -20	; write to a read-only location
=-21					err_Unsupported		= -21	; unsupported operation  (e.g., AT-XY on a too-dumb terminal)
=-22					err_ControlMismatch	= -22	; control structure mismatch
=-23					err_AddrAlignment	= -23	; address alignment exception
=-24					err_InvalidNumericArg	= -24	; invalid numeric argument
=-25					err_ReturnStackImbalance = -25	; return stack imbalance
=-26					err_LoopParmUnavailable = -26	; loop parameters unavailable
=-27					err_InvalidRecursion	= -27	; invalid recursion
=-28					err_UserInterrupt	= -28	; user interrupt
=-29					err_CompilerNesting	= -29	; compiler nesting
=-30					err_Obsolete		= -30	; obsolescent feature
=-31					err_NoBody		= -31	; >BODY used on non-CREATEd definition
=-32					err_InvalidName		= -32	; invalid name argument (e.g., TO name)
=-33					err_BlockRead		= -33	; block read exception
=-34					err_BlockWrite		= -34	; block write exception
=-35					err_InvalidBlock	= -35	; invalid block number
=-36					err_InvalidFilePosition = -36	; invalid file position
=-37					err_FileIO		= -37	; file I/O exception
=-38					err_FileMissing		= -38	; non-existent file
=-39					err_EndOfFile		= -39	; unexpected end of file
=-40					err_InvalidBase		= -40	; invalid BASE for floating point conversion
=-41					err_LossOfPrecision	= -41	; loss of precision
=-42					err_FPDivideBy0		= -42	; floating-point divide by zero
=-43					err_FPOutOfRange	= -43	; floating-point result out of range
=-44					err_FPStackOverflow	= -44	; floating-point stack overflow
=-45					err_FPStackUnderflow	= -45	; floating-point stack underflow
=-46					err_FPInvalidArg	= -46	; floating-point invalid argument
=-47					err_CompileWordsDeleted = -47	; compilation word list deleted
=-48					err_PostponeInvalid	= -48	; invalid POSTPONE
=-49					err_SearchOrderOverflow = -49	; search-order overflow
=-50					err_SearchOrderUnderflow = -50	; search-order underflow
=-51					err_CompileWordlistChanged = -51 ; compilation word list changed
=-52					err_ControlStackOverflow = -52	; control-flow stack overflow
=-53					err_ExceptionStackOverflow = -53 ; exception stack overflow
=-54					err_FPUnderflow		= -54	; floating-point underflow
=-55					err_FPFault		= -55	; floating-point unidentified fault
=-56					err_Quit		= -56	; QUIT
=-57					err_ConsoleIO		= -57	; exception in sending or receiving a character
=-58					err_BracketIf		= -58	; [IF], [ELSE], or [THEN] exception
=-59					err_Allocate		= -59	; ALLOCATE
=-60					err_Free		= -60	; FREE
=-61					err_Resize		= -61	; RESIZE
=-62					err_CloseFile		= -62	; CLOSE-FILE
=-63					err_CreateFile		= -63	; CREATE-FILE
=-64					err_DeleteFile		= -64	; DELETE-FILE
=-65					err_FilePosition	= -65	; FILE-POSITION
=-66					err_FileSize		= -66	; FILE-SIZE
=-67					err_FileStatus		= -67	; FILE-STATUS
=-68					err_FlushFile		= -68	; FLUSH-FILE
=-69					err_OpenFile		= -69	; OPEN-FILE
=-70					err_ReadFile		= -70	; READ-FILE
=-71					err_ReadLine		= -71	; READ-LINE
=-72					err_RenameFile		= -72	; RENAME-FILE
=-73					err_RepositionFile	= -73	; REPOSITION-FILE
=-74					err_ResizeFile		= -74	; RESIZE-FILE
=-75					err_WriteFile		= -75	; WRITE-FILE
=-76					err_WriteLine		= -76	; WRITE-LINE
=-77					err_MalformedXChar	= -77	; Malformed xchar
=-78					err_Substitute		= -78	; SUBSTITUTE
=-79					err_Replaces		= -79	; REPLACES
=-149					err_Refill		= -149	; Refill failed
=-150					err_Defer		= -150	; Defer not set
=-151					err_AlreadyInterpreting	= -151	; entering interpret when already interpreting
=-152					err_AlreadyCompiling	= -152	; entering compile when already compiling
=-154					err_TooManyWordlists   	= -154
.0000					zp0:
>0000					cp:	.word ?		; Compiler Pointer (see HERE)
>0002					InSrc:	.word ?		; input Source for SOURCE-ID
>0004					Cib:	.word ?		; address of current input buffer
>0006					CibLen:	.word ?		; length of current input buffer
>0008					ToIn:	.word ?		; pointer to CIB (>IN in Forth)
>000a					state:	.word ?		; STATE: -1 compile, 0 interpret
>000c					status: .word ?		; internal status flags
>000e					WorkWord: .word ?	; nt or xt of word being compiled (see status)
>0010					dp:	.word ?		; Dictionary Pointer temp
>0012					DoIndex: .word ?	; current Do index
>0014					tmp1:	.word ?		; temporary storage
>0016					tmp2:	.word ?		; temporary storage
>0018					tmp3:	.word ?		; temporary storage
>001a					tmp4:	.word ?		; temporary storage (tmpdsp)
>001c					tmp5:	.word ?		; temporary storage (tmptos)
>001e					editor1: .word ?	; temporary for editors
>0020					editor2: .word ?	; temporary for editors
>0022					editor3: .word ?	; temporary for editors
>0024					DStack:	.fill DDim*2	; data stack
.8000					Cold_zp_table:
>8000	66 0b					.word cp0		; cp
>8002	00 00					.word 0			; insrc (SOURCE-ID is 0 for keyboard)
>8004	00 02					.word buffer0		; cib
>8006	00 00					.word 0			; ciblen
>8008	00 00					.word 0			; toin
>800a	00 00					.word 0			; state (0 = interpret)
>800c	00 00					.word 0			; status
=14					Cold_zp_table_length = *-Cold_zp_table
.02ff					User0:
>02ff					PrecisionV: .byte ?	; # of decimal places for FP print
>0300					base:	.word ?		; number radix, default decimal
>0302					nc_limit: .word ?	; limit for Native Compile size
>0304					uf_strip: .word ?	; flag to strip underflow detection code
>0306					output:	.word ?		; vector for EMIT
>0308					input:	.word ?		; vector for KEY
>030a					HaveKey: .word ?	; vector for KEY?
>030c					BlkV:	.word ?		; BLK
>030e					ScrV:	.word ?		; SCR
>0310					CurrentV: .byte ?	; CURRENT (byte) (Compilation wordlist)
>0311					Num_WordlistsV: .byte ?	; #WORDLISTS (byte)
=12					max_wordlists = 12	; Maximum number of wordlists supported
>0312					WordlistsV: .fill 2*max_wordlists	; WORDLISTS (cells)
>032a					Num_OrderV: .byte ?	; #ORDER (byte)
>032b					Search_OrderV: .fill 9	; SEARCH-ORDER (bytes)
.0334					MarkEnd:
>0334					ToHold:	.byte ?		; pad buffer index for formatted output
>0335					RndState: .dword ?	; random # state
=0					wid_Forth = 0
=1					wid_Editor = 1
=2					wid_Assembler = 2
=3					wid_Root = 3
.800e					Cold_user_table:
>800e	08					.byte 8			; PrecisionV
>800f	0a 00					.word 10		; base
>8011	08 00					.word 8			; nc-limit
>8013	00 00					.word 0			; uf_strip (off by default)
>8015	20 f1					.word kernel_putc	; output
>8017	11 f1					.word kernel_getc	; input
>8019	1b f1					.word kernel_havekey	; havekey
>801b	00 00					.word 0				; BLK
>801d	00 00					.word 0				; SCR
>801f	00					.byte 0				; CURRENT = FORTH-WORDLIST
>8020	04					.byte 4				; #WORDLISTS (FORTH EDITOR ASSEMBLER ROOT)
>8021	8c df					.word forth_dictionary_start	; FORTH-WORDLIST
>8023	f1 e9					.word editor_dictionary_start	; EDITOR-WORDLIST
>8025	db e7					.word assembler_dictionary_start ; ASSEMBLER-WORDLIST
>8027	cb df					.word root_dictionary_start	; ROOT-WORDLIST
>8029	00 00 00 00 00 00 00 00			.word 0,0,0,0,0,0,0,0		; User wordlists
>8031	00 00 00 00 00 00 00 00
>8039	02					.byte 2				; #ORDER
>803a	00 02 00 00 00 00 00 00			.byte wid_Forth,wid_Assembler,0,0,0,0,0,0,0	; search-order
>8042	00
=53					Cold_user_table_length = *-Cold_user_table
=$03					AscCC   = $03	; break (CTRL-c)
=$07					AscBELL = $07	; bell sound
=$08					AscBS   = $08	; backspace
=$09					AscHT	= $09	; tab
=$0a					AscLF   = $0a	; line feed
=$0b					AScVT	= $0b	; vertical tab
=$0c					AscFF	= $0c	; form feed
=$0d					AscCR   = $0d	; carriage return
=$0e					AscCN   = $0e	; CTRL-n (used to recall next input history)
=$10					AscCP   = $10	; CTRL-p (used to recall previous input history)
=$1b					AscESC  = $1b	; escape
=$20					AscSP   = $20	; space
=$22					AscDQuote = $22	; double quote
=$5c					AscBackslash = $5c ; backslash
=$7f					AscDEL  = $7f	; delete (CTRL-h)
>0000							.fill $80	; |  unused space |   To align the last char of name.
=127					wh_NameLastChar	= *-1		; |		  |   Last char of name.
>0080					wh_HashNameLen:			    .byte ?	; |
=$e0					wh_HashMask		=	    %11100000	; |      lo 3 bits of last char of name
=$1f					wh_NameLengthMask	=	    %00011111	; |      length of name
>0081					wh_Flags:			    .byte ?	; |  flag bits
=$01					FP	=			    %00000001	; |	Far previous NT (two byte pointer rather than one byte offset)
=$02					DB	=			    %00000010	; |	Disjoint body (two byte pointer rather than adjoining body code)
=$04					CO	=			    %00000100	; |	Compile Only
=$08					IM	=			    %00001000	; |     Immediate Word
=$10					NN	=			    %00010000	; |	    | 1 | 0 |  NN : Word can only be called by JSR (never native)
=$20					AN	=			    %00100000  	; |	    | 0 | 1 |  AN : Word can only be inlined (always native)
=$30					ST	=			    %00110000	; |	    | 1 | 1 |  ST : Normal word with return stack juggling that
=3					wh_HeaderExtendMask =		     FP+DB	; |	of the header length directly by adding 4 to `flags & %00000011`.
=$40					UF	=			    %01000000   ; |     strippable underflow
>0082					wh_CodeLength:			   .byte ?	; |  Code length  |   Code length for native compile, max 255
.0083					wh_LinkNt:
=0					WordFlags .var 0 ; initialize for macro
=0					XtPtr1  .var 0  ; initialize for macro
=0					WordListLink .var 0	 ; start of FORTH wordlist
>8043	43 6f 6c 64			Name0:	.text "Cold"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=32711					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>8047	84					.byte (("Cold"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=32711					LinkDisplacement = Nt0-WordListLink
=$11						  WordFlags ::= WordFlags | FP
>8048	11					.byte WordFlags	;wh_Flags
>8049	03					.byte 3	;wh_CodeLength
>804a	00 00					  .word WordListLink
=$804c					XtPtr1 ::= *
=32711					WordListLink ::= Nt0 ; remember the nt of this word for later
.804c					Cold:
.804c	d8		cld				cld
.804d	a2 ff		ldx #$ff			ldx #rsp0		; Initialize 6502 stack (Return Stack)
.804f	9a		txs				txs
.8050	a2 0d		ldx #$0d			ldx #Cold_zp_table_length-1 ; Initialize important zero page variables from ROM
.8052	bd 00 80	lda $8000,x	-		lda Cold_zp_table,x	;   We can use X here
.8055	95 00		sta $00,x			sta zp0,x		;   because Tali hasn't set up the param stack yet.
.8057	ca		dex				dex
.8058	10 f8		bpl $8052			bpl -
.805a	a0 34		ldy #$34			ldy #Cold_user_table_length-1	; Initialize the user variables.
.805c	b9 0e 80	lda $800e,y	-		lda Cold_user_table,y
.805f	99 ff 02	sta $02ff,y			sta User0,y
.8062	88		dey				dey
.8063	10 f7		bpl $805c			bpl -
.8065	20 d6 c4	jsr $c4d6			jsr Empty_Stack		; Clear Data Stack. This is repeated in ABORT, but this way we
.8068	20 de b1	jsr $b1de			jsr BlockInit
.806b	20 4c bb	jsr $bb4c			jsr CR
.806e	a9 9c		lda #$9c			lda #<forth_words_start		; push start address
.8070	a0 80		ldy #$80			ldy #>forth_words_start
.8072	20 ba c7	jsr $c7ba			jsr PushYA
.8075	a9 d1		lda #$d1			lda #<forth_words_len		; push length
.8077	a0 00		ldy #$00			ldy #>forth_words_len
.8079	20 ba c7	jsr $c7ba			jsr PushYA
.807c	20 ec bf	jsr $bfec			jsr Evaluate
.807f	a9 00		lda #$00			lda #0
.8081	8d 66 07	sta $0766			sta hist_buff
.8084	8d e6 07	sta $07e6			sta hist_buff+$80
.8087	8d 66 08	sta $0866			sta hist_buff+$100
.808a	8d e6 08	sta $08e6			sta hist_buff+$180
.808d	8d 66 09	sta $0966			sta hist_buff+$200
.8090	8d e6 09	sta $09e6			sta hist_buff+$280
.8093	8d 66 0a	sta $0a66			sta hist_buff+$300
.8096	8d e6 0a	sta $0ae6			sta hist_buff+$380
.8099	4c 88 c4	jmp $c488			jmp Abort_Core2	;Quit
=80					CodeLen	.var *-XtPtr1
=$809c					Here1 = *	; remember here
>8049	50					.byte CodeLen	;patch wh_CodeLength
>809c	20 63 72 20 2e 28 20 54		forth_words_start: .binary "forth_words.asc" ; High-level Forth words, see forth_code/README.md
>80a4	61 6c 69 20 46 6f 72 74 68 20 32 20 72 65 6d 69
>80b4	78 20 66 6f 72 20 74 68 65 20 36 35 30 32 29 20
>80c4	63 72 20 2e 28 20 56 65 72 73 69 6f 6e 20 32 38
>80d4	20 4d 61 79 20 32 30 32 35 20 29 20 63 72 20 2e
>80e4	28 20 43 6f 70 79 72 69 67 68 74 20 32 30 31 34
>80f4	2d 32 30 32 34 20 53 63 6f 74 20 57 2e 20 53 74
>8104	65 76 65 6e 73 6f 6e 2c 20 53 61 6d 20 43 6f 6c
>8114	77 65 6c 6c 29 20 63 72 20 2e 28 20 54 61 6c 69
>8124	20 46 6f 72 74 68 20 32 20 63 6f 6d 65 73 20 77
>8134	69 74 68 20 61 62 73 6f 6c 75 74 65 6c 79 20 4e
>8144	4f 20 57 41 52 52 41 4e 54 59 29 20 63 72 20 2e
>8154	28 20 54 79 70 65 20 27 62 79 65 27 20 74 6f 20
>8164	65 78 69 74 29 20 63 72 20
=209					forth_words_len = *-forth_words_start
>816d					user_words_start: .binary "user_words.asc" ; User-defined Forth words, see forth_code/README.md
=0					user_words_len = *-user_words_start
>816d	4e 6f 4f 70			Name0:	.text "NoOp"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=33009					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>8171	04					.byte (("NoOp"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=0					WordFlags ::= 0	; modifiable copy, remember for later
=298					LinkDisplacement = Nt0-WordListLink
=1						  WordFlags ::= WordFlags | FP
>8172	01					.byte WordFlags	;wh_Flags
>8173	03					.byte 3	;wh_CodeLength
>8174	c7 7f					  .word WordListLink
=$8176					XtPtr1 ::= *
=33009					WordListLink ::= Nt0 ; remember the nt of this word for later
.8176	ea		nop				nop
=1					CodeLen	.var *-XtPtr1
=$8177					Here1 = *	; remember here
>8173	01					.byte CodeLen	;patch wh_CodeLength
.8177	60		rts				rts
>8178	43 43 40			Name0:	.text "CC@"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=33019					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>817b	03					.byte (("CC@"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=10					LinkDisplacement = Nt0-WordListLink
=$12						  WordFlags ::= WordFlags | DB
>817c	12					.byte WordFlags	;wh_Flags
>817d	08					.byte 8	;wh_CodeLength
>817e	0a					  .byte LinkDisplacement	; offset to previous nt
>817f	28 f1					  .word platform_CCAT		; pointer to xt
=0					XtPtr1 ::= 0
=33019					WordListLink ::= Nt0 ; remember the nt of this word for later
>8181	42 79 65			Name0:	.text "Bye"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=33028					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>8184	a3					.byte (("Bye"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=9					LinkDisplacement = Nt0-WordListLink
=$12						  WordFlags ::= WordFlags | DB
>8185	12					.byte WordFlags	;wh_Flags
>8186	08					.byte 8	;wh_CodeLength
>8187	09					  .byte LinkDisplacement	; offset to previous nt
>8188	27 f1					  .word platform_bye		; pointer to xt
=0					XtPtr1 ::= 0
=33028					WordListLink ::= Nt0 ; remember the nt of this word for later
>818a	54 79 70 65 53 79 6d 62		Name0:	.text "TypeSymbol"	;  name of word as a string, ending at wh_NameLastChar
>8192	6f 6c
=10					NameLength = *-Name0
=33044					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>8194	8a					.byte (("TypeSymbol"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=16					LinkDisplacement = Nt0-WordListLink
>8195	10					.byte WordFlags	;wh_Flags
>8196	03					.byte 3	;wh_CodeLength
>8197	10					  .byte LinkDisplacement	; offset to previous nt
=$8198					XtPtr1 ::= *
=33044					WordListLink ::= Nt0 ; remember the nt of this word for later
.8198	20 bd c8	jsr $c8bd	TypeSymbol:	jsr SLiteral_runtime
.819b	4c a3 81	jmp $81a3			  jmp +
>819e	20 20 28 20 24					  .text "  ( $"
.81a3	20 39 de	jsr $de39	+		jsr Type
.81a6	20 d2 df	jsr $dfd2			jsr Dup
.81a9	20 ec b8	jsr $b8ec			jsr Dot_Hex
.81ac	20 2d de	jsr $de2d			jsr Space
.81af	20 d6 81	jsr $81d6			jsr DictSearchXt	; ( addr_end addr operand offset nt )
.81b2	20 f7 cd	jsr $cdf7			jsr Name_To_String	; Change nt into the name
.81b5	20 39 de	jsr $de39			jsr Type		; print it.
.81b8	20 2d de	jsr $de2d			jsr Space
.81bb	b5 24		lda $24,x			lda DStack+0,x		; if non-zero offset
.81bd	15 25		ora $25,x			ora DStack+1,x
.81bf	f0 0b		beq $81cc			beq +
.81c1	a9 2b		lda #$2b			lda #'+'		;   print offset
.81c3	20 21 de	jsr $de21			jsr Emit_A
.81c6	20 d2 df	jsr $dfd2			jsr Dup
.81c9	20 52 dc	jsr $dc52			jsr U_Dot
.81cc	e8		inx		+		inx
.81cd	e8		inx				inx
.81ce	a9 29		lda #$29			lda #')'
.81d0	20 21 de	jsr $de21			jsr Emit_A
.81d3	4c 2d de	jmp $de2d			jmp Space
=62					CodeLen	.var *-XtPtr1
=$81d6					Here1 = *	; remember here
>8196	3e					.byte CodeLen	;patch wh_CodeLength
.81d6					DictSearchXt:
.81d6	ca		dex				dex			; alloc nt
.81d7	ca		dex				dex
.81d8	20 a9 df	jsr $dfa9			jsr Over		; alloc xt
.81db	a9 ff		lda #$ff			lda #$ff		; init best offset
.81dd	95 29		sta $29,x			sta DStack+5,x		; ( offset nt xt )
.81df	a9 fe		lda #$fe			lda #$100-2		; for each wordlist
.81e1	48		pha				pha
.81e2	68		pla		_ListNext:	pla
.81e3	18		clc				clc
.81e4	69 02		adc #$02			adc #2			; to next wordlist
.81e6	c9 18		cmp #$18			cmp #max_wordlists*2
.81e8	b0 10		bcs $81fa			bcs _ListDone
.81ea	48		pha				pha
.81eb	a8		tay				tay
.81ec	b9 12 03	lda $0312,y			lda WordlistsV+0,y	; Get the DP for that wordlist.
.81ef	85 14		sta $14				sta tmp1+0
.81f1	b9 13 03	lda $0313,y			lda WordlistsV+1,y
.81f4	85 15		sta $15				sta tmp1+1
.81f6	d0 0a		bne $8202			bne _WordTest
.81f8	f0 e8		beq $81e2			beq _ListNext		;   empty list
.81fa	e8		inx		_ListDone:	inx			; Drop pattern xt
.81fb	e8		inx				inx			; ( offset nt )
.81fc	60		rts				rts
.81fd	20 95 82	jsr $8295	_WordNext:	jsr LinkNext		; tmp1= next nt in list
.8200	f0 e0		beq $81e2			beq _ListNext		; end of Dictionary?
.8202	20 bb cd	jsr $cdbb	_WordTest:	jsr NameToIntTmp	; tmp2 = xt of this word
.8205	38		sec				sec			; tmp3 = xt offset for this word
.8206	b5 24		lda $24,x			lda DStack+0,x
.8208	e5 16		sbc $16				sbc tmp2+0
.820a	85 18		sta $18				sta tmp3+0
.820c	b5 25		lda $25,x			lda DStack+1,x
.820e	e5 17		sbc $17				sbc tmp2+1
.8210	85 19		sta $19				sta tmp3+1
.8212	20 7a 82	jsr $827a			jsr _test
.8215	a0 00		ldy #$00			ldy #0			; is this word a constant?
.8217	b1 16		lda ($16),y			lda (tmp2),y
.8219	c9 a0		cmp #$a0			cmp #$a0
.821b	f0 2a		beq $8247			beq _PushYA
.821d	c9 a9		cmp #$a9			cmp #$a9
.821f	f0 02		beq $8223			beq _PushZA
.8221	d0 da		bne $81fd			bne _WordNext
.8223	c8		iny		_PushZA:	iny			; get lda # operand
.8224	b5 24		lda $24,x			lda DStack+0,x
.8226	f1 16		sbc ($16),y			sbc (tmp2),y
.8228	85 18		sta $18				sta tmp3+0
.822a	b5 25		lda $25,x			lda DStack+1,x
.822c	e9 00		sbc #$00			sbc #0
.822e	85 19		sta $19				sta tmp3+1
.8230	c8		iny				iny			; check jmp opcode
.8231	b1 16		lda ($16),y			lda (tmp2),y
.8233	c9 4c		cmp #$4c			cmp #$4c
.8235	d0 c6		bne $81fd			bne _WordNext
.8237	c8		iny				iny			; check jmp operand lo
.8238	b1 16		lda ($16),y			lda (tmp2),y
.823a	c9 e9		cmp #$e9			cmp #<PushZA
.823c	d0 bf		bne $81fd			bne _WordNext
.823e	c8		iny				iny			; check jmp operand hi
.823f	b1 16		lda ($16),y			lda (tmp2),y
.8241	c9 c7		cmp #$c7			cmp #>PushZA
.8243	f0 2f		beq $8274			beq _KTest
.8245	d0 b6		bne $81fd			bne _WordNext
.8247	a0 02		ldy #$02	_PushYA:	ldy #2			; check LDA # opcode
.8249	b1 16		lda ($16),y			lda (tmp2),y
.824b	c9 a9		cmp #$a9			cmp #$a9
.824d	d0 ae		bne $81fd			bne _WordNext
.824f	c8		iny				iny			; get lda # operand
.8250	b5 24		lda $24,x			lda DStack+0,x
.8252	f1 16		sbc ($16),y			sbc (tmp2),y
.8254	85 18		sta $18				sta tmp3+0
.8256	a0 01		ldy #$01			ldy #1			; get LDY # operand
.8258	b5 25		lda $25,x			lda DStack+1,x
.825a	f1 16		sbc ($16),y			sbc (tmp2),y
.825c	85 19		sta $19				sta tmp3+1
.825e	a0 04		ldy #$04			ldy #4			; check JMP opcode
.8260	b1 16		lda ($16),y			lda (tmp2),y
.8262	c9 4c		cmp #$4c			cmp #$4c
.8264	d0 97		bne $81fd			bne _WordNext
.8266	c8		iny				iny			; check JMP operand lo
.8267	b1 16		lda ($16),y			lda (tmp2),y
.8269	c9 ba		cmp #$ba			cmp #<PushYA
.826b	d0 0a		bne $8277			bne _WordNext3
.826d	c8		iny				iny			; check JMP operand hi
.826e	b1 16		lda ($16),y			lda (tmp2),y
.8270	c9 c7		cmp #$c7			cmp #>PushYA
.8272	d0 03		bne $8277			bne _WordNext3
.8274	20 7a 82	jsr $827a	_KTest:		jsr _test
.8277	4c fd 81	jmp $81fd	_WordNext3:	jmp _WordNext
.827a					_test:
.827a	a5 18		lda $18				lda tmp3+0		; this word have smaller offset?
.827c	d5 28		cmp $28,x			cmp DStack+4,x
.827e	a5 19		lda $19				lda tmp3+1
.8280	f5 29		sbc $29,x			sbc DStack+5,x
.8282	b0 10		bcs $8294			bcs _trts
.8284	a5 18		lda $18				lda tmp3+0		;   save this better offset
.8286	a4 19		ldy $19				ldy tmp3+1
.8288	95 28		sta $28,x			sta DStack+4,x
.828a	94 29		sty $29,x			sty DStack+5,x
.828c	a5 14		lda $14				lda tmp1+0		;   save this better nt
.828e	a4 15		ldy $15				ldy tmp1+1
.8290	95 26		sta $26,x			sta DStack+2,x
.8292	94 27		sty $27,x			sty DStack+3,x
.8294	60		rts		_trts:		rts
.8295					LinkNext:
.8295	a0 81		ldy #$81			ldy #wh_Flags		; which kind of wh_LinkNt?
.8297	b1 14		lda ($14),y			lda (tmp1),y
.8299	29 01		and #$01			and #FP
.829b	f0 0e		beq $82ab			beq _LinkShort
.829d	a0 84		ldy #$84	_LinkLong:	ldy #wh_LinkNt+1	; tmp1 = tmp1->LinkNt (ptr)
.829f	b1 14		lda ($14),y			lda (tmp1),y
.82a1	48		pha				pha
.82a2	88		dey				dey
.82a3	b1 14		lda ($14),y			lda (tmp1),y
.82a5	85 14		sta $14				sta tmp1+0
.82a7	68		pla				pla
.82a8	85 15		sta $15				sta tmp1+1
.82aa	60		rts				rts
.82ab	a0 83		ldy #$83	_LinkShort:	ldy #wh_LinkNt		; tmp1 -= tmp1->LinkNt byte offset
.82ad	38		sec				sec
.82ae	a5 14		lda $14				lda tmp1+0
.82b0	f1 14		sbc ($14),y			sbc (tmp1),y
.82b2	85 14		sta $14				sta tmp1+0
.82b4	a5 15		lda $15				lda tmp1+1
.82b6	e9 00		sbc #$00			sbc #0
.82b8	85 15		sta $15				sta tmp1+1
.82ba	60		rts				rts
>82bb	44 53 74 61 63 6b		Name0:	.text "DStack"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=33345					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>82c1	66					.byte (("DStack"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=301					LinkDisplacement = Nt0-WordListLink
=$11						  WordFlags ::= WordFlags | FP
>82c2	11					.byte WordFlags	;wh_Flags
>82c3	03					.byte 3	;wh_CodeLength
>82c4	14 81					  .word WordListLink
=$82c6					XtPtr1 ::= *
=33345					WordListLink ::= Nt0 ; remember the nt of this word for later
.82c6	a9 24		lda #$24			lda #DStack
.82c8	4c e9 c7	jmp $c7e9			jmp PushZA
=5					CodeLen	.var *-XtPtr1
=$82cb					Here1 = *	; remember here
>82c3	05					.byte CodeLen	;patch wh_CodeLength
>82cb	52 53 74 61 63 6b		Name0:	.text "RStack"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=33361					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>82d1	66					.byte (("RStack"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=16					LinkDisplacement = Nt0-WordListLink
>82d2	10					.byte WordFlags	;wh_Flags
>82d3	03					.byte 3	;wh_CodeLength
>82d4	10					  .byte LinkDisplacement	; offset to previous nt
=$82d5					XtPtr1 ::= *
=33361					WordListLink ::= Nt0 ; remember the nt of this word for later
.82d5	a0 01		ldy #$01			ldy #>RStack
.82d7	a9 00		lda #$00			lda #<RStack
.82d9	4c ba c7	jmp $c7ba			jmp PushYA
=7					CodeLen	.var *-XtPtr1
=$82dc					Here1 = *	; remember here
>82d3	07					.byte CodeLen	;patch wh_CodeLength
>82dc	52 6e 64 53 74 61 74 65		Name0:	.text "RndState"	;  name of word as a string, ending at wh_NameLastChar
=8					NameLength = *-Name0
=33380					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>82e4	a8					.byte (("RndState"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=19					LinkDisplacement = Nt0-WordListLink
>82e5	10					.byte WordFlags	;wh_Flags
>82e6	03					.byte 3	;wh_CodeLength
>82e7	13					  .byte LinkDisplacement	; offset to previous nt
=$82e8					XtPtr1 ::= *
=33380					WordListLink ::= Nt0 ; remember the nt of this word for later
.82e8	a0 03		ldy #$03			ldy #>RndState
.82ea	a9 35		lda #$35			lda #<RndState
.82ec	4c ba c7	jmp $c7ba			jmp PushYA
=7					CodeLen	.var *-XtPtr1
=$82ef					Here1 = *	; remember here
>82e6	07					.byte CodeLen	;patch wh_CodeLength
>82ef	52 61 6e 64			Name0:	.text "Rand"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=33395					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>82f3	84					.byte (("Rand"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=0					WordFlags ::= 0	; modifiable copy, remember for later
=15					LinkDisplacement = Nt0-WordListLink
>82f4	00					.byte WordFlags	;wh_Flags
>82f5	03					.byte 3	;wh_CodeLength
>82f6	0f					  .byte LinkDisplacement	; offset to previous nt
=$82f7					XtPtr1 ::= *
=33395					WordListLink ::= Nt0 ; remember the nt of this word for later
.82f7					Rand:
.82f7	4e 36 03	lsr $0336			lsr RndState+1
.82fa	6e 35 03	ror $0335			ror RndState+0
.82fd	6e 38 03	ror $0338			ror RndState+3
.8300	6e 37 03	ror $0337			ror RndState+2
.8303	90 10		bcc $8315			bcc _19			;  IfCs,
.8305	ad 36 03	lda $0336			lda RndState+1
.8308	49 d0		eor #$d0			eor #$d0
.830a	8d 36 03	sta $0336			sta RndState+1
.830d	ad 37 03	lda $0337			lda RndState+2
.8310	49 01		eor #$01			eor #$01
.8312	8d 37 03	sta $0337			sta RndState+2
.8315					_19:
.8315	ad 37 03	lda $0337			lda RndState+2
.8318	ac 38 03	ldy $0338			ldy RndState+3
=36					CodeLen	.var *-XtPtr1
=$831b					Here1 = *	; remember here
>82f5	24					.byte CodeLen	;patch wh_CodeLength
.831b	60		rts				rts
>831c	52 61 6e 64 4d			Name0:	.text "RandM"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=33441					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>8321	a5					.byte (("RandM"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=46					LinkDisplacement = Nt0-WordListLink
>8322	10					.byte WordFlags	;wh_Flags
>8323	03					.byte 3	;wh_CodeLength
>8324	2e					  .byte LinkDisplacement	; offset to previous nt
=$8325					XtPtr1 ::= *
=33441					WordListLink ::= Nt0 ; remember the nt of this word for later
.8325	20 d2 df	jsr $dfd2	RandM:		jsr Dup		; ( umod umod )
.8328	20 f7 82	jsr $82f7			jsr Rand
.832b	4a		lsr a				lsr a		; make positive
.832c	95 27		sta $27,x			sta DStack+3,x
.832e	94 26		sty $26,x			sty DStack+2,x	; ( rand umod )
.8330	4c 62 bf	jmp $bf62			jmp Mod
=14					CodeLen	.var *-XtPtr1
=$8333					Here1 = *	; remember here
>8323	0e					.byte CodeLen	;patch wh_CodeLength
>0054					FIndex:	.byte ?		; floating-point stack index. empty=FDim, full=0
>0055					FSExp:   .fill FDim	; byte array[FDim] FP stack exponent
>005f					FSMant0: .fill FDim	; byte array[FDim] FP stack mantissa MSByte
>0069					FSMant1: .fill FDim	; byte array[FDim] FP stack mantissa 2nd
>0073					FSMant2: .fill FDim	; byte array[FDim] FP stack mantissa 3rd
>007d					FSMant3: .fill FDim	; byte array[FDim] FP stack mantissa 4th
>8333	46 49 6e 64 65 78		Name0:	.text "FIndex"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=33465					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>8339	06					.byte (("FIndex"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=24					LinkDisplacement = Nt0-WordListLink
>833a	10					.byte WordFlags	;wh_Flags
>833b	03					.byte 3	;wh_CodeLength
>833c	18					  .byte LinkDisplacement	; offset to previous nt
=$833d					XtPtr1 ::= *
=33465					WordListLink ::= Nt0 ; remember the nt of this word for later
.833d	a9 54		lda #$54			lda #FIndex
.833f	4c e9 c7	jmp $c7e9			jmp PushZA
=5					CodeLen	.var *-XtPtr1
=$8342					Here1 = *	; remember here
>833b	05					.byte CodeLen	;patch wh_CodeLength
>8342	46 44 69 6d			Name0:	.text "FDim"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=33478					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>8346	a4					.byte (("FDim"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>8347	10					.byte WordFlags	;wh_Flags
>8348	03					.byte 3	;wh_CodeLength
>8349	0d					  .byte LinkDisplacement	; offset to previous nt
=$834a					XtPtr1 ::= *
=33478					WordListLink ::= Nt0 ; remember the nt of this word for later
.834a	a9 0a		lda #$0a			lda #FDim
.834c	4c e9 c7	jmp $c7e9			jmp PushZA
=5					CodeLen	.var *-XtPtr1
=$834f					Here1 = *	; remember here
>8348	05					.byte CodeLen	;patch wh_CodeLength
>834f	46 53 45 78 70			Name0:	.text "FSExp"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=33492					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>8354	05					.byte (("FSExp"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=14					LinkDisplacement = Nt0-WordListLink
>8355	10					.byte WordFlags	;wh_Flags
>8356	03					.byte 3	;wh_CodeLength
>8357	0e					  .byte LinkDisplacement	; offset to previous nt
=$8358					XtPtr1 ::= *
=33492					WordListLink ::= Nt0 ; remember the nt of this word for later
.8358	a9 55		lda #$55			lda #FSExp
.835a	4c e9 c7	jmp $c7e9			jmp PushZA
=5					CodeLen	.var *-XtPtr1
=$835d					Here1 = *	; remember here
>8356	05					.byte CodeLen	;patch wh_CodeLength
>835d	46 53 4d 61 6e 74 30		Name0:	.text "FSMant0"	;  name of word as a string, ending at wh_NameLastChar
=7					NameLength = *-Name0
=33508					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>8364	07					.byte (("FSMant0"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=16					LinkDisplacement = Nt0-WordListLink
>8365	10					.byte WordFlags	;wh_Flags
>8366	03					.byte 3	;wh_CodeLength
>8367	10					  .byte LinkDisplacement	; offset to previous nt
=$8368					XtPtr1 ::= *
=33508					WordListLink ::= Nt0 ; remember the nt of this word for later
.8368	a9 5f		lda #$5f			lda #FSMant0
.836a	4c e9 c7	jmp $c7e9			jmp PushZA
=5					CodeLen	.var *-XtPtr1
=$836d					Here1 = *	; remember here
>8366	05					.byte CodeLen	;patch wh_CodeLength
>836d	46 53 4d 61 6e 74 31		Name0:	.text "FSMant1"	;  name of word as a string, ending at wh_NameLastChar
=7					NameLength = *-Name0
=33524					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>8374	27					.byte (("FSMant1"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=16					LinkDisplacement = Nt0-WordListLink
>8375	10					.byte WordFlags	;wh_Flags
>8376	03					.byte 3	;wh_CodeLength
>8377	10					  .byte LinkDisplacement	; offset to previous nt
=$8378					XtPtr1 ::= *
=33524					WordListLink ::= Nt0 ; remember the nt of this word for later
.8378	a9 69		lda #$69			lda #FSMant1
.837a	4c e9 c7	jmp $c7e9			jmp PushZA
=5					CodeLen	.var *-XtPtr1
=$837d					Here1 = *	; remember here
>8376	05					.byte CodeLen	;patch wh_CodeLength
>837d	46 53 4d 61 6e 74 32		Name0:	.text "FSMant2"	;  name of word as a string, ending at wh_NameLastChar
=7					NameLength = *-Name0
=33540					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>8384	47					.byte (("FSMant2"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=16					LinkDisplacement = Nt0-WordListLink
>8385	10					.byte WordFlags	;wh_Flags
>8386	03					.byte 3	;wh_CodeLength
>8387	10					  .byte LinkDisplacement	; offset to previous nt
=$8388					XtPtr1 ::= *
=33540					WordListLink ::= Nt0 ; remember the nt of this word for later
.8388	a9 73		lda #$73			lda #FSMant2
.838a	4c e9 c7	jmp $c7e9			jmp PushZA
=5					CodeLen	.var *-XtPtr1
=$838d					Here1 = *	; remember here
>8386	05					.byte CodeLen	;patch wh_CodeLength
>838d	46 53 4d 61 6e 74 33		Name0:	.text "FSMant3"	;  name of word as a string, ending at wh_NameLastChar
=7					NameLength = *-Name0
=33556					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>8394	67					.byte (("FSMant3"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=16					LinkDisplacement = Nt0-WordListLink
>8395	10					.byte WordFlags	;wh_Flags
>8396	03					.byte 3	;wh_CodeLength
>8397	10					  .byte LinkDisplacement	; offset to previous nt
=$8398					XtPtr1 ::= *
=33556					WordListLink ::= Nt0 ; remember the nt of this word for later
.8398	a9 7d		lda #$7d			lda #FSMant3
.839a	4c e9 c7	jmp $c7e9			jmp PushZA
=5					CodeLen	.var *-XtPtr1
=$839d					Here1 = *	; remember here
>8396	05					.byte CodeLen	;patch wh_CodeLength
=5					Float_Size = 5 ; # of bytes in memory for a float
>839d	46 6c 6f 61 74			Name0:	.text "Float"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=33570					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>83a2	85					.byte (("Float"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=14					LinkDisplacement = Nt0-WordListLink
>83a3	10					.byte WordFlags	;wh_Flags
>83a4	03					.byte 3	;wh_CodeLength
>83a5	0e					  .byte LinkDisplacement	; offset to previous nt
=$83a6					XtPtr1 ::= *
=33570					WordListLink ::= Nt0 ; remember the nt of this word for later
.83a6	a9 05		lda #$05	Float:		lda #Float_Size
.83a8	4c e9 c7	jmp $c7e9			jmp PushZA
=5					CodeLen	.var *-XtPtr1
=$83ab					Here1 = *	; remember here
>83a4	05					.byte CodeLen	;patch wh_CodeLength
>83ab	46 6c 6f 61 74 2b		Name0:	.text "Float+"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=33585					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>83b1	66					.byte (("Float+"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=15					LinkDisplacement = Nt0-WordListLink
>83b2	10					.byte WordFlags	;wh_Flags
>83b3	03					.byte 3	;wh_CodeLength
>83b4	0f					  .byte LinkDisplacement	; offset to previous nt
=$83b5					XtPtr1 ::= *
=33585					WordListLink ::= Nt0 ; remember the nt of this word for later
.83b5	a9 05		lda #$05	FloatPlus:	lda #Float_Size
.83b7	4c 48 da	jmp $da48			jmp Plus_A
=5					CodeLen	.var *-XtPtr1
=$83ba					Here1 = *	; remember here
>83b3	05					.byte CodeLen	;patch wh_CodeLength
>83ba	46 6c 6f 61 74 73		Name0:	.text "Floats"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=33600					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>83c0	66					.byte (("Floats"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=15					LinkDisplacement = Nt0-WordListLink
>83c1	10					.byte WordFlags	;wh_Flags
>83c2	03					.byte 3	;wh_CodeLength
>83c3	0f					  .byte LinkDisplacement	; offset to previous nt
=$83c4					XtPtr1 ::= *
=33600					WordListLink ::= Nt0 ; remember the nt of this word for later
.83c4	20 a6 83	jsr $83a6	Floats:		jsr Float
.83c7	4c 78 be	jmp $be78			jmp Star
=6					CodeLen	.var *-XtPtr1
=$83ca					Here1 = *	; remember here
>83c2	06					.byte CodeLen	;patch wh_CodeLength
>83ca	46 41 6c 69 67 6e		Name0:	.text "FAlign"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=33616					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>83d0	c6					.byte (("FAlign"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=0					WordFlags ::= 0	; modifiable copy, remember for later
=16					LinkDisplacement = Nt0-WordListLink
>83d1	00					.byte WordFlags	;wh_Flags
>83d2	03					.byte 3	;wh_CodeLength
>83d3	10					  .byte LinkDisplacement	; offset to previous nt
=$83d4					XtPtr1 ::= *
=33616					WordListLink ::= Nt0 ; remember the nt of this word for later
.83d4					FAlign:
=0					CodeLen	.var *-XtPtr1
=$83d4					Here1 = *	; remember here
>83d2	00					.byte CodeLen	;patch wh_CodeLength
.83d4	60		rts				rts
>83d5	46 41 6c 69 67 6e 65 64		Name0:	.text "FAligned"	;  name of word as a string, ending at wh_NameLastChar
=8					NameLength = *-Name0
=33629					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>83dd	88					.byte (("FAligned"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=0					WordFlags ::= 0	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>83de	00					.byte WordFlags	;wh_Flags
>83df	03					.byte 3	;wh_CodeLength
>83e0	0d					  .byte LinkDisplacement	; offset to previous nt
=$83e1					XtPtr1 ::= *
=33629					WordListLink ::= Nt0 ; remember the nt of this word for later
.83e1					FAligned:
=0					CodeLen	.var *-XtPtr1
=$83e1					Here1 = *	; remember here
>83df	00					.byte CodeLen	;patch wh_CodeLength
.83e1	60		rts				rts
>83e2	48 65 78 3e 46			Name0:	.text "Hex>F"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=33639					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>83e7	c5					.byte (("Hex>F"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=10					LinkDisplacement = Nt0-WordListLink
>83e8	10					.byte WordFlags	;wh_Flags
>83e9	03					.byte 3	;wh_CodeLength
>83ea	0a					  .byte LinkDisplacement	; offset to previous nt
=$83eb					XtPtr1 ::= *
=33639					WordListLink ::= Nt0 ; remember the nt of this word for later
.83eb	20 c8 84	jsr $84c8	PartsToF:	jsr FAllocX		; alloc FP stack entry, X= FP stack index
.83ee	a6 14		ldx $14				ldx tmp1+0		; restore data stack index
.83f0	a4 54		ldy $54				ldy FIndex		; Y= FP stack index
.83f2	20 c8 c3	jsr $c3c8			jsr PopA		; pop n_exp
.83f5	99 55 00	sta $0055,y			sta FSExp,y
.83f8	b5 25		lda $25,x			lda DStack+1,x
.83fa	99 5f 00	sta $005f,y			sta FSMant0,y
.83fd	b5 24		lda $24,x			lda DStack+0,x
.83ff	99 69 00	sta $0069,y			sta FSMant1,y
.8402	b5 27		lda $27,x			lda DStack+3,x
.8404	99 73 00	sta $0073,y			sta FSMant2,y
.8407	b5 26		lda $26,x			lda DStack+2,x
.8409	99 7d 00	sta $007d,y			sta FSMant3,y
.840c	4c 72 d5	jmp $d572			jmp Two_Drop
=36					CodeLen	.var *-XtPtr1
=$840f					Here1 = *	; remember here
>83e9	24					.byte CodeLen	;patch wh_CodeLength
>840f	46 3e 48 65 78			Name0:	.text "F>Hex"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=33684					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>8414	05					.byte (("F>Hex"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=45					LinkDisplacement = Nt0-WordListLink
>8415	10					.byte WordFlags	;wh_Flags
>8416	03					.byte 3	;wh_CodeLength
>8417	2d					  .byte LinkDisplacement	; offset to previous nt
=$8418					XtPtr1 ::= *
=33684					WordListLink ::= Nt0 ; remember the nt of this word for later
.8418	a4 54		ldy $54		FToParts:	ldy FIndex	; Y= FP stack index
.841a	ca		dex				dex		; alloc d_mantissa
.841b	ca		dex				dex
.841c	ca		dex				dex
.841d	ca		dex				dex
.841e	ca		dex				dex		; alloc n_exponent
.841f	ca		dex				dex
.8420	b9 5f 00	lda $005f,y			lda FSMant0,y	; copy mantissa
.8423	95 27		sta $27,x			sta DStack+3,x
.8425	b9 69 00	lda $0069,y			lda FSMant1,y
.8428	95 26		sta $26,x			sta DStack+2,x
.842a	b9 73 00	lda $0073,y			lda FSMant2,y
.842d	95 29		sta $29,x			sta DStack+5,x
.842f	b9 7d 00	lda $007d,y			lda FSMant3,y
.8432	95 28		sta $28,x			sta DStack+4,x
.8434	b9 55 00	lda $0055,y			lda FSExp,y	; copy exponent
.8437	95 24		sta $24,x			sta DStack+0,x
.8439	29 80		and #$80			and #$80	;   sign extend
.843b	f0 02		beq $843f			beq +
.843d	a9 ff		lda #$ff			lda #$ff
.843f	95 25		sta $25,x	+		sta DStack+1,x
.8441	e6 54		inc $54				inc FIndex	; FDrop r
=43					CodeLen	.var *-XtPtr1
=$8443					Here1 = *	; remember here
>8416	2b					.byte CodeLen	;patch wh_CodeLength
.8443	60		rts				rts
>8444	46 2e 48 65 78			Name0:	.text "F.Hex"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=33737					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>8449	05					.byte (("F.Hex"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=53					LinkDisplacement = Nt0-WordListLink
>844a	10					.byte WordFlags	;wh_Flags
>844b	03					.byte 3	;wh_CodeLength
>844c	35					  .byte LinkDisplacement	; offset to previous nt
=$844d					XtPtr1 ::= *
=33737					WordListLink ::= Nt0 ; remember the nt of this word for later
.844d	20 18 84	jsr $8418	FDotHex:	jsr FToParts	; get parts of r
.8450	20 d8 de	jsr $ded8			jsr Not_Rot
.8453	20 ec b8	jsr $b8ec			jsr Dot_Hex	; do mantissa
.8456	20 ec b8	jsr $b8ec			jsr Dot_Hex
.8459	a9 3a		lda #$3a			lda #':'
.845b	20 21 de	jsr $de21			jsr Emit_A
.845e	4c cb b8	jmp $b8cb			jmp C_Dot_Hex	; do exponent
=20					CodeLen	.var *-XtPtr1
=$8461					Here1 = *	; remember here
>844b	14					.byte CodeLen	;patch wh_CodeLength
>8461	46 43 6d 70 41			Name0:	.text "FCmpA"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=33766					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>8466	25					.byte (("FCmpA"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=29					LinkDisplacement = Nt0-WordListLink
>8467	10					.byte WordFlags	;wh_Flags
>8468	03					.byte 3	;wh_CodeLength
>8469	1d					  .byte LinkDisplacement	; offset to previous nt
=$846a					XtPtr1 ::= *
=33766					WordListLink ::= Nt0 ; remember the nt of this word for later
.846a	86 14		stx $14		FCmpA:		stx tmp1		; save data stack index
.846c	a6 54		ldx $54				ldx FIndex		; X= FP stack index
.846e	b5 5f		lda $5f,x			lda FSMant0+0,x		; r2 mantissa == 0 ?
.8470	f0 35		beq $84a7			beq _r2Zero
.8472	b4 60		ldy $60,x			ldy FSMant0+1,x		; r1 mantissa == 0 ?
.8474	f0 2b		beq $84a1			beq _r1Zero
.8476	55 60		eor $60,x			eor FSMant0+1,x		; compare mantissa sign
.8478	30 3d		bmi $84b7			bmi _MantissaSignDifferent
.847a	38		sec				sec			; compare exponent
.847b	b5 56		lda $56,x			lda FSExp+1,x
.847d	f5 55		sbc $55,x			sbc FSExp+0,x
.847f	d0 2b		bne $84ac			bne _ExponentDifferent
.8481	98		tya				tya			; compare mantissa MSB
.8482	f5 5f		sbc $5f,x			sbc FSMant0+0,x		;   always same sign so can't overflow
.8484	d0 17		bne $849d			bne _13
.8486	b5 6a		lda $6a,x			lda FSMant1+1,x		; compare mantissa 1
.8488	f5 69		sbc $69,x			sbc FSMant1+0,x
.848a	d0 0c		bne $8498			bne _12
.848c	b5 74		lda $74,x			lda FSMant2+1,x		; compare mantissa 2
.848e	f5 73		sbc $73,x			sbc FSMant2+0,x
.8490	d0 06		bne $8498			bne _12
.8492	b5 7e		lda $7e,x			lda FSMant3+1,x		; compare mantissa LSB
.8494	f5 7d		sbc $7d,x			sbc FSMant3+0,x
.8496	f0 05		beq $849d			beq _13
.8498	6a		ror a		_12:		ror a
.8499	49 80		eor #$80	_14:		eor #$80
.849b	09 01		ora #$01			ora #1
.849d	a6 14		ldx $14		_13:		ldx tmp1		; restore data stack index
.849f	a8		tay				tay			; set CPU flags
.84a0	60		rts				rts
.84a1	b5 5f		lda $5f,x	_r1Zero:	lda FSMant0+0,x		; return 0-r2
.84a3	d0 f4		bne $8499			bne _14
.84a5	f0 f6		beq $849d			beq _13
.84a7	b5 60		lda $60,x	_r2Zero:	lda FSMant0+1,x		; return r1
.84a9	4c 9d 84	jmp $849d			jmp _13
.84ac					_ExponentDifferent:
.84ac	50 02		bvc $84b0			bvc +
.84ae	49 80		eor #$80			eor #$80
.84b0					+
.84b0	55 5f		eor $5f,x			eor FSMant0+0,x
.84b2	a6 14		ldx $14				ldx tmp1		; restore data stack index
.84b4	09 01		ora #$01			ora #1			; set CPU flags
.84b6	60		rts				rts
.84b7					_MantissaSignDifferent:
.84b7	98		tya				tya
.84b8	a6 14		ldx $14				ldx tmp1		; restore data stack index
.84ba	09 01		ora #$01			ora #1
.84bc	60		rts				rts
=83					CodeLen	.var *-XtPtr1
=$84bd					Here1 = *	; remember here
>8468	53					.byte CodeLen	;patch wh_CodeLength
>84bd	46 41 6c 6c 6f 63 58		Name0:	.text "FAllocX"	;  name of word as a string, ending at wh_NameLastChar
=7					NameLength = *-Name0
=33860					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>84c4	07					.byte (("FAllocX"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=94					LinkDisplacement = Nt0-WordListLink
>84c5	10					.byte WordFlags	;wh_Flags
>84c6	03					.byte 3	;wh_CodeLength
>84c7	5e					  .byte LinkDisplacement	; offset to previous nt
=$84c8					XtPtr1 ::= *
=33860					WordListLink ::= Nt0 ; remember the nt of this word for later
.84c8					FAllocX:
.84c8	86 14		stx $14				stx tmp1+0	; save data stack index
.84ca	a6 54		ldx $54				ldx FIndex	; X= floating point stack index
.84cc	ca		dex				dex		; alloc FP stack entry
.84cd	e0 0a		cpx #$0a			cpx #FDim	; stack overflow or underflow?
.84cf	b0 03		bcs $84d4			bcs _err
.84d1	86 54		stx $54				stx FIndex
.84d3	60		rts				rts		; return X= FP stack index
.84d4	08		php		_err:		php		; save sign bit
.84d5	a6 14		ldx $14				ldx tmp1+0	; restore data stack index
.84d7	28		plp				plp		; restore sign bit
.84d8	4c 39 c4	jmp $c439			jmp Throw_FPStack
=19					CodeLen	.var *-XtPtr1
=$84db					Here1 = *	; remember here
>84c6	13					.byte CodeLen	;patch wh_CodeLength
>84db	46 4d 61 78			Name0:	.text "FMax"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=33887					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>84df	04					.byte (("FMax"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=27					LinkDisplacement = Nt0-WordListLink
>84e0	10					.byte WordFlags	;wh_Flags
>84e1	03					.byte 3	;wh_CodeLength
>84e2	1b					  .byte LinkDisplacement	; offset to previous nt
=$84e3					XtPtr1 ::= *
=33887					WordListLink ::= Nt0 ; remember the nt of this word for later
.84e3	20 6a 84	jsr $846a	FMax:		jsr FCmpA
.84e6	10 2c		bpl $8514			bpl FDrop
.84e8	30 44		bmi $852e			bmi FNip
=7					CodeLen	.var *-XtPtr1
=$84ea					Here1 = *	; remember here
>84e1	07					.byte CodeLen	;patch wh_CodeLength
>84ea	46 4d 69 6e			Name0:	.text "FMin"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=33902					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>84ee	c4					.byte (("FMin"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=15					LinkDisplacement = Nt0-WordListLink
>84ef	10					.byte WordFlags	;wh_Flags
>84f0	03					.byte 3	;wh_CodeLength
>84f1	0f					  .byte LinkDisplacement	; offset to previous nt
=$84f2					XtPtr1 ::= *
=33902					WordListLink ::= Nt0 ; remember the nt of this word for later
.84f2	20 6a 84	jsr $846a	FMin:		jsr FCmpA
.84f5	30 1d		bmi $8514			bmi FDrop
.84f7	10 35		bpl $852e			bpl FNip
=7					CodeLen	.var *-XtPtr1
=$84f9					Here1 = *	; remember here
>84f0	07					.byte CodeLen	;patch wh_CodeLength
>84f9	46 44 65 70 74 68		Name0:	.text "FDepth"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=33919					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>84ff	06					.byte (("FDepth"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=17					LinkDisplacement = Nt0-WordListLink
>8500	10					.byte WordFlags	;wh_Flags
>8501	03					.byte 3	;wh_CodeLength
>8502	11					  .byte LinkDisplacement	; offset to previous nt
=$8503					XtPtr1 ::= *
=33919					WordListLink ::= Nt0 ; remember the nt of this word for later
.8503	a9 0a		lda #$0a	FDepth:		lda #FDim
.8505	38		sec				sec
.8506	e5 54		sbc $54				sbc FIndex
.8508	4c e9 c7	jmp $c7e9			jmp PushZA
=8					CodeLen	.var *-XtPtr1
=$850b					Here1 = *	; remember here
>8501	08					.byte CodeLen	;patch wh_CodeLength
>850b	46 44 72 6f 70			Name0:	.text "FDrop"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=33936					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>8510	05					.byte (("FDrop"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=0					WordFlags ::= 0	; modifiable copy, remember for later
=17					LinkDisplacement = Nt0-WordListLink
>8511	00					.byte WordFlags	;wh_Flags
>8512	03					.byte 3	;wh_CodeLength
>8513	11					  .byte LinkDisplacement	; offset to previous nt
=$8514					XtPtr1 ::= *
=33936					WordListLink ::= Nt0 ; remember the nt of this word for later
.8514	e6 54		inc $54		FDrop:		inc FIndex
=2					CodeLen	.var *-XtPtr1
=$8516					Here1 = *	; remember here
>8512	02					.byte CodeLen	;patch wh_CodeLength
.8516	60		rts				rts
>8517	46 32 44 72 6f 70		Name0:	.text "F2Drop"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=33949					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>851d	06					.byte (("F2Drop"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=0					WordFlags ::= 0	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>851e	00					.byte WordFlags	;wh_Flags
>851f	03					.byte 3	;wh_CodeLength
>8520	0d					  .byte LinkDisplacement	; offset to previous nt
=$8521					XtPtr1 ::= *
=33949					WordListLink ::= Nt0 ; remember the nt of this word for later
.8521	e6 54		inc $54		F2Drop:		inc FIndex
.8523	e6 54		inc $54				inc FIndex
=4					CodeLen	.var *-XtPtr1
=$8525					Here1 = *	; remember here
>851f	04					.byte CodeLen	;patch wh_CodeLength
.8525	60		rts				rts
>8526	46 4e 69 70			Name0:	.text "FNip"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=33962					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>852a	04					.byte (("FNip"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=0					WordFlags ::= 0	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>852b	00					.byte WordFlags	;wh_Flags
>852c	03					.byte 3	;wh_CodeLength
>852d	0d					  .byte LinkDisplacement	; offset to previous nt
=$852e					XtPtr1 ::= *
=33962					WordListLink ::= Nt0 ; remember the nt of this word for later
.852e	86 14		stx $14		FNip:		stx tmp1		; save data stack index
.8530	a6 54		ldx $54				ldx FIndex		; X= FP stack index
.8532	b5 55		lda $55,x			lda FSExp+0,x		; copy exponent
.8534	95 56		sta $56,x			sta FSExp+1,x
.8536	b5 5f		lda $5f,x			lda FSMant0+0,x		; copy mantissa
.8538	95 60		sta $60,x			sta FSMant0+1,x
.853a	b5 69		lda $69,x			lda FSMant1+0,x
.853c	95 6a		sta $6a,x			sta FSMant1+1,x
.853e	b5 73		lda $73,x			lda FSMant2+0,x
.8540	95 74		sta $74,x			sta FSMant2+1,x
.8542	b5 7d		lda $7d,x			lda FSMant3+0,x
.8544	95 7e		sta $7e,x			sta FSMant3+1,x
.8546	e6 54		inc $54				inc FIndex		; FDrop
.8548	a6 14		ldx $14				ldx tmp1		; restore data stack index
=28					CodeLen	.var *-XtPtr1
=$854a					Here1 = *	; remember here
>852c	1c					.byte CodeLen	;patch wh_CodeLength
.854a	60		rts				rts
>854b	46 44 75 70			Name0:	.text "FDup"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=33999					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>854f	04					.byte (("FDup"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=0					WordFlags ::= 0	; modifiable copy, remember for later
=37					LinkDisplacement = Nt0-WordListLink
>8550	00					.byte WordFlags	;wh_Flags
>8551	03					.byte 3	;wh_CodeLength
>8552	25					  .byte LinkDisplacement	; offset to previous nt
=$8553					XtPtr1 ::= *
=33999					WordListLink ::= Nt0 ; remember the nt of this word for later
.8553	20 c8 84	jsr $84c8	FDup:		jsr FAllocX		; alloc FP stack entry, X=fp stack index
.8556	b5 56		lda $56,x			lda FSExp+1,x		; copy exponent
.8558	95 55		sta $55,x			sta FSExp+0,x
.855a	b5 60		lda $60,x			lda FSMant0+1,x		; copy mantissa
.855c	95 5f		sta $5f,x			sta FSMant0+0,x
.855e	b5 6a		lda $6a,x			lda FSMant1+1,x
.8560	95 69		sta $69,x			sta FSMant1+0,x
.8562	b5 74		lda $74,x			lda FSMant2+1,x
.8564	95 73		sta $73,x			sta FSMant2+0,x
.8566	b5 7e		lda $7e,x			lda FSMant3+1,x
.8568	95 7d		sta $7d,x			sta FSMant3+0,x
.856a	a6 14		ldx $14				ldx tmp1+0		; restore data stack index
=25					CodeLen	.var *-XtPtr1
=$856c					Here1 = *	; remember here
>8551	19					.byte CodeLen	;patch wh_CodeLength
.856c	60		rts				rts
>856d	46 4f 76 65 72			Name0:	.text "FOver"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=34034					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>8572	45					.byte (("FOver"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=0					WordFlags ::= 0	; modifiable copy, remember for later
=35					LinkDisplacement = Nt0-WordListLink
>8573	00					.byte WordFlags	;wh_Flags
>8574	03					.byte 3	;wh_CodeLength
>8575	23					  .byte LinkDisplacement	; offset to previous nt
=$8576					XtPtr1 ::= *
=34034					WordListLink ::= Nt0 ; remember the nt of this word for later
.8576	20 c8 84	jsr $84c8	FOver:		jsr FAllocX		; alloc FP stack entry, X=fp stack index
.8579	b5 57		lda $57,x			lda FSExp+2,x		; copy exponent
.857b	95 55		sta $55,x			sta FSExp+0,x
.857d	b5 61		lda $61,x			lda FSMant0+2,x		; copy mantissa
.857f	95 5f		sta $5f,x			sta FSMant0+0,x
.8581	b5 6b		lda $6b,x			lda FSMant1+2,x
.8583	95 69		sta $69,x			sta FSMant1+0,x
.8585	b5 75		lda $75,x			lda FSMant2+2,x
.8587	95 73		sta $73,x			sta FSMant2+0,x
.8589	b5 7f		lda $7f,x			lda FSMant3+2,x
.858b	95 7d		sta $7d,x			sta FSMant3+0,x
.858d	a6 14		ldx $14				ldx tmp1+0		; restore data stack index
=25					CodeLen	.var *-XtPtr1
=$858f					Here1 = *	; remember here
>8574	19					.byte CodeLen	;patch wh_CodeLength
.858f	60		rts				rts
>8590	46 50 69 63 6b			Name0:	.text "FPick"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=34069					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>8595	65					.byte (("FPick"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=0					WordFlags ::= 0	; modifiable copy, remember for later
=35					LinkDisplacement = Nt0-WordListLink
>8596	00					.byte WordFlags	;wh_Flags
>8597	03					.byte 3	;wh_CodeLength
>8598	23					  .byte LinkDisplacement	; offset to previous nt
=$8599					XtPtr1 ::= *
=34069					WordListLink ::= Nt0 ; remember the nt of this word for later
.8599	20 c8 c3	jsr $c3c8	FPick:		jsr PopA		; pop u (desired entry #)
.859c	18		clc		FPickA:		clc			; Y= fp stack index of [u]
.859d	65 54		adc $54				adc FIndex
.859f	a8		tay		FPick3:		tay
.85a0	20 c8 84	jsr $84c8			jsr FAllocX		; alloc FP stack entry, X=fp stack index
.85a3	b9 55 00	lda $0055,y			lda FSExp,y		; copy exponent
.85a6	95 55		sta $55,x			sta FSExp,x
.85a8	b9 5f 00	lda $005f,y			lda FSMant0,y		; copy mantissa
.85ab	95 5f		sta $5f,x			sta FSMant0,x
.85ad	b9 69 00	lda $0069,y			lda FSMant1,y
.85b0	95 69		sta $69,x			sta FSMant1,x
.85b2	b9 73 00	lda $0073,y			lda FSMant2,y
.85b5	95 73		sta $73,x			sta FSMant2,x
.85b7	b9 7d 00	lda $007d,y			lda FSMant3,y
.85ba	95 7d		sta $7d,x			sta FSMant3,x
.85bc	a6 14		ldx $14				ldx tmp1+0		; restore data stack index
=37					CodeLen	.var *-XtPtr1
=$85be					Here1 = *	; remember here
>8597	25					.byte CodeLen	;patch wh_CodeLength
.85be	60		rts				rts
>85bf	46 32 44 75 70			Name0:	.text "F2Dup"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=34116					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>85c4	05					.byte (("F2Dup"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=47					LinkDisplacement = Nt0-WordListLink
>85c5	10					.byte WordFlags	;wh_Flags
>85c6	03					.byte 3	;wh_CodeLength
>85c7	2f					  .byte LinkDisplacement	; offset to previous nt
=$85c8					XtPtr1 ::= *
=34116					WordListLink ::= Nt0 ; remember the nt of this word for later
.85c8	20 76 85	jsr $8576	F2Dup:		jsr FOver
.85cb	4c 76 85	jmp $8576			jmp FOver
=6					CodeLen	.var *-XtPtr1
=$85ce					Here1 = *	; remember here
>85c6	06					.byte CodeLen	;patch wh_CodeLength
>85ce	46 53 77 61 70			Name0:	.text "FSwap"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=34131					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>85d3	05					.byte (("FSwap"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=0					WordFlags ::= 0	; modifiable copy, remember for later
=15					LinkDisplacement = Nt0-WordListLink
>85d4	00					.byte WordFlags	;wh_Flags
>85d5	03					.byte 3	;wh_CodeLength
>85d6	0f					  .byte LinkDisplacement	; offset to previous nt
=$85d7					XtPtr1 ::= *
=34131					WordListLink ::= Nt0 ; remember the nt of this word for later
.85d7	86 14		stx $14		FSwap:		stx tmp1+0		; save data stack index
.85d9	a6 54		ldx $54				ldx FIndex		; X=FP stack index
.85db	b5 55		lda $55,x			lda FSExp+0,x		; do FSExp
.85dd	b4 56		ldy $56,x			ldy FSExp+1,x
.85df	95 56		sta $56,x			sta FSExp+1,x
.85e1	94 55		sty $55,x			sty FSExp+0,x	; sty dir,x exists
.85e3	b5 5f		lda $5f,x			lda FSMant0+0,x		; do FSMant0
.85e5	b4 60		ldy $60,x			ldy FSMant0+1,x
.85e7	95 60		sta $60,x			sta FSMant0+1,x
.85e9	94 5f		sty $5f,x			sty FSMant0+0,x	; sty dir,x exists
.85eb	b5 69		lda $69,x			lda FSMant1+0,x		; do FSMant1
.85ed	b4 6a		ldy $6a,x			ldy FSMant1+1,x
.85ef	95 6a		sta $6a,x			sta FSMant1+1,x
.85f1	94 69		sty $69,x			sty FSMant1+0,x	; sty dir,x exists
.85f3	b5 73		lda $73,x			lda FSMant2+0,x		; do FSMant2
.85f5	b4 74		ldy $74,x			ldy FSMant2+1,x
.85f7	95 74		sta $74,x			sta FSMant2+1,x
.85f9	94 73		sty $73,x			sty FSMant2+0,x	; sty dir,x exists
.85fb	b5 7d		lda $7d,x			lda FSMant3+0,x		; do FSMant3
.85fd	b4 7e		ldy $7e,x			ldy FSMant3+1,x
.85ff	95 7e		sta $7e,x			sta FSMant3+1,x
.8601	94 7d		sty $7d,x			sty FSMant3+0,x	; sty dir,x exists
.8603	a6 14		ldx $14				ldx tmp1+0		; restore data stack index
=46					CodeLen	.var *-XtPtr1
=$8605					Here1 = *	; remember here
>85d5	2e					.byte CodeLen	;patch wh_CodeLength
.8605	60		rts				rts
>8606	46 54 75 63 6b			Name0:	.text "FTuck"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=34187					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>860b	65					.byte (("FTuck"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=56					LinkDisplacement = Nt0-WordListLink
>860c	10					.byte WordFlags	;wh_Flags
>860d	03					.byte 3	;wh_CodeLength
>860e	38					  .byte LinkDisplacement	; offset to previous nt
=$860f					XtPtr1 ::= *
=34187					WordListLink ::= Nt0 ; remember the nt of this word for later
.860f	20 d7 85	jsr $85d7	FTuck:		jsr FSwap
.8612	4c 76 85	jmp $8576			jmp FOver
=6					CodeLen	.var *-XtPtr1
=$8615					Here1 = *	; remember here
>860d	06					.byte CodeLen	;patch wh_CodeLength
>8615	46 52 6f 74			Name0:	.text "FRot"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=34201					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>8619	84					.byte (("FRot"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=0					WordFlags ::= 0	; modifiable copy, remember for later
=14					LinkDisplacement = Nt0-WordListLink
>861a	00					.byte WordFlags	;wh_Flags
>861b	03					.byte 3	;wh_CodeLength
>861c	0e					  .byte LinkDisplacement	; offset to previous nt
=$861d					XtPtr1 ::= *
=34201					WordListLink ::= Nt0 ; remember the nt of this word for later
.861d	86 14		stx $14		FRot:		stx tmp1		; save data stack index
.861f	a5 54		lda $54				lda FIndex		; for FSMant3, FSMant2, FSMant1, FSMant0, FSExp
.8621	18		clc				clc
.8622	69 28		adc #$28			adc #4*FDim
.8624	38		sec				sec
.8625	aa		tax		_2:		tax
.8626	b4 57		ldy $57,x			ldy FSExp+2,x		;   do a byte
.8628	b5 56		lda $56,x			lda FSExp+1,x
.862a	95 57		sta $57,x			sta FSExp+2,x
.862c	b5 55		lda $55,x			lda FSExp+0,x
.862e	95 56		sta $56,x			sta FSExp+1,x
.8630	94 55		sty $55,x			sty FSExp+0,x	; sty dir,x exists
.8632	8a		txa				txa			;   next byte
.8633	e9 0a		sbc #$0a			sbc #FDim
.8635	b0 ee		bcs $8625			bcs _2			; until done
.8637	a6 14		ldx $14				ldx tmp1		; restore param stack index
=28					CodeLen	.var *-XtPtr1
=$8639					Here1 = *	; remember here
>861b	1c					.byte CodeLen	;patch wh_CodeLength
.8639	60		rts				rts
>863a	46 2d 52 6f 74			Name0:	.text "F-Rot"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=34239					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>863f	85					.byte (("F-Rot"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=38					LinkDisplacement = Nt0-WordListLink
>8640	10					.byte WordFlags	;wh_Flags
>8641	03					.byte 3	;wh_CodeLength
>8642	26					  .byte LinkDisplacement	; offset to previous nt
=$8643					XtPtr1 ::= *
=34239					WordListLink ::= Nt0 ; remember the nt of this word for later
.8643	20 1d 86	jsr $861d	FMRot:		jsr FRot
.8646	4c 1d 86	jmp $861d			jmp FRot
=6					CodeLen	.var *-XtPtr1
=$8649					Here1 = *	; remember here
>8641	06					.byte CodeLen	;patch wh_CodeLength
>8649	46 40				Name0:	.text "F@"	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=34251					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>864b	02					.byte (("F@"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=0					WordFlags ::= 0	; modifiable copy, remember for later
=12					LinkDisplacement = Nt0-WordListLink
>864c	00					.byte WordFlags	;wh_Flags
>864d	03					.byte 3	;wh_CodeLength
>864e	0c					  .byte LinkDisplacement	; offset to previous nt
=$864f					XtPtr1 ::= *
=34251					WordListLink ::= Nt0 ; remember the nt of this word for later
.864f	20 e3 c3	jsr $c3e3	FAt:		jsr PopYA		; pop addr
.8652	85 16		sta $16		FAt_YA:		sta tmp2+0		; save addr
.8654	84 17		sty $17				sty tmp2+1
.8656	a0 00		ldy #$00			ldy #0			; starting offset from tmp2
.8658	20 c8 84	jsr $84c8	FAt_Tmp2Y:	jsr FAllocX		; alloc FP stack entry, X= fp stack index
.865b	b1 16		lda ($16),y			lda (tmp2),y		; copy mantissa
.865d	95 7d		sta $7d,x			sta FSMant3,x
.865f	c8		iny				iny
.8660	b1 16		lda ($16),y			lda (tmp2),y
.8662	95 73		sta $73,x			sta FSMant2,x
.8664	c8		iny				iny
.8665	b1 16		lda ($16),y			lda (tmp2),y
.8667	95 69		sta $69,x			sta FSMant1,x
.8669	c8		iny				iny
.866a	b1 16		lda ($16),y			lda (tmp2),y
.866c	95 5f		sta $5f,x			sta FSMant0,x
.866e	c8		iny				iny			; copy exponent
.866f	b1 16		lda ($16),y			lda (tmp2),y
.8671	95 55		sta $55,x			sta FSExp,x
.8673	a6 14		ldx $14				ldx tmp1		; restore data stack index
=38					CodeLen	.var *-XtPtr1
=$8675					Here1 = *	; remember here
>864d	26					.byte CodeLen	;patch wh_CodeLength
.8675	60		rts				rts
>8676	46 21				Name0:	.text "F!"	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=34296					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>8678	22					.byte (("F!"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=0					WordFlags ::= 0	; modifiable copy, remember for later
=45					LinkDisplacement = Nt0-WordListLink
>8679	00					.byte WordFlags	;wh_Flags
>867a	03					.byte 3	;wh_CodeLength
>867b	2d					  .byte LinkDisplacement	; offset to previous nt
=$867c					XtPtr1 ::= *
=34296					WordListLink ::= Nt0 ; remember the nt of this word for later
.867c	20 e3 c3	jsr $c3e3	FStore:		jsr PopYA		; pop addr
.867f	85 14		sta $14		FStore_YA:	sta tmp1+0		; save addr
.8681	84 15		sty $15				sty tmp1+1
.8683	a0 00		ldy #$00			ldy #0
.8685	86 16		stx $16				stx tmp2		; save data stack index
.8687	a6 54		ldx $54				ldx FIndex		; X= FP stack index
.8689	b5 7d		lda $7d,x			lda FSMant3,x		; copy mantissa
.868b	91 14		sta ($14),y			sta (tmp1),y
.868d	b5 73		lda $73,x			lda FSMant2,x
.868f	c8		iny				iny
.8690	91 14		sta ($14),y			sta (tmp1),y
.8692	b5 69		lda $69,x			lda FSMant1,x
.8694	c8		iny				iny
.8695	91 14		sta ($14),y			sta (tmp1),y
.8697	b5 5f		lda $5f,x			lda FSMant0,x
.8699	c8		iny				iny
.869a	91 14		sta ($14),y			sta (tmp1),y
.869c	b5 55		lda $55,x			lda FSExp,x		; copy exponent
.869e	c8		iny				iny
.869f	91 14		sta ($14),y			sta (tmp1),y
.86a1	e6 54		inc $54				inc FIndex		; FDrop
.86a3	a6 16		ldx $16				ldx tmp2		; restore data stack index
=41					CodeLen	.var *-XtPtr1
=$86a5					Here1 = *	; remember here
>867a	29					.byte CodeLen	;patch wh_CodeLength
.86a5	60		rts				rts
>86a6	46 2c				Name0:	.text "F,"	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=34344					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>86a8	82					.byte (("F,"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=48					LinkDisplacement = Nt0-WordListLink
>86a9	10					.byte WordFlags	;wh_Flags
>86aa	03					.byte 3	;wh_CodeLength
>86ab	30					  .byte LinkDisplacement	; offset to previous nt
=$86ac					XtPtr1 ::= *
=34344					WordListLink ::= Nt0 ; remember the nt of this word for later
.86ac	a5 00		lda $00		FComma:		lda cp+0		; store f at Here
.86ae	a4 01		ldy $01				ldy cp+1
.86b0	20 7f 86	jsr $867f			jsr FStore_YA
.86b3	a9 05		lda #$05			lda #Float_Size
.86b5	4c b7 d0	jmp $d0b7			jmp Allot_ZA
=12					CodeLen	.var *-XtPtr1
=$86b8					Here1 = *	; remember here
>86aa	0c					.byte CodeLen	;patch wh_CodeLength
>86b8	46 30 21			Name0:	.text "F0!"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=34363					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>86bb	23					.byte (("F0!"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=19					LinkDisplacement = Nt0-WordListLink
>86bc	10					.byte WordFlags	;wh_Flags
>86bd	03					.byte 3	;wh_CodeLength
>86be	13					  .byte LinkDisplacement	; offset to previous nt
=$86bf					XtPtr1 ::= *
=34363					WordListLink ::= Nt0 ; remember the nt of this word for later
.86bf	20 ab 88	jsr $88ab	FZStore:	jsr F0
.86c2	4c 7c 86	jmp $867c			jmp FStore
=6					CodeLen	.var *-XtPtr1
=$86c5					Here1 = *	; remember here
>86bd	06					.byte CodeLen	;patch wh_CodeLength
>86c5	46 30 3d			Name0:	.text "F0="	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=34376					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>86c8	a3					.byte (("F0="[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>86c9	10					.byte WordFlags	;wh_Flags
>86ca	03					.byte 3	;wh_CodeLength
>86cb	0d					  .byte LinkDisplacement	; offset to previous nt
=$86cc					XtPtr1 ::= *
=34376					WordListLink ::= Nt0 ; remember the nt of this word for later
.86cc	a4 54		ldy $54		FZEq:		ldy FIndex
.86ce	b9 5f 00	lda $005f,y			lda FSMant0,y
.86d1	d0 24		bne $86f7			bne FFalse1
.86d3					FTrue1:
.86d3	e6 54		inc $54				inc FIndex	; FDrop
.86d5	4c c9 c7	jmp $c7c9			jmp True	; return true
=12					CodeLen	.var *-XtPtr1
=$86d8					Here1 = *	; remember here
>86ca	0c					.byte CodeLen	;patch wh_CodeLength
>86d8	46 30 3c 3e			Name0:	.text "F0<>"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=34396					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>86dc	c4					.byte (("F0<>"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=20					LinkDisplacement = Nt0-WordListLink
>86dd	10					.byte WordFlags	;wh_Flags
>86de	03					.byte 3	;wh_CodeLength
>86df	14					  .byte LinkDisplacement	; offset to previous nt
=$86e0					XtPtr1 ::= *
=34396					WordListLink ::= Nt0 ; remember the nt of this word for later
.86e0	a4 54		ldy $54		FZNe:		ldy FIndex
.86e2	b9 5f 00	lda $005f,y			lda FSMant0,y
.86e5	d0 ec		bne $86d3			bne FTrue1
.86e7	f0 0e		beq $86f7			beq FFalse1
=9					CodeLen	.var *-XtPtr1
=$86e9					Here1 = *	; remember here
>86de	09					.byte CodeLen	;patch wh_CodeLength
>86e9	46 30 3c			Name0:	.text "F0<"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=34412					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>86ec	83					.byte (("F0<"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=16					LinkDisplacement = Nt0-WordListLink
>86ed	10					.byte WordFlags	;wh_Flags
>86ee	03					.byte 3	;wh_CodeLength
>86ef	10					  .byte LinkDisplacement	; offset to previous nt
=$86f0					XtPtr1 ::= *
=34412					WordListLink ::= Nt0 ; remember the nt of this word for later
.86f0	a4 54		ldy $54		FZLt:		ldy FIndex
.86f2	b9 5f 00	lda $005f,y			lda FSMant0,y
.86f5	30 dc		bmi $86d3			bmi FTrue1
.86f7					FFalse1:
.86f7	e6 54		inc $54				inc FIndex	; FDrop
.86f9	4c db c7	jmp $c7db			jmp False	; return false
=12					CodeLen	.var *-XtPtr1
=$86fc					Here1 = *	; remember here
>86ee	0c					.byte CodeLen	;patch wh_CodeLength
>86fc	46 30 3e 3d			Name0:	.text "F0>="	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=34432					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>8700	a4					.byte (("F0>="[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=20					LinkDisplacement = Nt0-WordListLink
>8701	10					.byte WordFlags	;wh_Flags
>8702	03					.byte 3	;wh_CodeLength
>8703	14					  .byte LinkDisplacement	; offset to previous nt
=$8704					XtPtr1 ::= *
=34432					WordListLink ::= Nt0 ; remember the nt of this word for later
.8704	a4 54		ldy $54		FZGe:		ldy FIndex
.8706	b9 5f 00	lda $005f,y			lda FSMant0,y
.8709	10 c8		bpl $86d3			bpl FTrue1
.870b	30 ea		bmi $86f7			bmi FFalse1
=9					CodeLen	.var *-XtPtr1
=$870d					Here1 = *	; remember here
>8702	09					.byte CodeLen	;patch wh_CodeLength
>870d	46 30 3e			Name0:	.text "F0>"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=34448					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>8710	c3					.byte (("F0>"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=16					LinkDisplacement = Nt0-WordListLink
>8711	10					.byte WordFlags	;wh_Flags
>8712	03					.byte 3	;wh_CodeLength
>8713	10					  .byte LinkDisplacement	; offset to previous nt
=$8714					XtPtr1 ::= *
=34448					WordListLink ::= Nt0 ; remember the nt of this word for later
.8714	a4 54		ldy $54		FZGt:		ldy FIndex
.8716	b9 5f 00	lda $005f,y			lda FSMant0,y
.8719	30 dc		bmi $86f7			bmi FFalse1
.871b	d0 b6		bne $86d3			bne FTrue1
.871d	f0 d8		beq $86f7			beq FFalse1
=11					CodeLen	.var *-XtPtr1
=$871f					Here1 = *	; remember here
>8712	0b					.byte CodeLen	;patch wh_CodeLength
>871f	46 30 3c 3d			Name0:	.text "F0<="	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=34467					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>8723	a4					.byte (("F0<="[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=19					LinkDisplacement = Nt0-WordListLink
>8724	10					.byte WordFlags	;wh_Flags
>8725	03					.byte 3	;wh_CodeLength
>8726	13					  .byte LinkDisplacement	; offset to previous nt
=$8727					XtPtr1 ::= *
=34467					WordListLink ::= Nt0 ; remember the nt of this word for later
.8727	a4 54		ldy $54		FZLe:		ldy FIndex
.8729	b9 5f 00	lda $005f,y			lda FSMant0,y
.872c	30 a5		bmi $86d3			bmi FTrue1
.872e	d0 c7		bne $86f7			bne FFalse1
.8730	f0 a1		beq $86d3			beq FTrue1
=11					CodeLen	.var *-XtPtr1
=$8732					Here1 = *	; remember here
>8725	0b					.byte CodeLen	;patch wh_CodeLength
>8732	46 3c				Name0:	.text "F<"	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=34484					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>8734	82					.byte (("F<"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=17					LinkDisplacement = Nt0-WordListLink
>8735	10					.byte WordFlags	;wh_Flags
>8736	03					.byte 3	;wh_CodeLength
>8737	11					  .byte LinkDisplacement	; offset to previous nt
=$8738					XtPtr1 ::= *
=34484					WordListLink ::= Nt0 ; remember the nt of this word for later
.8738	20 6a 84	jsr $846a	FLt:		jsr FCmpA
.873b	30 32		bmi $876f			bmi FTrue2
.873d					FFalse2:
.873d	e6 54		inc $54				inc FIndex	; FDrop
.873f	e6 54		inc $54				inc FIndex	; FDrop
.8741	4c db c7	jmp $c7db			jmp False	; return False
=12					CodeLen	.var *-XtPtr1
=$8744					Here1 = *	; remember here
>8736	0c					.byte CodeLen	;patch wh_CodeLength
>8744	46 3e 3d			Name0:	.text "F>="	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=34503					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>8747	a3					.byte (("F>="[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=19					LinkDisplacement = Nt0-WordListLink
>8748	10					.byte WordFlags	;wh_Flags
>8749	03					.byte 3	;wh_CodeLength
>874a	13					  .byte LinkDisplacement	; offset to previous nt
=$874b					XtPtr1 ::= *
=34503					WordListLink ::= Nt0 ; remember the nt of this word for later
.874b	20 6a 84	jsr $846a	FGe:		jsr FCmpA
.874e	10 1f		bpl $876f			bpl FTrue2
.8750	30 eb		bmi $873d			bmi FFalse2
=7					CodeLen	.var *-XtPtr1
=$8752					Here1 = *	; remember here
>8749	07					.byte CodeLen	;patch wh_CodeLength
>8752	46 3e				Name0:	.text "F>"	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=34516					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>8754	c2					.byte (("F>"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>8755	10					.byte WordFlags	;wh_Flags
>8756	03					.byte 3	;wh_CodeLength
>8757	0d					  .byte LinkDisplacement	; offset to previous nt
=$8758					XtPtr1 ::= *
=34516					WordListLink ::= Nt0 ; remember the nt of this word for later
.8758	20 6a 84	jsr $846a	FGt:		jsr FCmpA
.875b	30 e0		bmi $873d			bmi FFalse2
.875d	d0 10		bne $876f			bne FTrue2
.875f	f0 dc		beq $873d			beq FFalse2
=9					CodeLen	.var *-XtPtr1
=$8761					Here1 = *	; remember here
>8756	09					.byte CodeLen	;patch wh_CodeLength
>8761	46 3c 3d			Name0:	.text "F<="	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=34532					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>8764	a3					.byte (("F<="[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=16					LinkDisplacement = Nt0-WordListLink
>8765	10					.byte WordFlags	;wh_Flags
>8766	03					.byte 3	;wh_CodeLength
>8767	10					  .byte LinkDisplacement	; offset to previous nt
=$8768					XtPtr1 ::= *
=34532					WordListLink ::= Nt0 ; remember the nt of this word for later
.8768	20 6a 84	jsr $846a	FLe:		jsr FCmpA
.876b	30 02		bmi $876f			bmi FTrue2
.876d	d0 ce		bne $873d			bne FFalse2
.876f					FTrue2:
.876f	e6 54		inc $54				inc FIndex	; FDrop
.8771	e6 54		inc $54				inc FIndex	; FDrop
.8773	4c c9 c7	jmp $c7c9			jmp True	; return True
=14					CodeLen	.var *-XtPtr1
=$8776					Here1 = *	; remember here
>8766	0e					.byte CodeLen	;patch wh_CodeLength
>8776	46 3c 3e			Name0:	.text "F<>"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=34553					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>8779	c3					.byte (("F<>"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=21					LinkDisplacement = Nt0-WordListLink
>877a	10					.byte WordFlags	;wh_Flags
>877b	03					.byte 3	;wh_CodeLength
>877c	15					  .byte LinkDisplacement	; offset to previous nt
=$877d					XtPtr1 ::= *
=34553					WordListLink ::= Nt0 ; remember the nt of this word for later
.877d	20 6a 84	jsr $846a	FNe:		jsr FCmpA
.8780	d0 ed		bne $876f			bne FTrue2
.8782	f0 b9		beq $873d			beq FFalse2
=7					CodeLen	.var *-XtPtr1
=$8784					Here1 = *	; remember here
>877b	07					.byte CodeLen	;patch wh_CodeLength
>8784	46 3d				Name0:	.text "F="	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=34566					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>8786	a2					.byte (("F="[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>8787	10					.byte WordFlags	;wh_Flags
>8788	03					.byte 3	;wh_CodeLength
>8789	0d					  .byte LinkDisplacement	; offset to previous nt
=$878a					XtPtr1 ::= *
=34566					WordListLink ::= Nt0 ; remember the nt of this word for later
.878a	20 6a 84	jsr $846a	FEq:		jsr FCmpA
.878d	d0 ae		bne $873d			bne FFalse2
.878f	f0 de		beq $876f			beq FTrue2
=7					CodeLen	.var *-XtPtr1
=$8791					Here1 = *	; remember here
>8788	07					.byte CodeLen	;patch wh_CodeLength
>8791	46 7e 41 62 73			Name0:	.text "F~Abs"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=34582					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>8796	65					.byte (("F~Abs"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=16					LinkDisplacement = Nt0-WordListLink
>8797	10					.byte WordFlags	;wh_Flags
>8798	03					.byte 3	;wh_CodeLength
>8799	10					  .byte LinkDisplacement	; offset to previous nt
=$879a					XtPtr1 ::= *
=34582					WordListLink ::= Nt0 ; remember the nt of this word for later
.879a	20 43 86	jsr $8643	FTAbs:		jsr FMRot
.879d	20 70 8b	jsr $8b70			jsr FMinus
.87a0	20 cb 8b	jsr $8bcb			jsr FAbs
.87a3	4c 58 87	jmp $8758			jmp FGt
=12					CodeLen	.var *-XtPtr1
=$87a6					Here1 = *	; remember here
>8798	0c					.byte CodeLen	;patch wh_CodeLength
>87a6	46 7e 52 65 6c			Name0:	.text "F~Rel"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=34603					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>87ab	85					.byte (("F~Rel"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=21					LinkDisplacement = Nt0-WordListLink
>87ac	10					.byte WordFlags	;wh_Flags
>87ad	03					.byte 3	;wh_CodeLength
>87ae	15					  .byte LinkDisplacement	; offset to previous nt
=$87af					XtPtr1 ::= *
=34603					WordListLink ::= Nt0 ; remember the nt of this word for later
.87af	20 76 85	jsr $8576	FTRel:		jsr FOver
.87b2	a9 03		lda #$03			lda #3
.87b4	20 9c 85	jsr $859c			jsr FPickA
.87b7	20 30 8b	jsr $8b30			jsr FPlus
.87ba	20 cb 8b	jsr $8bcb			jsr FAbs
.87bd	20 fe 8b	jsr $8bfe			jsr FStar		; r1 r2 r3*|r1+r2|
.87c0	20 43 86	jsr $8643			jsr FMRot		; r3*|r1+r2| r1 r2
.87c3	20 70 8b	jsr $8b70			jsr FMinus
.87c6	20 cb 8b	jsr $8bcb			jsr FAbs
.87c9	4c 58 87	jmp $8758			jmp FGt
=29					CodeLen	.var *-XtPtr1
=$87cc					Here1 = *	; remember here
>87ad	1d					.byte CodeLen	;patch wh_CodeLength
>87cc	46 7e				Name0:	.text "F~"	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=34638					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>87ce	c2					.byte (("F~"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=35					LinkDisplacement = Nt0-WordListLink
>87cf	10					.byte WordFlags	;wh_Flags
>87d0	03					.byte 3	;wh_CodeLength
>87d1	23					  .byte LinkDisplacement	; offset to previous nt
=$87d2					XtPtr1 ::= *
=34638					WordListLink ::= Nt0 ; remember the nt of this word for later
.87d2	a4 54		ldy $54		FTilde:		ldy FIndex
.87d4	b9 5f 00	lda $005f,y			lda FSMant0,y
.87d7	30 06		bmi $87df			bmi _10			; r3<0
.87d9	d0 bf		bne $879a			bne FTAbs		; r3>0
.87db	e6 54		inc $54				inc FIndex		; r3=0
.87dd	d0 ab		bne $878a			bne FEq
.87df	20 a5 8b	jsr $8ba5	_10:		jsr FNegate
.87e2	4c af 87	jmp $87af			jmp FTRel
=19					CodeLen	.var *-XtPtr1
=$87e5					Here1 = *	; remember here
>87d0	13					.byte CodeLen	;patch wh_CodeLength
>87e5	46 56 61 72 69 61 62 6c		Name0:	.text "FVariable"	;  name of word as a string, ending at wh_NameLastChar
>87ed	65
=9					NameLength = *-Name0
=34670					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>87ee	a9					.byte (("FVariable"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=24					WordFlags ::= IM+NN	; modifiable copy, remember for later
=32					LinkDisplacement = Nt0-WordListLink
>87ef	18					.byte WordFlags	;wh_Flags
>87f0	03					.byte 3	;wh_CodeLength
>87f1	20					  .byte LinkDisplacement	; offset to previous nt
=$87f2					XtPtr1 ::= *
=34670					WordListLink ::= Nt0 ; remember the nt of this word for later
.87f2	20 cd d1	jsr $d1cd	FVariable:	jsr Create		; compile word header & push PFA adr
.87f5	20 e0 cb	jsr $cbe0			jsr adjust_z		; fix word code length
.87f8	20 ab 88	jsr $88ab			jsr F0			; alloc & init data
.87fb	4c ac 86	jmp $86ac			jmp FComma
=12					CodeLen	.var *-XtPtr1
=$87fe					Here1 = *	; remember here
>87f0	0c					.byte CodeLen	;patch wh_CodeLength
>87fe	46 4c 69 74 65 72 61 6c		Name0:	.text "FLiteral"	;  name of word as a string, ending at wh_NameLastChar
=8					NameLength = *-Name0
=34694					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>8806	88					.byte (("FLiteral"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=24					WordFlags ::= IM+NN	; modifiable copy, remember for later
=24					LinkDisplacement = Nt0-WordListLink
>8807	18					.byte WordFlags	;wh_Flags
>8808	03					.byte 3	;wh_CodeLength
>8809	18					  .byte LinkDisplacement	; offset to previous nt
=$880a					XtPtr1 ::= *
=34694					WordListLink ::= Nt0 ; remember the nt of this word for later
.880a	20 1f 88	jsr $881f	FLiteral:	jsr FLitTest
.880d	f0 0a		beq $8819			beq _Short
.880f	a9 48		lda #$48			lda #<FLitI		; compile JSR FLitI
.8811	a0 88		ldy #$88			ldy #>FLitI
.8813	20 78 dd	jsr $dd78			jsr Jsr_Comma_YA
.8816	4c ac 86	jmp $86ac			jmp FComma		; compile inline operand, return
.8819	20 2b 88	jsr $882b	_Short:		jsr FLitShort
.881c	4c 78 dd	jmp $dd78			jmp Jsr_Comma_YA	; compile jsr FLitYA, & return
=21					CodeLen	.var *-XtPtr1
=$881f					Here1 = *	; remember here
>8808	15					.byte CodeLen	;patch wh_CodeLength
.881f					FLitTest:
.881f	a4 54		ldy $54				ldy FIndex
.8821	b9 69 00	lda $0069,y			lda FSMant1,y		; will short work?
.8824	19 73 00	ora $0073,y			ora FSMant2,y
.8827	19 7d 00	ora $007d,y			ora FSMant3,y
.882a	60		rts				rts
.882b					FLitShort:
.882b	a9 a9		lda #$a9			lda #$a9		; compile LDA #mant0
.882d	20 3e dd	jsr $dd3e			jsr C_Comma_A
.8830	b9 5f 00	lda $005f,y			lda FSMant0,y
.8833	20 3e dd	jsr $dd3e			jsr C_Comma_A
.8836	a9 a0		lda #$a0			lda #$a0		; compile LDY #exp
.8838	20 3e dd	jsr $dd3e			jsr C_Comma_A
.883b	b9 55 00	lda $0055,y			lda FSExp,y
.883e	20 3e dd	jsr $dd3e			jsr C_Comma_A
.8841	e6 54		inc $54				inc FIndex		; FDrop
.8843	a9 92		lda #$92			lda #<FLitYA		; point at FLitYA
.8845	a0 88		ldy #$88			ldy #>FLitYA
.8847	60		rts				rts
.8848					FLitI:
.8848	68		pla				pla			; tmp2= RTS addr
.8849	85 16		sta $16				sta tmp2+0
.884b	18		clc				clc			; bump RTS addr over inline float data
.884c	69 05		adc #$05			adc #Float_Size
.884e	a8		tay				tay
.884f	68		pla				pla
.8850	85 17		sta $17				sta tmp2+1
.8852	69 00		adc #$00			adc #0
.8854	48		pha				pha
.8855	98		tya				tya
.8856	48		pha				pha
.8857	a0 01		ldy #$01			ldy #1			; correct for RTS addr
.8859	4c 58 86	jmp $8658			jmp FAt_Tmp2Y		; fetch inline data, & return
>885c	46 43 6f 6e 73 74 61 6e		Name0:	.text "FConstant"	;  name of word as a string, ending at wh_NameLastChar
>8864	74
=9					NameLength = *-Name0
=34789					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>8865	89					.byte (("FConstant"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=95					LinkDisplacement = Nt0-WordListLink
>8866	10					.byte WordFlags	;wh_Flags
>8867	03					.byte 3	;wh_CodeLength
>8868	5f					  .byte LinkDisplacement	; offset to previous nt
=$8869					XtPtr1 ::= *
=34789					WordListLink ::= Nt0 ; remember the nt of this word for later
.8869	20 20 d1	jsr $d120	FConstant:	jsr Header_Comma	; compile word header
.886c	20 1f 88	jsr $881f			jsr FLitTest		; will short work?
.886f	f0 0d		beq $887e			beq _Short
.8871	a9 87		lda #$87			lda #<FConstantRun	; compile JSR
.8873	a0 88		ldy #$88			ldy #>FConstantRun
.8875	20 78 dd	jsr $dd78			jsr Jsr_Comma_YA
.8878	20 e0 cb	jsr $cbe0			jsr adjust_z
.887b	4c ac 86	jmp $86ac			jmp FComma		; compile inline operand, & return
.887e					_Short:
.887e	20 2b 88	jsr $882b			jsr FLitShort		; compile load value
.8881	20 8e dd	jsr $dd8e			jsr Jmp_Comma_YA	; compile JMP
.8884	4c e0 cb	jmp $cbe0			jmp adjust_z
=30					CodeLen	.var *-XtPtr1
=$8887					Here1 = *	; remember here
>8867	1e					.byte CodeLen	;patch wh_CodeLength
.8887					FConstantRun:
.8887	68		pla				pla			; tmp2= pop RTS addr
.8888	85 16		sta $16				sta tmp2+0
.888a	68		pla				pla
.888b	85 17		sta $17				sta tmp2+1
.888d	a0 01		ldy #$01			ldy #1			; correct for RTS addr
.888f	4c 58 86	jmp $8658			jmp FAt_Tmp2Y		; fetch inline data, & return
.8892					FLitYA:
.8892	20 c8 84	jsr $84c8			jsr FAllocX		; alloc FP stack entry, X=FP stack index
.8895	95 5f		sta $5f,x			sta FSMant0,x		; Mant= A,0,0,0
.8897	94 55		sty $55,x			sty FSExp,x	; sty dir,x exists
.8899	a9 00		lda #$00			lda #0
.889b	95 69		sta $69,x			sta FSMant1,x
.889d	95 73		sta $73,x			sta FSMant2,x
.889f	95 7d		sta $7d,x			sta FSMant3,x
.88a1	a6 14		ldx $14				ldx tmp1+0		; restore data stack index
.88a3	60		rts				rts
>88a4	30 2e 65			Name0:	.text "0.e"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=34855					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>88a7	a3					.byte (("0.e"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=66					LinkDisplacement = Nt0-WordListLink
>88a8	10					.byte WordFlags	;wh_Flags
>88a9	03					.byte 3	;wh_CodeLength
>88aa	42					  .byte LinkDisplacement	; offset to previous nt
=$88ab					XtPtr1 ::= *
=34855					WordListLink ::= Nt0 ; remember the nt of this word for later
.88ab	a9 00		lda #$00	F0:		lda #0			; FSMant0
.88ad	a0 80		ldy #$80			ldy #$80		; FSExp
.88af	d0 e1		bne $8892			bne FLitYA
=6					CodeLen	.var *-XtPtr1
=$88b1					Here1 = *	; remember here
>88a9	06					.byte CodeLen	;patch wh_CodeLength
>88b1	31 30 30 30 2e 65		Name0:	.text "1000.e"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=34871					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>88b7	a6					.byte (("1000.e"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=16					LinkDisplacement = Nt0-WordListLink
>88b8	10					.byte WordFlags	;wh_Flags
>88b9	03					.byte 3	;wh_CodeLength
>88ba	10					  .byte LinkDisplacement	; offset to previous nt
=$88bb					XtPtr1 ::= *
=34871					WordListLink ::= Nt0 ; remember the nt of this word for later
.88bb	a9 7d		lda #$7d	F1000:		lda #$7d
.88bd	a0 0a		ldy #$0a			ldy #10
.88bf	d0 d1		bne $8892			bne FLitYA
=6					CodeLen	.var *-XtPtr1
=$88c1					Here1 = *	; remember here
>88b9	06					.byte CodeLen	;patch wh_CodeLength
>88c1	31 30 2e 65			Name0:	.text "10.e"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=34885					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>88c5	a4					.byte (("10.e"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=14					LinkDisplacement = Nt0-WordListLink
>88c6	10					.byte WordFlags	;wh_Flags
>88c7	03					.byte 3	;wh_CodeLength
>88c8	0e					  .byte LinkDisplacement	; offset to previous nt
=$88c9					XtPtr1 ::= *
=34885					WordListLink ::= Nt0 ; remember the nt of this word for later
.88c9	a9 50		lda #$50	F10:		lda #$50
.88cb	a0 04		ldy #$04			ldy #4
.88cd	d0 c3		bne $8892			bne FLitYA
=6					CodeLen	.var *-XtPtr1
=$88cf					Here1 = *	; remember here
>88c7	06					.byte CodeLen	;patch wh_CodeLength
>88cf	32 2e 65			Name0:	.text "2.e"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=34898					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>88d2	a3					.byte (("2.e"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>88d3	10					.byte WordFlags	;wh_Flags
>88d4	03					.byte 3	;wh_CodeLength
>88d5	0d					  .byte LinkDisplacement	; offset to previous nt
=$88d6					XtPtr1 ::= *
=34898					WordListLink ::= Nt0 ; remember the nt of this word for later
.88d6	a9 40		lda #$40	F2:		lda #$40
.88d8	a0 02		ldy #$02			ldy #2
.88da	d0 b6		bne $8892			bne FLitYA
=6					CodeLen	.var *-XtPtr1
=$88dc					Here1 = *	; remember here
>88d4	06					.byte CodeLen	;patch wh_CodeLength
>88dc	31 2e 65			Name0:	.text "1.e"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=34911					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>88df	a3					.byte (("1.e"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>88e0	10					.byte WordFlags	;wh_Flags
>88e1	03					.byte 3	;wh_CodeLength
>88e2	0d					  .byte LinkDisplacement	; offset to previous nt
=$88e3					XtPtr1 ::= *
=34911					WordListLink ::= Nt0 ; remember the nt of this word for later
.88e3	a9 40		lda #$40	F1:		lda #$40
.88e5	a0 01		ldy #$01			ldy #1
.88e7	d0 a9		bne $8892			bne FLitYA
=6					CodeLen	.var *-XtPtr1
=$88e9					Here1 = *	; remember here
>88e1	06					.byte CodeLen	;patch wh_CodeLength
>88e9	2e 31 65			Name0:	.text ".1e"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=34924					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>88ec	a3					.byte ((".1e"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>88ed	10					.byte WordFlags	;wh_Flags
>88ee	03					.byte 3	;wh_CodeLength
>88ef	0d					  .byte LinkDisplacement	; offset to previous nt
=$88f0					XtPtr1 ::= *
=34924					WordListLink ::= Nt0 ; remember the nt of this word for later
.88f0	20 87 88	jsr $8887	F10th:		jsr FConstantRun
>88f3	67 66 66 66					.dword $66666667	; 32 bit signed binary mantissa.  $40000000 = +0.5
>88f7	fd						.char -3		; 8 bit signed binary exponent.  $00 = 2**0
=8					CodeLen	.var *-XtPtr1
=$88f8					Here1 = *	; remember here
>88ee	08					.byte CodeLen	;patch wh_CodeLength
>88f8	50 69				Name0:	.text "Pi"	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=34938					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>88fa	22					.byte (("Pi"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=14					LinkDisplacement = Nt0-WordListLink
>88fb	10					.byte WordFlags	;wh_Flags
>88fc	03					.byte 3	;wh_CodeLength
>88fd	0e					  .byte LinkDisplacement	; offset to previous nt
=$88fe					XtPtr1 ::= *
=34938					WordListLink ::= Nt0 ; remember the nt of this word for later
.88fe	20 87 88	jsr $8887	FPi:		jsr FConstantRun
>8901	51 ed 87 64					.dword $6487ed51	; 32 bit signed binary mantissa.  $40000000 = +0.5
>8905	02						.char 2		; 8 bit signed binary exponent.  $00 = 2**0
=8					CodeLen	.var *-XtPtr1
=$8906					Here1 = *	; remember here
>88fc	08					.byte CodeLen	;patch wh_CodeLength
>8906	50 69 2f 32			Name0:	.text "Pi/2"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=34954					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>890a	44					.byte (("Pi/2"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=16					LinkDisplacement = Nt0-WordListLink
>890b	10					.byte WordFlags	;wh_Flags
>890c	03					.byte 3	;wh_CodeLength
>890d	10					  .byte LinkDisplacement	; offset to previous nt
=$890e					XtPtr1 ::= *
=34954					WordListLink ::= Nt0 ; remember the nt of this word for later
.890e	20 87 88	jsr $8887	FPiH:		jsr FConstantRun
>8911	51 ed 87 64					.dword $6487ed51	; 32 bit signed binary mantissa.  $40000000 = +0.5
>8915	01						.char 1		; 8 bit signed binary exponent.  $00 = 2**0
=8					CodeLen	.var *-XtPtr1
=$8916					Here1 = *	; remember here
>890c	08					.byte CodeLen	;patch wh_CodeLength
>8916	50 69 2f 34			Name0:	.text "Pi/4"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=34970					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>891a	84					.byte (("Pi/4"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=16					LinkDisplacement = Nt0-WordListLink
>891b	10					.byte WordFlags	;wh_Flags
>891c	03					.byte 3	;wh_CodeLength
>891d	10					  .byte LinkDisplacement	; offset to previous nt
=$891e					XtPtr1 ::= *
=34970					WordListLink ::= Nt0 ; remember the nt of this word for later
.891e	20 87 88	jsr $8887	FPiQ:		jsr FConstantRun
>8921	51 ed 87 64					.dword $6487ed51	; 32 bit signed binary mantissa.  $40000000 = +0.5
>8925	00						.char 0		; 8 bit signed binary exponent.  $00 = 2**0
=8					CodeLen	.var *-XtPtr1
=$8926					Here1 = *	; remember here
>891c	08					.byte CodeLen	;patch wh_CodeLength
>8926	32 50 69			Name0:	.text "2Pi"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=34985					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>8929	23					.byte (("2Pi"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=15					LinkDisplacement = Nt0-WordListLink
>892a	10					.byte WordFlags	;wh_Flags
>892b	03					.byte 3	;wh_CodeLength
>892c	0f					  .byte LinkDisplacement	; offset to previous nt
=$892d					XtPtr1 ::= *
=34985					WordListLink ::= Nt0 ; remember the nt of this word for later
.892d	20 87 88	jsr $8887	F2Pi:		jsr FConstantRun
>8930	51 ed 87 64					.dword $6487ed51	; 32 bit signed binary mantissa.  $40000000 = +0.5
>8934	03						.char 3		; 8 bit signed binary exponent.  $00 = 2**0
=8					CodeLen	.var *-XtPtr1
=$8935					Here1 = *	; remember here
>892b	08					.byte CodeLen	;patch wh_CodeLength
>8935	46 2e 45			Name0:	.text "F.E"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=35000					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>8938	a3					.byte (("F.E"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=15					LinkDisplacement = Nt0-WordListLink
>8939	10					.byte WordFlags	;wh_Flags
>893a	03					.byte 3	;wh_CodeLength
>893b	0f					  .byte LinkDisplacement	; offset to previous nt
=$893c					XtPtr1 ::= *
=35000					WordListLink ::= Nt0 ; remember the nt of this word for later
.893c	20 87 88	jsr $8887	FE:		jsr FConstantRun
>893f	2c 2a fc 56					.dword $56fc2a2c	; 32 bit signed binary mantissa.  $40000000 = +0.5
>8943	02						.char 2		; 8 bit signed binary exponent.  $00 = 2**0
=8					CodeLen	.var *-XtPtr1
=$8944					Here1 = *	; remember here
>893a	08					.byte CodeLen	;patch wh_CodeLength
>8944	46 56 61 6c 75 65		Name0:	.text "FValue"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=35018					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>894a	a6					.byte (("FValue"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=24					WordFlags ::= IM+NN	; modifiable copy, remember for later
=18					LinkDisplacement = Nt0-WordListLink
>894b	18					.byte WordFlags	;wh_Flags
>894c	03					.byte 3	;wh_CodeLength
>894d	12					  .byte LinkDisplacement	; offset to previous nt
=$894e					XtPtr1 ::= *
=35018					WordListLink ::= Nt0 ; remember the nt of this word for later
.894e	20 20 d1	jsr $d120	FValue:		jsr Header_Comma	; compile word header
.8951	a9 5e		lda #$5e			lda #<FValue_runtime	; compile JSR FValue_runtime
.8953	a0 89		ldy #$89			ldy #>FValue_runtime
.8955	20 78 dd	jsr $dd78			jsr Jsr_Comma_YA
.8958	20 e0 cb	jsr $cbe0			jsr adjust_z		; fix word length
.895b	4c ac 86	jmp $86ac			jmp FComma		; alloc & init value
=16					CodeLen	.var *-XtPtr1
=$895e					Here1 = *	; remember here
>894c	10					.byte CodeLen	;patch wh_CodeLength
.895e					FValue_runtime:
.895e	4c 87 88	jmp $8887			jmp FConstantRun
>8961	46 53 63 61 6c 65		Name0:	.text "FScale"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=35047					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>8967	a6					.byte (("FScale"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=29					LinkDisplacement = Nt0-WordListLink
>8968	10					.byte WordFlags	;wh_Flags
>8969	03					.byte 3	;wh_CodeLength
>896a	1d					  .byte LinkDisplacement	; offset to previous nt
=$896b					XtPtr1 ::= *
=35047					WordListLink ::= Nt0 ; remember the nt of this word for later
.896b	20 c8 c3	jsr $c3c8	FScale:		jsr PopA		; pop n
.896e	86 14		stx $14		FScaleA:	stx tmp1		; save data stack index
.8970	a6 54		ldx $54				ldx FIndex		; X= FP stack index
.8972	b4 5f		ldy $5f,x			ldy FSMant0,x		; mantissa zero?
.8974	f0 07		beq $897d			beq _8
.8976	18		clc				clc
.8977	75 55		adc $55,x			adc FSExp,x
.8979	95 55		sta $55,x			sta FSExp,x
.897b	70 03		bvs $8980			bvs _overflow		; overflow or underflow?
.897d	a6 14		ldx $14		_8:		ldx tmp1		; restore data stack index
.897f	60		rts				rts
.8980					_overflow:
.8980	a6 14		ldx $14				ldx tmp1		; restore data stack index
.8982	20 43 c4	jsr $c443			jsr Throw_FpOutOfRange
=26					CodeLen	.var *-XtPtr1
=$8985					Here1 = *	; remember here
>8969	1a					.byte CodeLen	;patch wh_CodeLength
>8985	46 32 2a			Name0:	.text "F2*"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=35080					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>8988	43					.byte (("F2*"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=33					LinkDisplacement = Nt0-WordListLink
>8989	10					.byte WordFlags	;wh_Flags
>898a	03					.byte 3	;wh_CodeLength
>898b	21					  .byte LinkDisplacement	; offset to previous nt
=$898c					XtPtr1 ::= *
=35080					WordListLink ::= Nt0 ; remember the nt of this word for later
.898c	a9 01		lda #$01	F2Star:		lda #1
.898e	d0 de		bne $896e			bne FScaleA
=4					CodeLen	.var *-XtPtr1
=$8990					Here1 = *	; remember here
>898a	04					.byte CodeLen	;patch wh_CodeLength
>8990	46 32 2f			Name0:	.text "F2/"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=35091					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>8993	e3					.byte (("F2/"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=11					LinkDisplacement = Nt0-WordListLink
>8994	10					.byte WordFlags	;wh_Flags
>8995	03					.byte 3	;wh_CodeLength
>8996	0b					  .byte LinkDisplacement	; offset to previous nt
=$8997					XtPtr1 ::= *
=35091					WordListLink ::= Nt0 ; remember the nt of this word for later
.8997	a9 ff		lda #$ff	F2Slash:	lda #$ff
.8999	d0 d3		bne $896e			bne FScaleA
=4					CodeLen	.var *-XtPtr1
=$899b					Here1 = *	; remember here
>8995	04					.byte CodeLen	;patch wh_CodeLength
>899b	46 31 30 2a			Name0:	.text "F10*"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=35103					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>899f	44					.byte (("F10*"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=12					LinkDisplacement = Nt0-WordListLink
>89a0	10					.byte WordFlags	;wh_Flags
>89a1	03					.byte 3	;wh_CodeLength
>89a2	0c					  .byte LinkDisplacement	; offset to previous nt
=$89a3					XtPtr1 ::= *
=35103					WordListLink ::= Nt0 ; remember the nt of this word for later
.89a3	20 8c 89	jsr $898c	F10Star:	jsr F2Star
.89a6	20 53 85	jsr $8553			jsr FDup
.89a9	a9 02		lda #$02			lda #2
.89ab	20 6e 89	jsr $896e			jsr FScaleA
.89ae	4c 30 8b	jmp $8b30			jmp FPlus
.89b1	86 14		stx $14		FShiftA:	stx tmp1+0		; save data stack index
.89b3	a6 54		ldx $54				ldx FIndex		; X= FP stack index
.89b5	85 15		sta $15		FShiftAX:	sta tmp1+1		; save desired alignment
.89b7	38		sec				sec			; calc bit shift count
.89b8	f5 55		sbc $55,x			sbc FSExp,x
.89ba	f0 32		beq $89ee			beq _leave
.89bc	70 20		bvs $89de			bvs _overflow
.89be	30 2e		bmi $89ee			bmi _leave
.89c0	c9 20		cmp #$20			cmp #32
.89c2	b0 1c		bcs $89e0			bcs _zero
.89c4	a8		tay				tay
.89c5	a5 15		lda $15				lda tmp1+1
.89c7	95 55		sta $55,x			sta FSExp,x
.89c9	b5 5f		lda $5f,x			lda FSMant0,x
.89cb	c9 80		cmp #$80	_12:		cmp #$80		; mantissa >>=1
.89cd	6a		ror a				ror a
.89ce	76 69		ror $69,x			ror FSMant1,x
.89d0	76 73		ror $73,x			ror FSMant2,x
.89d2	76 7d		ror $7d,x			ror FSMant3,x
.89d4	88		dey				dey
.89d5	d0 f4		bne $89cb			bne _12
.89d7	95 5f		sta $5f,x			sta FSMant0,x
.89d9	b4 55		ldy $55,x	_30:		ldy FSExp,x
.89db	a6 54		ldx $54				ldx FIndex		; restore fp stack index (FShiftAX could have had a funny one)
.89dd	60		rts				rts
.89de	10 0e		bpl $89ee	_overflow:	bpl _leave
.89e0	a5 15		lda $15		_zero:		lda tmp1+1
.89e2	95 55		sta $55,x			sta FSExp,x		; return zero
.89e4	a9 00		lda #$00			lda #0
.89e6	95 5f		sta $5f,x			sta FSMant0,x
.89e8	95 69		sta $69,x			sta FSMant1,x
.89ea	95 73		sta $73,x			sta FSMant2,x
.89ec	95 7d		sta $7d,x			sta FSMant3,x
.89ee	18		clc		_leave:		clc
.89ef	90 e8		bcc $89d9			bcc _30
>89f1	46 6c 6f 6f 72			Name0:	.text "Floor"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=35190					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>89f6	45					.byte (("Floor"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=87					LinkDisplacement = Nt0-WordListLink
>89f7	10					.byte WordFlags	;wh_Flags
>89f8	03					.byte 3	;wh_CodeLength
>89f9	57					  .byte LinkDisplacement	; offset to previous nt
=$89fa					XtPtr1 ::= *
=35190					WordListLink ::= Nt0 ; remember the nt of this word for later
.89fa	a4 54		ldy $54		Floor:		ldy FIndex
.89fc	b9 5f 00	lda $005f,y			lda FSMant0,y		; negative?
.89ff	10 19		bpl $8a1a			bpl _a
.8a01	b9 55 00	lda $0055,y			lda FSExp,y		; > -1 ?
.8a04	10 14		bpl $8a1a			bpl _a
.8a06	a9 80		lda #$80			lda #$80		; return -1
.8a08	99 5f 00	sta $005f,y			sta FSMant0,y
.8a0b	a9 00		lda #$00			lda #0
.8a0d	99 55 00	sta $0055,y			sta FSExp,y
.8a10	99 69 00	sta $0069,y			sta FSMant1,y
.8a13	99 73 00	sta $0073,y			sta FSMant2,y
.8a16	99 7d 00	sta $007d,y			sta FSMant3,y
.8a19	60		rts				rts
.8a1a	a9 1f		lda #$1f	_a:		lda #31
.8a1c	20 b1 89	jsr $89b1			jsr FShiftA
.8a1f	4c aa 8a	jmp $8aaa			jmp FNormX
=40					CodeLen	.var *-XtPtr1
=$8a22					Here1 = *	; remember here
>89f8	28					.byte CodeLen	;patch wh_CodeLength
>8a22	46 54 72 75 6e 63		Name0:	.text "FTrunc"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=35240					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>8a28	66					.byte (("FTrunc"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=50					LinkDisplacement = Nt0-WordListLink
>8a29	10					.byte WordFlags	;wh_Flags
>8a2a	03					.byte 3	;wh_CodeLength
>8a2b	32					  .byte LinkDisplacement	; offset to previous nt
=$8a2c					XtPtr1 ::= *
=35240					WordListLink ::= Nt0 ; remember the nt of this word for later
.8a2c	a4 54		ldy $54		FTrunc:		ldy FIndex
.8a2e	b9 5f 00	lda $005f,y			lda FSMant0,y
.8a31	10 c7		bpl $89fa			bpl Floor
.8a33	20 a5 8b	jsr $8ba5			jsr FNegate
.8a36	20 fa 89	jsr $89fa			jsr Floor
.8a39	4c a5 8b	jmp $8ba5			jmp FNegate
>8a3c	46 52 6f 75 6e 64		Name0:	.text "FRound"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=35266					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>8a42	86					.byte (("FRound"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=26					LinkDisplacement = Nt0-WordListLink
>8a43	10					.byte WordFlags	;wh_Flags
>8a44	03					.byte 3	;wh_CodeLength
>8a45	1a					  .byte LinkDisplacement	; offset to previous nt
=$8a46					XtPtr1 ::= *
=35266					WordListLink ::= Nt0 ; remember the nt of this word for later
.8a46	a9 1f		lda #$1f	FRound:		lda #31
.8a48	20 b1 89	jsr $89b1			jsr FShiftA
.8a4b	90 05		bcc $8a52			bcc _15
.8a4d	a6 14		ldx $14				ldx tmp1+0		; restore data stack index
.8a4f	4c 64 8b	jmp $8b64			jmp F1Plus
.8a52	4c aa 8a	jmp $8aaa	_15:		jmp FNormX
=15					CodeLen	.var *-XtPtr1
=$8a55					Here1 = *	; remember here
>8a44	0f					.byte CodeLen	;patch wh_CodeLength
>8a55	46 49 6e 74 46 72 63		Name0:	.text "FIntFrc"	;  name of word as a string, ending at wh_NameLastChar
=7					NameLength = *-Name0
=35292					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>8a5c	67					.byte (("FIntFrc"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=26					LinkDisplacement = Nt0-WordListLink
>8a5d	10					.byte WordFlags	;wh_Flags
>8a5e	03					.byte 3	;wh_CodeLength
>8a5f	1a					  .byte LinkDisplacement	; offset to previous nt
=$8a60					XtPtr1 ::= *
=35292					WordListLink ::= Nt0 ; remember the nt of this word for later
.8a60	20 53 85	jsr $8553	FIntFrc:	jsr FDup	; ( r1 r1 )
.8a63	20 fa 89	jsr $89fa			jsr Floor	; ( r1 rint )
.8a66	20 0f 86	jsr $860f			jsr FTuck	; ( rint r1 rint )
.8a69	20 70 8b	jsr $8b70			jsr FMinus	; ( rint rfrac )
.8a6c	4c d7 85	jmp $85d7			jmp FSwap	; ( rfrac rint )
=15					CodeLen	.var *-XtPtr1
=$8a6f					Here1 = *	; remember here
>8a5e	0f					.byte CodeLen	;patch wh_CodeLength
>8a6f	46 4d 41 6c 69 67 6e 58		Name0:	.text "FMAlignX"	;  name of word as a string, ending at wh_NameLastChar
=8					NameLength = *-Name0
=35319					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>8a77	08					.byte (("FMAlignX"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=27					LinkDisplacement = Nt0-WordListLink
>8a78	10					.byte WordFlags	;wh_Flags
>8a79	03					.byte 3	;wh_CodeLength
>8a7a	1b					  .byte LinkDisplacement	; offset to previous nt
=$8a7b					XtPtr1 ::= *
=35319					WordListLink ::= Nt0 ; remember the nt of this word for later
.8a7b	86 14		stx $14		FMAlignX:	stx tmp1+0	; save data stack index
.8a7d	a6 54		ldx $54				ldx FIndex	; load FP stack index
.8a7f	e0 09		cpx #$09			cpx #FDim-1	; check FP stack for >=2 entries
.8a81	b0 19		bcs $8a9c			bcs Throw_FPStack_3
.8a83	b5 55		lda $55,x			lda FSExp+0,x	; compare exponents
.8a85	38		sec				sec
.8a86	f5 56		sbc $56,x			sbc FSExp+1,x
.8a88	30 03		bmi $8a8d			bmi _1		; r1 smaller?
.8a8a	d0 08		bne $8a94			bne _2		; r2 smaller?
.8a8c	60		rts				rts
.8a8d					_1:
.8a8d	70 07		bvs $8a96			bvs _2b		; was this a big positive #?
.8a8f	b5 56		lda $56,x	_1b:		lda FSExp+1,x	; make r1 like r2
.8a91	4c b5 89	jmp $89b5			jmp FShiftAX
.8a94					_2:
.8a94	70 f7		bvs $8a8d			bvs _1		; was this a big negative #?
.8a96	b5 55		lda $55,x	_2b:		lda FSExp+0,x	; make r2 like r1
.8a98	e8		inx				inx
.8a99	4c b5 89	jmp $89b5			jmp FShiftAX
=33					CodeLen	.var *-XtPtr1
=$8a9c					Here1 = *	; remember here
>8a79	21					.byte CodeLen	;patch wh_CodeLength
.8a9c	20 39 c4	jsr $c439	Throw_FPStack_3: jsr Throw_FPStack
>8a9f	46 4e 6f 72 6d			Name0:	.text "FNorm"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=35364					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>8aa4	a5					.byte (("FNorm"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=45					LinkDisplacement = Nt0-WordListLink
>8aa5	10					.byte WordFlags	;wh_Flags
>8aa6	03					.byte 3	;wh_CodeLength
>8aa7	2d					  .byte LinkDisplacement	; offset to previous nt
=$8aa8					XtPtr1 ::= *
=35364					WordListLink ::= Nt0 ; remember the nt of this word for later
.8aa8	86 14		stx $14		FNorm:		stx tmp1+0		; save data stack index
.8aaa	a6 54		ldx $54		FNormX:		ldx FIndex		; switch to FP stack
.8aac	b4 55		ldy $55,x			ldy FSExp,x
.8aae	b5 5f		lda $5f,x			lda FSMant0,x		; mantissa negative?
.8ab0	30 2d		bmi $8adf			bmi _Neg
.8ab2	d0 0f		bne $8ac3			bne _Pos2		; do byte shift
.8ab4	20 12 8b	jsr $8b12			jsr _ShiftB
.8ab7	d0 0a		bne $8ac3			bne _Pos2
.8ab9	20 12 8b	jsr $8b12			jsr _ShiftB
.8abc	d0 05		bne $8ac3			bne _Pos2
.8abe	20 12 8b	jsr $8b12			jsr _ShiftB
.8ac1	f0 43		beq $8b06			beq _zero		; no significant bits left?
.8ac3	18		clc		_Pos2:		clc
.8ac4	30 0a		bmi $8ad0			bmi _RShft
.8ac6	88		dey		_Pos3:		dey			; do bit shift
.8ac7	16 7d		asl $7d,x			asl FSMant3,x
.8ac9	36 73		rol $73,x			rol FSMant2,x
.8acb	36 69		rol $69,x			rol FSMant1,x
.8acd	2a		rol a				rol a
.8ace	10 f6		bpl $8ac6			bpl _Pos3
.8ad0					_RShft:
.8ad0	c8		iny				iny
.8ad1	6a		ror a				ror a
.8ad2	76 69		ror $69,x			ror FSMant1,x
.8ad4	76 73		ror $73,x			ror FSMant2,x
.8ad6	76 7d		ror $7d,x			ror FSMant3,x
.8ad8					_28:
.8ad8	95 5f		sta $5f,x			sta FSMant0,x
.8ada	94 55		sty $55,x			sty FSExp,x	; sty dir,x exists
.8adc	a6 14		ldx $14				ldx tmp1+0	; restore data stack index
.8ade	60		rts				rts
.8adf					_Neg:
.8adf	c9 ff		cmp #$ff			cmp #$ff
.8ae1	d0 11		bne $8af4			bne _Neg2	; do byte shift
.8ae3	20 12 8b	jsr $8b12			jsr _ShiftB
.8ae6	c9 ff		cmp #$ff			cmp #$ff
.8ae8	d0 0a		bne $8af4			bne _Neg2
.8aea	20 12 8b	jsr $8b12			jsr _ShiftB
.8aed	c9 ff		cmp #$ff			cmp #$ff
.8aef	d0 03		bne $8af4			bne _Neg2
.8af1	20 12 8b	jsr $8b12			jsr _ShiftB
.8af4	c9 00		cmp #$00	_Neg2:		cmp #0
.8af6	10 d8		bpl $8ad0			bpl _RShft
.8af8	88		dey		_Neg3:		dey
.8af9	16 7d		asl $7d,x			asl FSMant3,x
.8afb	36 73		rol $73,x			rol FSMant2,x
.8afd	36 69		rol $69,x			rol FSMant1,x
.8aff	2a		rol a				rol a
.8b00	30 f6		bmi $8af8			bmi _Neg3
.8b02	10 cc		bpl $8ad0			bpl _RShft
.8b04	68		pla		_Zerop:		pla
.8b05	68		pla				pla		; pop rts addr from _ShiftB
.8b06	a9 00		lda #$00	_zero:		lda #0
.8b08	95 7d		sta $7d,x			sta FSMant3,x
.8b0a	95 73		sta $73,x			sta FSMant2,x
.8b0c	95 69		sta $69,x			sta FSMant1,x
.8b0e	a0 80		ldy #$80			ldy #$80
.8b10	d0 c6		bne $8ad8			bne _28
.8b12					_ShiftB:
.8b12	98		tya				tya		; exponent -= 8
.8b13	38		sec				sec
.8b14	e9 08		sbc #$08			sbc #8
.8b16	a8		tay				tay
.8b17	70 eb		bvs $8b04			bvs _zerop	;is this useful? do we need more of them?
.8b19	b5 69		lda $69,x			lda FSMant1,x
.8b1b	48		pha				pha
.8b1c	b5 73		lda $73,x			lda FSMant2,x
.8b1e	95 69		sta $69,x			sta FSMant1,x
.8b20	b5 7d		lda $7d,x			lda FSMant3,x
.8b22	95 73		sta $73,x			sta FSMant2,x
.8b24	a9 00		lda #$00			lda #0
.8b26	95 7d		sta $7d,x			sta FSMant3,x
.8b28	68		pla				pla
.8b29	60		rts				rts
=130					CodeLen	.var *-XtPtr1
=$8b2a					Here1 = *	; remember here
>8aa6	82					.byte CodeLen	;patch wh_CodeLength
>8b2a	46 2b				Name0:	.text "F+"	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=35500					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>8b2c	62					.byte (("F+"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=136					LinkDisplacement = Nt0-WordListLink
>8b2d	10					.byte WordFlags	;wh_Flags
>8b2e	03					.byte 3	;wh_CodeLength
>8b2f	88					  .byte LinkDisplacement	; offset to previous nt
=$8b30					XtPtr1 ::= *
=35500					WordListLink ::= Nt0 ; remember the nt of this word for later
.8b30	20 7b 8a	jsr $8a7b	FPlus:		jsr FMAlignX	; align mantissas, X= FP stack index
.8b33	18		clc				clc		; add mantissas
.8b34	b5 7e		lda $7e,x			lda FSMant3+1,x
.8b36	75 7d		adc $7d,x			adc FSMant3+0,x
.8b38	95 7e		sta $7e,x			sta FSMant3+1,x
.8b3a	b5 74		lda $74,x			lda FSMant2+1,x
.8b3c	75 73		adc $73,x			adc FSMant2+0,x
.8b3e	95 74		sta $74,x			sta FSMant2+1,x
.8b40	b5 6a		lda $6a,x			lda FSMant1+1,x
.8b42	75 69		adc $69,x			adc FSMant1+0,x
.8b44	95 6a		sta $6a,x			sta FSMant1+1,x
.8b46	b5 60		lda $60,x			lda FSMant0+1,x
.8b48	75 5f		adc $5f,x			adc FSMant0+0,x
.8b4a					FPlusFin:
.8b4a	e8		inx				inx		; FDrop r2
.8b4b	86 54		stx $54				stx FIndex
.8b4d	50 09		bvc $8b58	FPlusFin3:	bvc _19		; if overflow
.8b4f	6a		ror a				ror a		;   shift mantissa right 1 bit
.8b50	76 69		ror $69,x			ror FSMant1,x
.8b52	76 73		ror $73,x			ror FSMant2,x
.8b54	76 7d		ror $7d,x			ror FSMant3,x
.8b56	f6 55		inc $55,x			inc FSExp,x	;   adjust exponent
.8b58					_19:
.8b58	95 5f		sta $5f,x			sta FSMant0,x
.8b5a	4c aa 8a	jmp $8aaa			jmp FNormX	; normalize, return
=45					CodeLen	.var *-XtPtr1
=$8b5d					Here1 = *	; remember here
>8b2e	2d					.byte CodeLen	;patch wh_CodeLength
>8b5d	46 31 2b			Name0:	.text "F1+"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=35552					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>8b60	63					.byte (("F1+"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=52					LinkDisplacement = Nt0-WordListLink
>8b61	10					.byte WordFlags	;wh_Flags
>8b62	03					.byte 3	;wh_CodeLength
>8b63	34					  .byte LinkDisplacement	; offset to previous nt
=$8b64					XtPtr1 ::= *
=35552					WordListLink ::= Nt0 ; remember the nt of this word for later
.8b64	20 e3 88	jsr $88e3	F1Plus:		jsr F1
.8b67	4c 30 8b	jmp $8b30			jmp FPlus
=6					CodeLen	.var *-XtPtr1
=$8b6a					Here1 = *	; remember here
>8b62	06					.byte CodeLen	;patch wh_CodeLength
>8b6a	46 2d				Name0:	.text "F-"	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=35564					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>8b6c	a2					.byte (("F-"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=12					LinkDisplacement = Nt0-WordListLink
>8b6d	10					.byte WordFlags	;wh_Flags
>8b6e	03					.byte 3	;wh_CodeLength
>8b6f	0c					  .byte LinkDisplacement	; offset to previous nt
=$8b70					XtPtr1 ::= *
=35564					WordListLink ::= Nt0 ; remember the nt of this word for later
.8b70	20 7b 8a	jsr $8a7b	FMinus:		jsr FMAlignX	; align mantissas
.8b73	38		sec				sec		; subtract mantissas
.8b74	b5 7e		lda $7e,x			lda FSMant3+1,x
.8b76	f5 7d		sbc $7d,x			sbc FSMant3+0,x
.8b78	95 7e		sta $7e,x			sta FSMant3+1,x
.8b7a	b5 74		lda $74,x			lda FSMant2+1,x
.8b7c	f5 73		sbc $73,x			sbc FSMant2+0,x
.8b7e	95 74		sta $74,x			sta FSMant2+1,x
.8b80	b5 6a		lda $6a,x			lda FSMant1+1,x
.8b82	f5 69		sbc $69,x			sbc FSMant1+0,x
.8b84	95 6a		sta $6a,x			sta FSMant1+1,x
.8b86	b5 60		lda $60,x			lda FSMant0+1,x
.8b88	f5 5f		sbc $5f,x			sbc FSMant0+0,x
.8b8a	4c 4a 8b	jmp $8b4a			jmp FPlusFin	; finish
=29					CodeLen	.var *-XtPtr1
=$8b8d					Here1 = *	; remember here
>8b6e	1d					.byte CodeLen	;patch wh_CodeLength
>8b8d	46 31 2d			Name0:	.text "F1-"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=35600					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>8b90	a3					.byte (("F1-"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=36					LinkDisplacement = Nt0-WordListLink
>8b91	10					.byte WordFlags	;wh_Flags
>8b92	03					.byte 3	;wh_CodeLength
>8b93	24					  .byte LinkDisplacement	; offset to previous nt
=$8b94					XtPtr1 ::= *
=35600					WordListLink ::= Nt0 ; remember the nt of this word for later
.8b94	20 e3 88	jsr $88e3	F1Minus:	jsr F1
.8b97	4c 70 8b	jmp $8b70			jmp FMinus
=6					CodeLen	.var *-XtPtr1
=$8b9a					Here1 = *	; remember here
>8b92	06					.byte CodeLen	;patch wh_CodeLength
>8b9a	46 4e 65 67 61 74 65		Name0:	.text "FNegate"	;  name of word as a string, ending at wh_NameLastChar
=7					NameLength = *-Name0
=35617					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>8ba1	a7					.byte (("FNegate"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=17					LinkDisplacement = Nt0-WordListLink
>8ba2	10					.byte WordFlags	;wh_Flags
>8ba3	03					.byte 3	;wh_CodeLength
>8ba4	11					  .byte LinkDisplacement	; offset to previous nt
=$8ba5					XtPtr1 ::= *
=35617					WordListLink ::= Nt0 ; remember the nt of this word for later
.8ba5	86 14		stx $14		FNegate:	stx tmp1	; save data stack index
.8ba7	a6 54		ldx $54				ldx FIndex	; X= FP stack index
.8ba9	38		sec				sec		; mantissa = 0 - mantissa
.8baa	a9 00		lda #$00			lda #0
.8bac	f5 7d		sbc $7d,x			sbc FSMant3,x
.8bae	95 7d		sta $7d,x			sta FSMant3,x
.8bb0	a9 00		lda #$00			lda #0
.8bb2	f5 73		sbc $73,x			sbc FSMant2,x
.8bb4	95 73		sta $73,x			sta FSMant2,x
.8bb6	a9 00		lda #$00			lda #0
.8bb8	f5 69		sbc $69,x			sbc FSMant1,x
.8bba	95 69		sta $69,x			sta FSMant1,x
.8bbc	a9 00		lda #$00			lda #0
.8bbe	f5 5f		sbc $5f,x			sbc FSMant0,x
.8bc0	4c 4d 8b	jmp $8b4d			jmp FPlusFin3	; finish up, return
=30					CodeLen	.var *-XtPtr1
=$8bc3					Here1 = *	; remember here
>8ba3	1e					.byte CodeLen	;patch wh_CodeLength
>8bc3	46 41 62 73			Name0:	.text "FAbs"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=35655					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>8bc7	64					.byte (("FAbs"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=38					LinkDisplacement = Nt0-WordListLink
>8bc8	10					.byte WordFlags	;wh_Flags
>8bc9	03					.byte 3	;wh_CodeLength
>8bca	26					  .byte LinkDisplacement	; offset to previous nt
=$8bcb					XtPtr1 ::= *
=35655					WordListLink ::= Nt0 ; remember the nt of this word for later
.8bcb	a4 54		ldy $54		FAbs:		ldy FIndex
.8bcd	b9 5f 00	lda $005f,y			lda FSMant0,y		; mantissa negative?
.8bd0	30 d3		bmi $8ba5			bmi FNegate
.8bd2	60		rts				rts
=8					CodeLen	.var *-XtPtr1
=$8bd3					Here1 = *	; remember here
>8bc9	08					.byte CodeLen	;patch wh_CodeLength
.8bd3	4c 39 c4	jmp $c439	Throw_FPStack_4: jmp Throw_FPStack
.8bd6	a4 54		ldy $54		FPos:		ldy FIndex		; load FP stack index
.8bd8	c0 09		cpy #$09			cpy #FDim-1		; check FP stack for 2
.8bda	b0 f7		bcs $8bd3			bcs Throw_FPStack_4
.8bdc	b9 5f 00	lda $005f,y			lda FSMant0+0,y		; calc result sign
.8bdf	59 60 00	eor $0060,y			eor FSMant0+1,y
.8be2	08		php				php
.8be3	b9 60 00	lda $0060,y			lda FSMant0+1,y		; if NOS negative
.8be6	10 07		bpl $8bef			bpl +
.8be8	e6 54		inc $54				inc FIndex		;   point at NOS
.8bea	20 a5 8b	jsr $8ba5			jsr FNegate		;   negate NOS
.8bed	c6 54		dec $54				dec FIndex		;   restore fp
.8bef					+
.8bef	20 cb 8b	jsr $8bcb			jsr FAbs		; abs TOS
.8bf2	86 14		stx $14				stx tmp1+0		; save data stack index
.8bf4	a6 54		ldx $54				ldx FIndex		; load FP stack index
.8bf6	28		plp				plp			; return sign flag
.8bf7	60		rts				rts
>8bf8	46 2a				Name0:	.text "F*"	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=35706					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>8bfa	42					.byte (("F*"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=51					LinkDisplacement = Nt0-WordListLink
>8bfb	10					.byte WordFlags	;wh_Flags
>8bfc	03					.byte 3	;wh_CodeLength
>8bfd	33					  .byte LinkDisplacement	; offset to previous nt
=$8bfe					XtPtr1 ::= *
=35706					WordListLink ::= Nt0 ; remember the nt of this word for later
.8bfe					FStar:
.8bfe	20 d6 8b	jsr $8bd6			jsr FPos		; make r1 & r2 positive,
.8c01	08		php				php			;   save r3 sign
.8c02	b5 55		lda $55,x			lda FSExp+0,x		; add exponents
.8c04	38		sec				sec
.8c05	75 56		adc $56,x			adc FSExp+1,x
.8c07	95 56		sta $56,x			sta FSExp+1,x
.8c09	50 12		bvc $8c1d			bvc _49			; IfVs,
.8c0b	b0 06		bcs $8c13			bcs _zero		;   underflow?
.8c0d	a6 14		ldx $14				ldx tmp1+0		;   restore data stack index
.8c0f	28		plp				plp			; RDrop sign flag
.8c10	20 43 c4	jsr $c443			jsr Throw_FpOutOfRange
.8c13	e8		inx		_zero:		inx			; F2Drop r1 & r2
.8c14	e8		inx				inx
.8c15	86 54		stx $54				stx FIndex
.8c17	28		plp				plp			; RDrop saved result sign
.8c18	a6 14		ldx $14				ldx tmp1+0		; restore data stack index
.8c1a	4c ab 88	jmp $88ab			jmp F0			; return zero
.8c1d					_49:
.8c1d	a9 00		lda #$00			lda #0			; tmp32= 0
.8c1f	85 16		sta $16				sta tmp2+0
.8c21	85 17		sta $17				sta tmp2+1
.8c23	85 18		sta $18				sta tmp3+0
.8c25	85 19		sta $19				sta tmp3+1
.8c27	b5 7e		lda $7e,x			lda FSMant3+1,x
.8c29	20 58 8c	jsr $8c58			jsr _Byte		; do bytes of r1 mantissa
.8c2c	b5 74		lda $74,x			lda FSMant2+1,x
.8c2e	20 58 8c	jsr $8c58			jsr _Byte
.8c31	b5 6a		lda $6a,x			lda FSMant1+1,x
.8c33	20 58 8c	jsr $8c58			jsr _Byte
.8c36	b5 60		lda $60,x			lda FSMant0+1,x
.8c38	20 58 8c	jsr $8c58			jsr _Byte
.8c3b	a5 16		lda $16				lda tmp2+0		; r1.mant= tmp32
.8c3d	95 7e		sta $7e,x			sta FSMant3+1,x
.8c3f	a5 17		lda $17				lda tmp2+1
.8c41	95 74		sta $74,x			sta FSMant2+1,x
.8c43	a5 18		lda $18				lda tmp3+0
.8c45	95 6a		sta $6a,x			sta FSMant1+1,x
.8c47	a5 19		lda $19				lda tmp3+1
.8c49	95 60		sta $60,x			sta FSMant0+1,x
.8c4b	e6 54		inc $54				inc FIndex		; FDrop
.8c4d	a6 14		ldx $14				ldx tmp1+0		; restore data stack index
.8c4f	28		plp				plp			; fix result sign
.8c50	10 03		bpl $8c55			bpl +
.8c52	4c a5 8b	jmp $8ba5			jmp FNegate
.8c55					+
.8c55	4c a8 8a	jmp $8aa8			jmp FNorm
.8c58					_Byte:
.8c58	49 ff		eor #$ff			eor #$ff
.8c5a	85 15		sta $15				sta tmp1+1
.8c5c	a0 08		ldy #$08			ldy #8			; for each bit in byte
.8c5e	46 15		lsr $15		_b1:		lsr tmp1+1		;   if bit set
.8c60	b0 18		bcs $8c7a			bcs _b3
.8c62	a5 16		lda $16				lda tmp2+0		;     tmp32 += r2
.8c64	75 7d		adc $7d,x			adc FSMant3+0,x
.8c66	85 16		sta $16				sta tmp2+0
.8c68	a5 17		lda $17				lda tmp2+1
.8c6a	75 73		adc $73,x			adc FSMant2+0,x
.8c6c	85 17		sta $17				sta tmp2+1
.8c6e	a5 18		lda $18				lda tmp3+0
.8c70	75 69		adc $69,x			adc FSMant1+0,x
.8c72	85 18		sta $18				sta tmp3+0
.8c74	a5 19		lda $19				lda tmp3+1
.8c76	75 5f		adc $5f,x			adc FSMant0+0,x
.8c78	85 19		sta $19				sta tmp3+1
.8c7a	46 19		lsr $19		_b3:		lsr tmp3+1		;   tmp32 >>= 1
.8c7c	66 18		ror $18				ror tmp3+0
.8c7e	66 17		ror $17				ror tmp2+1
.8c80	66 16		ror $16				ror tmp2+0
.8c82	88		dey				dey			;  next bit
.8c83	d0 d9		bne $8c5e			bne _b1
.8c85	60		rts				rts
=136					CodeLen	.var *-XtPtr1
=$8c86					Here1 = *	; remember here
>8bfc	88					.byte CodeLen	;patch wh_CodeLength
>8c86	46 53 71 72			Name0:	.text "FSqr"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=35850					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>8c8a	44					.byte (("FSqr"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=144					LinkDisplacement = Nt0-WordListLink
>8c8b	10					.byte WordFlags	;wh_Flags
>8c8c	03					.byte 3	;wh_CodeLength
>8c8d	90					  .byte LinkDisplacement	; offset to previous nt
=$8c8e					XtPtr1 ::= *
=35850					WordListLink ::= Nt0 ; remember the nt of this word for later
.8c8e	20 53 85	jsr $8553	FSqr:		jsr FDup
.8c91	4c fe 8b	jmp $8bfe			jmp FStar
=6					CodeLen	.var *-XtPtr1
=$8c94					Here1 = *	; remember here
>8c8c	06					.byte CodeLen	;patch wh_CodeLength
>8c94	46 2f				Name0:	.text "F/"	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=35862					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>8c96	e2					.byte (("F/"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=12					LinkDisplacement = Nt0-WordListLink
>8c97	10					.byte WordFlags	;wh_Flags
>8c98	03					.byte 3	;wh_CodeLength
>8c99	0c					  .byte LinkDisplacement	; offset to previous nt
=$8c9a					XtPtr1 ::= *
=35862					WordListLink ::= Nt0 ; remember the nt of this word for later
.8c9a	20 d6 8b	jsr $8bd6	FSlash:		jsr FPos		; make r1 & r2 positive
.8c9d	08		php				php			;   save result sign
.8c9e	b5 56		lda $56,x			lda FSExp+1,x		; calc exponent
.8ca0	18		clc				clc
.8ca1	69 01		adc #$01			adc #1
.8ca3	38		sec				sec
.8ca4	f5 55		sbc $55,x			sbc FSExp+0,x
.8ca6	95 56		sta $56,x			sta FSExp+1,x
.8ca8	50 12		bvc $8cbc			bvc _49			;  IfVs
.8caa	b0 06		bcs $8cb2			bcs _Zero		; underflow?
.8cac	28		plp				plp			; drop saved result sign
.8cad	a6 15		ldx $15				ldx tmp1+1		; restore data stack index
.8caf	20 43 c4	jsr $c443			jsr Throw_FpOutOfRange	; overflow
.8cb2	e8		inx		_Zero:		inx			; F2Drop
.8cb3	e8		inx				inx
.8cb4	86 54		stx $54				stx FIndex
.8cb6	28		plp				plp			; drop saved result sign
.8cb7	a6 14		ldx $14				ldx tmp1+0		; restore data stack index
.8cb9	4c ab 88	jmp $88ab			jmp F0			; return 0
.8cbc					_49:
.8cbc	b5 7e		lda $7e,x			lda FSMant3+1,x		; tmp32 = r1
.8cbe	85 16		sta $16				sta tmp2+0
.8cc0	b5 74		lda $74,x			lda FSMant2+1,x
.8cc2	85 17		sta $17				sta tmp2+1
.8cc4	b5 6a		lda $6a,x			lda FSMant1+1,x
.8cc6	85 18		sta $18				sta tmp3+0
.8cc8	b5 60		lda $60,x			lda FSMant0+1,x
.8cca	85 19		sta $19				sta tmp3+1
.8ccc	20 f5 8c	jsr $8cf5			jsr _Byte
.8ccf	95 60		sta $60,x			sta FSMant0+1,x
.8cd1	20 f5 8c	jsr $8cf5			jsr _Byte
.8cd4	95 6a		sta $6a,x			sta FSMant1+1,x
.8cd6	20 f5 8c	jsr $8cf5			jsr _Byte
.8cd9	95 74		sta $74,x			sta FSMant2+1,x
.8cdb	20 f5 8c	jsr $8cf5			jsr _Byte
.8cde	95 7e		sta $7e,x			sta FSMant3+1,x
.8ce0	56 60		lsr $60,x			lsr FSMant0+1,x
.8ce2	76 6a		ror $6a,x			ror FSMant1+1,x
.8ce4	76 74		ror $74,x			ror FSMant2+1,x
.8ce6	76 7e		ror $7e,x			ror FSMant3+1,x
.8ce8	e6 54		inc $54				inc FIndex		; FDrop
.8cea	a6 14		ldx $14				ldx tmp1+0		; restore X
.8cec	28		plp				plp			; fix sign
.8ced	10 03		bpl $8cf2			bpl +
.8cef	20 a5 8b	jsr $8ba5			jsr FNegate
.8cf2	4c a8 8a	jmp $8aa8	+		jmp FNorm
.8cf5					_Byte:
.8cf5	a0 08		ldy #$08			ldy #8			; for 8 bits
.8cf7					_1:
.8cf7	a5 19		lda $19				lda tmp3+1		;   if r1>=r2
.8cf9	d5 5f		cmp $5f,x			cmp FSMant0+0,x
.8cfb	d0 10		bne $8d0d			bne _4
.8cfd	a5 18		lda $18				lda tmp3+0
.8cff	d5 69		cmp $69,x			cmp FSMant1+0,x
.8d01	d0 0a		bne $8d0d			bne _4
.8d03	a5 17		lda $17				lda tmp2+1
.8d05	d5 73		cmp $73,x			cmp FSMant2+0,x
.8d07	d0 04		bne $8d0d			bne _4
.8d09	a5 16		lda $16				lda tmp2+0
.8d0b	d5 7d		cmp $7d,x			cmp FSMant3+0,x
.8d0d	90 18		bcc $8d27	_4:		bcc _2
.8d0f	a5 16		lda $16				lda tmp2+0		;     tmp32 -= r2
.8d11	f5 7d		sbc $7d,x			sbc FSMant3+0,x
.8d13	85 16		sta $16				sta tmp2+0
.8d15	a5 17		lda $17				lda tmp2+1
.8d17	f5 73		sbc $73,x			sbc FSMant2+0,x
.8d19	85 17		sta $17				sta tmp2+1
.8d1b	a5 18		lda $18				lda tmp3+0
.8d1d	f5 69		sbc $69,x			sbc FSMant1+0,x
.8d1f	85 18		sta $18				sta tmp3+0
.8d21	a5 19		lda $19				lda tmp3+1
.8d23	f5 5f		sbc $5f,x			sbc FSMant0+0,x
.8d25	85 19		sta $19				sta tmp3+1
.8d27	26 15		rol $15		_2:		rol tmp1+1		;   accum quotient bits
.8d29	06 16		asl $16				asl tmp2+0
.8d2b	26 17		rol $17				rol tmp2+1
.8d2d	26 18		rol $18				rol tmp3+0
.8d2f	26 19		rol $19				rol tmp3+1		;   tmp32<<=1
.8d31	88		dey				dey			;  next
.8d32	d0 c3		bne $8cf7			bne _1
.8d34	a5 15		lda $15				lda tmp1+1		; return bits
.8d36	60		rts				rts
=157					CodeLen	.var *-XtPtr1
=$8d37					Here1 = *	; remember here
>8c98	9d					.byte CodeLen	;patch wh_CodeLength
>8d37	46 31 2f			Name0:	.text "F1/"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=36026					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>8d3a	e3					.byte (("F1/"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=164					LinkDisplacement = Nt0-WordListLink
>8d3b	10					.byte WordFlags	;wh_Flags
>8d3c	03					.byte 3	;wh_CodeLength
>8d3d	a4					  .byte LinkDisplacement	; offset to previous nt
=$8d3e					XtPtr1 ::= *
=36026					WordListLink ::= Nt0 ; remember the nt of this word for later
.8d3e	20 e3 88	jsr $88e3	F1Slash:	jsr F1
.8d41	20 d7 85	jsr $85d7			jsr FSwap
.8d44	4c 9a 8c	jmp $8c9a			jmp FSlash
=9					CodeLen	.var *-XtPtr1
=$8d47					Here1 = *	; remember here
>8d3c	09					.byte CodeLen	;patch wh_CodeLength
>8d47	45 2a				Name0:	.text "E*"	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=36041					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>8d49	42					.byte (("E*"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=15					LinkDisplacement = Nt0-WordListLink
>8d4a	10					.byte WordFlags	;wh_Flags
>8d4b	03					.byte 3	;wh_CodeLength
>8d4c	0f					  .byte LinkDisplacement	; offset to previous nt
=$8d4d					XtPtr1 ::= *
=36041					WordListLink ::= Nt0 ; remember the nt of this word for later
.8d4d					EStar:
.8d4d	20 d6 8b	jsr $8bd6			jsr FPos		; make r1 & r2 positive
.8d50	08		php				php			;   remember result sign
.8d51	b5 55		lda $55,x			lda FSExp+0,x		; add exponents
.8d53	38		sec				sec
.8d54	75 56		adc $56,x			adc FSExp+1,x
.8d56	95 56		sta $56,x			sta FSExp+1,x
.8d58	70 1b		bvs $8d75			bvs _ExpOvfl
.8d5a	a0 00		ldy #$00			ldy #0
.8d5c	84 16		sty $16				sty tmp2+0
.8d5e	84 17		sty $17				sty tmp2+1		; zero result
.8d60	b5 6a		lda $6a,x			lda FSMant1+1,x
.8d62	20 84 8d	jsr $8d84			jsr _Byte		; do FSMant1+1 byte
.8d65	b5 60		lda $60,x			lda FSMant0+1,x
.8d67	20 84 8d	jsr $8d84			jsr _Byte		; do FSMant0+1 byte
.8d6a	a5 16		lda $16				lda tmp2+0		; r3 = tmp2
.8d6c	95 6a		sta $6a,x			sta FSMant1+1,x
.8d6e	a5 17		lda $17				lda tmp2+1
.8d70	95 60		sta $60,x			sta FSMant0+1,x
.8d72	4c a2 8d	jmp $8da2			jmp EFix3		; finish
.8d75					_ExpOvfl:
.8d75	b0 05		bcs $8d7c			bcs _Zero		;underflow?
.8d77	a6 14		ldx $14				ldx tmp1+0		; restore X
.8d79	20 43 c4	jsr $c443			jsr Throw_FpOutOfRange	;overflow
.8d7c	a9 00		lda #$00	_Zero:		lda #0
.8d7e	95 6a		sta $6a,x			sta FSMant1+1,x
.8d80	95 60		sta $60,x			sta FSMant0+1,x
.8d82	f0 1e		beq $8da2			beq EFix3
.8d84					_Byte:
.8d84	49 ff		eor #$ff			eor #$ff
.8d86	85 15		sta $15				sta tmp1+1
.8d88	a0 08		ldy #$08			ldy #8			; for 8 bits
.8d8a	46 15		lsr $15		_b1:		lsr tmp1+1		;   if bit set
.8d8c	b0 0c		bcs $8d9a			bcs _b5
.8d8e	a5 16		lda $16				lda tmp2+0		;     tmp2 += r2
.8d90	75 69		adc $69,x			adc FSMant1+0,x
.8d92	85 16		sta $16				sta tmp2+0
.8d94	a5 17		lda $17				lda tmp2+1
.8d96	75 5f		adc $5f,x			adc FSMant0+0,x
.8d98	85 17		sta $17				sta tmp2+1
.8d9a	46 17		lsr $17		_b5:		lsr tmp2+1		;   tmp2 <<= 1
.8d9c	66 16		ror $16				ror tmp2+0
.8d9e	88		dey				dey			;  next bit
.8d9f	d0 e9		bne $8d8a			bne _b1
.8da1	60		rts				rts
=85					CodeLen	.var *-XtPtr1
=$8da2					Here1 = *	; remember here
>8d4b	55					.byte CodeLen	;patch wh_CodeLength
.8da2					EFix3:
.8da2	a9 00		lda #$00			lda #0			; zero unused mantissa
.8da4	95 74		sta $74,x			sta FSMant2+1,x
.8da6	95 7e		sta $7e,x			sta FSMant3+1,x
.8da8	e6 54		inc $54				inc FIndex		; FDrop
.8daa	a6 14		ldx $14				ldx tmp1+0		; restore X
.8dac	28		plp				plp			;fix result sign
.8dad	10 03		bpl $8db2			bpl +
.8daf	4c a5 8b	jmp $8ba5			jmp FNegate
.8db2	4c a8 8a	jmp $8aa8	+		jmp FNorm
>8db5	45 53 71 72			Name0:	.text "ESqr"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=36153					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>8db9	44					.byte (("ESqr"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=112					LinkDisplacement = Nt0-WordListLink
>8dba	10					.byte WordFlags	;wh_Flags
>8dbb	03					.byte 3	;wh_CodeLength
>8dbc	70					  .byte LinkDisplacement	; offset to previous nt
=$8dbd					XtPtr1 ::= *
=36153					WordListLink ::= Nt0 ; remember the nt of this word for later
.8dbd	20 53 85	jsr $8553	ESqr:		jsr FDup
.8dc0	4c 4d 8d	jmp $8d4d			jmp EStar
=6					CodeLen	.var *-XtPtr1
=$8dc3					Here1 = *	; remember here
>8dbb	06					.byte CodeLen	;patch wh_CodeLength
>8dc3	45 2f				Name0:	.text "E/"	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=36165					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>8dc5	e2					.byte (("E/"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=12					LinkDisplacement = Nt0-WordListLink
>8dc6	10					.byte WordFlags	;wh_Flags
>8dc7	03					.byte 3	;wh_CodeLength
>8dc8	0c					  .byte LinkDisplacement	; offset to previous nt
=$8dc9					XtPtr1 ::= *
=36165					WordListLink ::= Nt0 ; remember the nt of this word for later
.8dc9	20 ea a0	jsr $a0ea	ESlash:		jsr EPos	; make e1 & e2 positive
.8dcc	08		php				php		; remember result sign
.8dcd	b5 56		lda $56,x			lda FSExp+1,x		; calc e3 exponent
.8dcf	38		sec				sec
.8dd0	f5 55		sbc $55,x			sbc FSExp+0,x
.8dd2	70 17		bvs $8deb			bvs _ExpOvfl
.8dd4	18		clc				clc
.8dd5	69 01		adc #$01			adc #1
.8dd7	95 56		sta $56,x			sta FSExp+1,x
.8dd9	20 fb 8d	jsr $8dfb			jsr _Byte		; gen quotient hi byte
.8ddc	48		pha				pha
.8ddd	20 fb 8d	jsr $8dfb			jsr _Byte		; gen quotient lo byte
.8de0	95 6a		sta $6a,x			sta FSMant1+1,x
.8de2	68		pla				pla
.8de3	4a		lsr a				lsr a
.8de4	95 60		sta $60,x			sta FSMant0+1,x
.8de6	76 6a		ror $6a,x			ror FSMant1+1,x
.8de8	4c a2 8d	jmp $8da2			jmp EFix3
.8deb					_ExpOvfl:
.8deb	a6 14		ldx $14				ldx tmp1+0		; restore data stack index
.8ded	b0 04		bcs $8df3			bcs _zero		; underflow?
.8def	28		plp				plp			; rdrop saved result sign
.8df0	20 43 c4	jsr $c443			jsr Throw_FpOutOfRange	; overflow
.8df3	28		plp		_zero:		plp			; rdrop saved result sign
.8df4	e6 54		inc $54				inc FIndex		; FDrop e2
.8df6	e6 54		inc $54				inc FIndex		; FDrop e1
.8df8	4c 27 9e	jmp $9e27			jmp E0			; return zero
.8dfb					_Byte:
.8dfb	a0 08		ldy #$08			ldy #8			; for 8 bits
.8dfd	b5 6a		lda $6a,x	_b1:		lda FSMant1+1,x		;   if r1 >= r2
.8dff	d5 69		cmp $69,x			cmp FSMant1+0,x
.8e01	b5 60		lda $60,x			lda FSMant0+1,x
.8e03	f5 5f		sbc $5f,x			sbc FSMant0+0,x
.8e05	90 09		bcc $8e10			bcc _b5
.8e07	95 60		sta $60,x			sta FSMant0+1,x
.8e09	b5 6a		lda $6a,x			lda FSMant1+1,x		;     r1 -= r2
.8e0b	f5 69		sbc $69,x			sbc FSMant1+0,x
.8e0d	95 6a		sta $6a,x			sta FSMant1+1,x
.8e0f	38		sec				sec
.8e10					_b5:
.8e10	26 15		rol $15				rol tmp1+1		;   save quotient bit
.8e12	16 6a		asl $6a,x			asl FSMant1+1,x		;   r1 *= 2
.8e14	36 60		rol $60,x			rol FSMant0+1,x
.8e16	88		dey				dey			;  next bit
.8e17	d0 e4		bne $8dfd			bne _b1
.8e19	a5 15		lda $15				lda tmp1+1		; return bits
.8e1b	60		rts				rts
=83					CodeLen	.var *-XtPtr1
=$8e1c					Here1 = *	; remember here
>8dc7	53					.byte CodeLen	;patch wh_CodeLength
>8e1c	45 31 2f			Name0:	.text "E1/"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=36255					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>8e1f	e3					.byte (("E1/"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=90					LinkDisplacement = Nt0-WordListLink
>8e20	10					.byte WordFlags	;wh_Flags
>8e21	03					.byte 3	;wh_CodeLength
>8e22	5a					  .byte LinkDisplacement	; offset to previous nt
=$8e23					XtPtr1 ::= *
=36255					WordListLink ::= Nt0 ; remember the nt of this word for later
.8e23	20 e3 88	jsr $88e3	E1Slash:	jsr F1
.8e26	20 d7 85	jsr $85d7			jsr FSwap
.8e29	4c c9 8d	jmp $8dc9			jmp ESlash
=9					CodeLen	.var *-XtPtr1
=$8e2c					Here1 = *	; remember here
>8e21	09					.byte CodeLen	;patch wh_CodeLength
>8e2c	53 3e 46			Name0:	.text "S>F"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=36271					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>8e2f	c3					.byte (("S>F"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=16					LinkDisplacement = Nt0-WordListLink
>8e30	10					.byte WordFlags	;wh_Flags
>8e31	03					.byte 3	;wh_CodeLength
>8e32	10					  .byte LinkDisplacement	; offset to previous nt
=$8e33					XtPtr1 ::= *
=36271					WordListLink ::= Nt0 ; remember the nt of this word for later
.8e33	20 e3 c3	jsr $c3e3	SToF:		jsr PopYA		; pop n
.8e36	20 c8 84	jsr $84c8	SToFYA:		jsr FAllocX		; alloc FP stack entry
.8e39	95 69		sta $69,x			sta FSMant1,x		; copy n to mantissa
.8e3b	94 5f		sty $5f,x			sty FSMant0,x	; sty dir,x exists
.8e3d	a9 00		lda #$00			lda #0			; pad mantissa
.8e3f	95 73		sta $73,x			sta FSMant2,x
.8e41	95 7d		sta $7d,x			sta FSMant3,x
.8e43	a9 0f		lda #$0f			lda #15			; set exponent
.8e45	95 55		sta $55,x			sta FSExp,x
.8e47	4c aa 8a	jmp $8aaa			jmp FNormX		; normalize, return
=23					CodeLen	.var *-XtPtr1
=$8e4a					Here1 = *	; remember here
>8e31	17					.byte CodeLen	;patch wh_CodeLength
>8e4a	44 3e 46			Name0:	.text "D>F"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=36301					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>8e4d	c3					.byte (("D>F"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=30					LinkDisplacement = Nt0-WordListLink
>8e4e	10					.byte WordFlags	;wh_Flags
>8e4f	03					.byte 3	;wh_CodeLength
>8e50	1e					  .byte LinkDisplacement	; offset to previous nt
=$8e51					XtPtr1 ::= *
=36301					WordListLink ::= Nt0 ; remember the nt of this word for later
.8e51	20 c8 84	jsr $84c8	FDToF:		jsr FAllocX		; alloc FP stack entry
.8e54	a6 14		ldx $14				ldx tmp1+0		; restore data stack index
.8e56	a4 54		ldy $54				ldy FIndex		; Y= fp stack index
.8e58	b5 26		lda $26,x			lda DStack+2,x		; mantissa= d
.8e5a	99 7d 00	sta $007d,y			sta FSMant3,y
.8e5d	b5 27		lda $27,x			lda DStack+3,x
.8e5f	99 73 00	sta $0073,y			sta FSMant2,y
.8e62	b5 24		lda $24,x			lda DStack+0,x
.8e64	99 69 00	sta $0069,y			sta FSMant1,y
.8e67	b5 25		lda $25,x			lda DStack+1,x
.8e69	99 5f 00	sta $005f,y			sta FSMant0,y
.8e6c	a9 1f		lda #$1f			lda #31			; set exponent
.8e6e	99 55 00	sta $0055,y			sta FSExp,y
.8e71	20 72 d5	jsr $d572			jsr Two_Drop
.8e74	4c a8 8a	jmp $8aa8			jmp FNorm		; normalize, return
=38					CodeLen	.var *-XtPtr1
=$8e77					Here1 = *	; remember here
>8e4f	26					.byte CodeLen	;patch wh_CodeLength
>8e77	46 3e 53			Name0:	.text "F>S"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=36346					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>8e7a	63					.byte (("F>S"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=45					LinkDisplacement = Nt0-WordListLink
>8e7b	10					.byte WordFlags	;wh_Flags
>8e7c	03					.byte 3	;wh_CodeLength
>8e7d	2d					  .byte LinkDisplacement	; offset to previous nt
=$8e7e					XtPtr1 ::= *
=36346					WordListLink ::= Nt0 ; remember the nt of this word for later
.8e7e	a4 54		ldy $54		FToS:		ldy FIndex
.8e80	b9 5f 00	lda $005f,y			lda FSMant0,y		; save sign
.8e83	08		php				php
.8e84	10 03		bpl $8e89			bpl +
.8e86	20 a5 8b	jsr $8ba5			jsr FNegate
.8e89					+
.8e89	a9 0f		lda #$0f			lda #15
.8e8b	20 b1 89	jsr $89b1			jsr FShiftA
.8e8e	a6 14		ldx $14				ldx tmp1+0		; restore data stack index
.8e90	c0 10		cpy #$10			cpy #15+1		; always positive, so unsigned compare works
.8e92	b0 17		bcs $8eab			bcs _overflow
.8e94	a4 54		ldy $54				ldy FIndex
.8e96	ca		dex				dex
.8e97	ca		dex				dex
.8e98	b9 5f 00	lda $005f,y			lda FSMant0,y
.8e9b	95 25		sta $25,x			sta DStack+1,x
.8e9d	b9 69 00	lda $0069,y			lda FSMant1,y
.8ea0	95 24		sta $24,x			sta DStack+0,x
.8ea2	e6 54		inc $54				inc FIndex		; FDrop
.8ea4	28		plp				plp			; apply saved sign
.8ea5	30 01		bmi $8ea8			bmi +
.8ea7	60		rts				rts
.8ea8	4c e9 d6	jmp $d6e9	+		jmp Negate
.8eab	28		plp		_overflow:	plp			; RDrop saved sign
.8eac	a9 f5		lda #$f5			lda #$100+err_OutOfRange
.8eae	20 68 c4	jsr $c468			jsr ThrowA
=51					CodeLen	.var *-XtPtr1
=$8eb1					Here1 = *	; remember here
>8e7c	33					.byte CodeLen	;patch wh_CodeLength
>8eb1	46 3e 44			Name0:	.text "F>D"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=36404					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>8eb4	83					.byte (("F>D"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=58					LinkDisplacement = Nt0-WordListLink
>8eb5	10					.byte WordFlags	;wh_Flags
>8eb6	03					.byte 3	;wh_CodeLength
>8eb7	3a					  .byte LinkDisplacement	; offset to previous nt
=$8eb8					XtPtr1 ::= *
=36404					WordListLink ::= Nt0 ; remember the nt of this word for later
.8eb8	a4 54		ldy $54		FToD:		ldy FIndex
.8eba	b9 5f 00	lda $005f,y			lda FSMant0,y		; save sign
.8ebd	08		php				php
.8ebe	10 03		bpl $8ec3			bpl +
.8ec0	20 a5 8b	jsr $8ba5			jsr FNegate
.8ec3					+
.8ec3	a9 1f		lda #$1f			lda #31
.8ec5	20 b1 89	jsr $89b1			jsr FShiftA
.8ec8	a6 14		ldx $14				ldx tmp1+0		; restore data stack index
.8eca	c0 20		cpy #$20			cpy #31+1		; always positive, so unsigned compare works
.8ecc	b0 23		bcs $8ef1			bcs _overflow
.8ece	a4 54		ldy $54				ldy FIndex
.8ed0	ca		dex				dex			; d= mantissa
.8ed1	ca		dex				dex
.8ed2	ca		dex				dex
.8ed3	ca		dex				dex
.8ed4	b9 5f 00	lda $005f,y			lda FSMant0,y
.8ed7	95 25		sta $25,x			sta DStack+1,x
.8ed9	b9 69 00	lda $0069,y			lda FSMant1,y
.8edc	95 24		sta $24,x			sta DStack+0,x
.8ede	b9 73 00	lda $0073,y			lda FSMant2,y
.8ee1	95 27		sta $27,x			sta DStack+3,x
.8ee3	b9 7d 00	lda $007d,y			lda FSMant3,y
.8ee6	95 26		sta $26,x			sta DStack+2,x
.8ee8	e6 54		inc $54				inc FIndex		; FDrop
.8eea	28		plp				plp			; apply saved sign
.8eeb	30 01		bmi $8eee			bmi +
.8eed	60		rts				rts
.8eee	4c 19 d7	jmp $d719	+		jmp DNegate
.8ef1	28		plp		_overflow:	plp			; RDrop sign
.8ef2	a9 f5		lda #$f5			lda #$100+err_OutOfRange
.8ef4	20 68 c4	jsr $c468			jsr ThrowA
=63					CodeLen	.var *-XtPtr1
=$8ef7					Here1 = *	; remember here
>8eb6	3f					.byte CodeLen	;patch wh_CodeLength
>8ef7	46 52 6e 64			Name0:	.text "FRnd"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=36475					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>8efb	84					.byte (("FRnd"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=71					LinkDisplacement = Nt0-WordListLink
>8efc	10					.byte WordFlags	;wh_Flags
>8efd	03					.byte 3	;wh_CodeLength
>8efe	47					  .byte LinkDisplacement	; offset to previous nt
=$8eff					XtPtr1 ::= *
=36475					WordListLink ::= Nt0 ; remember the nt of this word for later
.8eff	20 f7 82	jsr $82f7	FRnd:		jsr Rand		; generate next RndState
.8f02	20 c8 84	jsr $84c8			jsr FAllocX		; alloc FP stack entry
.8f05	4a		lsr a				lsr a			;   make positive
.8f06	95 5f		sta $5f,x			sta FSMant0,x
.8f08	94 69		sty $69,x			sty FSMant1,x	; sty dir,x exists
.8f0a	ad 35 03	lda $0335			lda RndState+0
.8f0d	95 73		sta $73,x			sta FSMant2,x
.8f0f	ad 36 03	lda $0336			lda RndState+1
.8f12	95 7d		sta $7d,x			sta FSMant3,x
.8f14	a9 00		lda #$00			lda #0			; exponent=0
.8f16	95 55		sta $55,x			sta FSExp,x
.8f18	4c aa 8a	jmp $8aaa			jmp FNormX		; normalize, return
=28					CodeLen	.var *-XtPtr1
=$8f1b					Here1 = *	; remember here
>8efd	1c					.byte CodeLen	;patch wh_CodeLength
>8f1b	46 53 71 72 74			Name0:	.text "FSqrt"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=36512					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>8f20	85					.byte (("FSqrt"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=37					LinkDisplacement = Nt0-WordListLink
>8f21	10					.byte WordFlags	;wh_Flags
>8f22	03					.byte 3	;wh_CodeLength
>8f23	25					  .byte LinkDisplacement	; offset to previous nt
=$8f24					XtPtr1 ::= *
=36512					WordListLink ::= Nt0 ; remember the nt of this word for later
.8f24	a4 54		ldy $54		FSqrt:		ldy FIndex
.8f26	b9 5f 00	lda $005f,y			lda FSMant0,y		; zero?
.8f29	d0 01		bne $8f2c			bne +
.8f2b	60		rts				rts			;   just return the zero
.8f2c					+
.8f2c	20 53 85	jsr $8553			jsr FDup		; get trial value
.8f2f	a4 54		ldy $54				ldy FIndex
.8f31	b9 55 00	lda $0055,y			lda FSExp,y		; halve the exponent of trial value
.8f34	c9 80		cmp #$80			cmp #$80
.8f36	6a		ror a				ror a
.8f37	99 55 00	sta $0055,y			sta FSExp,y
.8f3a	a9 09		lda #$09			lda #9			; for 9 iterations
.8f3c	48		pha		_3:		pha
.8f3d	20 c8 85	jsr $85c8			jsr F2Dup		;   calc new trial value
.8f40	20 9a 8c	jsr $8c9a			jsr FSlash
.8f43	20 30 8b	jsr $8b30			jsr FPlus
.8f46	20 97 89	jsr $8997			jsr F2Slash
.8f49	68		pla				pla			;  next
.8f4a	38		sec				sec
.8f4b	e9 01		sbc #$01			sbc #1
.8f4d	d0 ed		bne $8f3c			bne _3
.8f4f	4c 2e 85	jmp $852e			jmp FNip		; return trial value
=46					CodeLen	.var *-XtPtr1
=$8f52					Here1 = *	; remember here
>8f22	2e					.byte CodeLen	;patch wh_CodeLength
>8f52	50 72 65 63 69 73 69 6f		Name0:	.text "Precision"	;  name of word as a string, ending at wh_NameLastChar
>8f5a	6e
=9					NameLength = *-Name0
=36571					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>8f5b	c9					.byte (("Precision"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=59					LinkDisplacement = Nt0-WordListLink
>8f5c	10					.byte WordFlags	;wh_Flags
>8f5d	03					.byte 3	;wh_CodeLength
>8f5e	3b					  .byte LinkDisplacement	; offset to previous nt
=$8f5f					XtPtr1 ::= *
=36571					WordListLink ::= Nt0 ; remember the nt of this word for later
.8f5f	ad ff 02	lda $02ff	Precision:	lda PrecisionV
.8f62	4c e9 c7	jmp $c7e9			jmp PushZA
=6					CodeLen	.var *-XtPtr1
=$8f65					Here1 = *	; remember here
>8f5d	06					.byte CodeLen	;patch wh_CodeLength
.8f65	60		rts				rts
>8f66	53 65 74 2d 50 72 65 63		Name0:	.text "Set-Precision"	;  name of word as a string, ending at wh_NameLastChar
>8f6e	69 73 69 6f 6e
=13					NameLength = *-Name0
=36595					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>8f73	cd					.byte (("Set-Precision"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=24					LinkDisplacement = Nt0-WordListLink
>8f74	10					.byte WordFlags	;wh_Flags
>8f75	03					.byte 3	;wh_CodeLength
>8f76	18					  .byte LinkDisplacement	; offset to previous nt
=$8f77					XtPtr1 ::= *
=36595					WordListLink ::= Nt0 ; remember the nt of this word for later
.8f77	20 c8 c3	jsr $c3c8			jsr PopA
.8f7a	8d ff 02	sta $02ff			sta PrecisionV
=6					CodeLen	.var *-XtPtr1
=$8f7d					Here1 = *	; remember here
>8f75	06					.byte CodeLen	;patch wh_CodeLength
.8f7d	60		rts				rts
>8f7e	28 46 2e 29			Name0:	.text "(F.)"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=36610					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>8f82	24					.byte (("(F.)"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=15					LinkDisplacement = Nt0-WordListLink
>8f83	10					.byte WordFlags	;wh_Flags
>8f84	03					.byte 3	;wh_CodeLength
>8f85	0f					  .byte LinkDisplacement	; offset to previous nt
=$8f86					XtPtr1 ::= *
=36610					WordListLink ::= Nt0 ; remember the nt of this word for later
.8f86	20 03 90	jsr $9003	PFDot:		jsr pfcstart		;start collecting chars, make r positive
.8f89	20 8f 8f	jsr $8f8f			jsr PFDotSub
.8f8c	4c 21 90	jmp $9021			jmp pfcend
.8f8f					PFDotSub:
.8f8f	20 5f 8f	jsr $8f5f			jsr Precision	;alloc & init work area
.8f92	20 00 c8	jsr $c800			jsr One
=$27					_mantNzFound  = DStack+3	; nonzero mantissa digit processed
=$26					_NumSigDigits = DStack+2	; # of significant digits
=$24					_decimalPos   = DStack+0	; decimal point position
.8f95	20 e3 8f	jsr $8fe3			jsr FLt10		; scale down to <10, counting exponent
.8f98					_c:
.8f98	b5 24		lda $24,x			lda _decimalPos,x	;  insert decimal point here?
.8f9a	d0 05		bne $8fa1			bne _c2
.8f9c	a9 2e		lda #$2e			lda #'.'
.8f9e	20 18 90	jsr $9018			jsr pfchar
.8fa1	d6 24		dec $24,x	_c2:		dec _decimalPos,x
.8fa3	20 53 85	jsr $8553			jsr FDup		;  do a digit
.8fa6	20 7e 8e	jsr $8e7e			jsr FToS		;  ( work n )
.8fa9	b5 24		lda $24,x			lda DStack+0,x
.8fab	15 29		ora $29,x			ora _mantNzFound+2,x	;  doing significant digits?
.8fad	95 29		sta $29,x			sta _mantNzFound+2,x
.8faf	f0 08		beq $8fb9			beq _c7
.8fb1	d6 28		dec $28,x			dec _NumSigDigits+2,x
.8fb3	10 04		bpl $8fb9			bpl _c7
.8fb5	e8		inx				inx			;    drop integer
.8fb6	e8		inx				inx
.8fb7	d0 17		bne $8fd0			bne _d
.8fb9	b5 24		lda $24,x	_c7:		lda DStack+0,x		;  store the char
.8fbb	09 30		ora #$30			ora #'0'
.8fbd	20 18 90	jsr $9018			jsr pfchar
.8fc0	20 33 8e	jsr $8e33			jsr SToF		;  ( work )
.8fc3	20 70 8b	jsr $8b70			jsr FMinus
.8fc6	20 a3 89	jsr $89a3			jsr F10Star
.8fc9	a4 54		ldy $54				ldy FIndex		;  until mantissa==0
.8fcb	b9 5f 00	lda $005f,y			lda FSMant0,y
.8fce	d0 c8		bne $8f98			bne _c
.8fd0	d6 24		dec $24,x	_d:		dec _decimalPos,x	;do trailing zeros
.8fd2	30 08		bmi $8fdc			bmi _d9
.8fd4	a9 30		lda #$30			lda #'0'
.8fd6	20 18 90	jsr $9018			jsr pfchar
.8fd9	4c d0 8f	jmp $8fd0			jmp _d
.8fdc					_d9:
.8fdc	e8		inx				inx			; drop work area
.8fdd	e8		inx				inx
.8fde	e8		inx				inx
.8fdf	e8		inx				inx
.8fe0	e6 54		inc $54				inc FIndex		; FDrop
.8fe2	60		rts				rts
=93					CodeLen	.var *-XtPtr1
=$8fe3					Here1 = *	; remember here
>8f84	5d					.byte CodeLen	;patch wh_CodeLength
.8fe3					FLt10:
.8fe3	a4 54		ldy $54		_1:		ldy FIndex		; while r >= 10
.8fe5	b9 55 00	lda $0055,y			lda FSExp,y
.8fe8	30 18		bmi $9002			bmi _9			;   exponent negative?
.8fea	c9 04		cmp #$04			cmp #4
.8fec	90 14		bcc $9002			bcc _9			;   < 4 ?
.8fee	d0 07		bne $8ff7			bne _2			;   > 4 ?
.8ff0	b9 5f 00	lda $005f,y			lda FSMant0,y		;   r > 10 ?
.8ff3	c9 50		cmp #$50			cmp #$50
.8ff5	90 0b		bcc $9002			bcc _9
.8ff7	f6 24		inc $24,x	_2:		inc DStack+0,x		;   exp ++
.8ff9	20 c9 88	jsr $88c9			jsr F10			;   r /= 10
.8ffc	20 9a 8c	jsr $8c9a			jsr FSlash
.8fff	4c e3 8f	jmp $8fe3			jmp _1
.9002	60		rts		_9:		rts
.9003					pfcstart:
.9003	a9 01		lda #$01			lda #1
.9005	8d 34 03	sta $0334			sta ToHold
.9008	a4 54		ldy $54				ldy FIndex		; if r1 negative
.900a	b9 5f 00	lda $005f,y			lda FSMant0,y
.900d	10 08		bpl $9017			bpl _19
.900f	a9 2d		lda #$2d			lda #'-'		;   append sign
.9011	20 18 90	jsr $9018			jsr pfchar
.9014	4c a5 8b	jmp $8ba5			jmp FNegate		;   make positive, return
.9017	60		rts		_19:		rts
.9018					pfchar:
.9018	ac 34 03	ldy $0334			ldy ToHold
.901b	91 00		sta ($00),y			sta (cp),y
.901d	ee 34 03	inc $0334			inc ToHold
.9020	60		rts				rts
.9021					pfcend:
.9021	ad 34 03	lda $0334			lda ToHold
.9024	38		sec				sec
.9025	e9 01		sbc #$01			sbc #1
.9027	a0 00		ldy #$00			ldy #0
.9029	91 00		sta ($00),y			sta (cp),y		; fill in length
.902b	4c 67 da	jmp $da67			jmp Here		; push start addr
.902e					pfciA:
.902e	a8		tay				tay
.902f	10 09		bpl $903a			bpl _15			; IfMi,
.9031	c8		iny				iny			;   negate
.9032	98		tya				tya
.9033	49 ff		eor #$ff			eor #$ff
.9035	48		pha				pha
.9036	a9 2d		lda #$2d			lda #'-'
.9038	d0 03		bne $903d			bne _19
.903a	48		pha		_15:		pha
.903b	a9 2b		lda #$2b			lda #'+'
.903d					_19:
.903d	20 18 90	jsr $9018			jsr pfchar
.9040	68		pla				pla
.9041	a0 2f		ldy #$2f			ldy #'0'-1
.9043	c8		iny		_20:		iny
.9044	38		sec				sec
.9045	e9 0a		sbc #$0a			sbc #10
.9047	b0 fa		bcs $9043			bcs _20
.9049	69 0a		adc #$0a			adc #10
.904b	48		pha				pha
.904c	98		tya				tya
.904d	20 18 90	jsr $9018			jsr pfchar
.9050	68		pla				pla
.9051	09 30		ora #$30			ora #'0'
.9053	d0 c3		bne $9018			bne pfchar
>9055	46 2e				Name0:	.text "F."	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=36823					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9057	c2					.byte (("F."[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=213					LinkDisplacement = Nt0-WordListLink
>9058	10					.byte WordFlags	;wh_Flags
>9059	03					.byte 3	;wh_CodeLength
>905a	d5					  .byte LinkDisplacement	; offset to previous nt
=$905b					XtPtr1 ::= *
=36823					WordListLink ::= Nt0 ; remember the nt of this word for later
.905b	20 86 8f	jsr $8f86	FDot:		jsr PFDot
.905e	20 dc c1	jsr $c1dc	FDot2:		jsr Count
.9061	20 39 de	jsr $de39			jsr Type
.9064	4c 2d de	jmp $de2d			jmp Space
=12					CodeLen	.var *-XtPtr1
=$9067					Here1 = *	; remember here
>9059	0c					.byte CodeLen	;patch wh_CodeLength
>9067	46 2e 53			Name0:	.text "F.S"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=36842					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>906a	63					.byte (("F.S"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=19					LinkDisplacement = Nt0-WordListLink
>906b	10					.byte WordFlags	;wh_Flags
>906c	03					.byte 3	;wh_CodeLength
>906d	13					  .byte LinkDisplacement	; offset to previous nt
=$906e					XtPtr1 ::= *
=36842					WordListLink ::= Nt0 ; remember the nt of this word for later
.906e	a9 09		lda #$09	FDotS:		lda #FDim-1	; for each FP stack entry
.9070	d0 0b		bne $907d			bne _8
.9072	48		pha		_2:		pha
.9073	20 9f 85	jsr $859f			jsr FPick3	;   print it
.9076	20 5b 90	jsr $905b			jsr FDot
.9079	68		pla				pla		;  next
.907a	38		sec				sec
.907b	e9 01		sbc #$01			sbc #1
.907d	c5 54		cmp $54		_8:		cmp FIndex
.907f	b0 f1		bcs $9072			bcs _2
=19					CodeLen	.var *-XtPtr1
=$9081					Here1 = *	; remember here
>906c	13					.byte CodeLen	;patch wh_CodeLength
.9081	60		rts				rts
>9082	28 46 53 2e 29			Name0:	.text "(FS.)"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=36871					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9087	25					.byte (("(FS.)"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=29					LinkDisplacement = Nt0-WordListLink
>9088	10					.byte WordFlags	;wh_Flags
>9089	03					.byte 3	;wh_CodeLength
>908a	1d					  .byte LinkDisplacement	; offset to previous nt
=$908b					XtPtr1 ::= *
=36871					WordListLink ::= Nt0 ; remember the nt of this word for later
.908b	20 f7 c7	jsr $c7f7	PFSDot:		jsr Zero		; alloc work area
=$24					_exp    = DStack+0
.908e	20 03 90	jsr $9003			jsr pfcstart		; start collecting chars, make r positive
.9091	20 e3 8f	jsr $8fe3			jsr FLt10		; scale down to <10
.9094	a4 54		ldy $54		_c1:		ldy FIndex		; while r < 1
.9096	b9 5f 00	lda $005f,y			lda FSMant0,y		;   mantissa == 0 ?
.9099	f0 0f		beq $90aa			beq _c9
.909b	b9 55 00	lda $0055,y			lda FSExp,y		;   exp < 1 ?
.909e	f0 02		beq $90a2			beq _c2
.90a0	10 08		bpl $90aa			bpl _c9
.90a2	d6 24		dec $24,x	_c2:		dec DStack+0,x		;  exp -= 1
.90a4	20 a3 89	jsr $89a3			jsr F10Star		;  r *= 10
.90a7	4c 94 90	jmp $9094			jmp _c1
.90aa					_c9:
.90aa	20 8f 8f	jsr $8f8f	PFSDotM:	jsr PFDotSub		; do mantissa
.90ad	a9 45		lda #$45			lda #'E'
.90af	20 18 90	jsr $9018			jsr pfchar		; do exponent
.90b2	b5 24		lda $24,x			lda DStack+0,x		;   _exp
.90b4	20 2e 90	jsr $902e			jsr pfciA
.90b7	e8		inx				inx			; Drop work area
.90b8	e8		inx				inx
.90b9	4c 21 90	jmp $9021			jmp pfcend		; finish string
=49					CodeLen	.var *-XtPtr1
=$90bc					Here1 = *	; remember here
>9089	31					.byte CodeLen	;patch wh_CodeLength
>90bc	46 53 2e			Name0:	.text "FS."	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=36927					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>90bf	c3					.byte (("FS."[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=56					LinkDisplacement = Nt0-WordListLink
>90c0	10					.byte WordFlags	;wh_Flags
>90c1	03					.byte 3	;wh_CodeLength
>90c2	38					  .byte LinkDisplacement	; offset to previous nt
=$90c3					XtPtr1 ::= *
=36927					WordListLink ::= Nt0 ; remember the nt of this word for later
.90c3	20 8b 90	jsr $908b	FSDot:		jsr PFSDot
.90c6	4c 5e 90	jmp $905e			jmp FDot2
=6					CodeLen	.var *-XtPtr1
=$90c9					Here1 = *	; remember here
>90c1	06					.byte CodeLen	;patch wh_CodeLength
>90c9	28 46 45 2e 29			Name0:	.text "(FE.)"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=36942					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>90ce	25					.byte (("(FE.)"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=15					LinkDisplacement = Nt0-WordListLink
>90cf	10					.byte WordFlags	;wh_Flags
>90d0	03					.byte 3	;wh_CodeLength
>90d1	0f					  .byte LinkDisplacement	; offset to previous nt
=$90d2					XtPtr1 ::= *
=36942					WordListLink ::= Nt0 ; remember the nt of this word for later
.90d2	20 f7 c7	jsr $c7f7	PFEDot:		jsr Zero		; alloc work area
=$24					_exp    = DStack+0
.90d5	20 03 90	jsr $9003			jsr pfcstart		; start collecting chars, make r positive
.90d8	a4 54		ldy $54		_30:		ldy FIndex		; while r < 1
.90da	b9 5f 00	lda $005f,y			lda FSMant0,y
.90dd	f0 16		beq $90f5			beq _39
.90df	b9 55 00	lda $0055,y			lda FSExp,y
.90e2	f0 02		beq $90e6			beq _31
.90e4	10 0f		bpl $90f5			bpl _39
.90e6	d6 24		dec $24,x	_31:		dec _exp,x		;  exp -= 3
.90e8	d6 24		dec $24,x			dec _exp,x
.90ea	d6 24		dec $24,x			dec _exp,x
.90ec	20 bb 88	jsr $88bb			jsr F1000		;  r *= 1000
.90ef	20 fe 8b	jsr $8bfe			jsr FStar
.90f2	4c d8 90	jmp $90d8			jmp _30
.90f5					_39:
.90f5	a4 54		ldy $54		_a:		ldy FIndex		; while r >= 1000
.90f7	b9 55 00	lda $0055,y			lda FSExp,y
.90fa	30 1c		bmi $9118			bmi _a9			; exponent negative?
.90fc	c9 0a		cmp #$0a			cmp #10
.90fe	90 18		bcc $9118			bcc _a9			;   < 10 ?
.9100	d0 07		bne $9109			bne _a2			;   > 10 ?
.9102	b9 5f 00	lda $005f,y			lda FSMant0,y
.9105	c9 7d		cmp #$7d			cmp #$7d
.9107	90 0f		bcc $9118			bcc _a9
.9109	f6 24		inc $24,x	_a2:		inc _exp,x		;   exp += 3
.910b	f6 24		inc $24,x			inc _exp,x
.910d	f6 24		inc $24,x			inc _exp,x
.910f	20 bb 88	jsr $88bb			jsr F1000		;   r /= 1000
.9112	20 9a 8c	jsr $8c9a			jsr FSlash
.9115	4c f5 90	jmp $90f5			jmp _a
.9118					_a9:
.9118	4c aa 90	jmp $90aa			jmp PFSDotM
=73					CodeLen	.var *-XtPtr1
=$911b					Here1 = *	; remember here
>90d0	49					.byte CodeLen	;patch wh_CodeLength
>911b	46 45 2e			Name0:	.text "FE."	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=37022					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>911e	c3					.byte (("FE."[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=80					LinkDisplacement = Nt0-WordListLink
>911f	10					.byte WordFlags	;wh_Flags
>9120	03					.byte 3	;wh_CodeLength
>9121	50					  .byte LinkDisplacement	; offset to previous nt
=$9122					XtPtr1 ::= *
=37022					WordListLink ::= Nt0 ; remember the nt of this word for later
.9122	20 d2 90	jsr $90d2	FEDot:		jsr PFEDot
.9125	4c 5e 90	jmp $905e			jmp FDot2
=6					CodeLen	.var *-XtPtr1
=$9128					Here1 = *	; remember here
>9120	06					.byte CodeLen	;patch wh_CodeLength
>9128	46 27				Name0:	.text "F'"	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=37034					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>912a	e2					.byte (("F'"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=24					WordFlags ::= IM+NN	; modifiable copy, remember for later
=12					LinkDisplacement = Nt0-WordListLink
>912b	18					.byte WordFlags	;wh_Flags
>912c	03					.byte 3	;wh_CodeLength
>912d	0c					  .byte LinkDisplacement	; offset to previous nt
=$912e					XtPtr1 ::= *
=37034					WordListLink ::= Nt0 ; remember the nt of this word for later
.912e	20 87 ca	jsr $ca87	FQuote:		jsr Parse_Name		; get string
.9131	20 51 91	jsr $9151			jsr ToFloat		; convert
.9134	b5 24		lda $24,x			lda DStack+0,x		; error?
.9136	f0 0a		beq $9142			beq _Err
.9138	e8		inx				inx
.9139	e8		inx				inx
.913a	a5 0a		lda $0a				lda State		; compiling?
.913c	d0 01		bne $913f			bne _compile
.913e	60		rts				rts
.913f	4c 0a 88	jmp $880a	_compile:	jmp FLiteral		; compile a FP literal
.9142	a9 36		lda #$36	_Err:		lda #100+err_FPInvalidArg
.9144	20 68 c4	jsr $c468			jsr ThrowA
=25					CodeLen	.var *-XtPtr1
=$9147					Here1 = *	; remember here
>912c	19					.byte CodeLen	;patch wh_CodeLength
>9147	3e 46 6c 6f 61 74		Name0:	.text ">Float"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=37069					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>914d	86					.byte ((">Float"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=35					LinkDisplacement = Nt0-WordListLink
>914e	10					.byte WordFlags	;wh_Flags
>914f	03					.byte 3	;wh_CodeLength
>9150	23					  .byte LinkDisplacement	; offset to previous nt
=$9151					XtPtr1 ::= *
=37069					WordListLink ::= Nt0 ; remember the nt of this word for later
.9151					ToFloat:
.9151	20 f7 c7	jsr $c7f7			jsr Zero	; alloc & init workspace
.9154	20 f7 c7	jsr $c7f7			jsr Zero
.9157	20 f7 c7	jsr $c7f7			jsr Zero
=$2c					_addr		= DStack+8
=$2a					_len		= DStack+6
=$29					_mantfound 	= DStack+5		;mantissa digits found
=$28					_exponent 	= DStack+4		;exponent
=$27					_decimalPos 	= DStack+3		;decimal point position
=$26					_DecPointFound1 = DStack+2
=$25					_MantissaNegative1 = DStack+1
=$24					_ExponentNegative1 = DStack+0
.915a	20 ab 88	jsr $88ab			jsr F0			; init result
.915d	20 2f 92	jsr $922f	_11:		jsr _GetChar		; get mantissa prefix
.9160	b0 57		bcs $91b9			bcs _trueb ;_finishb
.9162	c9 20		cmp #$20			cmp #' '
.9164	f0 f7		beq $915d			beq _11
.9166	c9 2b		cmp #$2b			cmp #'+'
.9168	f0 06		beq $9170			beq _20
.916a	c9 2d		cmp #$2d			cmp #'-'
.916c	d0 07		bne $9175			bne _21
.916e	95 25		sta $25,x			sta _MantissaNegative1,x ; remember mantissa is negative
.9170	20 2f 92	jsr $922f	_20:		jsr _GetChar		; do next mantissa digits
.9173	b0 47		bcs $91bc			bcs _finishb
.9175	c9 2e		cmp #$2e	_21:		cmp #'.'
.9177	f0 31		beq $91aa			beq _27
.9179	c9 45		cmp #$45			cmp #'E'
.917b	f0 42		beq $91bf			beq _30
.917d	c9 65		cmp #$65			cmp #'e'
.917f	f0 3e		beq $91bf			beq _30
.9181	c9 44		cmp #$44			cmp #'D'
.9183	f0 3a		beq $91bf			beq _30
.9185	c9 64		cmp #$64			cmp #'d'
.9187	f0 36		beq $91bf			beq _30
.9189	38		sec				sec			;   a digit?
.918a	e9 30		sbc #$30			sbc #'0'
.918c	90 24		bcc $91b2			bcc _fail
.918e	c9 0a		cmp #$0a			cmp #9+1
.9190	b0 20		bcs $91b2			bcs _fail
.9192	48		pha				pha			; append digit to mantissa
.9193	20 a3 89	jsr $89a3			jsr F10Star
.9196	68		pla				pla
.9197	a0 00		ldy #$00			ldy #0
.9199	20 36 8e	jsr $8e36			jsr SToFYA
.919c	20 30 8b	jsr $8b30			jsr FPlus
.919f	f6 29		inc $29,x			inc _mantfound,x	; remember we found a mantissa digit
.91a1	b5 26		lda $26,x			lda _DecPointFound1,x	; if mantissa decimal point found
.91a3	f0 02		beq $91a7			beq +
.91a5	d6 27		dec $27,x			dec _decimalPos,x	;   increment decimal point position
.91a7					+
.91a7	4c 70 91	jmp $9170			jmp _20
.91aa					_27:
.91aa	b4 26		ldy $26,x			ldy _DecPointFound1,x	; already have one?
.91ac	d0 04		bne $91b2			bne _fail
.91ae	95 26		sta $26,x			sta _DecPointFound1,x	; we have one now!
.91b0	f0 be		beq $9170			beq _20
.91b2					_fail:
.91b2	20 14 85	jsr $8514			jsr FDrop
.91b5	a9 00		lda #$00			lda #0			;return false
.91b7	f0 69		beq $9222			beq _return
.91b9	4c 20 92	jmp $9220	_trueb:		jmp _true
.91bc	4c ed 91	jmp $91ed	_finishb:	jmp _finish
.91bf					_30:
.91bf	20 2f 92	jsr $922f			jsr _GetChar
.91c2	b0 29		bcs $91ed			bcs _finish
.91c4	c9 2b		cmp #$2b			cmp #'+'
.91c6	f0 06		beq $91ce			beq _40
.91c8	c9 2d		cmp #$2d			cmp #'-'
.91ca	d0 07		bne $91d3			bne _41
.91cc	95 24		sta $24,x			sta _ExponentNegative1,x ; remember exponent is negative
.91ce	20 2f 92	jsr $922f	_40:		jsr _GetChar		;get exponent digits
.91d1	b0 1a		bcs $91ed			bcs _finish
.91d3	38		sec		_41:		sec			;  digit?
.91d4	e9 30		sbc #$30			sbc #'0'
.91d6	90 da		bcc $91b2			bcc _fail
.91d8	c9 0a		cmp #$0a			cmp #9+1
.91da	b0 d6		bcs $91b2			bcs _fail
.91dc	85 14		sta $14				sta tmp1
.91de	16 28		asl $28,x			asl _exponent,x		;  exponent *= 10
.91e0	b5 28		lda $28,x			lda _exponent,x
.91e2	0a		asl a				asl a
.91e3	0a		asl a				asl a
.91e4	75 28		adc $28,x			adc _exponent,x
.91e6	65 14		adc $14				adc tmp1		;  + digit
.91e8	95 28		sta $28,x			sta _exponent,x
.91ea	4c ce 91	jmp $91ce			jmp _40
.91ed					_finish:
.91ed	b5 29		lda $29,x			lda _mantfound,x	;some mantissa digits found?
.91ef	f0 c1		beq $91b2			beq _fail
.91f1	b5 24		lda $24,x			lda _ExponentNegative1,x ;apply exponent sign
.91f3	f0 07		beq $91fc			beq +
.91f5	a9 00		lda #$00			lda #0
.91f7	38		sec				sec
.91f8	f5 28		sbc $28,x			sbc _exponent,x
.91fa	95 28		sta $28,x			sta _exponent,x
.91fc					+
.91fc	b5 28		lda $28,x			lda _exponent,x		;apply decimal position to exponent
.91fe	18		clc				clc
.91ff	75 27		adc $27,x			adc _decimalPos,x
.9201	95 28		sta $28,x			sta _exponent,x
.9203	4c 0b 92	jmp $920b			jmp _93
.9206	20 a3 89	jsr $89a3	_93b:		jsr F10Star		;apply exponent to mantissa
.9209	d6 28		dec $28,x			dec _exponent,x
.920b	f0 0a		beq $9217	_93:		beq _94
.920d	10 f7		bpl $9206			bpl _93b
.920f	20 c9 88	jsr $88c9	_94b:		jsr F10
.9212	20 9a 8c	jsr $8c9a			jsr FSlash
.9215	f6 28		inc $28,x			inc _exponent,x
.9217	30 f6		bmi $920f	_94:		bmi _94b
.9219					_95:
.9219	b5 25		lda $25,x			lda _MantissaNegative1,x ;apply mantissa sign
.921b	f0 03		beq $9220			beq +
.921d	20 a5 8b	jsr $8ba5			jsr FNegate
.9220					+
.9220	a9 ff		lda #$ff	_true:		lda #$ff		;return true
.9222					_return:
.9222	95 2c		sta $2c,x			sta _addr+0,x		; replace _addr with flag
.9224	95 2d		sta $2d,x			sta _addr+1,x
.9226	e8		inx				inx			; Drop work
.9227	e8		inx				inx
.9228	e8		inx				inx			; 2Drop work
.9229	e8		inx				inx
.922a	e8		inx				inx
.922b	e8		inx				inx
.922c	e8		inx				inx			; Drop len
.922d	e8		inx				inx
.922e	60		rts				rts
.922f					_GetChar:
.922f	38		sec				sec
.9230	b5 2a		lda $2a,x			lda _len,x
.9232	f0 0b		beq $923f			beq _gc_rts		; if end, return C=1
.9234	d6 2a		dec $2a,x			dec _len,x
.9236	a1 2c		lda ($2c,x)			lda (_addr,x)
.9238	f6 2c		inc $2c,x			inc _addr+0,x
.923a	d0 02		bne $923e			bne +
.923c	f6 2d		inc $2d,x			inc _addr+1,x
.923e					+
.923e	18		clc				clc			; get char, return C=0
.923f	60		rts		_gc_rts:	rts
>9240	46 4b 65 79			Name0:	.text "FKey"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=37316					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9244	24					.byte (("FKey"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=247					LinkDisplacement = Nt0-WordListLink
>9245	10					.byte WordFlags	;wh_Flags
>9246	03					.byte 3	;wh_CodeLength
>9247	f7					  .byte LinkDisplacement	; offset to previous nt
=$9248					XtPtr1 ::= *
=37316					WordListLink ::= Nt0 ; remember the nt of this word for later
.9248					FKey:
.9248	20 67 da	jsr $da67			jsr Here		; ( addr )
.924b	20 67 da	jsr $da67			jsr Here		; ( addr addr )
.924e	a9 28		lda #$28			lda #40			; ( addr addr 40 )
.9250	20 e9 c7	jsr $c7e9			jsr PushZA
.9253	20 de d2	jsr $d2de			jsr Accept		; ( addr len )
.9256	20 51 91	jsr $9151			jsr ToFloat		; ( true | false)
.9259	e8		inx				inx			; err?
.925a	e8		inx				inx
.925b	b5 22		lda $22,x			lda DStack-2,x
.925d	f0 01		beq $9260			beq _err
.925f	60		rts				rts
.9260	20 bd c8	jsr $c8bd	_err:		jsr SLiteral_runtime
.9263	4c 69 92	jmp $9269			  jmp +
>9266	20 3f 20					  .text " ? "
.9269	20 39 de	jsr $de39	+		jsr Type
.926c	4c 48 92	jmp $9248			jmp FKey
>926f	53 46 40			Name0:	.text "SF@"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=37362					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9272	03					.byte (("SF@"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=46					LinkDisplacement = Nt0-WordListLink
>9273	10					.byte WordFlags	;wh_Flags
>9274	03					.byte 3	;wh_CodeLength
>9275	2e					  .byte LinkDisplacement	; offset to previous nt
=$9276					XtPtr1 ::= *
=37362					WordListLink ::= Nt0 ; remember the nt of this word for later
.9276	20 e3 c3	jsr $c3e3	SFAt:		jsr PopYA		; pop sf_addr
.9279	85 16		sta $16		SFAt_YA:	sta tmp2+0		; save sf_addr
.927b	84 17		sty $17				sty tmp2+1
.927d	20 c8 84	jsr $84c8			jsr FAllocX		; alloc FP stack entry
.9280	a0 01		ldy #$01			ldy #1			; copy exponent
.9282	b1 16		lda ($16),y			lda (tmp2),y
.9284	0a		asl a				asl a
.9285	88		dey				dey
.9286	b1 16		lda ($16),y			lda (tmp2),y
.9288	2a		rol a				rol a
.9289	38		sec				sec
.928a	e9 7e		sbc #$7e			sbc #126
.928c	95 55		sta $55,x			sta FSExp,x
.928e	a0 01		ldy #$01			ldy #1			; copy mantissa
.9290	b1 16		lda ($16),y			lda (tmp2),y
.9292	09 80		ora #$80			ora #$80
.9294	4a		lsr a				lsr a
.9295	95 5f		sta $5f,x			sta FSMant0,x
.9297	c8		iny				iny
.9298	b1 16		lda ($16),y			lda (tmp2),y
.929a	6a		ror a				ror a
.929b	95 69		sta $69,x			sta FSMant1,x
.929d	c8		iny				iny
.929e	b1 16		lda ($16),y			lda (tmp2),y
.92a0	6a		ror a				ror a
.92a1	95 73		sta $73,x			sta FSMant2,x
.92a3	a9 00		lda #$00			lda #0
.92a5	6a		ror a				ror a
.92a6	95 7d		sta $7d,x			sta FSMant3,x
.92a8	a6 14		ldx $14				ldx tmp1+0		; restore data stack index
.92aa	a0 00		ldy #$00			ldy #0			; get sign
.92ac	b1 16		lda ($16),y			lda (tmp2),y
.92ae	10 03		bpl $92b3			bpl +
.92b0	20 a5 8b	jsr $8ba5			jsr FNegate
.92b3					+
=61					CodeLen	.var *-XtPtr1
=$92b3					Here1 = *	; remember here
>9274	3d					.byte CodeLen	;patch wh_CodeLength
.92b3	60		rts				rts
>92b4	53 46 21			Name0:	.text "SF!"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=37431					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>92b7	23					.byte (("SF!"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=69					LinkDisplacement = Nt0-WordListLink
>92b8	10					.byte WordFlags	;wh_Flags
>92b9	03					.byte 3	;wh_CodeLength
>92ba	45					  .byte LinkDisplacement	; offset to previous nt
=$92bb					XtPtr1 ::= *
=37431					WordListLink ::= Nt0 ; remember the nt of this word for later
.92bb	20 e3 c3	jsr $c3e3	SFStore:	jsr PopYA		; pop sf_addr
.92be	85 16		sta $16		SFStore_YA:	sta tmp2+0		; save
.92c0	84 17		sty $17				sty tmp2+1
.92c2	a4 54		ldy $54				ldy FIndex		; negative?
.92c4	b9 5f 00	lda $005f,y			lda FSMant0,y
.92c7	29 80		and #$80			and #$80		;  save sign
.92c9	85 19		sta $19				sta tmp3+1
.92cb	10 03		bpl $92d0			bpl +
.92cd	20 a5 8b	jsr $8ba5			jsr FNegate
.92d0					+
.92d0	86 14		stx $14				stx tmp1+0		; save data stack index
.92d2	a6 54		ldx $54				ldx FIndex		; switch to FP stack index
.92d4	b5 55		lda $55,x			lda FSExp,x		; +128
.92d6	18		clc				clc
.92d7	69 7e		adc #$7e			adc #126
.92d9	95 55		sta $55,x			sta FSExp,x
.92db	16 7d		asl $7d,x			asl FSMant3,x
.92dd	b5 73		lda $73,x			lda FSMant2,x
.92df	2a		rol a				rol a
.92e0	a0 03		ldy #$03			ldy #3			; +3 IEEE
.92e2	91 16		sta ($16),y			sta (tmp2),y
.92e4	b5 69		lda $69,x			lda FSMant1,x
.92e6	2a		rol a				rol a
.92e7	88		dey				dey			; +2 IEEE
.92e8	91 16		sta ($16),y			sta (tmp2),y
.92ea	b5 5f		lda $5f,x			lda FSMant0,x
.92ec	2a		rol a				rol a
.92ed	2a		rol a				rol a
.92ee	56 55		lsr $55,x			lsr FSExp,x
.92f0	6a		ror a				ror a
.92f1	88		dey				dey			; +1 IEEE
.92f2	91 16		sta ($16),y			sta (tmp2),y
.92f4	b5 55		lda $55,x			lda FSExp,x
.92f6	05 19		ora $19				ora tmp3+1		;  insert sign
.92f8	88		dey				dey			; +0 IEEE
.92f9	91 16		sta ($16),y			sta (tmp2),y
.92fb	e6 54		inc $54				inc FIndex		; FDrop
.92fd	a6 14		ldx $14				ldx tmp1+0		; restore data stack index
=68					CodeLen	.var *-XtPtr1
=$92ff					Here1 = *	; remember here
>92b9	44					.byte CodeLen	;patch wh_CodeLength
.92ff	60		rts				rts
>9300	53 46 6c 6f 61 74 2b		Name0:	.text "SFloat+"	;  name of word as a string, ending at wh_NameLastChar
=7					NameLength = *-Name0
=37511					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9307	67					.byte (("SFloat+"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=80					LinkDisplacement = Nt0-WordListLink
>9308	10					.byte WordFlags	;wh_Flags
>9309	03					.byte 3	;wh_CodeLength
>930a	50					  .byte LinkDisplacement	; offset to previous nt
=$930b					XtPtr1 ::= *
=37511					WordListLink ::= Nt0 ; remember the nt of this word for later
.930b	a9 04		lda #$04	SFloatPlus:	lda #4
.930d	4c 48 da	jmp $da48			jmp Plus_A
=5					CodeLen	.var *-XtPtr1
=$9310					Here1 = *	; remember here
>9309	05					.byte CodeLen	;patch wh_CodeLength
>9310	53 46 6c 6f 61 74 73		Name0:	.text "SFloats"	;  name of word as a string, ending at wh_NameLastChar
=7					NameLength = *-Name0
=37527					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9317	67					.byte (("SFloats"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=16					LinkDisplacement = Nt0-WordListLink
>9318	10					.byte WordFlags	;wh_Flags
>9319	03					.byte 3	;wh_CodeLength
>931a	10					  .byte LinkDisplacement	; offset to previous nt
=$931b					XtPtr1 ::= *
=37527					WordListLink ::= Nt0 ; remember the nt of this word for later
.931b	a9 02		lda #$02	SFloats:	lda #2
.931d	4c 8c db	jmp $db8c			jmp LShift_A
=5					CodeLen	.var *-XtPtr1
=$9320					Here1 = *	; remember here
>9319	05					.byte CodeLen	;patch wh_CodeLength
>9320	44 46 21			Name0:	.text "DF!"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=37539					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9323	23					.byte (("DF!"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=12					LinkDisplacement = Nt0-WordListLink
>9324	10					.byte WordFlags	;wh_Flags
>9325	03					.byte 3	;wh_CodeLength
>9326	0c					  .byte LinkDisplacement	; offset to previous nt
=$9327					XtPtr1 ::= *
=37539					WordListLink ::= Nt0 ; remember the nt of this word for later
.9327	20 e3 c3	jsr $c3e3	DFStore:	jsr PopYA		; pop df_addr
.932a	85 16		sta $16		DFStore_YA:	sta tmp2+0		; save df_addr
.932c	84 17		sty $17				sty tmp2+1
.932e	a4 54		ldy $54				ldy FIndex		; negative?
.9330	b9 5f 00	lda $005f,y			lda FSMant0,y
.9333	29 80		and #$80			and #$80		; remember sign
.9335	85 19		sta $19				sta tmp3+1
.9337	10 03		bpl $933c			bpl +			; make positive
.9339	20 a5 8b	jsr $8ba5			jsr FNegate
.933c					+
.933c	86 14		stx $14				stx tmp1+0		; save data stack index
.933e	a6 54		ldx $54				ldx FIndex
.9340	a9 00		lda #$00			lda #0
.9342	a0 07		ldy #$07			ldy #7			; +7 IEEE
.9344	91 16		sta ($16),y			sta (tmp2),y
.9346	88		dey				dey			; +6 IEEE
.9347	91 16		sta ($16),y			sta (tmp2),y
.9349	20 91 93	jsr $9391			jsr _shift		; shift mantissa
.934c	20 91 93	jsr $9391			jsr _shift
.934f	88		dey				dey			; +5 IEEE
.9350	91 16		sta ($16),y			sta (tmp2),y
.9352	b5 7d		lda $7d,x			lda FSMant3,x
.9354	88		dey				dey			; +4 IEEE
.9355	91 16		sta ($16),y			sta (tmp2),y
.9357	b5 73		lda $73,x			lda FSMant2,x
.9359	88		dey				dey			; +3 IEEE
.935a	91 16		sta ($16),y			sta (tmp2),y
.935c	b5 69		lda $69,x			lda FSMant1,x
.935e	88		dey				dey			; +2 IEEE
.935f	91 16		sta ($16),y			sta (tmp2),y
.9361	b5 5f		lda $5f,x			lda FSMant0,x		; clear extra bits
.9363	29 0f		and #$0f			and #$f
.9365	95 5f		sta $5f,x			sta FSMant0,x
.9367	b5 55		lda $55,x			lda FSExp,x
.9369	38		sec				sec
.936a	e9 02		sbc #$02			sbc #2
.936c	95 55		sta $55,x			sta FSExp,x
.936e	0a		asl a				asl a
.936f	0a		asl a				asl a
.9370	0a		asl a				asl a
.9371	0a		asl a				asl a
.9372	15 5f		ora $5f,x			ora FSMant0,x
.9374	88		dey				dey			; +1 IEEE
.9375	91 16		sta ($16),y			sta (tmp2),y
.9377	b5 55		lda $55,x			lda FSExp,x
.9379	08		php				php
.937a	4a		lsr a				lsr a
.937b	4a		lsr a				lsr a
.937c	4a		lsr a				lsr a
.937d	4a		lsr a				lsr a
.937e	18		clc				clc
.937f	69 30		adc #$30			adc #$30
.9381	28		plp				plp
.9382	30 03		bmi $9387			bmi +
.9384	18		clc				clc
.9385	69 10		adc #$10			adc #$10
.9387	05 19		ora $19		+		ora tmp3+1		; add sign bit
.9389	88		dey				dey			; +0 IEEE
.938a	91 16		sta ($16),y			sta (tmp2),y
.938c	e6 54		inc $54				inc FIndex		; FDrop
.938e	a6 14		ldx $14				ldx tmp1+0		; restore data stack index
.9390	60		rts				rts
.9391	56 5f		lsr $5f,x	_shift:		lsr FSMant0,x
.9393	76 69		ror $69,x			ror FSMant1,x
.9395	76 73		ror $73,x			ror FSMant2,x
.9397	76 7d		ror $7d,x			ror FSMant3,x
.9399	6a		ror a				ror a
=115					CodeLen	.var *-XtPtr1
=$939a					Here1 = *	; remember here
>9325	73					.byte CodeLen	;patch wh_CodeLength
.939a	60		rts				rts
>939b	44 46 40			Name0:	.text "DF@"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=37662					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>939e	03					.byte (("DF@"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=123					LinkDisplacement = Nt0-WordListLink
>939f	10					.byte WordFlags	;wh_Flags
>93a0	03					.byte 3	;wh_CodeLength
>93a1	7b					  .byte LinkDisplacement	; offset to previous nt
=$93a2					XtPtr1 ::= *
=37662					WordListLink ::= Nt0 ; remember the nt of this word for later
.93a2	20 e3 c3	jsr $c3e3	DFAt:		jsr PopYA		; pop df_addr
.93a5	85 16		sta $16		DFAt_YA:	sta tmp2+0		; save df_addr
.93a7	84 17		sty $17				sty tmp2+1
.93a9	20 c8 84	jsr $84c8			jsr FAllocX		; alloc FP stack entry
.93ac	a0 00		ldy #$00			ldy #0			; +0 IEEE byte
.93ae	b1 16		lda ($16),y			lda (tmp2),y
.93b0	95 55		sta $55,x			sta FSExp,x
.93b2	c8		iny				iny			; +1 IEEE byte
.93b3	b1 16		lda ($16),y			lda (tmp2),y
.93b5	95 5f		sta $5f,x			sta FSMant0,x
.93b7	c8		iny				iny			; +2 IEEE byte
.93b8	b1 16		lda ($16),y			lda (tmp2),y
.93ba	95 69		sta $69,x			sta FSMant1,x
.93bc	c8		iny				iny			; +3 IEEE byte
.93bd	b1 16		lda ($16),y			lda (tmp2),y
.93bf	95 73		sta $73,x			sta FSMant2,x
.93c1	c8		iny				iny			; +4 IEEE byte
.93c2	b1 16		lda ($16),y			lda (tmp2),y
.93c4	95 7d		sta $7d,x			sta FSMant3,x
.93c6	c8		iny				iny			; +5 IEEE byte
.93c7	b1 16		lda ($16),y			lda (tmp2),y
.93c9	20 f2 93	jsr $93f2			jsr _shifta		; shift exponent & mantissa bits into place
.93cc	20 f2 93	jsr $93f2			jsr _shifta
.93cf	b5 5f		lda $5f,x			lda FSMant0,x		; finish shifting exponent bits
.93d1	0a		asl a				asl a
.93d2	36 55		rol $55,x			rol FSExp,x
.93d4	0a		asl a				asl a
.93d5	36 55		rol $55,x			rol FSExp,x
.93d7	b5 55		lda $55,x			lda FSExp,x		; remove +1023
.93d9	18		clc				clc
.93da	69 02		adc #$02			adc #2
.93dc	95 55		sta $55,x			sta FSExp,x
.93de	b5 5f		lda $5f,x			lda FSMant0,x
.93e0	29 7f		and #$7f			and #$7f
.93e2	09 40		ora #$40			ora #$40		;   insert implied 1
.93e4	95 5f		sta $5f,x			sta FSMant0,x		;   insert sign=0
.93e6	a6 14		ldx $14				ldx tmp1		; restore data stack index
.93e8	a0 00		ldy #$00			ldy #0			; get sign from +0 IEEE byte
.93ea	b1 16		lda ($16),y			lda (tmp2),y
.93ec	10 03		bpl $93f1			bpl +
.93ee	20 a5 8b	jsr $8ba5			jsr FNegate
.93f1					+
.93f1	60		rts				rts
.93f2	0a		asl a		_shifta:	asl a
.93f3	36 7d		rol $7d,x			rol FSMant3,x
.93f5	36 73		rol $73,x			rol FSMant2,x
.93f7	36 69		rol $69,x			rol FSMant1,x
.93f9	36 5f		rol $5f,x			rol FSMant0,x
.93fb	36 55		rol $55,x			rol FSExp,x
.93fd	60		rts				rts
=92					CodeLen	.var *-XtPtr1
=$93fe					Here1 = *	; remember here
>93a0	5c					.byte CodeLen	;patch wh_CodeLength
>93fe	44 46 6c 6f 61 74 2b		Name0:	.text "DFloat+"	;  name of word as a string, ending at wh_NameLastChar
=7					NameLength = *-Name0
=37765					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9405	67					.byte (("DFloat+"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=103					LinkDisplacement = Nt0-WordListLink
>9406	10					.byte WordFlags	;wh_Flags
>9407	03					.byte 3	;wh_CodeLength
>9408	67					  .byte LinkDisplacement	; offset to previous nt
=$9409					XtPtr1 ::= *
=37765					WordListLink ::= Nt0 ; remember the nt of this word for later
.9409	a9 08		lda #$08	DFloatPlus:	lda #8
.940b	4c 48 da	jmp $da48			jmp Plus_A
=5					CodeLen	.var *-XtPtr1
=$940e					Here1 = *	; remember here
>9407	05					.byte CodeLen	;patch wh_CodeLength
>940e	44 46 6c 6f 61 74 73		Name0:	.text "DFloats"	;  name of word as a string, ending at wh_NameLastChar
=7					NameLength = *-Name0
=37781					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9415	67					.byte (("DFloats"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=16					LinkDisplacement = Nt0-WordListLink
>9416	10					.byte WordFlags	;wh_Flags
>9417	03					.byte 3	;wh_CodeLength
>9418	10					  .byte LinkDisplacement	; offset to previous nt
=$9419					XtPtr1 ::= *
=37781					WordListLink ::= Nt0 ; remember the nt of this word for later
.9419	a9 03		lda #$03	DFloats:	lda #3
.941b	4c 8c db	jmp $db8c			jmp LShift_A
=5					CodeLen	.var *-XtPtr1
=$941e					Here1 = *	; remember here
>9417	05					.byte CodeLen	;patch wh_CodeLength
>941e	46 4d 50 6f 6c 79		Name0:	.text "FMPoly"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=37796					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9424	26					.byte (("FMPoly"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=15					LinkDisplacement = Nt0-WordListLink
>9425	10					.byte WordFlags	;wh_Flags
>9426	03					.byte 3	;wh_CodeLength
>9427	0f					  .byte LinkDisplacement	; offset to previous nt
=$9428					XtPtr1 ::= *
=37796					WordListLink ::= Nt0 ; remember the nt of this word for later
.9428	20 e3 c3	jsr $c3e3	FMPoly:		jsr PopYA
.942b	20 ba c7	jsr $c7ba	FMPolyYA:	jsr PushYA		; push coefficent table addr
.942e	20 52 86	jsr $8652			jsr FAt_YA		; fetch 1st coefficent
.9431	4c 44 94	jmp $9444			jmp _4
.9434	20 76 85	jsr $8576	_2:		jsr FOver
.9437	20 fe 8b	jsr $8bfe			jsr FStar
.943a	b5 24		lda $24,x			lda DStack+0,x		; fetch next coefficent
.943c	b4 25		ldy $25,x			ldy DStack+1,x
.943e	20 52 86	jsr $8652			jsr FAt_YA
.9441	20 30 8b	jsr $8b30			jsr FPlus
.9444	a9 05		lda #$05	_4:		lda #Float_Size		; bump coefficent ptr
.9446	20 48 da	jsr $da48			jsr Plus_A
.9449	a1 24		lda ($24,x)			lda (DStack+0,x)	; end of coefficent list?
.944b	d0 e7		bne $9434			bne _2
.944d	e8		inx				inx			; Drop coefficent ptr
.944e	e8		inx				inx
=39					CodeLen	.var *-XtPtr1
=$944f					Here1 = *	; remember here
>9426	27					.byte CodeLen	;patch wh_CodeLength
.944f	60		rts				rts
>9450	46 4c 6f 67 32 4d 31 4d		Name0:	.text "FLog2M1M"	;  name of word as a string, ending at wh_NameLastChar
=8					NameLength = *-Name0
=37848					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9458	a8					.byte (("FLog2M1M"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=52					LinkDisplacement = Nt0-WordListLink
>9459	10					.byte WordFlags	;wh_Flags
>945a	03					.byte 3	;wh_CodeLength
>945b	34					  .byte LinkDisplacement	; offset to previous nt
=$945c					XtPtr1 ::= *
=37848					WordListLink ::= Nt0 ; remember the nt of this word for later
.945c	a9 66		lda #$66	FLog2M1M:	lda #<_c
.945e	a0 94		ldy #$94			ldy #>_c
.9460	20 2b 94	jsr $942b			jsr FMPolyYA
.9463	4c fe 8b	jmp $8bfe			jmp FStar
=10					CodeLen	.var *-XtPtr1
=$9466					Here1 = *	; remember here
>945a	0a					.byte CodeLen	;patch wh_CodeLength
.9466					_c:
>9466	cc cf 97 7c					.dword $7C97CFCC	; 32 bit signed binary mantissa.  $40000000 = +0.5
>946a	fa						.char -6		; 8 bit signed binary exponent.  $00 = 2**0
>946b	64 87 94 af					.dword $AF948764	; 32 bit signed binary mantissa.  $40000000 = +0.5
>946f	fd						.char -3		; 8 bit signed binary exponent.  $00 = 2**0
>9470	66 c8 d4 62					.dword $62D4C866	; 32 bit signed binary mantissa.  $40000000 = +0.5
>9474	fe						.char -2		; 8 bit signed binary exponent.  $00 = 2**0
>9475	e2 9c c3 ac					.dword $ACC39CE2	; 32 bit signed binary mantissa.  $40000000 = +0.5
>9479	ff						.char -1		; 8 bit signed binary exponent.  $00 = 2**0
>947a	1a c6 2b 79					.dword $792BC61A	; 32 bit signed binary mantissa.  $40000000 = +0.5
>947e	ff						.char -1		; 8 bit signed binary exponent.  $00 = 2**0
>947f	07 e1 c4 a3					.dword $A3C4E107	; 32 bit signed binary mantissa.  $40000000 = +0.5
>9483	00						.char 0		; 8 bit signed binary exponent.  $00 = 2**0
>9484	91 a5 54 5c					.dword $5C54A591	; 32 bit signed binary mantissa.  $40000000 = +0.5
>9488	01						.char 1		; 8 bit signed binary exponent.  $00 = 2**0
>9489	00						.byte 0
>948a	46 4c 6f 67 32			Name0:	.text "FLog2"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=37903					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>948f	45					.byte (("FLog2"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=55					LinkDisplacement = Nt0-WordListLink
>9490	10					.byte WordFlags	;wh_Flags
>9491	03					.byte 3	;wh_CodeLength
>9492	37					  .byte LinkDisplacement	; offset to previous nt
=$9493					XtPtr1 ::= *
=37903					WordListLink ::= Nt0 ; remember the nt of this word for later
.9493	a4 54		ldy $54		FLog2:		ldy FIndex
.9495	b9 5f 00	lda $005f,y			lda FSMant0,y	; bad param?
.9498	30 20		bmi $94ba			bmi _OutOfRange
.949a	f0 1e		beq $94ba			beq _OutOfRange
.949c	b9 55 00	lda $0055,y			lda FSExp,y
.949f	48		pha				pha		; remember orig exponent
.94a0	a9 01		lda #$01			lda #1
.94a2	99 55 00	sta $0055,y			sta FSExp,y	; set to 1
.94a5	20 94 8b	jsr $8b94			jsr F1Minus
.94a8	20 5c 94	jsr $945c			jsr FLog2M1M
.94ab	a0 00		ldy #$00			ldy #0		; add orig exponent to float
.94ad	68		pla				pla
.94ae	38		sec				sec
.94af	e9 01		sbc #$01			sbc #1
.94b1	10 01		bpl $94b4			bpl +
.94b3	88		dey				dey
.94b4					+
.94b4	20 36 8e	jsr $8e36			jsr SToFYA
.94b7	4c 30 8b	jmp $8b30			jmp FPlus
.94ba	4c 43 c4	jmp $c443	_OutOfRange:	jmp Throw_FpOutOfRange
=42					CodeLen	.var *-XtPtr1
=$94bd					Here1 = *	; remember here
>9491	2a					.byte CodeLen	;patch wh_CodeLength
>94bd	46 4c 6e			Name0:	.text "FLn"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=37952					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>94c0	c3					.byte (("FLn"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=49					LinkDisplacement = Nt0-WordListLink
>94c1	10					.byte WordFlags	;wh_Flags
>94c2	03					.byte 3	;wh_CodeLength
>94c3	31					  .byte LinkDisplacement	; offset to previous nt
=$94c4					XtPtr1 ::= *
=37952					WordListLink ::= Nt0 ; remember the nt of this word for later
.94c4	20 93 94	jsr $9493	FLn:		jsr FLog2
.94c7	20 48 88	jsr $8848			jsr FLitI
>94ca	f8 0b b9 58					.dword $58b90bf8	; 32 bit signed binary mantissa.  $40000000 = +0.5
>94ce	00						.char 0		; 8 bit signed binary exponent.  $00 = 2**0
.94cf	4c fe 8b	jmp $8bfe			jmp FStar
=14					CodeLen	.var *-XtPtr1
=$94d2					Here1 = *	; remember here
>94c2	0e					.byte CodeLen	;patch wh_CodeLength
>94d2	46 4c 6e 50 31			Name0:	.text "FLnP1"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=37975					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>94d7	25					.byte (("FLnP1"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=23					LinkDisplacement = Nt0-WordListLink
>94d8	10					.byte WordFlags	;wh_Flags
>94d9	03					.byte 3	;wh_CodeLength
>94da	17					  .byte LinkDisplacement	; offset to previous nt
=$94db					XtPtr1 ::= *
=37975					WordListLink ::= Nt0 ; remember the nt of this word for later
.94db	20 64 8b	jsr $8b64	FlnP1:		jsr F1Plus
.94de	4c c4 94	jmp $94c4			jmp FLn
=6					CodeLen	.var *-XtPtr1
=$94e1					Here1 = *	; remember here
>94d9	06					.byte CodeLen	;patch wh_CodeLength
>94e1	46 4c 6f 67			Name0:	.text "FLog"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=37989					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>94e5	e4					.byte (("FLog"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=14					LinkDisplacement = Nt0-WordListLink
>94e6	10					.byte WordFlags	;wh_Flags
>94e7	03					.byte 3	;wh_CodeLength
>94e8	0e					  .byte LinkDisplacement	; offset to previous nt
=$94e9					XtPtr1 ::= *
=37989					WordListLink ::= Nt0 ; remember the nt of this word for later
.94e9	20 93 94	jsr $9493	FLog:		jsr FLog2
.94ec	20 48 88	jsr $8848			jsr FLitI
>94ef	3c 4d 10 4d					.dword $4d104d3c	; 32 bit signed binary mantissa.  $40000000 = +0.5
>94f3	ff						.char -1		; 8 bit signed binary exponent.  $00 = 2**0
.94f4	4c fe 8b	jmp $8bfe			jmp FStar
=14					CodeLen	.var *-XtPtr1
=$94f7					Here1 = *	; remember here
>94e7	0e					.byte CodeLen	;patch wh_CodeLength
>94f7	46 45 78 70 32 4d 31 4d		Name0:	.text "FExp2M1M"	;  name of word as a string, ending at wh_NameLastChar
=8					NameLength = *-Name0
=38015					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>94ff	a8					.byte (("FExp2M1M"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=26					LinkDisplacement = Nt0-WordListLink
>9500	10					.byte WordFlags	;wh_Flags
>9501	03					.byte 3	;wh_CodeLength
>9502	1a					  .byte LinkDisplacement	; offset to previous nt
=$9503					XtPtr1 ::= *
=38015					WordListLink ::= Nt0 ; remember the nt of this word for later
.9503	a9 0d		lda #$0d	FExp2M1M:	lda #<_c
.9505	a0 95		ldy #$95			ldy #>_c
.9507	20 2b 94	jsr $942b			jsr FMPolyYA
.950a	4c fe 8b	jmp $8bfe			jmp FStar
=10					CodeLen	.var *-XtPtr1
=$950d					Here1 = *	; remember here
>9501	0a					.byte CodeLen	;patch wh_CodeLength
.950d					_c:
>950d	e7 dc 4f 7c					.dword $7C4FDCe7	; 32 bit signed binary mantissa.  $40000000 = +0.5
>9511	f7						.char -9		; 8 bit signed binary exponent.  $00 = 2**0
>9512	de ca 4c 49					.dword $494CCADe	; 32 bit signed binary mantissa.  $40000000 = +0.5
>9516	fa						.char -6		; 8 bit signed binary exponent.  $00 = 2**0
>9517	fb 42 64 72					.dword $726442fb	; 32 bit signed binary mantissa.  $40000000 = +0.5
>951b	fc						.char -4		; 8 bit signed binary exponent.  $00 = 2**0
>951c	50 90 f4 7a					.dword $7AF49050	; 32 bit signed binary mantissa.  $40000000 = +0.5
>9520	fe						.char -2		; 8 bit signed binary exponent.  $00 = 2**0
>9521	a2 3c b9 58					.dword $58B93Ca2	; 32 bit signed binary mantissa.  $40000000 = +0.5
>9525	00						.char 0		; 8 bit signed binary exponent.  $00 = 2**0
>9526	00						.byte 0
>9527	46 45 78 70 32			Name0:	.text "FExp2"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=38060					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>952c	45					.byte (("FExp2"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=45					LinkDisplacement = Nt0-WordListLink
>952d	10					.byte WordFlags	;wh_Flags
>952e	03					.byte 3	;wh_CodeLength
>952f	2d					  .byte LinkDisplacement	; offset to previous nt
=$9530					XtPtr1 ::= *
=38060					WordListLink ::= Nt0 ; remember the nt of this word for later
.9530	20 60 8a	jsr $8a60	FExp2:		jsr FIntFrc	; ( f: r_rem r_int )
.9533	20 7e 8e	jsr $8e7e			jsr FToS
.9536	20 03 95	jsr $9503			jsr FExp2M1M
.9539	20 64 8b	jsr $8b64			jsr F1Plus
.953c	20 c8 c3	jsr $c3c8			jsr PopA
.953f	a4 54		ldy $54				ldy FIndex
.9541	18		clc				clc
.9542	79 55 00	adc $0055,y			adc FSExp,y
.9545	99 55 00	sta $0055,y			sta FSExp,y
=24					CodeLen	.var *-XtPtr1
=$9548					Here1 = *	; remember here
>952e	18					.byte CodeLen	;patch wh_CodeLength
.9548	60		rts				rts
>9549	46 45 78 70			Name0:	.text "FExp"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=38093					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>954d	04					.byte (("FExp"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=33					LinkDisplacement = Nt0-WordListLink
>954e	10					.byte WordFlags	;wh_Flags
>954f	03					.byte 3	;wh_CodeLength
>9550	21					  .byte LinkDisplacement	; offset to previous nt
=$9551					XtPtr1 ::= *
=38093					WordListLink ::= Nt0 ; remember the nt of this word for later
.9551					FExp:
.9551	20 48 88	jsr $8848			jsr FLitI
>9554	94 1d 55 5c					.dword $5c551d94	; 32 bit signed binary mantissa.  $40000000 = +0.5
>9558	01						.char 1		; 8 bit signed binary exponent.  $00 = 2**0
.9559	20 fe 8b	jsr $8bfe			jsr FStar
.955c	4c 30 95	jmp $9530			jmp FExp2
=14					CodeLen	.var *-XtPtr1
=$955f					Here1 = *	; remember here
>954f	0e					.byte CodeLen	;patch wh_CodeLength
>955f	46 45 78 70 4d 31		Name0:	.text "FExpM1"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=38117					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9565	26					.byte (("FExpM1"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=24					LinkDisplacement = Nt0-WordListLink
>9566	10					.byte WordFlags	;wh_Flags
>9567	03					.byte 3	;wh_CodeLength
>9568	18					  .byte LinkDisplacement	; offset to previous nt
=$9569					XtPtr1 ::= *
=38117					WordListLink ::= Nt0 ; remember the nt of this word for later
.9569	20 51 95	jsr $9551	FExpM1:		jsr FExp
.956c	4c 94 8b	jmp $8b94			jmp F1Minus
=6					CodeLen	.var *-XtPtr1
=$956f					Here1 = *	; remember here
>9567	06					.byte CodeLen	;patch wh_CodeLength
>956f	46 41 4c 6f 67			Name0:	.text "FALog"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=38132					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9574	e5					.byte (("FALog"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=15					LinkDisplacement = Nt0-WordListLink
>9575	10					.byte WordFlags	;wh_Flags
>9576	03					.byte 3	;wh_CodeLength
>9577	0f					  .byte LinkDisplacement	; offset to previous nt
=$9578					XtPtr1 ::= *
=38132					WordListLink ::= Nt0 ; remember the nt of this word for later
.9578					FALog:
.9578	20 48 88	jsr $8848			jsr FLitI
>957b	25 3c 4d 6a					.dword $6a4d3c25	; 32 bit signed binary mantissa.  $40000000 = +0.5
>957f	02						.char 2		; 8 bit signed binary exponent.  $00 = 2**0
.9580	20 fe 8b	jsr $8bfe			jsr FStar
.9583	4c 30 95	jmp $9530			jmp FExp2
=14					CodeLen	.var *-XtPtr1
=$9586					Here1 = *	; remember here
>9576	0e					.byte CodeLen	;patch wh_CodeLength
>9586	46 2a 2a			Name0:	.text "F**"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=38153					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9589	43					.byte (("F**"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=21					LinkDisplacement = Nt0-WordListLink
>958a	10					.byte WordFlags	;wh_Flags
>958b	03					.byte 3	;wh_CodeLength
>958c	15					  .byte LinkDisplacement	; offset to previous nt
=$958d					XtPtr1 ::= *
=38153					WordListLink ::= Nt0 ; remember the nt of this word for later
.958d	20 d7 85	jsr $85d7	FPower:		jsr FSwap
.9590	20 93 94	jsr $9493			jsr FLog2
.9593	20 fe 8b	jsr $8bfe			jsr FStar
.9596	4c 30 95	jmp $9530			jmp FExp2
=12					CodeLen	.var *-XtPtr1
=$9599					Here1 = *	; remember here
>958b	0c					.byte CodeLen	;patch wh_CodeLength
>9599	44 65 67 32 52 61 64		Name0:	.text "Deg2Rad"	;  name of word as a string, ending at wh_NameLastChar
=7					NameLength = *-Name0
=38176					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>95a0	87					.byte (("Deg2Rad"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=23					LinkDisplacement = Nt0-WordListLink
>95a1	10					.byte WordFlags	;wh_Flags
>95a2	03					.byte 3	;wh_CodeLength
>95a3	17					  .byte LinkDisplacement	; offset to previous nt
=$95a4					XtPtr1 ::= *
=38176					WordListLink ::= Nt0 ; remember the nt of this word for later
.95a4					Deg2Rad:
.95a4	20 48 88	jsr $8848			jsr FLitI
>95a7	8a 1a 7d 47					.dword $477d1A8A	; 32 bit signed binary mantissa.  $40000000 = +0.5
>95ab	fb						.char -5		; 8 bit signed binary exponent.  $00 = 2**0
.95ac	4c fe 8b	jmp $8bfe			jmp FStar
=11					CodeLen	.var *-XtPtr1
=$95af					Here1 = *	; remember here
>95a2	0b					.byte CodeLen	;patch wh_CodeLength
>95af	52 61 64 32 44 65 67		Name0:	.text "Rad2Deg"	;  name of word as a string, ending at wh_NameLastChar
=7					NameLength = *-Name0
=38198					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>95b6	e7					.byte (("Rad2Deg"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=22					LinkDisplacement = Nt0-WordListLink
>95b7	10					.byte WordFlags	;wh_Flags
>95b8	03					.byte 3	;wh_CodeLength
>95b9	16					  .byte LinkDisplacement	; offset to previous nt
=$95ba					XtPtr1 ::= *
=38198					WordListLink ::= Nt0 ; remember the nt of this word for later
.95ba					Rad2Deg:
.95ba	20 48 88	jsr $8848			jsr FLitI
>95bd	68 70 97 72					.dword $72977068	; 32 bit signed binary mantissa.  $40000000 = +0.5
>95c1	06						.char 6		; 8 bit signed binary exponent.  $00 = 2**0
.95c2	4c fe 8b	jmp $8bfe			jmp FStar
=11					CodeLen	.var *-XtPtr1
=$95c5					Here1 = *	; remember here
>95b8	0b					.byte CodeLen	;patch wh_CodeLength
>95c5	46 41 52 65 64 75 63 65		Name0:	.text "FAReduce"	;  name of word as a string, ending at wh_NameLastChar
=8					NameLength = *-Name0
=38221					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>95cd	a8					.byte (("FAReduce"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=23					LinkDisplacement = Nt0-WordListLink
>95ce	10					.byte WordFlags	;wh_Flags
>95cf	03					.byte 3	;wh_CodeLength
>95d0	17					  .byte LinkDisplacement	; offset to previous nt
=$95d1					XtPtr1 ::= *
=38221					WordListLink ::= Nt0 ; remember the nt of this word for later
.95d1	a4 54		ldy $54		FAReduce:	ldy FIndex
.95d3	b9 5f 00	lda $005f,y			lda FSMant0,y		; zero?
.95d6	f0 2f		beq $9607			beq _ok
.95d8	b9 55 00	lda $0055,y			lda FSExp,y		; get exponent
.95db	30 2a		bmi $9607			bmi _ok			; small?
.95dd	c9 01		cmp #$01			cmp #1			; maybe need mirror?
.95df	30 26		bmi $9607			bmi _ok			;if exponent <=0
.95e1	f0 24		beq $9607			beq _ok
.95e3	c9 02		cmp #$02			cmp #2			; maybe need rotation?
.95e5	b0 22		bcs $9609			bcs _exp2
.95e7	b9 5f 00	lda $005f,y			lda FSMant0,y
.95ea	c9 65		cmp #$65			cmp #$65		;in -pi/2..pi/2 ?
.95ec	90 19		bcc $9607			bcc _ok
.95ee	c9 9b		cmp #$9b			cmp #$100-$65
.95f0	b0 15		bcs $9607			bcs _ok
.95f2					_mir:
.95f2	20 fe 88	jsr $88fe			jsr FPi
.95f5	a4 54		ldy $54				ldy FIndex
.95f7	b9 60 00	lda $0060,y			lda FSMant0+1,y
.95fa	10 03		bpl $95ff			bpl _3
.95fc	20 a5 8b	jsr $8ba5			jsr FNegate
.95ff	20 d7 85	jsr $85d7	_3:		jsr FSwap
.9602	20 70 8b	jsr $8b70			jsr FMinus
.9605	38		sec				sec		; mirrored
.9606	60		rts				rts
.9607	18		clc		_ok:		clc		; not mirrored
.9608	60		rts				rts
.9609	d0 0b		bne $9616	_exp2:		bne _rot	;if exp>2 then fix
.960b	b9 5f 00	lda $005f,y			lda FSMant0,y
.960e	c9 65		cmp #$65			cmp #$65	;if mant>pi or mant<-pi then fix
.9610	90 e0		bcc $95f2			bcc _mir
.9612	c9 9b		cmp #$9b			cmp #$100-$65
.9614	b0 dc		bcs $95f2			bcs _mir
.9616	20 2d 89	jsr $892d	_rot:		jsr F2Pi
.9619	20 9a 8c	jsr $8c9a			jsr FSlash
.961c	20 60 8a	jsr $8a60			jsr FIntFrc
.961f	e6 54		inc $54				inc FIndex	; FDrop integer part
.9621	a4 54		ldy $54				ldy FIndex	;if >=.5
.9623	b9 55 00	lda $0055,y			lda FSExp,y
.9626	a8		tay				tay
.9627	30 03		bmi $962c			bmi _rot4
.9629	20 94 8b	jsr $8b94			jsr F1Minus	;  subtract 1
.962c	20 2d 89	jsr $892d	_rot4:		jsr F2Pi
.962f	20 fe 8b	jsr $8bfe			jsr FStar
.9632	4c d1 95	jmp $95d1			jmp FAReduce	; rotate done, look again
=100					CodeLen	.var *-XtPtr1
=$9635					Here1 = *	; remember here
>95cf	64					.byte CodeLen	;patch wh_CodeLength
>9635	46 53 69 6e			Name0:	.text "FSin"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=38329					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9639	c4					.byte (("FSin"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=108					LinkDisplacement = Nt0-WordListLink
>963a	10					.byte WordFlags	;wh_Flags
>963b	03					.byte 3	;wh_CodeLength
>963c	6c					  .byte LinkDisplacement	; offset to previous nt
=$963d					XtPtr1 ::= *
=38329					WordListLink ::= Nt0 ; remember the nt of this word for later
.963d	20 d1 95	jsr $95d1	FSin:		jsr FAReduce
.9640	20 53 85	jsr $8553	FSinM:		jsr FDup
.9643	20 8e 8c	jsr $8c8e			jsr FSqr	; x x^2
.9646	a9 56		lda #$56			lda #<_c
.9648	a0 96		ldy #$96			ldy #>_c
.964a	20 2b 94	jsr $942b			jsr FMPolyYA
.964d	20 fe 8b	jsr $8bfe			jsr FStar
.9650	20 64 8b	jsr $8b64			jsr F1Plus	; C0 +1.0
.9653	4c fe 8b	jmp $8bfe			jmp FStar
=25					CodeLen	.var *-XtPtr1
=$9656					Here1 = *	; remember here
>963b	19					.byte CodeLen	;patch wh_CodeLength
.9656					_c:
>9656	ba a7 21 57					.dword $5721a7ba	; 32 bit signed binary mantissa.  $40000000 = +0.5
>965a	ee						.char -18		; 8 bit signed binary exponent.  $00 = 2**0
>965b	3a 0b 2a 98					.dword $982a0b3a	; 32 bit signed binary mantissa.  $40000000 = +0.5
>965f	f4						.char -12		; 8 bit signed binary exponent.  $00 = 2**0
>9660	4c 8f 43 44					.dword $44438f4c	; 32 bit signed binary mantissa.  $40000000 = +0.5
>9664	fa						.char -6		; 8 bit signed binary exponent.  $00 = 2**0
>9665	2b ae aa aa					.dword $aaaaae2b	; 32 bit signed binary mantissa.  $40000000 = +0.5
>9669	fe						.char -2		; 8 bit signed binary exponent.  $00 = 2**0
>966a	00						.byte 0
>966b	46 43 73 63			Name0:	.text "FCsc"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=38383					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>966f	64					.byte (("FCsc"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=54					LinkDisplacement = Nt0-WordListLink
>9670	10					.byte WordFlags	;wh_Flags
>9671	03					.byte 3	;wh_CodeLength
>9672	36					  .byte LinkDisplacement	; offset to previous nt
=$9673					XtPtr1 ::= *
=38383					WordListLink ::= Nt0 ; remember the nt of this word for later
.9673	20 3d 96	jsr $963d	FCsc:		jsr FSin
.9676	4c 3e 8d	jmp $8d3e			jmp F1Slash		; 1/SIN(r1)
=6					CodeLen	.var *-XtPtr1
=$9679					Here1 = *	; remember here
>9671	06					.byte CodeLen	;patch wh_CodeLength
>9679	46 43 6f 73			Name0:	.text "FCos"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=38397					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>967d	64					.byte (("FCos"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=14					LinkDisplacement = Nt0-WordListLink
>967e	10					.byte WordFlags	;wh_Flags
>967f	03					.byte 3	;wh_CodeLength
>9680	0e					  .byte LinkDisplacement	; offset to previous nt
=$9681					XtPtr1 ::= *
=38397					WordListLink ::= Nt0 ; remember the nt of this word for later
.9681	20 0e 89	jsr $890e	FCos:		jsr FPiH
.9684	20 30 8b	jsr $8b30			jsr FPlus
.9687	4c 3d 96	jmp $963d			jmp FSin
=9					CodeLen	.var *-XtPtr1
=$968a					Here1 = *	; remember here
>967f	09					.byte CodeLen	;patch wh_CodeLength
>968a	46 53 65 63			Name0:	.text "FSec"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=38414					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>968e	64					.byte (("FSec"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=17					LinkDisplacement = Nt0-WordListLink
>968f	10					.byte WordFlags	;wh_Flags
>9690	03					.byte 3	;wh_CodeLength
>9691	11					  .byte LinkDisplacement	; offset to previous nt
=$9692					XtPtr1 ::= *
=38414					WordListLink ::= Nt0 ; remember the nt of this word for later
.9692	20 81 96	jsr $9681	FSec:		jsr FCos
.9695	4c 3e 8d	jmp $8d3e			jmp F1Slash		; 1/COS(r1)
=6					CodeLen	.var *-XtPtr1
=$9698					Here1 = *	; remember here
>9690	06					.byte CodeLen	;patch wh_CodeLength
>9698	46 53 69 6e 43 6f 73		Name0:	.text "FSinCos"	;  name of word as a string, ending at wh_NameLastChar
=7					NameLength = *-Name0
=38431					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>969f	67					.byte (("FSinCos"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=17					LinkDisplacement = Nt0-WordListLink
>96a0	10					.byte WordFlags	;wh_Flags
>96a1	03					.byte 3	;wh_CodeLength
>96a2	11					  .byte LinkDisplacement	; offset to previous nt
=$96a3					XtPtr1 ::= *
=38431					WordListLink ::= Nt0 ; remember the nt of this word for later
.96a3	20 53 85	jsr $8553	FSinCos:	jsr FDup
.96a6	20 3d 96	jsr $963d			jsr FSin
.96a9	20 d7 85	jsr $85d7			jsr FSwap
.96ac	4c 81 96	jmp $9681			jmp FCos
=12					CodeLen	.var *-XtPtr1
=$96af					Here1 = *	; remember here
>96a1	0c					.byte CodeLen	;patch wh_CodeLength
>96af	46 54 61 6e			Name0:	.text "FTan"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=38451					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>96b3	c4					.byte (("FTan"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=20					LinkDisplacement = Nt0-WordListLink
>96b4	10					.byte WordFlags	;wh_Flags
>96b5	03					.byte 3	;wh_CodeLength
>96b6	14					  .byte LinkDisplacement	; offset to previous nt
=$96b7					XtPtr1 ::= *
=38451					WordListLink ::= Nt0 ; remember the nt of this word for later
.96b7	20 d1 95	jsr $95d1	FTan:		jsr FAReduce
.96ba	90 06		bcc $96c2			bcc _30
.96bc	20 c2 96	jsr $96c2			jsr _30
.96bf	4c a5 8b	jmp $8ba5			jmp FNegate
.96c2					_30:
.96c2	20 53 85	jsr $8553			jsr FDup
.96c5	20 cb 8b	jsr $8bcb			jsr FAbs
.96c8	20 1e 89	jsr $891e			jsr FPiQ
.96cb	20 68 87	jsr $8768			jsr FLe
.96ce	e8		inx				inx			; pop f
.96cf	e8		inx				inx
.96d0	b5 24		lda $24,x			lda DStack+0,x
.96d2	d0 19		bne $96ed			bne FTanM
.96d4	20 0e 89	jsr $890e			jsr FPiH
.96d7	a4 54		ldy $54				ldy FIndex		; get sign
.96d9	b9 5f 00	lda $005f,y			lda FSMant0,y
.96dc	10 03		bpl $96e1			bpl +
.96de	20 a5 8b	jsr $8ba5			jsr FNegate
.96e1					+
.96e1	20 d7 85	jsr $85d7			jsr FSwap
.96e4	20 70 8b	jsr $8b70			jsr FMinus
.96e7	20 ed 96	jsr $96ed			jsr FTanM
.96ea	4c 3e 8d	jmp $8d3e			jmp F1Slash
=54					CodeLen	.var *-XtPtr1
=$96ed					Here1 = *	; remember here
>96b5	36					.byte CodeLen	;patch wh_CodeLength
.96ed	20 53 85	jsr $8553	FTanM:		jsr FDup
.96f0	20 8e 8c	jsr $8c8e			jsr FSqr		; x x^2
.96f3	a9 03		lda #$03			lda #<_c
.96f5	a0 97		ldy #$97			ldy #>_c
.96f7	20 2b 94	jsr $942b			jsr FMPolyYA
.96fa	20 fe 8b	jsr $8bfe			jsr FStar
.96fd	20 64 8b	jsr $8b64			jsr F1Plus		; c0 1.0
.9700	4c fe 8b	jmp $8bfe			jmp FStar
.9703					_c:
>9703	1e ae 4d 58					.dword $584DAE1E	; 32 bit signed binary mantissa.  $40000000 = +0.5
>9707	fb						.char -5		; 8 bit signed binary exponent.  $00 = 2**0
>9708	51 0a eb 57					.dword $57EB0A51	; 32 bit signed binary mantissa.  $40000000 = +0.5
>970c	fa						.char -6		; 8 bit signed binary exponent.  $00 = 2**0
>970d	98 d9 14 77					.dword $7714D998	; 32 bit signed binary mantissa.  $40000000 = +0.5
>9711	fc						.char -4		; 8 bit signed binary exponent.  $00 = 2**0
>9712	f9 10 ea 43					.dword $43EA10F9	; 32 bit signed binary mantissa.  $40000000 = +0.5
>9716	fe						.char -2		; 8 bit signed binary exponent.  $00 = 2**0
>9717	1b e2 57 55					.dword $5557E21B	; 32 bit signed binary mantissa.  $40000000 = +0.5
>971b	ff						.char -1		; 8 bit signed binary exponent.  $00 = 2**0
>971c	00						.byte 0
>971d	46 43 6f 74			Name0:	.text "FCot"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=38561					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9721	84					.byte (("FCot"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=110					LinkDisplacement = Nt0-WordListLink
>9722	10					.byte WordFlags	;wh_Flags
>9723	03					.byte 3	;wh_CodeLength
>9724	6e					  .byte LinkDisplacement	; offset to previous nt
=$9725					XtPtr1 ::= *
=38561					WordListLink ::= Nt0 ; remember the nt of this word for later
.9725	20 b7 96	jsr $96b7	FCot:		jsr FTan
.9728	4c 3e 8d	jmp $8d3e			jmp F1Slash	; =1/TAN(r1)
=6					CodeLen	.var *-XtPtr1
=$972b					Here1 = *	; remember here
>9723	06					.byte CodeLen	;patch wh_CodeLength
>972b	46 41 43 6f 73			Name0:	.text "FACos"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=38576					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9730	65					.byte (("FACos"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=15					LinkDisplacement = Nt0-WordListLink
>9731	10					.byte WordFlags	;wh_Flags
>9732	03					.byte 3	;wh_CodeLength
>9733	0f					  .byte LinkDisplacement	; offset to previous nt
=$9734					XtPtr1 ::= *
=38576					WordListLink ::= Nt0 ; remember the nt of this word for later
.9734	a4 54		ldy $54		FACos:		ldy FIndex
.9736	b9 5f 00	lda $005f,y			lda FSMant0,y
.9739	08		php				php			; save sign
.973a	20 cb 8b	jsr $8bcb			jsr FAbs
.973d	a9 60		lda #$60			lda #<_c
.973f	a0 97		ldy #$97			ldy #>_c
.9741	20 2b 94	jsr $942b			jsr FMPolyYA
.9744	20 d7 85	jsr $85d7			jsr FSwap
.9747	20 a5 8b	jsr $8ba5			jsr FNegate
.974a	20 64 8b	jsr $8b64			jsr F1Plus
.974d	20 24 8f	jsr $8f24			jsr FSqrt
.9750	20 fe 8b	jsr $8bfe			jsr FStar
.9753	28		plp				plp			; was r1 negative?
.9754	10 09		bpl $975f			bpl +
.9756	20 fe 88	jsr $88fe			jsr FPi
.9759	20 d7 85	jsr $85d7			jsr FSwap
.975c	20 70 8b	jsr $8b70			jsr FMinus
.975f					+
=43					CodeLen	.var *-XtPtr1
=$975f					Here1 = *	; remember here
>9732	2b					.byte CodeLen	;patch wh_CodeLength
.975f	60		rts				rts
.9760					_c:
>9760	8b 5e 9f 4b					.dword $4B9F5E8B	; 32 bit signed binary mantissa.  $40000000 = +0.5
>9764	f8						.char -8		; 8 bit signed binary exponent.  $00 = 2**0
>9765	ad cc 29 a4					.dword $A429CCAD	; 32 bit signed binary mantissa.  $40000000 = +0.5
>9769	fa						.char -6		; 8 bit signed binary exponent.  $00 = 2**0
>976a	98 a1 a3 6e					.dword $6EA3A198	; 32 bit signed binary mantissa.  $40000000 = +0.5
>976e	fb						.char -5		; 8 bit signed binary exponent.  $00 = 2**0
>976f	5a 10 e1 9b					.dword $9BE1105A	; 32 bit signed binary mantissa.  $40000000 = +0.5
>9773	fc						.char -4		; 8 bit signed binary exponent.  $00 = 2**0
>9774	c6 71 ea 5a					.dword $5AEA71C6	; 32 bit signed binary mantissa.  $40000000 = +0.5
>9778	fd						.char -3		; 8 bit signed binary exponent.  $00 = 2**0
>9779	e0 56 21 92					.dword $922156E0	; 32 bit signed binary mantissa.  $40000000 = +0.5
>977d	fe						.char -2		; 8 bit signed binary exponent.  $00 = 2**0
>977e	41 ed 87 64					.dword $6487ED41	; 32 bit signed binary mantissa.  $40000000 = +0.5
>9782	01						.char 1		; 8 bit signed binary exponent.  $00 = 2**0
>9783	00						.byte 0
>9784	46 41 53 65 63			Name0:	.text "FASec"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=38665					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9789	65					.byte (("FASec"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=89					LinkDisplacement = Nt0-WordListLink
>978a	10					.byte WordFlags	;wh_Flags
>978b	03					.byte 3	;wh_CodeLength
>978c	59					  .byte LinkDisplacement	; offset to previous nt
=$978d					XtPtr1 ::= *
=38665					WordListLink ::= Nt0 ; remember the nt of this word for later
.978d	20 3e 8d	jsr $8d3e	FASec:		jsr F1Slash
.9790	4c 34 97	jmp $9734			jmp FACos
=6					CodeLen	.var *-XtPtr1
=$9793					Here1 = *	; remember here
>978b	06					.byte CodeLen	;patch wh_CodeLength
>9793	46 41 53 69 6e			Name0:	.text "FASin"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=38680					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9798	c5					.byte (("FASin"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=15					LinkDisplacement = Nt0-WordListLink
>9799	10					.byte WordFlags	;wh_Flags
>979a	03					.byte 3	;wh_CodeLength
>979b	0f					  .byte LinkDisplacement	; offset to previous nt
=$979c					XtPtr1 ::= *
=38680					WordListLink ::= Nt0 ; remember the nt of this word for later
.979c	20 34 97	jsr $9734	FASin:		jsr FACos
.979f	20 a5 8b	jsr $8ba5			jsr FNegate
.97a2	20 0e 89	jsr $890e			jsr FPiH
.97a5	4c 30 8b	jmp $8b30			jmp FPlus
=12					CodeLen	.var *-XtPtr1
=$97a8					Here1 = *	; remember here
>979a	0c					.byte CodeLen	;patch wh_CodeLength
>97a8	46 41 43 73 63			Name0:	.text "FACsc"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=38701					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>97ad	65					.byte (("FACsc"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=21					LinkDisplacement = Nt0-WordListLink
>97ae	10					.byte WordFlags	;wh_Flags
>97af	03					.byte 3	;wh_CodeLength
>97b0	15					  .byte LinkDisplacement	; offset to previous nt
=$97b1					XtPtr1 ::= *
=38701					WordListLink ::= Nt0 ; remember the nt of this word for later
.97b1	20 3e 8d	jsr $8d3e	FACsc:		jsr F1Slash
.97b4	4c 9c 97	jmp $979c			jmp FASin
=6					CodeLen	.var *-XtPtr1
=$97b7					Here1 = *	; remember here
>97af	06					.byte CodeLen	;patch wh_CodeLength
>97b7	46 41 54 61 6e			Name0:	.text "FATan"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=38716					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>97bc	c5					.byte (("FATan"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=15					LinkDisplacement = Nt0-WordListLink
>97bd	10					.byte WordFlags	;wh_Flags
>97be	03					.byte 3	;wh_CodeLength
>97bf	0f					  .byte LinkDisplacement	; offset to previous nt
=$97c0					XtPtr1 ::= *
=38716					WordListLink ::= Nt0 ; remember the nt of this word for later
.97c0					FATan:
.97c0	a4 54		ldy $54				ldy FIndex
.97c2	b9 55 00	lda $0055,y			lda FSExp,y		; Abs(r1)<1 ?
.97c5	30 1b		bmi $97e2			bmi FATanM
.97c7	f0 19		beq $97e2			beq FATanM
.97c9	b9 5f 00	lda $005f,y			lda FSMant0,y		; save sign
.97cc	08		php				php
.97cd	20 3e 8d	jsr $8d3e			jsr F1Slash
.97d0	20 e2 97	jsr $97e2			jsr FATanM
.97d3	20 a5 8b	jsr $8ba5			jsr FNegate
.97d6	20 0e 89	jsr $890e			jsr FPiH
.97d9	28		plp				plp
.97da	10 03		bpl $97df			bpl _18
.97dc	20 a5 8b	jsr $8ba5			jsr FNegate
.97df	4c 30 8b	jmp $8b30	_18:		jmp FPlus
.97e2	20 53 85	jsr $8553	FATanM:		jsr FDup		; x x
.97e5	20 8e 8c	jsr $8c8e			jsr FSqr		; x xsqr
.97e8	a9 f8		lda #$f8			lda #<_c
.97ea	a0 97		ldy #$97			ldy #>_c
.97ec	20 2b 94	jsr $942b			jsr FMPolyYA
.97ef	20 fe 8b	jsr $8bfe			jsr FStar		; x poly
.97f2	20 64 8b	jsr $8b64			jsr F1Plus		; x poly
.97f5	4c fe 8b	jmp $8bfe			jmp FStar
.97f8					_c:
>97f8	98 08 2d 76					.dword $762D0898	; 32 bit signed binary mantissa.  $40000000 = +0.5
>97fc	f9						.char -7		; 8 bit signed binary exponent.  $00 = 2**0
>97fd	55 a1 32 b8					.dword $B832A155	; 32 bit signed binary mantissa.  $40000000 = +0.5
>9801	fc						.char -4		; 8 bit signed binary exponent.  $00 = 2**0
>9802	a8 d7 a2 53					.dword $53A2D7A8	; 32 bit signed binary mantissa.  $40000000 = +0.5
>9806	fd						.char -3		; 8 bit signed binary exponent.  $00 = 2**0
>9807	be 91 85 bb					.dword $BB8591BE	; 32 bit signed binary mantissa.  $40000000 = +0.5
>980b	fe						.char -2		; 8 bit signed binary exponent.  $00 = 2**0
>980c	06 65 aa 65					.dword $65AA6506	; 32 bit signed binary mantissa.  $40000000 = +0.5
>9810	fe						.char -2		; 8 bit signed binary exponent.  $00 = 2**0
>9811	12 21 b0 aa					.dword $AAB02112	; 32 bit signed binary mantissa.  $40000000 = +0.5
>9815	ff						.char -1		; 8 bit signed binary exponent.  $00 = 2**0
>9816	00						.byte 0
>9817	46 41 43 6f 74			Name0:	.text "FACot"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=38812					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>981c	85					.byte (("FACot"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=96					LinkDisplacement = Nt0-WordListLink
>981d	10					.byte WordFlags	;wh_Flags
>981e	03					.byte 3	;wh_CodeLength
>981f	60					  .byte LinkDisplacement	; offset to previous nt
=$9820					XtPtr1 ::= *
=38812					WordListLink ::= Nt0 ; remember the nt of this word for later
.9820	20 3e 8d	jsr $8d3e	FACot:		jsr F1Slash
.9823	4c c0 97	jmp $97c0			jmp FATan
=6					CodeLen	.var *-XtPtr1
=$9826					Here1 = *	; remember here
>981e	06					.byte CodeLen	;patch wh_CodeLength
>9826	46 41 54 61 6e 32		Name0:	.text "FATan2"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=38828					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>982c	46					.byte (("FATan2"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=16					LinkDisplacement = Nt0-WordListLink
>982d	10					.byte WordFlags	;wh_Flags
>982e	03					.byte 3	;wh_CodeLength
>982f	10					  .byte LinkDisplacement	; offset to previous nt
=$9830					XtPtr1 ::= *
=38828					WordListLink ::= Nt0 ; remember the nt of this word for later
.9830	a4 54		ldy $54		FATan2:		ldy FIndex
.9832	b9 5f 00	lda $005f,y			lda FSMant0+0,y	; get rx sign
.9835	f0 1c		beq $9853			beq _rxzero
.9837	0a		asl a				asl a		;   C=rx sign
.9838	b9 60 00	lda $0060,y			lda FSMant0+1,y	;   N=ry sign
.983b	08		php				php		; save signs
.983c	20 9a 8c	jsr $8c9a			jsr FSlash
.983f	20 c0 97	jsr $97c0			jsr FATan
.9842	28		plp				plp		; pop signs
.9843	b0 01		bcs $9846			bcs _rxneg
.9845	60		rts		_rts:		rts
.9846	08		php		_rxneg:		php
.9847	20 fe 88	jsr $88fe			jsr FPi
.984a	28		plp				plp
.984b	10 03		bpl $9850			bpl +
.984d	20 a5 8b	jsr $8ba5			jsr FNegate
.9850	4c 30 8b	jmp $8b30	+		jmp FPlus
.9853	e6 54		inc $54		_rxzero:	inc FIndex	; FDrop rx
.9855	b9 5f 00	lda $005f,y			lda FSMant0,y
.9858	08		php				php
.9859	e6 54		inc $54				inc FIndex	; FDrop ry
.985b	20 0e 89	jsr $890e			jsr FPiH
.985e	28		plp				plp
.985f	10 e4		bpl $9845			bpl _rts
.9861	4c a5 8b	jmp $8ba5			jmp FNegate
=52					CodeLen	.var *-XtPtr1
=$9864					Here1 = *	; remember here
>982e	34					.byte CodeLen	;patch wh_CodeLength
>9864	46 53 67 6e			Name0:	.text "FSgn"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=38888					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9868	c4					.byte (("FSgn"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=60					LinkDisplacement = Nt0-WordListLink
>9869	10					.byte WordFlags	;wh_Flags
>986a	03					.byte 3	;wh_CodeLength
>986b	3c					  .byte LinkDisplacement	; offset to previous nt
=$986c					XtPtr1 ::= *
=38888					WordListLink ::= Nt0 ; remember the nt of this word for later
.986c	a4 54		ldy $54		FSgn:		ldy FIndex
.986e	b9 5f 00	lda $005f,y			lda FSMant0,y
.9871	f0 0a		beq $987d			beq _zero
.9873	e6 54		inc $54				inc FIndex
.9875	b9 5f 00	lda $005f,y			lda FSMant0,y
.9878	30 04		bmi $987e			bmi FM1
.987a	4c e3 88	jmp $88e3			jmp F1
.987d	60		rts		_zero:		rts
=18					CodeLen	.var *-XtPtr1
=$987e					Here1 = *	; remember here
>986a	12					.byte CodeLen	;patch wh_CodeLength
.987e	a9 80		lda #$80	FM1:		lda #$80
.9880	a0 00		ldy #$00			ldy #0
.9882	4c 92 88	jmp $8892			jmp FLitYA
=25					CodeLen	.var *-XtPtr1
=$9885					Here1 = *	; remember here
>986a	19					.byte CodeLen	;patch wh_CodeLength
>9885	46 53 69 6e 48			Name0:	.text "FSinH"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=38922					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>988a	05					.byte (("FSinH"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=34					LinkDisplacement = Nt0-WordListLink
>988b	10					.byte WordFlags	;wh_Flags
>988c	03					.byte 3	;wh_CodeLength
>988d	22					  .byte LinkDisplacement	; offset to previous nt
=$988e					XtPtr1 ::= *
=38922					WordListLink ::= Nt0 ; remember the nt of this word for later
.988e	20 53 85	jsr $8553	FSinH:		jsr FDup
.9891	20 51 95	jsr $9551			jsr FExp
.9894	20 d7 85	jsr $85d7			jsr FSwap
.9897	20 a5 8b	jsr $8ba5			jsr FNegate
.989a	20 51 95	jsr $9551			jsr FExp
.989d	20 70 8b	jsr $8b70			jsr FMinus
.98a0	4c 97 89	jmp $8997			jmp F2Slash
=21					CodeLen	.var *-XtPtr1
=$98a3					Here1 = *	; remember here
>988c	15					.byte CodeLen	;patch wh_CodeLength
>98a3	46 43 73 63 48			Name0:	.text "FCscH"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=38952					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>98a8	05					.byte (("FCscH"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=30					LinkDisplacement = Nt0-WordListLink
>98a9	10					.byte WordFlags	;wh_Flags
>98aa	03					.byte 3	;wh_CodeLength
>98ab	1e					  .byte LinkDisplacement	; offset to previous nt
=$98ac					XtPtr1 ::= *
=38952					WordListLink ::= Nt0 ; remember the nt of this word for later
.98ac	20 8e 98	jsr $988e	FCscH:		jsr FSinH
.98af	4c 3e 8d	jmp $8d3e			jmp F1Slash
=6					CodeLen	.var *-XtPtr1
=$98b2					Here1 = *	; remember here
>98aa	06					.byte CodeLen	;patch wh_CodeLength
>98b2	46 43 6f 73 48			Name0:	.text "FCosH"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=38967					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>98b7	05					.byte (("FCosH"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=15					LinkDisplacement = Nt0-WordListLink
>98b8	10					.byte WordFlags	;wh_Flags
>98b9	03					.byte 3	;wh_CodeLength
>98ba	0f					  .byte LinkDisplacement	; offset to previous nt
=$98bb					XtPtr1 ::= *
=38967					WordListLink ::= Nt0 ; remember the nt of this word for later
.98bb	20 53 85	jsr $8553	FCosH:		jsr FDup
.98be	20 51 95	jsr $9551			jsr FExp
.98c1	20 d7 85	jsr $85d7			jsr FSwap
.98c4	20 a5 8b	jsr $8ba5			jsr FNegate
.98c7	20 51 95	jsr $9551			jsr FExp
.98ca	20 30 8b	jsr $8b30			jsr FPlus
.98cd	4c 97 89	jmp $8997			jmp F2Slash
=21					CodeLen	.var *-XtPtr1
=$98d0					Here1 = *	; remember here
>98b9	15					.byte CodeLen	;patch wh_CodeLength
>98d0	46 53 65 63 48			Name0:	.text "FSecH"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=38997					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>98d5	05					.byte (("FSecH"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=30					LinkDisplacement = Nt0-WordListLink
>98d6	10					.byte WordFlags	;wh_Flags
>98d7	03					.byte 3	;wh_CodeLength
>98d8	1e					  .byte LinkDisplacement	; offset to previous nt
=$98d9					XtPtr1 ::= *
=38997					WordListLink ::= Nt0 ; remember the nt of this word for later
.98d9	20 bb 98	jsr $98bb	FSecH:		jsr FCosH
.98dc	4c 3e 8d	jmp $8d3e			jmp F1Slash
=6					CodeLen	.var *-XtPtr1
=$98df					Here1 = *	; remember here
>98d7	06					.byte CodeLen	;patch wh_CodeLength
>98df	46 54 61 6e 48			Name0:	.text "FTanH"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=39012					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>98e4	05					.byte (("FTanH"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=15					LinkDisplacement = Nt0-WordListLink
>98e5	10					.byte WordFlags	;wh_Flags
>98e6	03					.byte 3	;wh_CodeLength
>98e7	0f					  .byte LinkDisplacement	; offset to previous nt
=$98e8					XtPtr1 ::= *
=39012					WordListLink ::= Nt0 ; remember the nt of this word for later
.98e8	20 53 85	jsr $8553	FTanH:		jsr FDup
.98eb	20 a5 8b	jsr $8ba5			jsr FNegate	; X -X
.98ee	20 51 95	jsr $9551			jsr FExp	; X Exp(-X)
.98f1	20 d7 85	jsr $85d7			jsr FSwap	; Exp(-X) X
.98f4	20 51 95	jsr $9551			jsr FExp	; Exp(-X) Exp(X)
.98f7	20 76 85	jsr $8576			jsr FOver	; Exp(-X) Exp(X) Exp(-X)
.98fa	20 30 8b	jsr $8b30			jsr FPlus	; Exp(-X) Exp(X)+Exp(-X)
.98fd	20 9a 8c	jsr $8c9a			jsr FSlash	; Exp(-X)/(Exp(X)+Exp(-X))
.9900	20 8c 89	jsr $898c			jsr F2Star	; Exp(-X)/(Exp(X)+Exp(-X))*2
.9903	20 a5 8b	jsr $8ba5			jsr FNegate
.9906	4c 64 8b	jmp $8b64			jmp F1Plus
=33					CodeLen	.var *-XtPtr1
=$9909					Here1 = *	; remember here
>98e6	21					.byte CodeLen	;patch wh_CodeLength
>9909	46 43 6f 74 48			Name0:	.text "FCotH"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=39054					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>990e	05					.byte (("FCotH"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=42					LinkDisplacement = Nt0-WordListLink
>990f	10					.byte WordFlags	;wh_Flags
>9910	03					.byte 3	;wh_CodeLength
>9911	2a					  .byte LinkDisplacement	; offset to previous nt
=$9912					XtPtr1 ::= *
=39054					WordListLink ::= Nt0 ; remember the nt of this word for later
.9912	20 e8 98	jsr $98e8	FCotH:		jsr FTanH
.9915	4c 3e 8d	jmp $8d3e			jmp F1Slash
=6					CodeLen	.var *-XtPtr1
=$9918					Here1 = *	; remember here
>9910	06					.byte CodeLen	;patch wh_CodeLength
>9918	46 41 53 69 6e 48		Name0:	.text "FASinH"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=39070					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>991e	06					.byte (("FASinH"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=16					LinkDisplacement = Nt0-WordListLink
>991f	10					.byte WordFlags	;wh_Flags
>9920	03					.byte 3	;wh_CodeLength
>9921	10					  .byte LinkDisplacement	; offset to previous nt
=$9922					XtPtr1 ::= *
=39070					WordListLink ::= Nt0 ; remember the nt of this word for later
.9922	20 53 85	jsr $8553	FASinH:		jsr FDup	; X X
.9925	20 8e 8c	jsr $8c8e			jsr FSqr	; X X*X
.9928	20 64 8b	jsr $8b64			jsr F1Plus	; X X*X+1
.992b	20 24 8f	jsr $8f24			jsr FSqrt	; X sqrt(X*X+1)
.992e	20 30 8b	jsr $8b30			jsr FPlus	;
.9931	4c c4 94	jmp $94c4			jmp FLn
=18					CodeLen	.var *-XtPtr1
=$9934					Here1 = *	; remember here
>9920	12					.byte CodeLen	;patch wh_CodeLength
>9934	46 41 43 73 63 48		Name0:	.text "FACscH"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=39098					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>993a	06					.byte (("FACscH"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=28					LinkDisplacement = Nt0-WordListLink
>993b	10					.byte WordFlags	;wh_Flags
>993c	03					.byte 3	;wh_CodeLength
>993d	1c					  .byte LinkDisplacement	; offset to previous nt
=$993e					XtPtr1 ::= *
=39098					WordListLink ::= Nt0 ; remember the nt of this word for later
.993e	20 3e 8d	jsr $8d3e	FACscH:		jsr F1Slash
.9941	4c 22 99	jmp $9922			jmp FASinH
=6					CodeLen	.var *-XtPtr1
=$9944					Here1 = *	; remember here
>993c	06					.byte CodeLen	;patch wh_CodeLength
>9944	46 41 43 6f 73 48		Name0:	.text "FACosH"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=39114					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>994a	06					.byte (("FACosH"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=16					LinkDisplacement = Nt0-WordListLink
>994b	10					.byte WordFlags	;wh_Flags
>994c	03					.byte 3	;wh_CodeLength
>994d	10					  .byte LinkDisplacement	; offset to previous nt
=$994e					XtPtr1 ::= *
=39114					WordListLink ::= Nt0 ; remember the nt of this word for later
.994e	20 53 85	jsr $8553	FACosH:		jsr FDup
.9951	20 8e 8c	jsr $8c8e			jsr FSqr
.9954	20 94 8b	jsr $8b94			jsr F1Minus
.9957	20 24 8f	jsr $8f24			jsr FSqrt
.995a	20 30 8b	jsr $8b30			jsr FPlus
.995d	4c c4 94	jmp $94c4			jmp FLn
=18					CodeLen	.var *-XtPtr1
=$9960					Here1 = *	; remember here
>994c	12					.byte CodeLen	;patch wh_CodeLength
>9960	46 41 53 65 63 48		Name0:	.text "FASecH"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=39142					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9966	06					.byte (("FASecH"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=28					LinkDisplacement = Nt0-WordListLink
>9967	10					.byte WordFlags	;wh_Flags
>9968	03					.byte 3	;wh_CodeLength
>9969	1c					  .byte LinkDisplacement	; offset to previous nt
=$996a					XtPtr1 ::= *
=39142					WordListLink ::= Nt0 ; remember the nt of this word for later
.996a	20 3e 8d	jsr $8d3e	FASecH:		jsr F1Slash
.996d	4c 4e 99	jmp $994e			jmp FACosH
=6					CodeLen	.var *-XtPtr1
=$9970					Here1 = *	; remember here
>9968	06					.byte CodeLen	;patch wh_CodeLength
>9970	46 41 54 61 6e 48		Name0:	.text "FATanH"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=39158					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9976	06					.byte (("FATanH"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=16					LinkDisplacement = Nt0-WordListLink
>9977	10					.byte WordFlags	;wh_Flags
>9978	03					.byte 3	;wh_CodeLength
>9979	10					  .byte LinkDisplacement	; offset to previous nt
=$997a					XtPtr1 ::= *
=39158					WordListLink ::= Nt0 ; remember the nt of this word for later
.997a	20 53 85	jsr $8553	FAtanH:		jsr FDup	; x x
.997d	20 64 8b	jsr $8b64			jsr F1Plus	; x x+1
.9980	20 d7 85	jsr $85d7			jsr FSwap	; 1+x x
.9983	20 e3 88	jsr $88e3			jsr F1
.9986	20 d7 85	jsr $85d7			jsr FSwap
.9989	20 70 8b	jsr $8b70			jsr FMinus	; 1+x 1-x
.998c	20 9a 8c	jsr $8c9a			jsr FSlash	; (1+x)/(1-x)
.998f	20 c4 94	jsr $94c4			jsr FLn
.9992	4c 97 89	jmp $8997			jmp F2Slash
=27					CodeLen	.var *-XtPtr1
=$9995					Here1 = *	; remember here
>9978	1b					.byte CodeLen	;patch wh_CodeLength
>9995	46 41 43 6f 74 48		Name0:	.text "FACotH"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=39195					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>999b	06					.byte (("FACotH"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=37					LinkDisplacement = Nt0-WordListLink
>999c	10					.byte WordFlags	;wh_Flags
>999d	03					.byte 3	;wh_CodeLength
>999e	25					  .byte LinkDisplacement	; offset to previous nt
=$999f					XtPtr1 ::= *
=39195					WordListLink ::= Nt0 ; remember the nt of this word for later
.999f	20 3e 8d	jsr $8d3e	FACotH: 	jsr F1Slash
.99a2	4c 7a 99	jmp $997a			jmp FATanH
=6					CodeLen	.var *-XtPtr1
=$99a5					Here1 = *	; remember here
>999d	06					.byte CodeLen	;patch wh_CodeLength
=3					EFloat_Size = 3	; # of in memory byte for an E Float
>99a5	45 46 6c 6f 61 74		Name0:	.text "EFloat"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=39211					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>99ab	86					.byte (("EFloat"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=16					LinkDisplacement = Nt0-WordListLink
>99ac	10					.byte WordFlags	;wh_Flags
>99ad	03					.byte 3	;wh_CodeLength
>99ae	10					  .byte LinkDisplacement	; offset to previous nt
=$99af					XtPtr1 ::= *
=39211					WordListLink ::= Nt0 ; remember the nt of this word for later
.99af	a9 03		lda #$03	EFloat:		lda #EFloat_Size
.99b1	4c e9 c7	jmp $c7e9			jmp PushZA
=5					CodeLen	.var *-XtPtr1
=$99b4					Here1 = *	; remember here
>99ad	05					.byte CodeLen	;patch wh_CodeLength
>99b4	45 46 6c 6f 61 74 2b		Name0:	.text "EFloat+"	;  name of word as a string, ending at wh_NameLastChar
=7					NameLength = *-Name0
=39227					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>99bb	67					.byte (("EFloat+"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=16					LinkDisplacement = Nt0-WordListLink
>99bc	10					.byte WordFlags	;wh_Flags
>99bd	03					.byte 3	;wh_CodeLength
>99be	10					  .byte LinkDisplacement	; offset to previous nt
=$99bf					XtPtr1 ::= *
=39227					WordListLink ::= Nt0 ; remember the nt of this word for later
.99bf	a9 03		lda #$03	EFloatPlus:	lda #EFloat_Size
.99c1	4c 48 da	jmp $da48			jmp Plus_A
=5					CodeLen	.var *-XtPtr1
=$99c4					Here1 = *	; remember here
>99bd	05					.byte CodeLen	;patch wh_CodeLength
>99c4	45 46 6c 6f 61 74 73		Name0:	.text "EFloats"	;  name of word as a string, ending at wh_NameLastChar
=7					NameLength = *-Name0
=39243					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>99cb	67					.byte (("EFloats"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=16					LinkDisplacement = Nt0-WordListLink
>99cc	10					.byte WordFlags	;wh_Flags
>99cd	03					.byte 3	;wh_CodeLength
>99ce	10					  .byte LinkDisplacement	; offset to previous nt
=$99cf					XtPtr1 ::= *
=39243					WordListLink ::= Nt0 ; remember the nt of this word for later
.99cf	20 af 99	jsr $99af	EFloats:	jsr EFloat
.99d2	4c 78 be	jmp $be78			jmp Star
=6					CodeLen	.var *-XtPtr1
=$99d5					Here1 = *	; remember here
>99cd	06					.byte CodeLen	;patch wh_CodeLength
>99d5	45 41 6c 69 67 6e		Name0:	.text "EAlign"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=39259					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>99db	c6					.byte (("EAlign"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=0					WordFlags ::= 0	; modifiable copy, remember for later
=16					LinkDisplacement = Nt0-WordListLink
>99dc	00					.byte WordFlags	;wh_Flags
>99dd	03					.byte 3	;wh_CodeLength
>99de	10					  .byte LinkDisplacement	; offset to previous nt
=$99df					XtPtr1 ::= *
=39259					WordListLink ::= Nt0 ; remember the nt of this word for later
.99df					EAlign:
=0					CodeLen	.var *-XtPtr1
=$99df					Here1 = *	; remember here
>99dd	00					.byte CodeLen	;patch wh_CodeLength
.99df	60		rts				rts
>99e0	45 41 6c 69 67 6e 65 64		Name0:	.text "EAligned"	;  name of word as a string, ending at wh_NameLastChar
=8					NameLength = *-Name0
=39272					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>99e8	88					.byte (("EAligned"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=0					WordFlags ::= 0	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>99e9	00					.byte WordFlags	;wh_Flags
>99ea	03					.byte 3	;wh_CodeLength
>99eb	0d					  .byte LinkDisplacement	; offset to previous nt
=$99ec					XtPtr1 ::= *
=39272					WordListLink ::= Nt0 ; remember the nt of this word for later
.99ec					EAligned:
=0					CodeLen	.var *-XtPtr1
=$99ec					Here1 = *	; remember here
>99ea	00					.byte CodeLen	;patch wh_CodeLength
.99ec	60		rts				rts
>99ed	48 65 78 3e 45			Name0:	.text "Hex>E"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=39282					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>99f2	a5					.byte (("Hex>E"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=10					LinkDisplacement = Nt0-WordListLink
>99f3	10					.byte WordFlags	;wh_Flags
>99f4	03					.byte 3	;wh_CodeLength
>99f5	0a					  .byte LinkDisplacement	; offset to previous nt
=$99f6					XtPtr1 ::= *
=39282					WordListLink ::= Nt0 ; remember the nt of this word for later
.99f6	20 c8 84	jsr $84c8	PartsToE:	jsr FAllocX		; alloc FP stack entry, X= FP stack index
.99f9	a6 14		ldx $14				ldx tmp1+0		; restore data stack index
.99fb	a4 54		ldy $54				ldy FIndex		; Y= FP stack index
.99fd	20 c8 c3	jsr $c3c8			jsr PopA		; pop n_exp
.9a00	99 55 00	sta $0055,y			sta FSExp,y
.9a03	b5 25		lda $25,x			lda DStack+1,x
.9a05	99 5f 00	sta $005f,y			sta FSMant0,y
.9a08	b5 24		lda $24,x			lda DStack+0,x
.9a0a	99 69 00	sta $0069,y			sta FSMant1,y
.9a0d	e8		inx				inx			; Drop
.9a0e	e8		inx				inx
=25					CodeLen	.var *-XtPtr1
=$9a0f					Here1 = *	; remember here
>99f4	19					.byte CodeLen	;patch wh_CodeLength
.9a0f	60		rts				rts
>9a10	45 3e 48 65 78			Name0:	.text "E>Hex"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=39317					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9a15	05					.byte (("E>Hex"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=35					LinkDisplacement = Nt0-WordListLink
>9a16	10					.byte WordFlags	;wh_Flags
>9a17	03					.byte 3	;wh_CodeLength
>9a18	23					  .byte LinkDisplacement	; offset to previous nt
=$9a19					XtPtr1 ::= *
=39317					WordListLink ::= Nt0 ; remember the nt of this word for later
.9a19	a4 54		ldy $54		EToParts:	ldy FIndex	; Y= FP stack index
.9a1b	ca		dex				dex		; alloc n_mantissa
.9a1c	ca		dex				dex
.9a1d	ca		dex				dex		; alloc n_exponent
.9a1e	ca		dex				dex
.9a1f	b9 5f 00	lda $005f,y			lda FSMant0,y	; copy mantissa
.9a22	95 27		sta $27,x			sta DStack+3,x
.9a24	b9 69 00	lda $0069,y			lda FSMant1,y
.9a27	95 26		sta $26,x			sta DStack+2,x
.9a29	b9 55 00	lda $0055,y			lda FSExp,y	; copy exponent
.9a2c	95 24		sta $24,x			sta DStack+0,x
.9a2e	29 80		and #$80			and #$80	;   sign extend
.9a30	f0 02		beq $9a34			beq +
.9a32	a9 ff		lda #$ff			lda #$ff
.9a34	95 25		sta $25,x	+		sta DStack+1,x
.9a36	e6 54		inc $54				inc FIndex	; FDrop r
=31					CodeLen	.var *-XtPtr1
=$9a38					Here1 = *	; remember here
>9a17	1f					.byte CodeLen	;patch wh_CodeLength
.9a38	60		rts				rts
>9a39	45 2e 48 65 78			Name0:	.text "E.Hex"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=39358					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9a3e	05					.byte (("E.Hex"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=41					LinkDisplacement = Nt0-WordListLink
>9a3f	10					.byte WordFlags	;wh_Flags
>9a40	03					.byte 3	;wh_CodeLength
>9a41	29					  .byte LinkDisplacement	; offset to previous nt
=$9a42					XtPtr1 ::= *
=39358					WordListLink ::= Nt0 ; remember the nt of this word for later
.9a42	20 19 9a	jsr $9a19	EDotHex:	jsr EToParts	; get parts of r
.9a45	20 f3 df	jsr $dff3			jsr Swap
.9a48	20 ec b8	jsr $b8ec			jsr Dot_Hex	; do mantissa
.9a4b	a9 3a		lda #$3a			lda #':'
.9a4d	20 21 de	jsr $de21			jsr Emit_A
.9a50	4c cb b8	jmp $b8cb			jmp C_Dot_Hex	; do exponent
=17					CodeLen	.var *-XtPtr1
=$9a53					Here1 = *	; remember here
>9a40	11					.byte CodeLen	;patch wh_CodeLength
>9a53	45 43 6d 70 41			Name0:	.text "ECmpA"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=39384					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9a58	25					.byte (("ECmpA"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=26					LinkDisplacement = Nt0-WordListLink
>9a59	10					.byte WordFlags	;wh_Flags
>9a5a	03					.byte 3	;wh_CodeLength
>9a5b	1a					  .byte LinkDisplacement	; offset to previous nt
=$9a5c					XtPtr1 ::= *
=39384					WordListLink ::= Nt0 ; remember the nt of this word for later
.9a5c	86 14		stx $14		ECmpA:		stx tmp1		; save data stack index
.9a5e	a6 54		ldx $54				ldx FIndex		; X= FP stack index
.9a60	b5 5f		lda $5f,x			lda FSMant0+0,x		; r2 mantissa == 0 ?
.9a62	f0 29		beq $9a8d			beq _r2Zero
.9a64	b4 60		ldy $60,x			ldy FSMant0+1,x		; r1 mantissa == 0 ?
.9a66	f0 1f		beq $9a87			beq _r1Zero
.9a68	55 60		eor $60,x			eor FSMant0+1,x		; compare mantissa sign
.9a6a	30 31		bmi $9a9d			bmi _MantissaSignDifferent
.9a6c	38		sec				sec			; compare exponent
.9a6d	b5 56		lda $56,x			lda FSExp+1,x
.9a6f	f5 55		sbc $55,x			sbc FSExp+0,x
.9a71	d0 1f		bne $9a92			bne _ExponentDifferent
.9a73	98		tya				tya			; compare mantissa MSB
.9a74	f5 5f		sbc $5f,x			sbc FSMant0+0,x		;   always same sign so can't overflow
.9a76	d0 0b		bne $9a83			bne _13
.9a78	b5 6a		lda $6a,x			lda FSMant1+1,x		; compare mantissa 1
.9a7a	f5 69		sbc $69,x			sbc FSMant1+0,x
.9a7c	f0 05		beq $9a83			beq _13
.9a7e	6a		ror a		_12:		ror a
.9a7f	49 80		eor #$80	_14:		eor #$80
.9a81	09 01		ora #$01			ora #1
.9a83	a6 14		ldx $14		_13:		ldx tmp1		; restore data stack index
.9a85	a8		tay				tay			; set CPU flags
.9a86	60		rts				rts
.9a87	b5 5f		lda $5f,x	_r1Zero:	lda FSMant0+0,x		; return 0-r2
.9a89	d0 f4		bne $9a7f			bne _14
.9a8b	f0 f6		beq $9a83			beq _13
.9a8d	b5 60		lda $60,x	_r2Zero:	lda FSMant0+1,x		; return r1
.9a8f	4c 83 9a	jmp $9a83			jmp _13
.9a92					_ExponentDifferent:
.9a92	50 02		bvc $9a96			bvc +
.9a94	49 80		eor #$80			eor #$80
.9a96					+
.9a96	55 5f		eor $5f,x			eor FSMant0+0,x
.9a98	a6 14		ldx $14				ldx tmp1		; restore data stack index
.9a9a	09 01		ora #$01			ora #1			; set CPU flags
.9a9c	60		rts				rts
.9a9d					_MantissaSignDifferent:
.9a9d	98		tya				tya
.9a9e	a6 14		ldx $14				ldx tmp1		; restore data stack index
.9aa0	09 01		ora #$01			ora #1
.9aa2	60		rts				rts
=71					CodeLen	.var *-XtPtr1
=$9aa3					Here1 = *	; remember here
>9a5a	47					.byte CodeLen	;patch wh_CodeLength
>9aa3	45 4d 61 78			Name0:	.text "EMax"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=39463					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9aa7	04					.byte (("EMax"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=79					LinkDisplacement = Nt0-WordListLink
>9aa8	10					.byte WordFlags	;wh_Flags
>9aa9	03					.byte 3	;wh_CodeLength
>9aaa	4f					  .byte LinkDisplacement	; offset to previous nt
=$9aab					XtPtr1 ::= *
=39463					WordListLink ::= Nt0 ; remember the nt of this word for later
.9aab	20 5c 9a	jsr $9a5c	EMax:		jsr ECmpA
.9aae	10 2c		bpl $9adc			bpl EDrop
.9ab0	30 44		bmi $9af6			bmi ENip
=7					CodeLen	.var *-XtPtr1
=$9ab2					Here1 = *	; remember here
>9aa9	07					.byte CodeLen	;patch wh_CodeLength
>9ab2	45 4d 69 6e			Name0:	.text "EMin"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=39478					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9ab6	c4					.byte (("EMin"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=15					LinkDisplacement = Nt0-WordListLink
>9ab7	10					.byte WordFlags	;wh_Flags
>9ab8	03					.byte 3	;wh_CodeLength
>9ab9	0f					  .byte LinkDisplacement	; offset to previous nt
=$9aba					XtPtr1 ::= *
=39478					WordListLink ::= Nt0 ; remember the nt of this word for later
.9aba	20 5c 9a	jsr $9a5c	EMin:		jsr ECmpA
.9abd	30 1d		bmi $9adc			bmi EDrop
.9abf	10 35		bpl $9af6			bpl ENip
=7					CodeLen	.var *-XtPtr1
=$9ac1					Here1 = *	; remember here
>9ab8	07					.byte CodeLen	;patch wh_CodeLength
>9ac1	45 44 65 70 74 68		Name0:	.text "EDepth"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=39495					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9ac7	06					.byte (("EDepth"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=17					LinkDisplacement = Nt0-WordListLink
>9ac8	10					.byte WordFlags	;wh_Flags
>9ac9	03					.byte 3	;wh_CodeLength
>9aca	11					  .byte LinkDisplacement	; offset to previous nt
=$9acb					XtPtr1 ::= *
=39495					WordListLink ::= Nt0 ; remember the nt of this word for later
.9acb	a9 0a		lda #$0a	EDepth:		lda #FDim
.9acd	38		sec				sec
.9ace	e5 54		sbc $54				sbc FIndex
.9ad0	4c e9 c7	jmp $c7e9			jmp PushZA
=8					CodeLen	.var *-XtPtr1
=$9ad3					Here1 = *	; remember here
>9ac9	08					.byte CodeLen	;patch wh_CodeLength
>9ad3	45 44 72 6f 70			Name0:	.text "EDrop"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=39512					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9ad8	05					.byte (("EDrop"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=0					WordFlags ::= 0	; modifiable copy, remember for later
=17					LinkDisplacement = Nt0-WordListLink
>9ad9	00					.byte WordFlags	;wh_Flags
>9ada	03					.byte 3	;wh_CodeLength
>9adb	11					  .byte LinkDisplacement	; offset to previous nt
=$9adc					XtPtr1 ::= *
=39512					WordListLink ::= Nt0 ; remember the nt of this word for later
.9adc	e6 54		inc $54		EDrop:		inc FIndex
=2					CodeLen	.var *-XtPtr1
=$9ade					Here1 = *	; remember here
>9ada	02					.byte CodeLen	;patch wh_CodeLength
.9ade	60		rts				rts
>9adf	45 32 44 72 6f 70		Name0:	.text "E2Drop"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=39525					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9ae5	06					.byte (("E2Drop"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=0					WordFlags ::= 0	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>9ae6	00					.byte WordFlags	;wh_Flags
>9ae7	03					.byte 3	;wh_CodeLength
>9ae8	0d					  .byte LinkDisplacement	; offset to previous nt
=$9ae9					XtPtr1 ::= *
=39525					WordListLink ::= Nt0 ; remember the nt of this word for later
.9ae9	e6 54		inc $54		E2Drop:		inc FIndex
.9aeb	e6 54		inc $54				inc FIndex
=4					CodeLen	.var *-XtPtr1
=$9aed					Here1 = *	; remember here
>9ae7	04					.byte CodeLen	;patch wh_CodeLength
.9aed	60		rts				rts
>9aee	45 4e 69 70			Name0:	.text "ENip"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=39538					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9af2	04					.byte (("ENip"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=0					WordFlags ::= 0	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>9af3	00					.byte WordFlags	;wh_Flags
>9af4	03					.byte 3	;wh_CodeLength
>9af5	0d					  .byte LinkDisplacement	; offset to previous nt
=$9af6					XtPtr1 ::= *
=39538					WordListLink ::= Nt0 ; remember the nt of this word for later
.9af6	86 14		stx $14		ENip:		stx tmp1		; save data stack index
.9af8	a6 54		ldx $54				ldx FIndex		; X= FP stack index
.9afa	b5 55		lda $55,x			lda FSExp+0,x		; copy exponent
.9afc	95 56		sta $56,x			sta FSExp+1,x
.9afe	b5 5f		lda $5f,x			lda FSMant0+0,x		; copy mantissa
.9b00	95 60		sta $60,x			sta FSMant0+1,x
.9b02	b5 69		lda $69,x			lda FSMant1+0,x
.9b04	95 6a		sta $6a,x			sta FSMant1+1,x
.9b06	e6 54		inc $54				inc FIndex		; EDrop
.9b08	a6 14		ldx $14				ldx tmp1		; restore data stack index
=20					CodeLen	.var *-XtPtr1
=$9b0a					Here1 = *	; remember here
>9af4	14					.byte CodeLen	;patch wh_CodeLength
.9b0a	60		rts				rts
>9b0b	45 44 75 70			Name0:	.text "EDup"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=39567					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9b0f	04					.byte (("EDup"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=0					WordFlags ::= 0	; modifiable copy, remember for later
=29					LinkDisplacement = Nt0-WordListLink
>9b10	00					.byte WordFlags	;wh_Flags
>9b11	03					.byte 3	;wh_CodeLength
>9b12	1d					  .byte LinkDisplacement	; offset to previous nt
=$9b13					XtPtr1 ::= *
=39567					WordListLink ::= Nt0 ; remember the nt of this word for later
.9b13	20 c8 84	jsr $84c8	EDup:		jsr FAllocX		; alloc FP stack entry, X=fp stack index
.9b16	b5 56		lda $56,x			lda FSExp+1,x		; copy exponent
.9b18	95 55		sta $55,x			sta FSExp+0,x
.9b1a	b5 60		lda $60,x			lda FSMant0+1,x		; copy mantissa
.9b1c	95 5f		sta $5f,x			sta FSMant0+0,x
.9b1e	b5 6a		lda $6a,x			lda FSMant1+1,x
.9b20	95 69		sta $69,x			sta FSMant1+0,x
.9b22	a6 14		ldx $14				ldx tmp1+0		; restore data stack index
=17					CodeLen	.var *-XtPtr1
=$9b24					Here1 = *	; remember here
>9b11	11					.byte CodeLen	;patch wh_CodeLength
.9b24	60		rts				rts
>9b25	45 4f 76 65 72			Name0:	.text "EOver"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=39594					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9b2a	45					.byte (("EOver"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=0					WordFlags ::= 0	; modifiable copy, remember for later
=27					LinkDisplacement = Nt0-WordListLink
>9b2b	00					.byte WordFlags	;wh_Flags
>9b2c	03					.byte 3	;wh_CodeLength
>9b2d	1b					  .byte LinkDisplacement	; offset to previous nt
=$9b2e					XtPtr1 ::= *
=39594					WordListLink ::= Nt0 ; remember the nt of this word for later
.9b2e	20 c8 84	jsr $84c8	EOver:		jsr FAllocX		; alloc FP stack entry, X=fp stack index
.9b31	b5 57		lda $57,x			lda FSExp+2,x		; copy exponent
.9b33	95 55		sta $55,x			sta FSExp+0,x
.9b35	b5 61		lda $61,x			lda FSMant0+2,x		; copy mantissa
.9b37	95 5f		sta $5f,x			sta FSMant0+0,x
.9b39	b5 6b		lda $6b,x			lda FSMant1+2,x
.9b3b	95 69		sta $69,x			sta FSMant1+0,x
.9b3d	a6 14		ldx $14				ldx tmp1+0		; restore data stack index
=17					CodeLen	.var *-XtPtr1
=$9b3f					Here1 = *	; remember here
>9b2c	11					.byte CodeLen	;patch wh_CodeLength
.9b3f	60		rts				rts
>9b40	45 50 69 63 6b			Name0:	.text "EPick"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=39621					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9b45	65					.byte (("EPick"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=0					WordFlags ::= 0	; modifiable copy, remember for later
=27					LinkDisplacement = Nt0-WordListLink
>9b46	00					.byte WordFlags	;wh_Flags
>9b47	03					.byte 3	;wh_CodeLength
>9b48	1b					  .byte LinkDisplacement	; offset to previous nt
=$9b49					XtPtr1 ::= *
=39621					WordListLink ::= Nt0 ; remember the nt of this word for later
.9b49	20 c8 c3	jsr $c3c8	EPick:		jsr PopA		; pop u (desired entry #)
.9b4c	18		clc		EPickA:		clc			; Y= fp stack index of [u]
.9b4d	65 54		adc $54				adc FIndex
.9b4f	a8		tay		EPick3:		tay
.9b50	20 c8 84	jsr $84c8			jsr FAllocX		; alloc FP stack entry, X=fp stack index
.9b53	b9 55 00	lda $0055,y			lda FSExp,y		; copy exponent
.9b56	95 55		sta $55,x			sta FSExp,x
.9b58	b9 5f 00	lda $005f,y			lda FSMant0,y		; copy mantissa
.9b5b	95 5f		sta $5f,x			sta FSMant0,x
.9b5d	b9 69 00	lda $0069,y			lda FSMant1,y
.9b60	95 69		sta $69,x			sta FSMant1,x
.9b62	a6 14		ldx $14				ldx tmp1+0		; restore data stack index
=27					CodeLen	.var *-XtPtr1
=$9b64					Here1 = *	; remember here
>9b47	1b					.byte CodeLen	;patch wh_CodeLength
.9b64	60		rts				rts
>9b65	45 32 44 75 70			Name0:	.text "E2Dup"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=39658					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9b6a	05					.byte (("E2Dup"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=37					LinkDisplacement = Nt0-WordListLink
>9b6b	10					.byte WordFlags	;wh_Flags
>9b6c	03					.byte 3	;wh_CodeLength
>9b6d	25					  .byte LinkDisplacement	; offset to previous nt
=$9b6e					XtPtr1 ::= *
=39658					WordListLink ::= Nt0 ; remember the nt of this word for later
.9b6e	20 2e 9b	jsr $9b2e	E2Dup:		jsr EOver
.9b71	4c 2e 9b	jmp $9b2e			jmp EOver
=6					CodeLen	.var *-XtPtr1
=$9b74					Here1 = *	; remember here
>9b6c	06					.byte CodeLen	;patch wh_CodeLength
>9b74	45 53 77 61 70			Name0:	.text "ESwap"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=39673					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9b79	05					.byte (("ESwap"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=0					WordFlags ::= 0	; modifiable copy, remember for later
=15					LinkDisplacement = Nt0-WordListLink
>9b7a	00					.byte WordFlags	;wh_Flags
>9b7b	03					.byte 3	;wh_CodeLength
>9b7c	0f					  .byte LinkDisplacement	; offset to previous nt
=$9b7d					XtPtr1 ::= *
=39673					WordListLink ::= Nt0 ; remember the nt of this word for later
.9b7d	86 14		stx $14		ESwap:		stx tmp1+0		; save data stack index
.9b7f	a6 54		ldx $54				ldx FIndex		; X=FP stack index
.9b81	b5 55		lda $55,x			lda FSExp+0,x		; do FSExp
.9b83	b4 56		ldy $56,x			ldy FSExp+1,x
.9b85	95 56		sta $56,x			sta FSExp+1,x
.9b87	94 55		sty $55,x			sty FSExp+0,x	; sty dir,x exists
.9b89	b5 5f		lda $5f,x			lda FSMant0+0,x		; do FSMant0
.9b8b	b4 60		ldy $60,x			ldy FSMant0+1,x
.9b8d	95 60		sta $60,x			sta FSMant0+1,x
.9b8f	94 5f		sty $5f,x			sty FSMant0+0,x	; sty dir,x exists
.9b91	b5 69		lda $69,x			lda FSMant1+0,x		; do FSMant1
.9b93	b4 6a		ldy $6a,x			ldy FSMant1+1,x
.9b95	95 6a		sta $6a,x			sta FSMant1+1,x
.9b97	94 69		sty $69,x			sty FSMant1+0,x	; sty dir,x exists
.9b99	a6 14		ldx $14				ldx tmp1+0		; restore data stack index
=30					CodeLen	.var *-XtPtr1
=$9b9b					Here1 = *	; remember here
>9b7b	1e					.byte CodeLen	;patch wh_CodeLength
.9b9b	60		rts				rts
>9b9c	45 54 75 63 6b			Name0:	.text "ETuck"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=39713					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9ba1	65					.byte (("ETuck"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=40					LinkDisplacement = Nt0-WordListLink
>9ba2	10					.byte WordFlags	;wh_Flags
>9ba3	03					.byte 3	;wh_CodeLength
>9ba4	28					  .byte LinkDisplacement	; offset to previous nt
=$9ba5					XtPtr1 ::= *
=39713					WordListLink ::= Nt0 ; remember the nt of this word for later
.9ba5	20 7d 9b	jsr $9b7d	ETuck:		jsr ESwap
.9ba8	4c 2e 9b	jmp $9b2e			jmp EOver
=6					CodeLen	.var *-XtPtr1
=$9bab					Here1 = *	; remember here
>9ba3	06					.byte CodeLen	;patch wh_CodeLength
>9bab	45 52 6f 74			Name0:	.text "ERot"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=39727					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9baf	84					.byte (("ERot"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=0					WordFlags ::= 0	; modifiable copy, remember for later
=14					LinkDisplacement = Nt0-WordListLink
>9bb0	00					.byte WordFlags	;wh_Flags
>9bb1	03					.byte 3	;wh_CodeLength
>9bb2	0e					  .byte LinkDisplacement	; offset to previous nt
=$9bb3					XtPtr1 ::= *
=39727					WordListLink ::= Nt0 ; remember the nt of this word for later
.9bb3	86 14		stx $14		ERot:		stx tmp1		; save data stack index
.9bb5	a5 54		lda $54				lda FIndex		; for FSMant3, FSMant2, FSMant1, FSMant0, FSExp
.9bb7	18		clc				clc
.9bb8	69 14		adc #$14			adc #2*FDim
.9bba	d0 03		bne $9bbf			bne _3
.9bbc	8a		txa		_2:		txa			;    next byte
.9bbd	e9 0a		sbc #$0a			sbc #FDim
.9bbf	aa		tax		_3:		tax
.9bc0	b4 57		ldy $57,x			ldy FSExp+2,x		;   do a byte
.9bc2	b5 56		lda $56,x			lda FSExp+1,x
.9bc4	95 57		sta $57,x			sta FSExp+2,x
.9bc6	b5 55		lda $55,x			lda FSExp+0,x
.9bc8	95 56		sta $56,x			sta FSExp+1,x
.9bca	94 55		sty $55,x			sty FSExp+0,x	; sty dir,x exists
.9bcc	e4 54		cpx $54				cpx FIndex		; done?
.9bce	d0 ec		bne $9bbc			bne _2
.9bd0	a6 14		ldx $14				ldx tmp1		; restore param stack index
=31					CodeLen	.var *-XtPtr1
=$9bd2					Here1 = *	; remember here
>9bb1	1f					.byte CodeLen	;patch wh_CodeLength
.9bd2	60		rts				rts
>9bd3	45 2d 52 6f 74			Name0:	.text "E-Rot"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=39768					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9bd8	85					.byte (("E-Rot"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=41					LinkDisplacement = Nt0-WordListLink
>9bd9	10					.byte WordFlags	;wh_Flags
>9bda	03					.byte 3	;wh_CodeLength
>9bdb	29					  .byte LinkDisplacement	; offset to previous nt
=$9bdc					XtPtr1 ::= *
=39768					WordListLink ::= Nt0 ; remember the nt of this word for later
.9bdc	20 b3 9b	jsr $9bb3	EMRot:		jsr ERot
.9bdf	4c b3 9b	jmp $9bb3			jmp ERot
=6					CodeLen	.var *-XtPtr1
=$9be2					Here1 = *	; remember here
>9bda	06					.byte CodeLen	;patch wh_CodeLength
>9be2	45 40				Name0:	.text "E@"	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=39780					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9be4	02					.byte (("E@"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=0					WordFlags ::= 0	; modifiable copy, remember for later
=12					LinkDisplacement = Nt0-WordListLink
>9be5	00					.byte WordFlags	;wh_Flags
>9be6	03					.byte 3	;wh_CodeLength
>9be7	0c					  .byte LinkDisplacement	; offset to previous nt
=$9be8					XtPtr1 ::= *
=39780					WordListLink ::= Nt0 ; remember the nt of this word for later
.9be8	20 e3 c3	jsr $c3e3	EAt:		jsr PopYA		; pop addr
.9beb	85 16		sta $16		EAt_YA:		sta tmp2+0		; save addr
.9bed	84 17		sty $17				sty tmp2+1
.9bef	a0 00		ldy #$00			ldy #0			; starting offset from tmp2
.9bf1	20 c8 84	jsr $84c8	EAt_Tmp2Y:	jsr FAllocX		; alloc FP stack entry, X= fp stack index
.9bf4	b1 16		lda ($16),y			lda (tmp2),y		; copy mantissa
.9bf6	95 69		sta $69,x			sta FSMant1,x
.9bf8	c8		iny				iny
.9bf9	b1 16		lda ($16),y			lda (tmp2),y
.9bfb	95 5f		sta $5f,x			sta FSMant0,x
.9bfd	c8		iny				iny			; copy exponent
.9bfe	b1 16		lda ($16),y			lda (tmp2),y
.9c00	95 55		sta $55,x			sta FSExp,x
.9c02	a6 14		ldx $14				ldx tmp1		; restore data stack index
=28					CodeLen	.var *-XtPtr1
=$9c04					Here1 = *	; remember here
>9be6	1c					.byte CodeLen	;patch wh_CodeLength
.9c04	60		rts				rts
>9c05	45 21				Name0:	.text "E!"	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=39815					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9c07	22					.byte (("E!"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=0					WordFlags ::= 0	; modifiable copy, remember for later
=35					LinkDisplacement = Nt0-WordListLink
>9c08	00					.byte WordFlags	;wh_Flags
>9c09	03					.byte 3	;wh_CodeLength
>9c0a	23					  .byte LinkDisplacement	; offset to previous nt
=$9c0b					XtPtr1 ::= *
=39815					WordListLink ::= Nt0 ; remember the nt of this word for later
.9c0b	20 e3 c3	jsr $c3e3	EStore:		jsr PopYA		; pop addr
.9c0e	85 14		sta $14		EStore_YA:	sta tmp1+0		; save addr
.9c10	84 15		sty $15				sty tmp1+1
.9c12	a0 00		ldy #$00			ldy #0
.9c14	86 16		stx $16				stx tmp2		; save data stack index
.9c16	a6 54		ldx $54				ldx FIndex		; X= FP stack index
.9c18	b5 69		lda $69,x			lda FSMant1,x		; copy mantissa
.9c1a	91 14		sta ($14),y			sta (tmp1),y
.9c1c	b5 5f		lda $5f,x			lda FSMant0,x
.9c1e	c8		iny				iny
.9c1f	91 14		sta ($14),y			sta (tmp1),y
.9c21	b5 55		lda $55,x			lda FSExp,x		; copy exponent
.9c23	c8		iny				iny
.9c24	91 14		sta ($14),y			sta (tmp1),y
.9c26	e6 54		inc $54				inc FIndex		; FDrop
.9c28	a6 16		ldx $16				ldx tmp2		; restore data stack index
=31					CodeLen	.var *-XtPtr1
=$9c2a					Here1 = *	; remember here
>9c09	1f					.byte CodeLen	;patch wh_CodeLength
.9c2a	60		rts				rts
>9c2b	45 2c				Name0:	.text "E,"	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=39853					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9c2d	82					.byte (("E,"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=38					LinkDisplacement = Nt0-WordListLink
>9c2e	10					.byte WordFlags	;wh_Flags
>9c2f	03					.byte 3	;wh_CodeLength
>9c30	26					  .byte LinkDisplacement	; offset to previous nt
=$9c31					XtPtr1 ::= *
=39853					WordListLink ::= Nt0 ; remember the nt of this word for later
.9c31	a5 00		lda $00		EComma:		lda cp+0		; store f at Here
.9c33	a4 01		ldy $01				ldy cp+1
.9c35	20 0e 9c	jsr $9c0e			jsr EStore_YA
.9c38	a9 03		lda #$03			lda #EFloat_Size
.9c3a	4c b7 d0	jmp $d0b7			jmp Allot_ZA
=12					CodeLen	.var *-XtPtr1
=$9c3d					Here1 = *	; remember here
>9c2f	0c					.byte CodeLen	;patch wh_CodeLength
>9c3d	45 30 21			Name0:	.text "E0!"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=39872					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9c40	23					.byte (("E0!"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=19					LinkDisplacement = Nt0-WordListLink
>9c41	10					.byte WordFlags	;wh_Flags
>9c42	03					.byte 3	;wh_CodeLength
>9c43	13					  .byte LinkDisplacement	; offset to previous nt
=$9c44					XtPtr1 ::= *
=39872					WordListLink ::= Nt0 ; remember the nt of this word for later
.9c44	20 27 9e	jsr $9e27	EZStore:	jsr E0
.9c47	4c 0b 9c	jmp $9c0b			jmp EStore
=6					CodeLen	.var *-XtPtr1
=$9c4a					Here1 = *	; remember here
>9c42	06					.byte CodeLen	;patch wh_CodeLength
>9c4a	45 30 3d			Name0:	.text "E0="	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=39885					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9c4d	a3					.byte (("E0="[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>9c4e	10					.byte WordFlags	;wh_Flags
>9c4f	03					.byte 3	;wh_CodeLength
>9c50	0d					  .byte LinkDisplacement	; offset to previous nt
=$9c51					XtPtr1 ::= *
=39885					WordListLink ::= Nt0 ; remember the nt of this word for later
.9c51	a4 54		ldy $54		EZEq:		ldy FIndex
.9c53	b9 5f 00	lda $005f,y			lda FSMant0,y
.9c56	d0 24		bne $9c7c			bne EFalse1
.9c58					ETrue1:
.9c58	e6 54		inc $54				inc FIndex	; EDrop
.9c5a	4c c9 c7	jmp $c7c9			jmp True	; return true
=12					CodeLen	.var *-XtPtr1
=$9c5d					Here1 = *	; remember here
>9c4f	0c					.byte CodeLen	;patch wh_CodeLength
>9c5d	45 30 3c 3e			Name0:	.text "E0<>"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=39905					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9c61	c4					.byte (("E0<>"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=20					LinkDisplacement = Nt0-WordListLink
>9c62	10					.byte WordFlags	;wh_Flags
>9c63	03					.byte 3	;wh_CodeLength
>9c64	14					  .byte LinkDisplacement	; offset to previous nt
=$9c65					XtPtr1 ::= *
=39905					WordListLink ::= Nt0 ; remember the nt of this word for later
.9c65	a4 54		ldy $54		EZNe:		ldy FIndex
.9c67	b9 5f 00	lda $005f,y			lda FSMant0,y
.9c6a	d0 ec		bne $9c58			bne ETrue1
.9c6c	f0 0e		beq $9c7c			beq EFalse1
=9					CodeLen	.var *-XtPtr1
=$9c6e					Here1 = *	; remember here
>9c63	09					.byte CodeLen	;patch wh_CodeLength
>9c6e	45 30 3c			Name0:	.text "E0<"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=39921					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9c71	83					.byte (("E0<"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=16					LinkDisplacement = Nt0-WordListLink
>9c72	10					.byte WordFlags	;wh_Flags
>9c73	03					.byte 3	;wh_CodeLength
>9c74	10					  .byte LinkDisplacement	; offset to previous nt
=$9c75					XtPtr1 ::= *
=39921					WordListLink ::= Nt0 ; remember the nt of this word for later
.9c75	a4 54		ldy $54		EZLt:		ldy FIndex
.9c77	b9 5f 00	lda $005f,y			lda FSMant0,y
.9c7a	30 dc		bmi $9c58			bmi ETrue1
.9c7c					EFalse1:
.9c7c	e6 54		inc $54				inc FIndex	; EDrop
.9c7e	4c db c7	jmp $c7db			jmp False	; return false
=12					CodeLen	.var *-XtPtr1
=$9c81					Here1 = *	; remember here
>9c73	0c					.byte CodeLen	;patch wh_CodeLength
>9c81	45 30 3e 3d			Name0:	.text "E0>="	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=39941					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9c85	a4					.byte (("E0>="[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=20					LinkDisplacement = Nt0-WordListLink
>9c86	10					.byte WordFlags	;wh_Flags
>9c87	03					.byte 3	;wh_CodeLength
>9c88	14					  .byte LinkDisplacement	; offset to previous nt
=$9c89					XtPtr1 ::= *
=39941					WordListLink ::= Nt0 ; remember the nt of this word for later
.9c89	a4 54		ldy $54		EZGe:		ldy FIndex
.9c8b	b9 5f 00	lda $005f,y			lda FSMant0,y
.9c8e	10 c8		bpl $9c58			bpl ETrue1
.9c90	30 ea		bmi $9c7c			bmi EFalse1
=9					CodeLen	.var *-XtPtr1
=$9c92					Here1 = *	; remember here
>9c87	09					.byte CodeLen	;patch wh_CodeLength
>9c92	45 30 3e			Name0:	.text "E0>"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=39957					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9c95	c3					.byte (("E0>"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=16					LinkDisplacement = Nt0-WordListLink
>9c96	10					.byte WordFlags	;wh_Flags
>9c97	03					.byte 3	;wh_CodeLength
>9c98	10					  .byte LinkDisplacement	; offset to previous nt
=$9c99					XtPtr1 ::= *
=39957					WordListLink ::= Nt0 ; remember the nt of this word for later
.9c99	a4 54		ldy $54		EZGt:		ldy FIndex
.9c9b	b9 5f 00	lda $005f,y			lda FSMant0,y
.9c9e	30 dc		bmi $9c7c			bmi EFalse1
.9ca0	d0 b6		bne $9c58			bne ETrue1
.9ca2	f0 d8		beq $9c7c			beq EFalse1
=11					CodeLen	.var *-XtPtr1
=$9ca4					Here1 = *	; remember here
>9c97	0b					.byte CodeLen	;patch wh_CodeLength
>9ca4	45 30 3c 3d			Name0:	.text "E0<="	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=39976					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9ca8	a4					.byte (("E0<="[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=19					LinkDisplacement = Nt0-WordListLink
>9ca9	10					.byte WordFlags	;wh_Flags
>9caa	03					.byte 3	;wh_CodeLength
>9cab	13					  .byte LinkDisplacement	; offset to previous nt
=$9cac					XtPtr1 ::= *
=39976					WordListLink ::= Nt0 ; remember the nt of this word for later
.9cac	a4 54		ldy $54		EZLe:		ldy FIndex
.9cae	b9 5f 00	lda $005f,y			lda FSMant0,y
.9cb1	30 a5		bmi $9c58			bmi ETrue1
.9cb3	d0 c7		bne $9c7c			bne EFalse1
.9cb5	f0 a1		beq $9c58			beq ETrue1
=11					CodeLen	.var *-XtPtr1
=$9cb7					Here1 = *	; remember here
>9caa	0b					.byte CodeLen	;patch wh_CodeLength
>9cb7	45 3c				Name0:	.text "E<"	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=39993					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9cb9	82					.byte (("E<"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=17					LinkDisplacement = Nt0-WordListLink
>9cba	10					.byte WordFlags	;wh_Flags
>9cbb	03					.byte 3	;wh_CodeLength
>9cbc	11					  .byte LinkDisplacement	; offset to previous nt
=$9cbd					XtPtr1 ::= *
=39993					WordListLink ::= Nt0 ; remember the nt of this word for later
.9cbd	20 5c 9a	jsr $9a5c	ELt:		jsr ECmpA
.9cc0	30 32		bmi $9cf4			bmi ETrue2
.9cc2					EFalse2:
.9cc2	e6 54		inc $54				inc FIndex	; EDrop
.9cc4	e6 54		inc $54				inc FIndex	; EDrop
.9cc6	4c db c7	jmp $c7db			jmp False	; return False
=12					CodeLen	.var *-XtPtr1
=$9cc9					Here1 = *	; remember here
>9cbb	0c					.byte CodeLen	;patch wh_CodeLength
>9cc9	45 3e 3d			Name0:	.text "E>="	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=40012					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9ccc	a3					.byte (("E>="[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=19					LinkDisplacement = Nt0-WordListLink
>9ccd	10					.byte WordFlags	;wh_Flags
>9cce	03					.byte 3	;wh_CodeLength
>9ccf	13					  .byte LinkDisplacement	; offset to previous nt
=$9cd0					XtPtr1 ::= *
=40012					WordListLink ::= Nt0 ; remember the nt of this word for later
.9cd0	20 5c 9a	jsr $9a5c	EGe:		jsr ECmpA
.9cd3	10 1f		bpl $9cf4			bpl ETrue2
.9cd5	30 eb		bmi $9cc2			bmi EFalse2
=7					CodeLen	.var *-XtPtr1
=$9cd7					Here1 = *	; remember here
>9cce	07					.byte CodeLen	;patch wh_CodeLength
>9cd7	45 3e				Name0:	.text "E>"	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=40025					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9cd9	c2					.byte (("E>"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>9cda	10					.byte WordFlags	;wh_Flags
>9cdb	03					.byte 3	;wh_CodeLength
>9cdc	0d					  .byte LinkDisplacement	; offset to previous nt
=$9cdd					XtPtr1 ::= *
=40025					WordListLink ::= Nt0 ; remember the nt of this word for later
.9cdd	20 5c 9a	jsr $9a5c	EGt:		jsr ECmpA
.9ce0	30 e0		bmi $9cc2			bmi EFalse2
.9ce2	d0 10		bne $9cf4			bne ETrue2
.9ce4	f0 dc		beq $9cc2			beq EFalse2
=9					CodeLen	.var *-XtPtr1
=$9ce6					Here1 = *	; remember here
>9cdb	09					.byte CodeLen	;patch wh_CodeLength
>9ce6	45 3c 3d			Name0:	.text "E<="	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=40041					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9ce9	a3					.byte (("E<="[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=16					LinkDisplacement = Nt0-WordListLink
>9cea	10					.byte WordFlags	;wh_Flags
>9ceb	03					.byte 3	;wh_CodeLength
>9cec	10					  .byte LinkDisplacement	; offset to previous nt
=$9ced					XtPtr1 ::= *
=40041					WordListLink ::= Nt0 ; remember the nt of this word for later
.9ced	20 5c 9a	jsr $9a5c	ELe:		jsr ECmpA
.9cf0	30 02		bmi $9cf4			bmi ETrue2
.9cf2	d0 ce		bne $9cc2			bne EFalse2
.9cf4					ETrue2:
.9cf4	e6 54		inc $54				inc FIndex	; EDrop
.9cf6	e6 54		inc $54				inc FIndex	; EDrop
.9cf8	4c c9 c7	jmp $c7c9			jmp True	; return True
=14					CodeLen	.var *-XtPtr1
=$9cfb					Here1 = *	; remember here
>9ceb	0e					.byte CodeLen	;patch wh_CodeLength
>9cfb	45 3c 3e			Name0:	.text "E<>"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=40062					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9cfe	c3					.byte (("E<>"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=21					LinkDisplacement = Nt0-WordListLink
>9cff	10					.byte WordFlags	;wh_Flags
>9d00	03					.byte 3	;wh_CodeLength
>9d01	15					  .byte LinkDisplacement	; offset to previous nt
=$9d02					XtPtr1 ::= *
=40062					WordListLink ::= Nt0 ; remember the nt of this word for later
.9d02	20 5c 9a	jsr $9a5c	ENe:		jsr ECmpA
.9d05	d0 ed		bne $9cf4			bne ETrue2
.9d07	f0 b9		beq $9cc2			beq EFalse2
=7					CodeLen	.var *-XtPtr1
=$9d09					Here1 = *	; remember here
>9d00	07					.byte CodeLen	;patch wh_CodeLength
>9d09	45 3d				Name0:	.text "E="	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=40075					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9d0b	a2					.byte (("E="[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>9d0c	10					.byte WordFlags	;wh_Flags
>9d0d	03					.byte 3	;wh_CodeLength
>9d0e	0d					  .byte LinkDisplacement	; offset to previous nt
=$9d0f					XtPtr1 ::= *
=40075					WordListLink ::= Nt0 ; remember the nt of this word for later
.9d0f	20 5c 9a	jsr $9a5c	EEq:		jsr ECmpA
.9d12	d0 ae		bne $9cc2			bne EFalse2
.9d14	f0 de		beq $9cf4			beq ETrue2
=7					CodeLen	.var *-XtPtr1
=$9d16					Here1 = *	; remember here
>9d0d	07					.byte CodeLen	;patch wh_CodeLength
>9d16	45 7e 41 62 73			Name0:	.text "E~Abs"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=40091					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9d1b	65					.byte (("E~Abs"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=16					LinkDisplacement = Nt0-WordListLink
>9d1c	10					.byte WordFlags	;wh_Flags
>9d1d	03					.byte 3	;wh_CodeLength
>9d1e	10					  .byte LinkDisplacement	; offset to previous nt
=$9d1f					XtPtr1 ::= *
=40091					WordListLink ::= Nt0 ; remember the nt of this word for later
.9d1f	20 dc 9b	jsr $9bdc	ETAbs:		jsr EMRot
.9d22	20 9c a0	jsr $a09c			jsr EMinus
.9d25	20 df a0	jsr $a0df			jsr EAbs
.9d28	4c dd 9c	jmp $9cdd			jmp EGt
=12					CodeLen	.var *-XtPtr1
=$9d2b					Here1 = *	; remember here
>9d1d	0c					.byte CodeLen	;patch wh_CodeLength
>9d2b	45 7e 52 65 6c			Name0:	.text "E~Rel"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=40112					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9d30	85					.byte (("E~Rel"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=21					LinkDisplacement = Nt0-WordListLink
>9d31	10					.byte WordFlags	;wh_Flags
>9d32	03					.byte 3	;wh_CodeLength
>9d33	15					  .byte LinkDisplacement	; offset to previous nt
=$9d34					XtPtr1 ::= *
=40112					WordListLink ::= Nt0 ; remember the nt of this word for later
.9d34	20 2e 9b	jsr $9b2e	ETRel:		jsr EOver
.9d37	a9 03		lda #$03			lda #3
.9d39	20 4c 9b	jsr $9b4c			jsr EPickA
.9d3c	20 6c a0	jsr $a06c			jsr EPlus
.9d3f	20 df a0	jsr $a0df			jsr EAbs
.9d42	20 4d 8d	jsr $8d4d			jsr EStar		; r1 r2 r3*|r1+r2|
.9d45	20 dc 9b	jsr $9bdc			jsr EMRot		; r3*|r1+r2| r1 r2
.9d48	20 9c a0	jsr $a09c			jsr EMinus
.9d4b	20 df a0	jsr $a0df			jsr EAbs
.9d4e	4c dd 9c	jmp $9cdd			jmp EGt
=29					CodeLen	.var *-XtPtr1
=$9d51					Here1 = *	; remember here
>9d32	1d					.byte CodeLen	;patch wh_CodeLength
>9d51	45 7e				Name0:	.text "E~"	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=40147					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9d53	c2					.byte (("E~"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=35					LinkDisplacement = Nt0-WordListLink
>9d54	10					.byte WordFlags	;wh_Flags
>9d55	03					.byte 3	;wh_CodeLength
>9d56	23					  .byte LinkDisplacement	; offset to previous nt
=$9d57					XtPtr1 ::= *
=40147					WordListLink ::= Nt0 ; remember the nt of this word for later
.9d57	a4 54		ldy $54		ETilde:		ldy FIndex
.9d59	b9 5f 00	lda $005f,y			lda FSMant0,y
.9d5c	30 06		bmi $9d64			bmi _10			; e3<0
.9d5e	d0 bf		bne $9d1f			bne ETAbs		; e3>0
.9d60	e6 54		inc $54				inc FIndex		; e3=0
.9d62	d0 ab		bne $9d0f			bne EEq
.9d64	20 c5 a0	jsr $a0c5	_10:		jsr ENegate
.9d67	4c 34 9d	jmp $9d34			jmp ETRel
=19					CodeLen	.var *-XtPtr1
=$9d6a					Here1 = *	; remember here
>9d55	13					.byte CodeLen	;patch wh_CodeLength
>9d6a	45 56 61 72 69 61 62 6c		Name0:	.text "EVariable"	;  name of word as a string, ending at wh_NameLastChar
>9d72	65
=9					NameLength = *-Name0
=40179					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9d73	a9					.byte (("EVariable"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=24					WordFlags ::= IM+NN	; modifiable copy, remember for later
=32					LinkDisplacement = Nt0-WordListLink
>9d74	18					.byte WordFlags	;wh_Flags
>9d75	03					.byte 3	;wh_CodeLength
>9d76	20					  .byte LinkDisplacement	; offset to previous nt
=$9d77					XtPtr1 ::= *
=40179					WordListLink ::= Nt0 ; remember the nt of this word for later
.9d77	20 cd d1	jsr $d1cd	EVariable:	jsr Create		; compile word header & push PFA adr
.9d7a	20 e0 cb	jsr $cbe0			jsr adjust_z		; fix word code length
.9d7d	20 27 9e	jsr $9e27			jsr E0			; alloc & init data
.9d80	4c 31 9c	jmp $9c31			jmp EComma
=12					CodeLen	.var *-XtPtr1
=$9d83					Here1 = *	; remember here
>9d75	0c					.byte CodeLen	;patch wh_CodeLength
>9d83	45 4c 69 74 65 72 61 6c		Name0:	.text "ELiteral"	;  name of word as a string, ending at wh_NameLastChar
=8					NameLength = *-Name0
=40203					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9d8b	88					.byte (("ELiteral"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=24					WordFlags ::= IM+NN	; modifiable copy, remember for later
=24					LinkDisplacement = Nt0-WordListLink
>9d8c	18					.byte WordFlags	;wh_Flags
>9d8d	03					.byte 3	;wh_CodeLength
>9d8e	18					  .byte LinkDisplacement	; offset to previous nt
=$9d8f					XtPtr1 ::= *
=40203					WordListLink ::= Nt0 ; remember the nt of this word for later
.9d8f	20 a4 9d	jsr $9da4	ELiteral:	jsr ELitTest
.9d92	f0 0a		beq $9d9e			beq _Short
.9d94	a9 c7		lda #$c7			lda #<ELitI		; compile JSR FLitI
.9d96	a0 9d		ldy #$9d			ldy #>ELitI
.9d98	20 78 dd	jsr $dd78			jsr Jsr_Comma_YA
.9d9b	4c 31 9c	jmp $9c31			jmp EComma		; compile inline operand, return
.9d9e	20 aa 9d	jsr $9daa	_Short:		jsr ELitShort
.9da1	4c 78 dd	jmp $dd78			jmp Jsr_Comma_YA	; compile jsr ELitYA, & return
=21					CodeLen	.var *-XtPtr1
=$9da4					Here1 = *	; remember here
>9d8d	15					.byte CodeLen	;patch wh_CodeLength
.9da4					ELitTest:
.9da4	a4 54		ldy $54				ldy FIndex
.9da6	b9 69 00	lda $0069,y			lda FSMant1,y		; will short work?
.9da9	60		rts				rts
.9daa					ELitShort:
.9daa	a9 a9		lda #$a9			lda #$a9		; compile LDA #mant0
.9dac	20 3e dd	jsr $dd3e			jsr C_Comma_A
.9daf	b9 5f 00	lda $005f,y			lda FSMant0,y
.9db2	20 3e dd	jsr $dd3e			jsr C_Comma_A
.9db5	a9 a0		lda #$a0			lda #$a0		; compile LDY #exp
.9db7	20 3e dd	jsr $dd3e			jsr C_Comma_A
.9dba	b9 55 00	lda $0055,y			lda FSExp,y
.9dbd	20 3e dd	jsr $dd3e			jsr C_Comma_A
.9dc0	e6 54		inc $54				inc FIndex		; FDrop
.9dc2	a9 11		lda #$11			lda #<ELitYA		; point at FLitYA
.9dc4	a0 9e		ldy #$9e			ldy #>ELitYA
.9dc6	60		rts				rts
.9dc7					ELitI:
.9dc7	68		pla				pla			; tmp2= RTS addr
.9dc8	85 16		sta $16				sta tmp2+0
.9dca	18		clc				clc			; bump RTS addr over inline float data
.9dcb	69 03		adc #$03			adc #EFloat_Size
.9dcd	a8		tay				tay
.9dce	68		pla				pla
.9dcf	85 17		sta $17				sta tmp2+1
.9dd1	69 00		adc #$00			adc #0
.9dd3	48		pha				pha
.9dd4	98		tya				tya
.9dd5	48		pha				pha
.9dd6	a0 01		ldy #$01			ldy #1			; correct for RTS addr
.9dd8	4c f1 9b	jmp $9bf1			jmp EAt_Tmp2Y		; fetch inline data, & return
>9ddb	45 43 6f 6e 73 74 61 6e		Name0:	.text "EConstant"	;  name of word as a string, ending at wh_NameLastChar
>9de3	74
=9					NameLength = *-Name0
=40292					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9de4	89					.byte (("EConstant"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=89					LinkDisplacement = Nt0-WordListLink
>9de5	10					.byte WordFlags	;wh_Flags
>9de6	03					.byte 3	;wh_CodeLength
>9de7	59					  .byte LinkDisplacement	; offset to previous nt
=$9de8					XtPtr1 ::= *
=40292					WordListLink ::= Nt0 ; remember the nt of this word for later
.9de8	20 20 d1	jsr $d120	EConstant:	jsr Header_Comma	; compile word header
.9deb	20 a4 9d	jsr $9da4			jsr ELitTest		; will short work?
.9dee	f0 0d		beq $9dfd			beq _Short
.9df0	a9 06		lda #$06			lda #<EConstantRun	; compile call
.9df2	a0 9e		ldy #$9e			ldy #>EConstantRun
.9df4	20 78 dd	jsr $dd78			jsr Jsr_Comma_YA
.9df7	20 e0 cb	jsr $cbe0			jsr adjust_z
.9dfa	4c 31 9c	jmp $9c31			jmp EComma		; inline operand, & return
.9dfd					_Short:
.9dfd	20 aa 9d	jsr $9daa			jsr ELitShort		; compile load value
.9e00	20 8e dd	jsr $dd8e			jsr Jmp_Comma_YA	; compile JMP
.9e03	4c e0 cb	jmp $cbe0			jmp adjust_z
=30					CodeLen	.var *-XtPtr1
=$9e06					Here1 = *	; remember here
>9de6	1e					.byte CodeLen	;patch wh_CodeLength
.9e06					EConstantRun:
.9e06	68		pla				pla			; tmp2= pop RTS addr
.9e07	85 16		sta $16				sta tmp2+0
.9e09	68		pla				pla
.9e0a	85 17		sta $17				sta tmp2+1
.9e0c	a0 01		ldy #$01			ldy #1			; correct for RTS addr
.9e0e	4c f1 9b	jmp $9bf1			jmp EAt_Tmp2Y		; fetch inline data, & return
.9e11					ELitYA:
.9e11	20 c8 84	jsr $84c8			jsr FAllocX		; alloc FP stack entry, X=FP stack index
.9e14	95 5f		sta $5f,x			sta FSMant0,x		; Mant= A,0
.9e16	94 55		sty $55,x			sty FSExp,x	; sty dir,x exists
.9e18	a9 00		lda #$00			lda #0
.9e1a	95 69		sta $69,x			sta FSMant1,x
.9e1c	a6 14		ldx $14				ldx tmp1+0		; restore data stack index
.9e1e	60		rts				rts
>9e1f	45 30 2e 65			Name0:	.text "E0.e"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=40355					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9e23	a4					.byte (("E0.e"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=63					LinkDisplacement = Nt0-WordListLink
>9e24	10					.byte WordFlags	;wh_Flags
>9e25	03					.byte 3	;wh_CodeLength
>9e26	3f					  .byte LinkDisplacement	; offset to previous nt
=$9e27					XtPtr1 ::= *
=40355					WordListLink ::= Nt0 ; remember the nt of this word for later
.9e27	a9 00		lda #$00	E0:		lda #0			; FSMant0
.9e29	a0 80		ldy #$80			ldy #$80		; FSExp
.9e2b	d0 e4		bne $9e11			bne ELitYA
=6					CodeLen	.var *-XtPtr1
=$9e2d					Here1 = *	; remember here
>9e25	06					.byte CodeLen	;patch wh_CodeLength
>9e2d	45 31 30 30 30 2e 65		Name0:	.text "E1000.e"	;  name of word as a string, ending at wh_NameLastChar
=7					NameLength = *-Name0
=40372					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9e34	a7					.byte (("E1000.e"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=17					LinkDisplacement = Nt0-WordListLink
>9e35	10					.byte WordFlags	;wh_Flags
>9e36	03					.byte 3	;wh_CodeLength
>9e37	11					  .byte LinkDisplacement	; offset to previous nt
=$9e38					XtPtr1 ::= *
=40372					WordListLink ::= Nt0 ; remember the nt of this word for later
.9e38	a9 7d		lda #$7d	E1000:		lda #$7d
.9e3a	a0 0a		ldy #$0a			ldy #10
.9e3c	d0 d3		bne $9e11			bne ELitYA
=6					CodeLen	.var *-XtPtr1
=$9e3e					Here1 = *	; remember here
>9e36	06					.byte CodeLen	;patch wh_CodeLength
>9e3e	45 31 30 2e 65			Name0:	.text "E10.e"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=40387					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9e43	a5					.byte (("E10.e"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=15					LinkDisplacement = Nt0-WordListLink
>9e44	10					.byte WordFlags	;wh_Flags
>9e45	03					.byte 3	;wh_CodeLength
>9e46	0f					  .byte LinkDisplacement	; offset to previous nt
=$9e47					XtPtr1 ::= *
=40387					WordListLink ::= Nt0 ; remember the nt of this word for later
.9e47	a9 50		lda #$50	E10:		lda #$50
.9e49	a0 04		ldy #$04			ldy #4
.9e4b	d0 c4		bne $9e11			bne ELitYA
=6					CodeLen	.var *-XtPtr1
=$9e4d					Here1 = *	; remember here
>9e45	06					.byte CodeLen	;patch wh_CodeLength
>9e4d	45 32 2e 65			Name0:	.text "E2.e"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=40401					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9e51	a4					.byte (("E2.e"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=14					LinkDisplacement = Nt0-WordListLink
>9e52	10					.byte WordFlags	;wh_Flags
>9e53	03					.byte 3	;wh_CodeLength
>9e54	0e					  .byte LinkDisplacement	; offset to previous nt
=$9e55					XtPtr1 ::= *
=40401					WordListLink ::= Nt0 ; remember the nt of this word for later
.9e55	a9 40		lda #$40	E2:		lda #$40
.9e57	a0 02		ldy #$02			ldy #2
.9e59	d0 b6		bne $9e11			bne ELitYA
=6					CodeLen	.var *-XtPtr1
=$9e5b					Here1 = *	; remember here
>9e53	06					.byte CodeLen	;patch wh_CodeLength
>9e5b	45 31 2e 65			Name0:	.text "E1.e"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=40415					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9e5f	a4					.byte (("E1.e"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=14					LinkDisplacement = Nt0-WordListLink
>9e60	10					.byte WordFlags	;wh_Flags
>9e61	03					.byte 3	;wh_CodeLength
>9e62	0e					  .byte LinkDisplacement	; offset to previous nt
=$9e63					XtPtr1 ::= *
=40415					WordListLink ::= Nt0 ; remember the nt of this word for later
.9e63	a9 40		lda #$40	E1:		lda #$40
.9e65	a0 01		ldy #$01			ldy #1
.9e67	d0 a8		bne $9e11			bne ELitYA
=6					CodeLen	.var *-XtPtr1
=$9e69					Here1 = *	; remember here
>9e61	06					.byte CodeLen	;patch wh_CodeLength
>9e69	45 2e 31 65			Name0:	.text "E.1e"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=40429					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9e6d	a4					.byte (("E.1e"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=14					LinkDisplacement = Nt0-WordListLink
>9e6e	10					.byte WordFlags	;wh_Flags
>9e6f	03					.byte 3	;wh_CodeLength
>9e70	0e					  .byte LinkDisplacement	; offset to previous nt
=$9e71					XtPtr1 ::= *
=40429					WordListLink ::= Nt0 ; remember the nt of this word for later
.9e71	20 06 9e	jsr $9e06	E10th:		jsr eConstantRun
>9e74	67 66						.word $6667		; 16 bit signed binary mantissa.  $4000 = +0.5
>9e76	fd						.char -3		; 8 bit signed exponent.  $00 = 2**0
=6					CodeLen	.var *-XtPtr1
=$9e77					Here1 = *	; remember here
>9e6f	06					.byte CodeLen	;patch wh_CodeLength
>9e77	45 50 69			Name0:	.text "EPi"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=40442					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9e7a	23					.byte (("EPi"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>9e7b	10					.byte WordFlags	;wh_Flags
>9e7c	03					.byte 3	;wh_CodeLength
>9e7d	0d					  .byte LinkDisplacement	; offset to previous nt
=$9e7e					XtPtr1 ::= *
=40442					WordListLink ::= Nt0 ; remember the nt of this word for later
.9e7e	20 06 9e	jsr $9e06	EPi:		jsr EConstantRun
>9e81	88 64						.word $6488		; 16 bit signed binary mantissa.  $4000 = +0.5
>9e83	02						.char 2		; 8 bit signed exponent.  $00 = 2**0
=6					CodeLen	.var *-XtPtr1
=$9e84					Here1 = *	; remember here
>9e7c	06					.byte CodeLen	;patch wh_CodeLength
>9e84	45 50 69 2f 32			Name0:	.text "EPi/2"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=40457					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9e89	45					.byte (("EPi/2"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=15					LinkDisplacement = Nt0-WordListLink
>9e8a	10					.byte WordFlags	;wh_Flags
>9e8b	03					.byte 3	;wh_CodeLength
>9e8c	0f					  .byte LinkDisplacement	; offset to previous nt
=$9e8d					XtPtr1 ::= *
=40457					WordListLink ::= Nt0 ; remember the nt of this word for later
.9e8d	20 06 9e	jsr $9e06	EPiH:		jsr EConstantRun
>9e90	88 64						.word $6488		; 16 bit signed binary mantissa.  $4000 = +0.5
>9e92	01						.char 1		; 8 bit signed exponent.  $00 = 2**0
=6					CodeLen	.var *-XtPtr1
=$9e93					Here1 = *	; remember here
>9e8b	06					.byte CodeLen	;patch wh_CodeLength
>9e93	45 50 69 2f 34			Name0:	.text "EPi/4"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=40472					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9e98	85					.byte (("EPi/4"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=15					LinkDisplacement = Nt0-WordListLink
>9e99	10					.byte WordFlags	;wh_Flags
>9e9a	03					.byte 3	;wh_CodeLength
>9e9b	0f					  .byte LinkDisplacement	; offset to previous nt
=$9e9c					XtPtr1 ::= *
=40472					WordListLink ::= Nt0 ; remember the nt of this word for later
.9e9c	20 06 9e	jsr $9e06	EPiQ:		jsr EConstantRun
>9e9f	88 64						.word $6488		; 16 bit signed binary mantissa.  $4000 = +0.5
>9ea1	00						.char 0		; 8 bit signed exponent.  $00 = 2**0
=6					CodeLen	.var *-XtPtr1
=$9ea2					Here1 = *	; remember here
>9e9a	06					.byte CodeLen	;patch wh_CodeLength
>9ea2	45 32 50 69			Name0:	.text "E2Pi"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=40486					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9ea6	24					.byte (("E2Pi"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=14					LinkDisplacement = Nt0-WordListLink
>9ea7	10					.byte WordFlags	;wh_Flags
>9ea8	03					.byte 3	;wh_CodeLength
>9ea9	0e					  .byte LinkDisplacement	; offset to previous nt
=$9eaa					XtPtr1 ::= *
=40486					WordListLink ::= Nt0 ; remember the nt of this word for later
.9eaa	20 06 9e	jsr $9e06	E2Pi:		jsr EConstantRun
>9ead	88 64						.word $6488		; 16 bit signed binary mantissa.  $4000 = +0.5
>9eaf	03						.char 3		; 8 bit signed exponent.  $00 = 2**0
=6					CodeLen	.var *-XtPtr1
=$9eb0					Here1 = *	; remember here
>9ea8	06					.byte CodeLen	;patch wh_CodeLength
>9eb0	45 2e 45			Name0:	.text "E.E"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=40499					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9eb3	a3					.byte (("E.E"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>9eb4	10					.byte WordFlags	;wh_Flags
>9eb5	03					.byte 3	;wh_CodeLength
>9eb6	0d					  .byte LinkDisplacement	; offset to previous nt
=$9eb7					XtPtr1 ::= *
=40499					WordListLink ::= Nt0 ; remember the nt of this word for later
.9eb7	20 06 9e	jsr $9e06	EE:		jsr EConstantRun
>9eba	fc 56						.word $56fc		; 16 bit signed binary mantissa.  $4000 = +0.5
>9ebc	02						.char 2		; 8 bit signed exponent.  $00 = 2**0
=6					CodeLen	.var *-XtPtr1
=$9ebd					Here1 = *	; remember here
>9eb5	06					.byte CodeLen	;patch wh_CodeLength
>9ebd	45 56 61 6c 75 65		Name0:	.text "EValue"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=40515					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9ec3	a6					.byte (("EValue"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=24					WordFlags ::= IM+NN	; modifiable copy, remember for later
=16					LinkDisplacement = Nt0-WordListLink
>9ec4	18					.byte WordFlags	;wh_Flags
>9ec5	03					.byte 3	;wh_CodeLength
>9ec6	10					  .byte LinkDisplacement	; offset to previous nt
=$9ec7					XtPtr1 ::= *
=40515					WordListLink ::= Nt0 ; remember the nt of this word for later
.9ec7	20 20 d1	jsr $d120	EValue:		jsr Header_Comma	; compile word header
.9eca	a9 d7		lda #$d7			lda #<EValue_runtime	; compile JSR EValue_runtime
.9ecc	a0 9e		ldy #$9e			ldy #>EValue_runtime
.9ece	20 78 dd	jsr $dd78			jsr Jsr_Comma_YA
.9ed1	20 e0 cb	jsr $cbe0			jsr adjust_z		; fix word length
.9ed4	4c 31 9c	jmp $9c31			jmp EComma		; alloc & init value
=16					CodeLen	.var *-XtPtr1
=$9ed7					Here1 = *	; remember here
>9ec5	10					.byte CodeLen	;patch wh_CodeLength
.9ed7					EValue_runtime:
.9ed7	4c 06 9e	jmp $9e06			jmp EConstantRun
>9eda	45 53 63 61 6c 65		Name0:	.text "EScale"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=40544					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9ee0	a6					.byte (("EScale"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=29					LinkDisplacement = Nt0-WordListLink
>9ee1	10					.byte WordFlags	;wh_Flags
>9ee2	03					.byte 3	;wh_CodeLength
>9ee3	1d					  .byte LinkDisplacement	; offset to previous nt
=$9ee4					XtPtr1 ::= *
=40544					WordListLink ::= Nt0 ; remember the nt of this word for later
.9ee4	20 c8 c3	jsr $c3c8	EScale:		jsr PopA		; pop n
.9ee7	86 14		stx $14		EScaleA:	stx tmp1		; save data stack index
.9ee9	a6 54		ldx $54				ldx FIndex		; X= FP stack index
.9eeb	b4 5f		ldy $5f,x			ldy FSMant0,x		; mantissa zero?
.9eed	f0 07		beq $9ef6			beq _8
.9eef	18		clc				clc
.9ef0	75 55		adc $55,x			adc FSExp,x
.9ef2	95 55		sta $55,x			sta FSExp,x
.9ef4	70 03		bvs $9ef9			bvs _overflow		; overflow or underflow?
.9ef6	a6 14		ldx $14		_8:		ldx tmp1		; restore data stack index
.9ef8	60		rts				rts
.9ef9					_overflow:
.9ef9	a6 14		ldx $14				ldx tmp1		; restore data stack index
.9efb	20 43 c4	jsr $c443			jsr Throw_FpOutOfRange
=26					CodeLen	.var *-XtPtr1
=$9efe					Here1 = *	; remember here
>9ee2	1a					.byte CodeLen	;patch wh_CodeLength
>9efe	45 32 2a			Name0:	.text "E2*"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=40577					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9f01	43					.byte (("E2*"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=33					LinkDisplacement = Nt0-WordListLink
>9f02	10					.byte WordFlags	;wh_Flags
>9f03	03					.byte 3	;wh_CodeLength
>9f04	21					  .byte LinkDisplacement	; offset to previous nt
=$9f05					XtPtr1 ::= *
=40577					WordListLink ::= Nt0 ; remember the nt of this word for later
.9f05	a9 01		lda #$01	E2Star:		lda #1
.9f07	d0 de		bne $9ee7			bne EScaleA
=4					CodeLen	.var *-XtPtr1
=$9f09					Here1 = *	; remember here
>9f03	04					.byte CodeLen	;patch wh_CodeLength
>9f09	45 32 2f			Name0:	.text "E2/"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=40588					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9f0c	e3					.byte (("E2/"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=11					LinkDisplacement = Nt0-WordListLink
>9f0d	10					.byte WordFlags	;wh_Flags
>9f0e	03					.byte 3	;wh_CodeLength
>9f0f	0b					  .byte LinkDisplacement	; offset to previous nt
=$9f10					XtPtr1 ::= *
=40588					WordListLink ::= Nt0 ; remember the nt of this word for later
.9f10	a9 ff		lda #$ff	E2Slash:	lda #$ff
.9f12	d0 d3		bne $9ee7			bne EScaleA
=4					CodeLen	.var *-XtPtr1
=$9f14					Here1 = *	; remember here
>9f0e	04					.byte CodeLen	;patch wh_CodeLength
>9f14	45 31 30 2a			Name0:	.text "E10*"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=40600					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9f18	44					.byte (("E10*"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=12					LinkDisplacement = Nt0-WordListLink
>9f19	10					.byte WordFlags	;wh_Flags
>9f1a	03					.byte 3	;wh_CodeLength
>9f1b	0c					  .byte LinkDisplacement	; offset to previous nt
=$9f1c					XtPtr1 ::= *
=40600					WordListLink ::= Nt0 ; remember the nt of this word for later
.9f1c	20 05 9f	jsr $9f05	E10Star:	jsr E2Star
.9f1f	20 13 9b	jsr $9b13			jsr EDup
.9f22	a9 02		lda #$02			lda #2
.9f24	20 e7 9e	jsr $9ee7			jsr EScaleA
.9f27	4c 6c a0	jmp $a06c			jmp EPlus
=14					CodeLen	.var *-XtPtr1
=$9f2a					Here1 = *	; remember here
>9f1a	0e					.byte CodeLen	;patch wh_CodeLength
>9f2a	45 46 6c 6f 6f 72		Name0:	.text "EFloor"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=40624					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9f30	46					.byte (("EFloor"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=24					LinkDisplacement = Nt0-WordListLink
>9f31	10					.byte WordFlags	;wh_Flags
>9f32	03					.byte 3	;wh_CodeLength
>9f33	18					  .byte LinkDisplacement	; offset to previous nt
=$9f34					XtPtr1 ::= *
=40624					WordListLink ::= Nt0 ; remember the nt of this word for later
.9f34	a4 54		ldy $54		EFloor:		ldy FIndex
.9f36	b9 5f 00	lda $005f,y			lda FSMant0,y		; negative?
.9f39	10 13		bpl $9f4e			bpl _a
.9f3b	b9 55 00	lda $0055,y			lda FSExp,y		; > -1 ?
.9f3e	10 0e		bpl $9f4e			bpl _a
.9f40	a9 80		lda #$80			lda #$80		; return -1
.9f42	99 5f 00	sta $005f,y			sta FSMant0,y
.9f45	a9 00		lda #$00			lda #0
.9f47	99 55 00	sta $0055,y			sta FSExp,y
.9f4a	99 69 00	sta $0069,y			sta FSMant1,y
.9f4d	60		rts				rts
.9f4e	a9 0f		lda #$0f	_a:		lda #16-1
.9f50	20 56 9f	jsr $9f56			jsr EShiftA
.9f53	4c 16 a0	jmp $a016			jmp ENormX
=34					CodeLen	.var *-XtPtr1
=$9f56					Here1 = *	; remember here
>9f32	22					.byte CodeLen	;patch wh_CodeLength
.9f56	86 14		stx $14		EShiftA:	stx tmp1+0		; save data stack index
.9f58	a6 54		ldx $54				ldx FIndex		; X= FP stack index
.9f5a	85 15		sta $15		EShiftAX:	sta tmp1+1		; save desired alignment
.9f5c	38		sec				sec			; calc bit shift count
.9f5d	f5 55		sbc $55,x			sbc FSExp,x
.9f5f	f0 2a		beq $9f8b			beq _leave
.9f61	70 1c		bvs $9f7f			bvs _overflow
.9f63	30 26		bmi $9f8b			bmi _leave
.9f65	c9 10		cmp #$10			cmp #16
.9f67	b0 18		bcs $9f81			bcs _zero
.9f69	a8		tay				tay
.9f6a	a5 15		lda $15				lda tmp1+1
.9f6c	95 55		sta $55,x			sta FSExp,x
.9f6e	b5 5f		lda $5f,x			lda FSMant0,x
.9f70	c9 80		cmp #$80	_12:		cmp #$80		; mantissa >>=1
.9f72	6a		ror a				ror a
.9f73	76 69		ror $69,x			ror FSMant1,x
.9f75	88		dey				dey
.9f76	d0 f8		bne $9f70			bne _12
.9f78	95 5f		sta $5f,x			sta FSMant0,x
.9f7a	b4 55		ldy $55,x	_30:		ldy FSExp,x
.9f7c	a6 54		ldx $54				ldx FIndex		; restore fp stack index (EShiftAX could have had a funny one)
.9f7e	60		rts				rts
.9f7f	10 0a		bpl $9f8b	_overflow:	bpl _leave
.9f81	a5 15		lda $15		_zero:		lda tmp1+1		; return zero
.9f83	95 55		sta $55,x			sta FSExp,x
.9f85	a9 00		lda #$00			lda #0
.9f87	95 5f		sta $5f,x			sta FSMant0,x
.9f89	95 69		sta $69,x			sta FSMant1,x
.9f8b	18		clc		_leave:		clc
.9f8c	90 ec		bcc $9f7a			bcc _30
>9f8e	45 54 72 75 6e 63		Name0:	.text "ETrunc"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=40724					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9f94	66					.byte (("ETrunc"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=100					LinkDisplacement = Nt0-WordListLink
>9f95	10					.byte WordFlags	;wh_Flags
>9f96	03					.byte 3	;wh_CodeLength
>9f97	64					  .byte LinkDisplacement	; offset to previous nt
=$9f98					XtPtr1 ::= *
=40724					WordListLink ::= Nt0 ; remember the nt of this word for later
.9f98	a4 54		ldy $54		ETrunc:		ldy FIndex
.9f9a	b9 5f 00	lda $005f,y			lda FSMant0,y
.9f9d	10 95		bpl $9f34			bpl EFloor
.9f9f	20 c5 a0	jsr $a0c5			jsr ENegate
.9fa2	20 34 9f	jsr $9f34			jsr EFloor
.9fa5	4c c5 a0	jmp $a0c5			jmp ENegate
>9fa8	45 52 6f 75 6e 64		Name0:	.text "ERound"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=40750					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9fae	86					.byte (("ERound"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=26					LinkDisplacement = Nt0-WordListLink
>9faf	10					.byte WordFlags	;wh_Flags
>9fb0	03					.byte 3	;wh_CodeLength
>9fb1	1a					  .byte LinkDisplacement	; offset to previous nt
=$9fb2					XtPtr1 ::= *
=40750					WordListLink ::= Nt0 ; remember the nt of this word for later
.9fb2	a9 0f		lda #$0f	ERound:		lda #15
.9fb4	20 56 9f	jsr $9f56			jsr EShiftA
.9fb7	90 05		bcc $9fbe			bcc _15
.9fb9	a6 14		ldx $14				ldx tmp1+0		; restore data stack index
.9fbb	4c 90 a0	jmp $a090			jmp E1Plus
.9fbe	4c 16 a0	jmp $a016	_15:		jmp ENormX
=15					CodeLen	.var *-XtPtr1
=$9fc1					Here1 = *	; remember here
>9fb0	0f					.byte CodeLen	;patch wh_CodeLength
>9fc1	45 49 6e 74 46 72 63		Name0:	.text "EIntFrc"	;  name of word as a string, ending at wh_NameLastChar
=7					NameLength = *-Name0
=40776					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9fc8	67					.byte (("EIntFrc"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=26					LinkDisplacement = Nt0-WordListLink
>9fc9	10					.byte WordFlags	;wh_Flags
>9fca	03					.byte 3	;wh_CodeLength
>9fcb	1a					  .byte LinkDisplacement	; offset to previous nt
=$9fcc					XtPtr1 ::= *
=40776					WordListLink ::= Nt0 ; remember the nt of this word for later
.9fcc	20 13 9b	jsr $9b13	EIntFrc:	jsr EDup	; ( e1 e1 )
.9fcf	20 34 9f	jsr $9f34			jsr EFloor	; ( e1 eint )
.9fd2	20 a5 9b	jsr $9ba5			jsr ETuck	; ( eint e1 eint )
.9fd5	20 9c a0	jsr $a09c			jsr EMinus	; ( eint efrac )
.9fd8	4c 7d 9b	jmp $9b7d			jmp ESwap	; ( efrac eint )
=15					CodeLen	.var *-XtPtr1
=$9fdb					Here1 = *	; remember here
>9fca	0f					.byte CodeLen	;patch wh_CodeLength
>9fdb	45 4d 41 6c 69 67 6e 58		Name0:	.text "EMAlignX"	;  name of word as a string, ending at wh_NameLastChar
=8					NameLength = *-Name0
=40803					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>9fe3	08					.byte (("EMAlignX"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=27					LinkDisplacement = Nt0-WordListLink
>9fe4	10					.byte WordFlags	;wh_Flags
>9fe5	03					.byte 3	;wh_CodeLength
>9fe6	1b					  .byte LinkDisplacement	; offset to previous nt
=$9fe7					XtPtr1 ::= *
=40803					WordListLink ::= Nt0 ; remember the nt of this word for later
.9fe7	86 14		stx $14		EMAlignX:	stx tmp1+0	; save data stack index
.9fe9	a6 54		ldx $54				ldx FIndex	; load FP stack index
.9feb	e0 09		cpx #$09			cpx #FDim-1	; check FP stack for >=2 entries
.9fed	b0 19		bcs $a008			bcs Throw_FPStack_e3
.9fef	b5 55		lda $55,x			lda FSExp+0,x	; compare exponents
.9ff1	38		sec				sec
.9ff2	f5 56		sbc $56,x			sbc FSExp+1,x
.9ff4	30 03		bmi $9ff9			bmi _1		; r1 smaller?
.9ff6	d0 08		bne $a000			bne _2		; r2 smaller?
.9ff8	60		rts				rts
.9ff9					_1:
.9ff9	70 07		bvs $a002			bvs _2b		; was this a big positive #?
.9ffb	b5 56		lda $56,x	_1b:		lda FSExp+1,x	; make r1 like r2
.9ffd	4c 5a 9f	jmp $9f5a			jmp EShiftAX
.a000					_2:
.a000	70 f7		bvs $9ff9			bvs _1		; was this a big negative #?
.a002	b5 55		lda $55,x	_2b:		lda FSExp+0,x	; make r2 like r1
.a004	e8		inx				inx
.a005	4c 5a 9f	jmp $9f5a			jmp EShiftAX
=33					CodeLen	.var *-XtPtr1
=$a008					Here1 = *	; remember here
>9fe5	21					.byte CodeLen	;patch wh_CodeLength
.a008	20 39 c4	jsr $c439	Throw_FPStack_e3: jsr Throw_FPStack
>a00b	45 4e 6f 72 6d			Name0:	.text "ENorm"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=40848					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>a010	a5					.byte (("ENorm"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=45					LinkDisplacement = Nt0-WordListLink
>a011	10					.byte WordFlags	;wh_Flags
>a012	03					.byte 3	;wh_CodeLength
>a013	2d					  .byte LinkDisplacement	; offset to previous nt
=$a014					XtPtr1 ::= *
=40848					WordListLink ::= Nt0 ; remember the nt of this word for later
.a014	86 14		stx $14		ENorm:		stx tmp1+0		; save data stack index
.a016	a6 54		ldx $54		ENormX:		ldx FIndex		; switch to FP stack
.a018	b4 55		ldy $55,x			ldy FSExp,x
.a01a	b5 5f		lda $5f,x			lda FSMant0,x		; mantissa negative?
.a01c	30 1b		bmi $a039			bmi _Neg
.a01e	d0 05		bne $a025			bne _Pos2		; do byte shift
.a020	20 56 a0	jsr $a056			jsr _ShiftB
.a023	f0 29		beq $a04e			beq _zero		; no significant bits left?
.a025	18		clc		_Pos2:		clc
.a026	30 06		bmi $a02e			bmi _RShft
.a028	88		dey		_Pos3:		dey			; do bit shift
.a029	16 69		asl $69,x			asl FSMant1,x
.a02b	2a		rol a				rol a
.a02c	10 fa		bpl $a028			bpl _Pos3
.a02e					_RShft:
.a02e	c8		iny				iny
.a02f	6a		ror a				ror a
.a030	76 69		ror $69,x			ror FSMant1,x
.a032					_28:
.a032	95 5f		sta $5f,x			sta FSMant0,x
.a034	94 55		sty $55,x			sty FSExp,x	; sty dir,x exists
.a036	a6 14		ldx $14				ldx tmp1+0	; restore data stack index
.a038	60		rts				rts
.a039					_Neg:
.a039	c9 ff		cmp #$ff			cmp #$ff
.a03b	d0 03		bne $a040			bne _Neg2	; do byte shift
.a03d	20 56 a0	jsr $a056			jsr _ShiftB
.a040	c9 00		cmp #$00	_Neg2:		cmp #0
.a042	10 ea		bpl $a02e			bpl _RShft
.a044	88		dey		_Neg3:		dey
.a045	16 69		asl $69,x			asl FSMant1,x
.a047	2a		rol a				rol a
.a048	30 fa		bmi $a044			bmi _Neg3
.a04a	10 e2		bpl $a02e			bpl _RShft
.a04c	68		pla		_Zerop:		pla
.a04d	68		pla				pla		; pop rts addr from _ShiftB
.a04e	a9 00		lda #$00	_zero:		lda #0
.a050	95 69		sta $69,x			sta FSMant1,x
.a052	a0 80		ldy #$80			ldy #$80
.a054	d0 dc		bne $a032			bne _28
.a056					_ShiftB:
.a056	98		tya				tya		; exponent -= 8
.a057	38		sec				sec
.a058	e9 08		sbc #$08			sbc #8
.a05a	a8		tay				tay
.a05b	70 ef		bvs $a04c			bvs _zerop	;is this useful? do we need more of them?
.a05d	b5 69		lda $69,x			lda FSMant1,x
.a05f	48		pha				pha
.a060	a9 00		lda #$00			lda #0
.a062	95 69		sta $69,x			sta FSMant1,x
.a064	68		pla				pla
.a065	60		rts				rts
=82					CodeLen	.var *-XtPtr1
=$a066					Here1 = *	; remember here
>a012	52					.byte CodeLen	;patch wh_CodeLength
>a066	45 2b				Name0:	.text "E+"	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=40936					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>a068	62					.byte (("E+"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=88					LinkDisplacement = Nt0-WordListLink
>a069	10					.byte WordFlags	;wh_Flags
>a06a	03					.byte 3	;wh_CodeLength
>a06b	58					  .byte LinkDisplacement	; offset to previous nt
=$a06c					XtPtr1 ::= *
=40936					WordListLink ::= Nt0 ; remember the nt of this word for later
.a06c	20 7b 8a	jsr $8a7b	EPlus:		jsr FMAlignX	; align mantissas, X= FP stack index
.a06f	18		clc				clc		; add mantissas
.a070	b5 6a		lda $6a,x			lda FSMant1+1,x
.a072	75 69		adc $69,x			adc FSMant1+0,x
.a074	95 6a		sta $6a,x			sta FSMant1+1,x
.a076	b5 60		lda $60,x			lda FSMant0+1,x
.a078	75 5f		adc $5f,x			adc FSMant0+0,x
.a07a					EPlusFin:
.a07a	e8		inx				inx		; FDrop r2
.a07b	86 54		stx $54				stx FIndex
.a07d	50 05		bvc $a084	EPlusFin3:	bvc _19		; if overflow
.a07f	6a		ror a				ror a		;   shift mantissa right 1 bit
.a080	76 69		ror $69,x			ror FSMant1,x
.a082	f6 55		inc $55,x			inc FSExp,x	;   adjust exponent
.a084					_19:
.a084	95 5f		sta $5f,x			sta FSMant0,x
.a086	4c 16 a0	jmp $a016			jmp ENormX	; normalize, return
=29					CodeLen	.var *-XtPtr1
=$a089					Here1 = *	; remember here
>a06a	1d					.byte CodeLen	;patch wh_CodeLength
>a089	45 31 2b			Name0:	.text "E1+"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=40972					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>a08c	63					.byte (("E1+"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=36					LinkDisplacement = Nt0-WordListLink
>a08d	10					.byte WordFlags	;wh_Flags
>a08e	03					.byte 3	;wh_CodeLength
>a08f	24					  .byte LinkDisplacement	; offset to previous nt
=$a090					XtPtr1 ::= *
=40972					WordListLink ::= Nt0 ; remember the nt of this word for later
.a090	20 63 9e	jsr $9e63	E1Plus:		jsr E1
.a093	4c 6c a0	jmp $a06c			jmp EPlus
=6					CodeLen	.var *-XtPtr1
=$a096					Here1 = *	; remember here
>a08e	06					.byte CodeLen	;patch wh_CodeLength
>a096	45 2d				Name0:	.text "E-"	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=40984					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>a098	a2					.byte (("E-"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=12					LinkDisplacement = Nt0-WordListLink
>a099	10					.byte WordFlags	;wh_Flags
>a09a	03					.byte 3	;wh_CodeLength
>a09b	0c					  .byte LinkDisplacement	; offset to previous nt
=$a09c					XtPtr1 ::= *
=40984					WordListLink ::= Nt0 ; remember the nt of this word for later
.a09c	20 7b 8a	jsr $8a7b	EMinus:		jsr FMAlignX	; align mantissas
.a09f	38		sec				sec		; subtract mantissas
.a0a0	b5 6a		lda $6a,x			lda FSMant1+1,x
.a0a2	f5 69		sbc $69,x			sbc FSMant1+0,x
.a0a4	95 6a		sta $6a,x			sta FSMant1+1,x
.a0a6	b5 60		lda $60,x			lda FSMant0+1,x
.a0a8	f5 5f		sbc $5f,x			sbc FSMant0+0,x
.a0aa	4c 7a a0	jmp $a07a			jmp EPlusFin	; finish
=17					CodeLen	.var *-XtPtr1
=$a0ad					Here1 = *	; remember here
>a09a	11					.byte CodeLen	;patch wh_CodeLength
>a0ad	45 31 2d			Name0:	.text "E1-"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=41008					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>a0b0	a3					.byte (("E1-"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=24					LinkDisplacement = Nt0-WordListLink
>a0b1	10					.byte WordFlags	;wh_Flags
>a0b2	03					.byte 3	;wh_CodeLength
>a0b3	18					  .byte LinkDisplacement	; offset to previous nt
=$a0b4					XtPtr1 ::= *
=41008					WordListLink ::= Nt0 ; remember the nt of this word for later
.a0b4	20 63 9e	jsr $9e63	E1Minus:	jsr E1
.a0b7	4c 9c a0	jmp $a09c			jmp EMinus
=6					CodeLen	.var *-XtPtr1
=$a0ba					Here1 = *	; remember here
>a0b2	06					.byte CodeLen	;patch wh_CodeLength
>a0ba	45 4e 65 67 61 74 65		Name0:	.text "ENegate"	;  name of word as a string, ending at wh_NameLastChar
=7					NameLength = *-Name0
=41025					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>a0c1	a7					.byte (("ENegate"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=17					LinkDisplacement = Nt0-WordListLink
>a0c2	10					.byte WordFlags	;wh_Flags
>a0c3	03					.byte 3	;wh_CodeLength
>a0c4	11					  .byte LinkDisplacement	; offset to previous nt
=$a0c5					XtPtr1 ::= *
=41025					WordListLink ::= Nt0 ; remember the nt of this word for later
.a0c5	86 14		stx $14		ENegate:	stx tmp1	; save data stack index
.a0c7	a6 54		ldx $54				ldx FIndex	; X= FP stack index
.a0c9	38		sec				sec		; mantissa = 0 - mantissa
.a0ca	a9 00		lda #$00			lda #0
.a0cc	f5 69		sbc $69,x			sbc FSMant1,x
.a0ce	95 69		sta $69,x			sta FSMant1,x
.a0d0	a9 00		lda #$00			lda #0
.a0d2	f5 5f		sbc $5f,x			sbc FSMant0,x
.a0d4	4c 7d a0	jmp $a07d			jmp EPlusFin3	; finish up, return
=18					CodeLen	.var *-XtPtr1
=$a0d7					Here1 = *	; remember here
>a0c3	12					.byte CodeLen	;patch wh_CodeLength
>a0d7	45 41 62 73			Name0:	.text "EAbs"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=41051					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>a0db	64					.byte (("EAbs"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=26					LinkDisplacement = Nt0-WordListLink
>a0dc	10					.byte WordFlags	;wh_Flags
>a0dd	03					.byte 3	;wh_CodeLength
>a0de	1a					  .byte LinkDisplacement	; offset to previous nt
=$a0df					XtPtr1 ::= *
=41051					WordListLink ::= Nt0 ; remember the nt of this word for later
.a0df	a4 54		ldy $54		EAbs:		ldy FIndex
.a0e1	b9 5f 00	lda $005f,y			lda FSMant0,y		; mantissa negative?
.a0e4	30 df		bmi $a0c5			bmi ENegate
.a0e6	60		rts				rts
=8					CodeLen	.var *-XtPtr1
=$a0e7					Here1 = *	; remember here
>a0dd	08					.byte CodeLen	;patch wh_CodeLength
.a0e7	4c 39 c4	jmp $c439	Throw_FPStack_e4: jmp Throw_FPStack
.a0ea	a4 54		ldy $54		EPos:		ldy FIndex		; load FP stack index
.a0ec	c0 09		cpy #$09			cpy #FDim-1		; check FP stack for 2
.a0ee	b0 f7		bcs $a0e7			bcs Throw_FPStack_e4
.a0f0	b9 5f 00	lda $005f,y			lda FSMant0+0,y		; calc result sign
.a0f3	59 60 00	eor $0060,y			eor FSMant0+1,y
.a0f6	08		php				php
.a0f7	b9 60 00	lda $0060,y			lda FSMant0+1,y		; if NOS negative
.a0fa	10 07		bpl $a103			bpl +
.a0fc	e6 54		inc $54				inc FIndex		;   point at NOS
.a0fe	20 c5 a0	jsr $a0c5			jsr ENegate		;   negate NOS
.a101	c6 54		dec $54				dec FIndex		;   restore fp
.a103					+
.a103	20 df a0	jsr $a0df			jsr EAbs		; abs TOS
.a106	86 14		stx $14				stx tmp1+0		; save data stack index
.a108	a6 54		ldx $54				ldx FIndex		; load FP stack index
.a10a	28		plp				plp			; restore sign flag
.a10b	60		rts				rts
>a10c	46 3e 45			Name0:	.text "F>E"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=41103					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>a10f	a3					.byte (("F>E"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=0					WordFlags ::= 0	; modifiable copy, remember for later
=52					LinkDisplacement = Nt0-WordListLink
>a110	00					.byte WordFlags	;wh_Flags
>a111	03					.byte 3	;wh_CodeLength
>a112	34					  .byte LinkDisplacement	; offset to previous nt
=$a113					XtPtr1 ::= *
=41103					WordListLink ::= Nt0 ; remember the nt of this word for later
.a113					FToE:
=0					CodeLen	.var *-XtPtr1
=$a113					Here1 = *	; remember here
>a111	00					.byte CodeLen	;patch wh_CodeLength
.a113	60		rts				rts
>a114	45 3e 46			Name0:	.text "E>F"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=41111					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>a117	c3					.byte (("E>F"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=0					WordFlags ::= 0	; modifiable copy, remember for later
=8					LinkDisplacement = Nt0-WordListLink
>a118	00					.byte WordFlags	;wh_Flags
>a119	03					.byte 3	;wh_CodeLength
>a11a	08					  .byte LinkDisplacement	; offset to previous nt
=$a11b					XtPtr1 ::= *
=41111					WordListLink ::= Nt0 ; remember the nt of this word for later
.a11b	a4 54		ldy $54		EToF:		ldy FIndex
.a11d	a9 00		lda #$00			lda #0			; zero 2nd 16 bits of mantissa
.a11f	99 73 00	sta $0073,y			sta FSMant2,y
.a122	99 7d 00	sta $007d,y			sta FSMant3,y
=10					CodeLen	.var *-XtPtr1
=$a125					Here1 = *	; remember here
>a119	0a					.byte CodeLen	;patch wh_CodeLength
.a125	60		rts				rts
>a126	53 3e 45			Name0:	.text "S>E"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=41129					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>a129	a3					.byte (("S>E"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=18					LinkDisplacement = Nt0-WordListLink
>a12a	10					.byte WordFlags	;wh_Flags
>a12b	03					.byte 3	;wh_CodeLength
>a12c	12					  .byte LinkDisplacement	; offset to previous nt
=$a12d					XtPtr1 ::= *
=41129					WordListLink ::= Nt0 ; remember the nt of this word for later
.a12d	20 e3 c3	jsr $c3e3	SToE:		jsr PopYA		; pop n
.a130	20 c8 84	jsr $84c8	SToEYA:		jsr FAllocX		; alloc FP stack entry
.a133	95 69		sta $69,x			sta FSMant1,x		; copy n to mantissa
.a135	94 5f		sty $5f,x			sty FSMant0,x	; sty dir,x exists
.a137	a9 0f		lda #$0f			lda #15			; set exponent
.a139	95 55		sta $55,x			sta FSExp,x
.a13b	4c 16 a0	jmp $a016			jmp ENormX		; normalize, return
=17					CodeLen	.var *-XtPtr1
=$a13e					Here1 = *	; remember here
>a12b	11					.byte CodeLen	;patch wh_CodeLength
>a13e	45 3e 53			Name0:	.text "E>S"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=41153					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>a141	63					.byte (("E>S"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=24					LinkDisplacement = Nt0-WordListLink
>a142	10					.byte WordFlags	;wh_Flags
>a143	03					.byte 3	;wh_CodeLength
>a144	18					  .byte LinkDisplacement	; offset to previous nt
=$a145					XtPtr1 ::= *
=41153					WordListLink ::= Nt0 ; remember the nt of this word for later
.a145	a4 54		ldy $54		EToS:		ldy FIndex
.a147	b9 5f 00	lda $005f,y			lda FSMant0,y		; save sign
.a14a	08		php				php
.a14b	10 03		bpl $a150			bpl +
.a14d	20 c5 a0	jsr $a0c5			jsr ENegate
.a150					+
.a150	a9 0f		lda #$0f			lda #15
.a152	20 56 9f	jsr $9f56			jsr EShiftA
.a155	a6 14		ldx $14				ldx tmp1+0		; restore data stack index
.a157	c0 10		cpy #$10			cpy #15+1		; always positive, so unsigned compare works
.a159	b0 17		bcs $a172			bcs _overflow
.a15b	a4 54		ldy $54				ldy FIndex
.a15d	ca		dex				dex
.a15e	ca		dex				dex
.a15f	b9 5f 00	lda $005f,y			lda FSMant0,y
.a162	95 25		sta $25,x			sta DStack+1,x
.a164	b9 69 00	lda $0069,y			lda FSMant1,y
.a167	95 24		sta $24,x			sta DStack+0,x
.a169	e6 54		inc $54				inc FIndex		; EDrop
.a16b	28		plp				plp			; apply saved sign
.a16c	30 01		bmi $a16f			bmi +
.a16e	60		rts				rts
.a16f	4c e9 d6	jmp $d6e9	+		jmp Negate
.a172	28		plp		_overflow:	plp			; RDrop saved sign
.a173	a9 f5		lda #$f5			lda #$100+err_OutOfRange
.a175	20 68 c4	jsr $c468			jsr ThrowA
=51					CodeLen	.var *-XtPtr1
=$a178					Here1 = *	; remember here
>a143	33					.byte CodeLen	;patch wh_CodeLength
>a178	45 52 6e 64			Name0:	.text "ERnd"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=41212					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>a17c	84					.byte (("ERnd"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=59					LinkDisplacement = Nt0-WordListLink
>a17d	10					.byte WordFlags	;wh_Flags
>a17e	03					.byte 3	;wh_CodeLength
>a17f	3b					  .byte LinkDisplacement	; offset to previous nt
=$a180					XtPtr1 ::= *
=41212					WordListLink ::= Nt0 ; remember the nt of this word for later
.a180	20 f7 82	jsr $82f7	ERnd:		jsr Rand		; generate next RndState
.a183	20 c8 84	jsr $84c8			jsr FAllocX		; alloc FP stack entry
.a186	4a		lsr a				lsr a			;   make positive
.a187	95 5f		sta $5f,x			sta FSMant0,x
.a189	94 69		sty $69,x			sty FSMant1,x	; sty dir,x exists
.a18b	a9 00		lda #$00			lda #0			; exponent=0
.a18d	95 55		sta $55,x			sta FSExp,x
.a18f	4c 16 a0	jmp $a016			jmp ENormX		; normalize, return
=18					CodeLen	.var *-XtPtr1
=$a192					Here1 = *	; remember here
>a17e	12					.byte CodeLen	;patch wh_CodeLength
>a192	45 53 71 72 74			Name0:	.text "ESqrt"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=41239					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>a197	85					.byte (("ESqrt"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=27					LinkDisplacement = Nt0-WordListLink
>a198	10					.byte WordFlags	;wh_Flags
>a199	03					.byte 3	;wh_CodeLength
>a19a	1b					  .byte LinkDisplacement	; offset to previous nt
=$a19b					XtPtr1 ::= *
=41239					WordListLink ::= Nt0 ; remember the nt of this word for later
.a19b	a4 54		ldy $54		ESqrt:		ldy FIndex
.a19d	b9 5f 00	lda $005f,y			lda FSMant0,y		; zero?
.a1a0	d0 01		bne $a1a3			bne +
.a1a2	60		rts				rts			;   just return the zero
.a1a3					+
.a1a3	20 13 9b	jsr $9b13			jsr EDup		; get trial value
.a1a6	a4 54		ldy $54				ldy FIndex
.a1a8	b9 55 00	lda $0055,y			lda FSExp,y		; halve the exponent of trial value
.a1ab	c9 80		cmp #$80			cmp #$80
.a1ad	6a		ror a				ror a
.a1ae	99 55 00	sta $0055,y			sta FSExp,y
.a1b1	a9 09		lda #$09			lda #9			; for 9 iterations
.a1b3	48		pha		_3:		pha
.a1b4	20 6e 9b	jsr $9b6e			jsr E2Dup		;   calc new trial value
.a1b7	20 c9 8d	jsr $8dc9			jsr ESlash
.a1ba	20 6c a0	jsr $a06c			jsr EPlus
.a1bd	20 10 9f	jsr $9f10			jsr E2Slash
.a1c0	68		pla				pla			;  next
.a1c1	38		sec				sec
.a1c2	e9 01		sbc #$01			sbc #1
.a1c4	d0 ed		bne $a1b3			bne _3
.a1c6	4c f6 9a	jmp $9af6			jmp ENip		; return trial value
=46					CodeLen	.var *-XtPtr1
=$a1c9					Here1 = *	; remember here
>a199	2e					.byte CodeLen	;patch wh_CodeLength
>a1c9	28 45 2e 29			Name0:	.text "(E.)"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=41293					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>a1cd	24					.byte (("(E.)"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=54					LinkDisplacement = Nt0-WordListLink
>a1ce	10					.byte WordFlags	;wh_Flags
>a1cf	03					.byte 3	;wh_CodeLength
>a1d0	36					  .byte LinkDisplacement	; offset to previous nt
=$a1d1					XtPtr1 ::= *
=41293					WordListLink ::= Nt0 ; remember the nt of this word for later
.a1d1	20 4e a2	jsr $a24e	PEDot:		jsr pecstart		;start collecting chars, make r positive
.a1d4	20 da a1	jsr $a1da			jsr PEDotSub
.a1d7	4c 21 90	jmp $9021			jmp pfcend
.a1da					PEDotSub:
.a1da	20 5f 8f	jsr $8f5f			jsr Precision	;alloc & init work area
.a1dd	20 00 c8	jsr $c800			jsr One
=$27					_mantNzFound  = DStack+3	; nonzero mantissa digit processed
=$26					_NumSigDigits = DStack+2	; # of significant digits
=$24					_decimalPos   = DStack+0	; decimal point position
.a1e0	20 2e a2	jsr $a22e			jsr ELt10		; scale down to <10, counting exponent
.a1e3					_c:
.a1e3	b5 24		lda $24,x			lda _decimalPos,x	;  insert decimal point here?
.a1e5	d0 05		bne $a1ec			bne _c2
.a1e7	a9 2e		lda #$2e			lda #'.'
.a1e9	20 18 90	jsr $9018			jsr pfchar
.a1ec	d6 24		dec $24,x	_c2:		dec _decimalPos,x
.a1ee	20 13 9b	jsr $9b13			jsr EDup		;  do a digit
.a1f1	20 45 a1	jsr $a145			jsr EToS		; ( work n )
.a1f4	b5 24		lda $24,x			lda DStack+0,x
.a1f6	15 29		ora $29,x			ora _mantNzFound+2,x	;  doing significant digits?
.a1f8	95 29		sta $29,x			sta _mantNzFound+2,x
.a1fa	f0 08		beq $a204			beq _c7
.a1fc	d6 28		dec $28,x			dec _NumSigDigits+2,x
.a1fe	10 04		bpl $a204			bpl _c7
.a200	e8		inx				inx			;    drop integer
.a201	e8		inx				inx
.a202	d0 17		bne $a21b			bne _d
.a204	b5 24		lda $24,x	_c7:		lda DStack+0,x		;  store the char
.a206	09 30		ora #$30			ora #'0'
.a208	20 18 90	jsr $9018			jsr pfchar
.a20b	20 2d a1	jsr $a12d			jsr SToE		; ( work )
.a20e	20 9c a0	jsr $a09c			jsr EMinus
.a211	20 1c 9f	jsr $9f1c			jsr E10Star
.a214	a4 54		ldy $54				ldy FIndex		;  until mantissa==0
.a216	b9 5f 00	lda $005f,y			lda FSMant0,y
.a219	d0 c8		bne $a1e3			bne _c
.a21b	d6 24		dec $24,x	_d:		dec _decimalPos,x	;do trailing zeros
.a21d	30 08		bmi $a227			bmi _d9
.a21f	a9 30		lda #$30			lda #'0'
.a221	20 18 90	jsr $9018			jsr pfchar
.a224	4c 1b a2	jmp $a21b			jmp _d
.a227	e8		inx		_d9:		inx			; drop work area
.a228	e8		inx				inx
.a229	e8		inx				inx
.a22a	e8		inx				inx
.a22b	e6 54		inc $54				inc FIndex		; FDrop
.a22d	60		rts				rts
=93					CodeLen	.var *-XtPtr1
=$a22e					Here1 = *	; remember here
>a1cf	5d					.byte CodeLen	;patch wh_CodeLength
.a22e					ELt10:
.a22e	a4 54		ldy $54		_1:		ldy FIndex		; while e1 >= 10
.a230	b9 55 00	lda $0055,y			lda FSExp,y
.a233	30 18		bmi $a24d			bmi _9			;   exponent negative?
.a235	c9 04		cmp #$04			cmp #4
.a237	90 14		bcc $a24d			bcc _9			;   < 4 ?
.a239	d0 07		bne $a242			bne _2			;   > 4 ?
.a23b	b9 5f 00	lda $005f,y			lda FSMant0,y		;   mantissa >= 10 ?
.a23e	c9 50		cmp #$50			cmp #$50
.a240	90 0b		bcc $a24d			bcc _9
.a242	f6 24		inc $24,x	_2:		inc DStack+0,x		;   exp ++
.a244	20 47 9e	jsr $9e47			jsr E10			;   e /= 10
.a247	20 c9 8d	jsr $8dc9			jsr ESlash
.a24a	4c 2e a2	jmp $a22e			jmp _1
.a24d	60		rts		_9:		rts
.a24e					pecstart:
.a24e	a9 01		lda #$01			lda #1
.a250	8d 34 03	sta $0334			sta ToHold
.a253	a4 54		ldy $54				ldy FIndex		; if e1 negative
.a255	b9 5f 00	lda $005f,y			lda FSMant0,y
.a258	10 08		bpl $a262			bpl _19
.a25a	a9 2d		lda #$2d			lda #'-'		;   append sign
.a25c	20 18 90	jsr $9018			jsr pfchar
.a25f	4c c5 a0	jmp $a0c5			jmp ENegate		;   make positive, return
.a262	60		rts		_19:		rts
>a263	45 2e				Name0:	.text "E."	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=41445					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>a265	c2					.byte (("E."[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=152					LinkDisplacement = Nt0-WordListLink
>a266	10					.byte WordFlags	;wh_Flags
>a267	03					.byte 3	;wh_CodeLength
>a268	98					  .byte LinkDisplacement	; offset to previous nt
=$a269					XtPtr1 ::= *
=41445					WordListLink ::= Nt0 ; remember the nt of this word for later
.a269	20 d1 a1	jsr $a1d1	EDot:		jsr PEDot
.a26c	20 dc c1	jsr $c1dc	EDot2:		jsr Count
.a26f	20 39 de	jsr $de39			jsr Type
.a272	4c 2d de	jmp $de2d			jmp Space
=12					CodeLen	.var *-XtPtr1
=$a275					Here1 = *	; remember here
>a267	0c					.byte CodeLen	;patch wh_CodeLength
>a275	45 2e 53			Name0:	.text "E.S"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=41464					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>a278	63					.byte (("E.S"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=19					LinkDisplacement = Nt0-WordListLink
>a279	10					.byte WordFlags	;wh_Flags
>a27a	03					.byte 3	;wh_CodeLength
>a27b	13					  .byte LinkDisplacement	; offset to previous nt
=$a27c					XtPtr1 ::= *
=41464					WordListLink ::= Nt0 ; remember the nt of this word for later
.a27c	a9 09		lda #$09	EDotS:		lda #FDim-1	; for each FP stack entry
.a27e	d0 0b		bne $a28b			bne _8
.a280	48		pha		_2:		pha
.a281	20 4f 9b	jsr $9b4f			jsr EPick3	;   print it
.a284	20 69 a2	jsr $a269			jsr EDot
.a287	68		pla				pla		;  next
.a288	38		sec				sec
.a289	e9 01		sbc #$01			sbc #1
.a28b	c5 54		cmp $54		_8:		cmp FIndex
.a28d	b0 f1		bcs $a280			bcs _2
=19					CodeLen	.var *-XtPtr1
=$a28f					Here1 = *	; remember here
>a27a	13					.byte CodeLen	;patch wh_CodeLength
.a28f	60		rts				rts
>a290	28 45 53 2e 29			Name0:	.text "(ES.)"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=41493					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>a295	25					.byte (("(ES.)"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=29					LinkDisplacement = Nt0-WordListLink
>a296	10					.byte WordFlags	;wh_Flags
>a297	03					.byte 3	;wh_CodeLength
>a298	1d					  .byte LinkDisplacement	; offset to previous nt
=$a299					XtPtr1 ::= *
=41493					WordListLink ::= Nt0 ; remember the nt of this word for later
.a299	20 f7 c7	jsr $c7f7	PESDot:		jsr Zero		; alloc work area
=$24					_exp    = DStack+0
.a29c	20 4e a2	jsr $a24e			jsr pecstart		; start collecting chars, make r positive
.a29f	20 2e a2	jsr $a22e			jsr ELt10		; scale down to <10
.a2a2	a4 54		ldy $54		_c1:		ldy FIndex		; while r < 1
.a2a4	b9 5f 00	lda $005f,y			lda FSMant0,y		;   mantissa == 0 ?
.a2a7	f0 0f		beq $a2b8			beq _c9
.a2a9	b9 55 00	lda $0055,y			lda FSExp,y		;   exp < 1 ?
.a2ac	f0 02		beq $a2b0			beq _c2
.a2ae	10 08		bpl $a2b8			bpl _c9
.a2b0	d6 24		dec $24,x	_c2:		dec DStack+0,x		;  exp -= 1
.a2b2	20 1c 9f	jsr $9f1c			jsr E10Star		;  r *= 10
.a2b5	4c a2 a2	jmp $a2a2			jmp _c1
.a2b8					_c9:
.a2b8	20 da a1	jsr $a1da	PESDotM:	jsr PEDotSub		; do mantissa
.a2bb	a9 45		lda #$45			lda #'E'
.a2bd	20 18 90	jsr $9018			jsr pfchar		; do exponent
.a2c0	b5 24		lda $24,x			lda DStack+0,x		;   _exp
.a2c2	20 2e 90	jsr $902e			jsr pfciA
.a2c5	e8		inx				inx			; Drop work area
.a2c6	e8		inx				inx
.a2c7	4c 21 90	jmp $9021			jmp pfcend		; finish string
=49					CodeLen	.var *-XtPtr1
=$a2ca					Here1 = *	; remember here
>a297	31					.byte CodeLen	;patch wh_CodeLength
>a2ca	45 53 2e			Name0:	.text "ES."	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=41549					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>a2cd	c3					.byte (("ES."[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=56					LinkDisplacement = Nt0-WordListLink
>a2ce	10					.byte WordFlags	;wh_Flags
>a2cf	03					.byte 3	;wh_CodeLength
>a2d0	38					  .byte LinkDisplacement	; offset to previous nt
=$a2d1					XtPtr1 ::= *
=41549					WordListLink ::= Nt0 ; remember the nt of this word for later
.a2d1	20 99 a2	jsr $a299	ESDot:		jsr PESDot
.a2d4	4c 6c a2	jmp $a26c			jmp EDot2
=6					CodeLen	.var *-XtPtr1
=$a2d7					Here1 = *	; remember here
>a2cf	06					.byte CodeLen	;patch wh_CodeLength
>a2d7	28 45 45 2e 29			Name0:	.text "(EE.)"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=41564					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>a2dc	25					.byte (("(EE.)"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=15					LinkDisplacement = Nt0-WordListLink
>a2dd	10					.byte WordFlags	;wh_Flags
>a2de	03					.byte 3	;wh_CodeLength
>a2df	0f					  .byte LinkDisplacement	; offset to previous nt
=$a2e0					XtPtr1 ::= *
=41564					WordListLink ::= Nt0 ; remember the nt of this word for later
.a2e0	20 f7 c7	jsr $c7f7	PEEDot:		jsr Zero		; alloc work area
=$24					_exp    = DStack+0
.a2e3	20 4e a2	jsr $a24e			jsr pecstart		; start collecting chars, make r positive
.a2e6	a4 54		ldy $54		_30:		ldy FIndex		; while r < 1
.a2e8	b9 5f 00	lda $005f,y			lda FSMant0,y
.a2eb	f0 16		beq $a303			beq _39
.a2ed	b9 55 00	lda $0055,y			lda FSExp,y
.a2f0	f0 02		beq $a2f4			beq _31
.a2f2	10 0f		bpl $a303			bpl _39
.a2f4	d6 24		dec $24,x	_31:		dec _exp,x		;  exp -= 3
.a2f6	d6 24		dec $24,x			dec _exp,x
.a2f8	d6 24		dec $24,x			dec _exp,x
.a2fa	20 38 9e	jsr $9e38			jsr E1000		;  r *= 1000
.a2fd	20 4d 8d	jsr $8d4d			jsr EStar
.a300	4c e6 a2	jmp $a2e6			jmp _30
.a303					_39:
.a303	a4 54		ldy $54		_a:		ldy FIndex		; while r >= 1000
.a305	b9 55 00	lda $0055,y			lda FSExp,y
.a308	30 1c		bmi $a326			bmi _a9			; exponent negative?
.a30a	c9 0a		cmp #$0a			cmp #10
.a30c	90 18		bcc $a326			bcc _a9			;   < 10 ?
.a30e	d0 07		bne $a317			bne _a2			;   > 10 ?
.a310	b9 5f 00	lda $005f,y			lda FSMant0,y
.a313	c9 7d		cmp #$7d			cmp #$7d
.a315	90 0f		bcc $a326			bcc _a9
.a317	f6 24		inc $24,x	_a2:		inc _exp,x		;   exp += 3
.a319	f6 24		inc $24,x			inc _exp,x
.a31b	f6 24		inc $24,x			inc _exp,x
.a31d	20 38 9e	jsr $9e38			jsr E1000		;   r /= 1000
.a320	20 c9 8d	jsr $8dc9			jsr ESlash
.a323	4c 03 a3	jmp $a303			jmp _a
.a326					_a9:
.a326	4c b8 a2	jmp $a2b8			jmp PESDotM
=73					CodeLen	.var *-XtPtr1
=$a329					Here1 = *	; remember here
>a2de	49					.byte CodeLen	;patch wh_CodeLength
>a329	45 45 2e			Name0:	.text "EE."	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=41644					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>a32c	c3					.byte (("EE."[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=80					LinkDisplacement = Nt0-WordListLink
>a32d	10					.byte WordFlags	;wh_Flags
>a32e	03					.byte 3	;wh_CodeLength
>a32f	50					  .byte LinkDisplacement	; offset to previous nt
=$a330					XtPtr1 ::= *
=41644					WordListLink ::= Nt0 ; remember the nt of this word for later
.a330	20 e0 a2	jsr $a2e0	EEDot:		jsr PEEDot
.a333	4c 6c a2	jmp $a26c			jmp EDot2
=6					CodeLen	.var *-XtPtr1
=$a336					Here1 = *	; remember here
>a32e	06					.byte CodeLen	;patch wh_CodeLength
>a336	45 27				Name0:	.text "E'"	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=41656					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>a338	e2					.byte (("E'"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=24					WordFlags ::= IM+NN	; modifiable copy, remember for later
=12					LinkDisplacement = Nt0-WordListLink
>a339	18					.byte WordFlags	;wh_Flags
>a33a	03					.byte 3	;wh_CodeLength
>a33b	0c					  .byte LinkDisplacement	; offset to previous nt
=$a33c					XtPtr1 ::= *
=41656					WordListLink ::= Nt0 ; remember the nt of this word for later
.a33c	20 87 ca	jsr $ca87	EQuote:		jsr Parse_Name		; get string
.a33f	20 60 a3	jsr $a360			jsr ToEFloat		; convert
.a342	b5 24		lda $24,x			lda DStack+0,x		; error?
.a344	f0 0a		beq $a350			beq _Err
.a346	e8		inx				inx
.a347	e8		inx				inx
.a348	a5 0a		lda $0a				lda State		; compiling?
.a34a	d0 01		bne $a34d			bne _compile
.a34c	60		rts				rts
.a34d	4c 8f 9d	jmp $9d8f	_compile:	jmp ELiteral		; compile a FP literal
.a350	a9 36		lda #$36	_Err:		lda #100+err_FPInvalidArg
.a352	20 68 c4	jsr $c468			jsr ThrowA
=25					CodeLen	.var *-XtPtr1
=$a355					Here1 = *	; remember here
>a33a	19					.byte CodeLen	;patch wh_CodeLength
>a355	3e 45 46 6c 6f 61 74		Name0:	.text ">EFloat"	;  name of word as a string, ending at wh_NameLastChar
=7					NameLength = *-Name0
=41692					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>a35c	87					.byte ((">EFloat"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=36					LinkDisplacement = Nt0-WordListLink
>a35d	10					.byte WordFlags	;wh_Flags
>a35e	03					.byte 3	;wh_CodeLength
>a35f	24					  .byte LinkDisplacement	; offset to previous nt
=$a360					XtPtr1 ::= *
=41692					WordListLink ::= Nt0 ; remember the nt of this word for later
.a360					ToEFloat:
.a360	20 f7 c7	jsr $c7f7			jsr Zero	; alloc & init workspace
.a363	20 f7 c7	jsr $c7f7			jsr Zero
.a366	20 f7 c7	jsr $c7f7			jsr Zero
=$2c					_addr		= DStack+8
=$2a					_len		= DStack+6
=$29					_mantfound 	= DStack+5		;mantissa digits found
=$28					_exponent 	= DStack+4		;exponent
=$27					_decimalPos 	= DStack+3		;decimal point position
=$26					_DecPointFound1 = DStack+2
=$25					_MantissaNegative1 = DStack+1
=$24					_ExponentNegative1 = DStack+0
.a369	20 27 9e	jsr $9e27			jsr E0			; init result
.a36c	20 3d a4	jsr $a43d	_11:		jsr _GetChar		; get mantissa prefix
.a36f	b0 56		bcs $a3c7			bcs _trueb ;_finishb
.a371	c9 20		cmp #$20			cmp #' '
.a373	f0 f7		beq $a36c			beq _11
.a375	c9 2b		cmp #$2b			cmp #'+'
.a377	f0 06		beq $a37f			beq _20
.a379	c9 2d		cmp #$2d			cmp #'-'
.a37b	d0 07		bne $a384			bne _21
.a37d	95 25		sta $25,x			sta _MantissaNegative1,x ; remember mantissa is negative
.a37f	20 3d a4	jsr $a43d	_20:		jsr _GetChar		; do next mantissa digits
.a382	b0 46		bcs $a3ca			bcs _finishb
.a384	c9 2e		cmp #$2e	_21:		cmp #'.'
.a386	f0 31		beq $a3b9			beq _27
.a388	c9 45		cmp #$45			cmp #'E'
.a38a	f0 41		beq $a3cd			beq _30
.a38c	c9 65		cmp #$65			cmp #'e'
.a38e	f0 3d		beq $a3cd			beq _30
.a390	c9 44		cmp #$44			cmp #'D'
.a392	f0 39		beq $a3cd			beq _30
.a394	c9 64		cmp #$64			cmp #'d'
.a396	f0 35		beq $a3cd			beq _30
.a398	38		sec				sec			;   a digit?
.a399	e9 30		sbc #$30			sbc #'0'
.a39b	90 24		bcc $a3c1			bcc _fail
.a39d	c9 0a		cmp #$0a			cmp #9+1
.a39f	b0 20		bcs $a3c1			bcs _fail
.a3a1	48		pha				pha			; append digit to mantissa
.a3a2	20 1c 9f	jsr $9f1c			jsr E10Star
.a3a5	68		pla				pla
.a3a6	a0 00		ldy #$00			ldy #0
.a3a8	20 30 a1	jsr $a130			jsr SToEYA
.a3ab	20 6c a0	jsr $a06c			jsr EPlus
.a3ae	f6 29		inc $29,x			inc _mantfound,x	; remember we found a mantissa digit
.a3b0	b5 26		lda $26,x			lda _DecPointFound1,x	; if mantissa decimal point found
.a3b2	f0 02		beq $a3b6			beq +
.a3b4	d6 27		dec $27,x			dec _decimalPos,x	;   increment decimal point position
.a3b6					+
.a3b6	4c 7f a3	jmp $a37f			jmp _20
.a3b9					_27:
.a3b9	b4 26		ldy $26,x			ldy _DecPointFound1,x	; already have one?
.a3bb	d0 04		bne $a3c1			bne _fail
.a3bd	95 26		sta $26,x			sta _DecPointFound1,x	; we have one now!
.a3bf	f0 be		beq $a37f			beq _20
.a3c1					_fail:
.a3c1	e6 54		inc $54				inc FIndex		; EDrop
.a3c3	a9 00		lda #$00			lda #0			;return false
.a3c5	f0 69		beq $a430			beq _return
.a3c7	4c 2e a4	jmp $a42e	_trueb:		jmp _true
.a3ca	4c fb a3	jmp $a3fb	_finishb:	jmp _finish
.a3cd					_30:
.a3cd	20 3d a4	jsr $a43d			jsr _GetChar
.a3d0	b0 29		bcs $a3fb			bcs _finish
.a3d2	c9 2b		cmp #$2b			cmp #'+'
.a3d4	f0 06		beq $a3dc			beq _40
.a3d6	c9 2d		cmp #$2d			cmp #'-'
.a3d8	d0 07		bne $a3e1			bne _41
.a3da	95 24		sta $24,x			sta _ExponentNegative1,x ; remember exponent is negative
.a3dc	20 3d a4	jsr $a43d	_40:		jsr _GetChar		;get exponent digits
.a3df	b0 1a		bcs $a3fb			bcs _finish
.a3e1	38		sec		_41:		sec			;  digit?
.a3e2	e9 30		sbc #$30			sbc #'0'
.a3e4	90 db		bcc $a3c1			bcc _fail
.a3e6	c9 0a		cmp #$0a			cmp #9+1
.a3e8	b0 d7		bcs $a3c1			bcs _fail
.a3ea	85 14		sta $14				sta tmp1
.a3ec	16 28		asl $28,x			asl _exponent,x		;  exponent *= 10
.a3ee	b5 28		lda $28,x			lda _exponent,x
.a3f0	0a		asl a				asl a
.a3f1	0a		asl a				asl a
.a3f2	75 28		adc $28,x			adc _exponent,x
.a3f4	65 14		adc $14				adc tmp1		;  + digit
.a3f6	95 28		sta $28,x			sta _exponent,x
.a3f8	4c dc a3	jmp $a3dc			jmp _40
.a3fb					_finish:
.a3fb	b5 29		lda $29,x			lda _mantfound,x	;some mantissa digits found?
.a3fd	f0 c2		beq $a3c1			beq _fail
.a3ff	b5 24		lda $24,x			lda _ExponentNegative1,x ;apply exponent sign
.a401	f0 07		beq $a40a			beq +
.a403	a9 00		lda #$00			lda #0
.a405	38		sec				sec
.a406	f5 28		sbc $28,x			sbc _exponent,x
.a408	95 28		sta $28,x			sta _exponent,x
.a40a					+
.a40a	b5 28		lda $28,x			lda _exponent,x		;apply decimal position to exponent
.a40c	18		clc				clc
.a40d	75 27		adc $27,x			adc _decimalPos,x
.a40f	95 28		sta $28,x			sta _exponent,x
.a411	4c 19 a4	jmp $a419			jmp _93
.a414	20 1c 9f	jsr $9f1c	_93b:		jsr E10Star		;apply exponent to mantissa
.a417	d6 28		dec $28,x			dec _exponent,x
.a419	f0 0a		beq $a425	_93:		beq _94
.a41b	10 f7		bpl $a414			bpl _93b
.a41d	20 47 9e	jsr $9e47	_94b:		jsr E10
.a420	20 c9 8d	jsr $8dc9			jsr ESlash
.a423	f6 28		inc $28,x			inc _exponent,x
.a425	30 f6		bmi $a41d	_94:		bmi _94b
.a427					_95:
.a427	b5 25		lda $25,x			lda _MantissaNegative1,x ;apply mantissa sign
.a429	f0 03		beq $a42e			beq +
.a42b	20 c5 a0	jsr $a0c5			jsr ENegate
.a42e					+
.a42e	a9 ff		lda #$ff	_true:		lda #$ff		;return true
.a430					_return:
.a430	95 2c		sta $2c,x			sta _addr+0,x		; replace _addr with flag
.a432	95 2d		sta $2d,x			sta _addr+1,x
.a434	e8		inx				inx			; Drop work
.a435	e8		inx				inx
.a436	e8		inx				inx			; 2Drop work
.a437	e8		inx				inx
.a438	e8		inx				inx
.a439	e8		inx				inx
.a43a	e8		inx				inx			; Drop len
.a43b	e8		inx				inx
.a43c	60		rts				rts
.a43d					_GetChar:
.a43d	38		sec				sec
.a43e	b5 2a		lda $2a,x			lda _len,x
.a440	f0 0b		beq $a44d			beq _gc_rts		; if end, return C=1
.a442	d6 2a		dec $2a,x			dec _len,x
.a444	a1 2c		lda ($2c,x)			lda (_addr,x)
.a446	f6 2c		inc $2c,x			inc _addr+0,x
.a448	d0 02		bne $a44c			bne +
.a44a	f6 2d		inc $2d,x			inc _addr+1,x
.a44c					+
.a44c	18		clc				clc			; get char, return C=0
.a44d	60		rts		_gc_rts:	rts
>a44e	45 4b 65 79			Name0:	.text "EKey"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=41938					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>a452	24					.byte (("EKey"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=246					LinkDisplacement = Nt0-WordListLink
>a453	10					.byte WordFlags	;wh_Flags
>a454	03					.byte 3	;wh_CodeLength
>a455	f6					  .byte LinkDisplacement	; offset to previous nt
=$a456					XtPtr1 ::= *
=41938					WordListLink ::= Nt0 ; remember the nt of this word for later
.a456					EKey:
.a456	20 67 da	jsr $da67			jsr Here		; ( addr )
.a459	20 67 da	jsr $da67			jsr Here		; ( addr addr )
.a45c	a9 28		lda #$28			lda #40			; ( addr addr 40 )
.a45e	20 e9 c7	jsr $c7e9			jsr PushZA
.a461	20 de d2	jsr $d2de			jsr Accept		; ( addr len )
.a464	20 60 a3	jsr $a360			jsr ToEFloat		; ( true | false)
.a467	e8		inx				inx			; err?
.a468	e8		inx				inx
.a469	b5 22		lda $22,x			lda DStack-2,x
.a46b	f0 01		beq $a46e			beq _err
.a46d	60		rts				rts
.a46e	20 bd c8	jsr $c8bd	_err:		jsr SLiteral_runtime
.a471	4c 77 a4	jmp $a477			  jmp +
>a474	20 3f 20					  .text " ? "
.a477	20 39 de	jsr $de39	+		jsr Type
.a47a	4c 56 a4	jmp $a456			jmp EKey
>a47d	45 4d 50 6f 6c 79		Name0:	.text "EMPoly"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=41987					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>a483	26					.byte (("EMPoly"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=49					LinkDisplacement = Nt0-WordListLink
>a484	10					.byte WordFlags	;wh_Flags
>a485	03					.byte 3	;wh_CodeLength
>a486	31					  .byte LinkDisplacement	; offset to previous nt
=$a487					XtPtr1 ::= *
=41987					WordListLink ::= Nt0 ; remember the nt of this word for later
.a487	20 e3 c3	jsr $c3e3	EMPoly:		jsr PopYA
.a48a	20 ba c7	jsr $c7ba	EMPolyYA:	jsr PushYA		; push coefficent addr
.a48d	20 eb 9b	jsr $9beb			jsr EAt_YA		; fetch 1st coefficent
.a490	4c a3 a4	jmp $a4a3			jmp _4
.a493	20 2e 9b	jsr $9b2e	_2:		jsr EOver
.a496	20 4d 8d	jsr $8d4d			jsr EStar
.a499	b5 24		lda $24,x			lda DStack+0,x		; fetch next coefficent
.a49b	b4 25		ldy $25,x			ldy DStack+1,x
.a49d	20 eb 9b	jsr $9beb			jsr EAt_YA
.a4a0	20 6c a0	jsr $a06c			jsr EPlus
.a4a3	a9 03		lda #$03	_4:		lda #EFloat_Size	; bump coefficent ptr
.a4a5	20 48 da	jsr $da48			jsr Plus_A
.a4a8	a1 24		lda ($24,x)			lda (DStack+0,x)	; end of coefficent list?
.a4aa	d0 e7		bne $a493			bne _2
.a4ac	e8		inx				inx			; Drop coefficent ptr
.a4ad	e8		inx				inx
=39					CodeLen	.var *-XtPtr1
=$a4ae					Here1 = *	; remember here
>a485	27					.byte CodeLen	;patch wh_CodeLength
.a4ae	60		rts				rts
>a4af	45 4c 6f 67 32 4d 31 4d		Name0:	.text "ELog2M1M"	;  name of word as a string, ending at wh_NameLastChar
=8					NameLength = *-Name0
=42039					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>a4b7	a8					.byte (("ELog2M1M"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=52					LinkDisplacement = Nt0-WordListLink
>a4b8	10					.byte WordFlags	;wh_Flags
>a4b9	03					.byte 3	;wh_CodeLength
>a4ba	34					  .byte LinkDisplacement	; offset to previous nt
=$a4bb					XtPtr1 ::= *
=42039					WordListLink ::= Nt0 ; remember the nt of this word for later
.a4bb	a9 c5		lda #$c5	ELog2M1M:	lda #<_c
.a4bd	a0 a4		ldy #$a4			ldy #>_c
.a4bf	20 8a a4	jsr $a48a			jsr EMPolyYA
.a4c2	4c 4d 8d	jmp $8d4d			jmp EStar
=10					CodeLen	.var *-XtPtr1
=$a4c5					Here1 = *	; remember here
>a4b9	0a					.byte CodeLen	;patch wh_CodeLength
.a4c5					_c:
>a4c5	e6 ab						.word $abe6		; 16 bit signed binary mantissa.  $4000 = +0.5
>a4c7	fd						.char -3		; 8 bit signed exponent.  $00 = 2**0
>a4c8	39 52						.word $5239		; 16 bit signed binary mantissa.  $4000 = +0.5
>a4ca	ff						.char -1		; 8 bit signed exponent.  $00 = 2**0
>a4cb	3e a9						.word $a93e		; 16 bit signed binary mantissa.  $4000 = +0.5
>a4cd	00						.char 0		; 8 bit signed exponent.  $00 = 2**0
>a4ce	14 5c						.word $5c14		; 16 bit signed binary mantissa.  $4000 = +0.5
>a4d0	01						.char 1		; 8 bit signed exponent.  $00 = 2**0
>a4d1	00					.byte 0
>a4d2	45 4c 6f 67 32			Name0:	.text "ELog2"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=42071					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>a4d7	45					.byte (("ELog2"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=32					LinkDisplacement = Nt0-WordListLink
>a4d8	10					.byte WordFlags	;wh_Flags
>a4d9	03					.byte 3	;wh_CodeLength
>a4da	20					  .byte LinkDisplacement	; offset to previous nt
=$a4db					XtPtr1 ::= *
=42071					WordListLink ::= Nt0 ; remember the nt of this word for later
.a4db	a4 54		ldy $54		ELog2:		ldy FIndex
.a4dd	b9 5f 00	lda $005f,y			lda FSMant0,y	; bad param?
.a4e0	30 20		bmi $a502			bmi _OutOfRange
.a4e2	f0 1e		beq $a502			beq _OutOfRange
.a4e4	b9 55 00	lda $0055,y			lda FSExp,y
.a4e7	48		pha				pha		; remember orig exponent
.a4e8	a9 01		lda #$01			lda #1
.a4ea	99 55 00	sta $0055,y			sta FSExp,y	; set to 1
.a4ed	20 b4 a0	jsr $a0b4			jsr E1Minus
.a4f0	20 bb a4	jsr $a4bb			jsr ELog2M1M
.a4f3	a0 00		ldy #$00			ldy #0		; add orig exponent to float
.a4f5	68		pla				pla
.a4f6	38		sec				sec
.a4f7	e9 01		sbc #$01			sbc #1
.a4f9	10 01		bpl $a4fc			bpl +
.a4fb	88		dey				dey
.a4fc					+
.a4fc	20 30 a1	jsr $a130			jsr SToEYA
.a4ff	4c 6c a0	jmp $a06c			jmp EPlus
.a502	4c 43 c4	jmp $c443	_OutOfRange:	jmp Throw_FpOutOfRange
=42					CodeLen	.var *-XtPtr1
=$a505					Here1 = *	; remember here
>a4d9	2a					.byte CodeLen	;patch wh_CodeLength
>a505	45 4c 6e			Name0:	.text "ELn"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=42120					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>a508	c3					.byte (("ELn"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=49					LinkDisplacement = Nt0-WordListLink
>a509	10					.byte WordFlags	;wh_Flags
>a50a	03					.byte 3	;wh_CodeLength
>a50b	31					  .byte LinkDisplacement	; offset to previous nt
=$a50c					XtPtr1 ::= *
=42120					WordListLink ::= Nt0 ; remember the nt of this word for later
.a50c	20 db a4	jsr $a4db	ELn:		jsr ELog2
.a50f	20 c7 9d	jsr $9dc7			jsr ELitI
>a512	b9 58						.word $58b9		; 16 bit signed binary mantissa.  $4000 = +0.5
>a514	00						.char 0		; 8 bit signed exponent.  $00 = 2**0
.a515	4c 4d 8d	jmp $8d4d			jmp EStar
=12					CodeLen	.var *-XtPtr1
=$a518					Here1 = *	; remember here
>a50a	0c					.byte CodeLen	;patch wh_CodeLength
>a518	45 4c 6e 50 31			Name0:	.text "ELnP1"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=42141					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>a51d	25					.byte (("ELnP1"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=21					LinkDisplacement = Nt0-WordListLink
>a51e	10					.byte WordFlags	;wh_Flags
>a51f	03					.byte 3	;wh_CodeLength
>a520	15					  .byte LinkDisplacement	; offset to previous nt
=$a521					XtPtr1 ::= *
=42141					WordListLink ::= Nt0 ; remember the nt of this word for later
.a521	20 90 a0	jsr $a090	ElnP1:		jsr E1Plus
.a524	4c 0c a5	jmp $a50c			jmp ELn
=6					CodeLen	.var *-XtPtr1
=$a527					Here1 = *	; remember here
>a51f	06					.byte CodeLen	;patch wh_CodeLength
>a527	45 4c 6f 67			Name0:	.text "ELog"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=42155					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>a52b	e4					.byte (("ELog"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=14					LinkDisplacement = Nt0-WordListLink
>a52c	10					.byte WordFlags	;wh_Flags
>a52d	03					.byte 3	;wh_CodeLength
>a52e	0e					  .byte LinkDisplacement	; offset to previous nt
=$a52f					XtPtr1 ::= *
=42155					WordListLink ::= Nt0 ; remember the nt of this word for later
.a52f	20 db a4	jsr $a4db	ELog:		jsr ELog2
.a532	20 c7 9d	jsr $9dc7			jsr ELitI
>a535	10 4d						.word $4d10		; 16 bit signed binary mantissa.  $4000 = +0.5
>a537	ff						.char -1		; 8 bit signed exponent.  $00 = 2**0
.a538	4c 4d 8d	jmp $8d4d			jmp EStar
=12					CodeLen	.var *-XtPtr1
=$a53b					Here1 = *	; remember here
>a52d	0c					.byte CodeLen	;patch wh_CodeLength
>a53b	45 45 78 70 32 4d 31 4d		Name0:	.text "EExp2M1M"	;  name of word as a string, ending at wh_NameLastChar
=8					NameLength = *-Name0
=42179					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>a543	a8					.byte (("EExp2M1M"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=24					LinkDisplacement = Nt0-WordListLink
>a544	10					.byte WordFlags	;wh_Flags
>a545	03					.byte 3	;wh_CodeLength
>a546	18					  .byte LinkDisplacement	; offset to previous nt
=$a547					XtPtr1 ::= *
=42179					WordListLink ::= Nt0 ; remember the nt of this word for later
.a547	a9 51		lda #$51	EExp2M1M:	lda #<_c
.a549	a0 a5		ldy #$a5			ldy #>_c
.a54b	20 8a a4	jsr $a48a			jsr EMPolyYA
.a54e	4c 4d 8d	jmp $8d4d			jmp EStar
=10					CodeLen	.var *-XtPtr1
=$a551					Here1 = *	; remember here
>a545	0a					.byte CodeLen	;patch wh_CodeLength
.a551					_c:
>a551	26 51						.word $5126		; 16 bit signed binary mantissa.  $4000 = +0.5
>a553	fd						.char -3		; 8 bit signed exponent.  $00 = 2**0
>a554	21 73						.word $7321		; 16 bit signed binary mantissa.  $4000 = +0.5
>a556	fe						.char -2		; 8 bit signed exponent.  $00 = 2**0
>a557	13 59						.word $5913		; 16 bit signed binary mantissa.  $4000 = +0.5
>a559	00						.char 0		; 8 bit signed exponent.  $00 = 2**0
>a55a	00					.byte 0
>a55b	45 45 78 70 32			Name0:	.text "EExp2"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=42208					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>a560	45					.byte (("EExp2"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=29					LinkDisplacement = Nt0-WordListLink
>a561	10					.byte WordFlags	;wh_Flags
>a562	03					.byte 3	;wh_CodeLength
>a563	1d					  .byte LinkDisplacement	; offset to previous nt
=$a564					XtPtr1 ::= *
=42208					WordListLink ::= Nt0 ; remember the nt of this word for later
.a564	20 cc 9f	jsr $9fcc	EExp2:		jsr EIntFrc	; ( f: r_rem r_int )
.a567	20 45 a1	jsr $a145			jsr EToS
.a56a	20 47 a5	jsr $a547			jsr EExp2M1M
.a56d	20 90 a0	jsr $a090			jsr E1Plus
.a570	20 c8 c3	jsr $c3c8			jsr PopA
.a573	a4 54		ldy $54				ldy FIndex
.a575	18		clc				clc
.a576	79 55 00	adc $0055,y			adc FSExp,y
.a579	99 55 00	sta $0055,y			sta FSExp,y
=24					CodeLen	.var *-XtPtr1
=$a57c					Here1 = *	; remember here
>a562	18					.byte CodeLen	;patch wh_CodeLength
.a57c	60		rts				rts
>a57d	45 45 78 70			Name0:	.text "EExp"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=42241					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>a581	04					.byte (("EExp"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=33					LinkDisplacement = Nt0-WordListLink
>a582	10					.byte WordFlags	;wh_Flags
>a583	03					.byte 3	;wh_CodeLength
>a584	21					  .byte LinkDisplacement	; offset to previous nt
=$a585					XtPtr1 ::= *
=42241					WordListLink ::= Nt0 ; remember the nt of this word for later
.a585					EExp:
.a585	20 c7 9d	jsr $9dc7			jsr ELitI
>a588	55 5c						.word $5c55		; 16 bit signed binary mantissa.  $4000 = +0.5
>a58a	01						.char 1		; 8 bit signed exponent.  $00 = 2**0
.a58b	20 4d 8d	jsr $8d4d			jsr EStar
.a58e	4c 64 a5	jmp $a564			jmp EExp2
=12					CodeLen	.var *-XtPtr1
=$a591					Here1 = *	; remember here
>a583	0c					.byte CodeLen	;patch wh_CodeLength
>a591	45 45 78 70 4d 31		Name0:	.text "EExpM1"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=42263					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>a597	26					.byte (("EExpM1"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=22					LinkDisplacement = Nt0-WordListLink
>a598	10					.byte WordFlags	;wh_Flags
>a599	03					.byte 3	;wh_CodeLength
>a59a	16					  .byte LinkDisplacement	; offset to previous nt
=$a59b					XtPtr1 ::= *
=42263					WordListLink ::= Nt0 ; remember the nt of this word for later
.a59b	20 85 a5	jsr $a585	EExpM1:		jsr EExp
.a59e	4c b4 a0	jmp $a0b4			jmp E1Minus
=6					CodeLen	.var *-XtPtr1
=$a5a1					Here1 = *	; remember here
>a599	06					.byte CodeLen	;patch wh_CodeLength
>a5a1	45 41 4c 6f 67			Name0:	.text "EALog"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=42278					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>a5a6	e5					.byte (("EALog"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=15					LinkDisplacement = Nt0-WordListLink
>a5a7	10					.byte WordFlags	;wh_Flags
>a5a8	03					.byte 3	;wh_CodeLength
>a5a9	0f					  .byte LinkDisplacement	; offset to previous nt
=$a5aa					XtPtr1 ::= *
=42278					WordListLink ::= Nt0 ; remember the nt of this word for later
.a5aa					EALog:
.a5aa	20 c7 9d	jsr $9dc7			jsr ELitI
>a5ad	4d 6a						.word $6a4d		; 16 bit signed binary mantissa.  $4000 = +0.5
>a5af	02						.char 2		; 8 bit signed exponent.  $00 = 2**0
.a5b0	20 4d 8d	jsr $8d4d			jsr EStar
.a5b3	4c 64 a5	jmp $a564			jmp EExp2
=12					CodeLen	.var *-XtPtr1
=$a5b6					Here1 = *	; remember here
>a5a8	0c					.byte CodeLen	;patch wh_CodeLength
>a5b6	45 2a 2a			Name0:	.text "E**"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=42297					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>a5b9	43					.byte (("E**"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=19					LinkDisplacement = Nt0-WordListLink
>a5ba	10					.byte WordFlags	;wh_Flags
>a5bb	03					.byte 3	;wh_CodeLength
>a5bc	13					  .byte LinkDisplacement	; offset to previous nt
=$a5bd					XtPtr1 ::= *
=42297					WordListLink ::= Nt0 ; remember the nt of this word for later
.a5bd	20 7d 9b	jsr $9b7d	EPower:		jsr ESwap
.a5c0	20 db a4	jsr $a4db			jsr ELog2
.a5c3	20 4d 8d	jsr $8d4d			jsr EStar
.a5c6	4c 64 a5	jmp $a564			jmp EExp2
=12					CodeLen	.var *-XtPtr1
=$a5c9					Here1 = *	; remember here
>a5bb	0c					.byte CodeLen	;patch wh_CodeLength
>a5c9	45 44 65 67 32 52 61 64		Name0:	.text "EDeg2Rad"	;  name of word as a string, ending at wh_NameLastChar
=8					NameLength = *-Name0
=42321					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>a5d1	88					.byte (("EDeg2Rad"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=24					LinkDisplacement = Nt0-WordListLink
>a5d2	10					.byte WordFlags	;wh_Flags
>a5d3	03					.byte 3	;wh_CodeLength
>a5d4	18					  .byte LinkDisplacement	; offset to previous nt
=$a5d5					XtPtr1 ::= *
=42321					WordListLink ::= Nt0 ; remember the nt of this word for later
.a5d5					EDeg2Rad:
.a5d5	20 c7 9d	jsr $9dc7			jsr ELitI
>a5d8	7d 47						.word $477d		; 16 bit signed binary mantissa.  $4000 = +0.5
>a5da	fb						.char -5		; 8 bit signed exponent.  $00 = 2**0
.a5db	4c 4d 8d	jmp $8d4d			jmp EStar
=9					CodeLen	.var *-XtPtr1
=$a5de					Here1 = *	; remember here
>a5d3	09					.byte CodeLen	;patch wh_CodeLength
>a5de	45 52 61 64 32 44 65 67		Name0:	.text "ERad2Deg"	;  name of word as a string, ending at wh_NameLastChar
=8					NameLength = *-Name0
=42342					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>a5e6	e8					.byte (("ERad2Deg"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=21					LinkDisplacement = Nt0-WordListLink
>a5e7	10					.byte WordFlags	;wh_Flags
>a5e8	03					.byte 3	;wh_CodeLength
>a5e9	15					  .byte LinkDisplacement	; offset to previous nt
=$a5ea					XtPtr1 ::= *
=42342					WordListLink ::= Nt0 ; remember the nt of this word for later
.a5ea					ERad2Deg:
.a5ea	20 c7 9d	jsr $9dc7			jsr ELitI
>a5ed	97 72						.word $7297		; 16 bit signed binary mantissa.  $4000 = +0.5
>a5ef	06						.char 6		; 8 bit signed exponent.  $00 = 2**0
.a5f0	4c 4d 8d	jmp $8d4d			jmp EStar
=9					CodeLen	.var *-XtPtr1
=$a5f3					Here1 = *	; remember here
>a5e8	09					.byte CodeLen	;patch wh_CodeLength
>a5f3	45 41 52 65 64 75 63 65		Name0:	.text "EAReduce"	;  name of word as a string, ending at wh_NameLastChar
=8					NameLength = *-Name0
=42363					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>a5fb	a8					.byte (("EAReduce"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=21					LinkDisplacement = Nt0-WordListLink
>a5fc	10					.byte WordFlags	;wh_Flags
>a5fd	03					.byte 3	;wh_CodeLength
>a5fe	15					  .byte LinkDisplacement	; offset to previous nt
=$a5ff					XtPtr1 ::= *
=42363					WordListLink ::= Nt0 ; remember the nt of this word for later
.a5ff	a4 54		ldy $54		EAReduce:	ldy FIndex
.a601	b9 5f 00	lda $005f,y			lda FSMant0,y		; zero?
.a604	f0 2f		beq $a635			beq _ok
.a606	b9 55 00	lda $0055,y			lda FSExp,y		; get exponent
.a609	30 2a		bmi $a635			bmi _ok			; small?
.a60b	c9 01		cmp #$01			cmp #1			; maybe need mirror?
.a60d	30 26		bmi $a635			bmi _ok			;if exponent <=0
.a60f	f0 24		beq $a635			beq _ok
.a611	c9 02		cmp #$02			cmp #2			; maybe need rotation?
.a613	b0 22		bcs $a637			bcs _exp2
.a615	b9 5f 00	lda $005f,y			lda FSMant0,y
.a618	c9 65		cmp #$65			cmp #$65		;in -pi/2..pi/2 ?
.a61a	90 19		bcc $a635			bcc _ok
.a61c	c9 9b		cmp #$9b			cmp #$100-$65
.a61e	b0 15		bcs $a635			bcs _ok
.a620					_mir:
.a620	20 7e 9e	jsr $9e7e			jsr EPi
.a623	a4 54		ldy $54				ldy FIndex
.a625	b9 60 00	lda $0060,y			lda FSMant0+1,y
.a628	10 03		bpl $a62d			bpl _3
.a62a	20 c5 a0	jsr $a0c5			jsr ENegate
.a62d	20 7d 9b	jsr $9b7d	_3:		jsr ESwap
.a630	20 9c a0	jsr $a09c			jsr EMinus
.a633	38		sec				sec		; mirrored
.a634	60		rts				rts
.a635	18		clc		_ok:		clc		; not mirrored
.a636	60		rts				rts
.a637	d0 0b		bne $a644	_exp2:		bne _rot	;if exp>2 then fix
.a639	b9 5f 00	lda $005f,y			lda FSMant0,y
.a63c	c9 65		cmp #$65			cmp #$65	;if mant>pi or mant<-pi then fix
.a63e	90 e0		bcc $a620			bcc _mir
.a640	c9 9b		cmp #$9b			cmp #$100-$65
.a642	b0 dc		bcs $a620			bcs _mir
.a644	20 aa 9e	jsr $9eaa	_rot:		jsr E2Pi
.a647	20 c9 8d	jsr $8dc9			jsr ESlash
.a64a	20 cc 9f	jsr $9fcc			jsr EIntFrc
.a64d	e6 54		inc $54				inc FIndex	; FDrop integer part
.a64f	a4 54		ldy $54				ldy FIndex	;if >=.5
.a651	b9 55 00	lda $0055,y			lda FSExp,y
.a654	a8		tay				tay
.a655	30 03		bmi $a65a			bmi _rot4
.a657	20 b4 a0	jsr $a0b4			jsr E1Minus	;  subtract 1
.a65a	20 aa 9e	jsr $9eaa	_rot4:		jsr E2Pi
.a65d	20 4d 8d	jsr $8d4d			jsr EStar
.a660	4c ff a5	jmp $a5ff			jmp EAReduce	; rotate done, look again
=100					CodeLen	.var *-XtPtr1
=$a663					Here1 = *	; remember here
>a5fd	64					.byte CodeLen	;patch wh_CodeLength
>a663	45 53 69 6e			Name0:	.text "ESin"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=42471					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>a667	c4					.byte (("ESin"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=108					LinkDisplacement = Nt0-WordListLink
>a668	10					.byte WordFlags	;wh_Flags
>a669	03					.byte 3	;wh_CodeLength
>a66a	6c					  .byte LinkDisplacement	; offset to previous nt
=$a66b					XtPtr1 ::= *
=42471					WordListLink ::= Nt0 ; remember the nt of this word for later
.a66b	20 ff a5	jsr $a5ff	ESin:		jsr EAReduce
.a66e	20 13 9b	jsr $9b13	ESinM:		jsr EDup
.a671	20 bd 8d	jsr $8dbd			jsr ESqr	; x x^2
.a674	a9 84		lda #$84			lda #<_c
.a676	a0 a6		ldy #$a6			ldy #>_c
.a678	20 8a a4	jsr $a48a			jsr EMPolyYA
.a67b	20 4d 8d	jsr $8d4d			jsr EStar
.a67e	20 90 a0	jsr $a090			jsr E1Plus	; C0 +1.0
.a681	4c 4d 8d	jmp $8d4d			jmp EStar
=25					CodeLen	.var *-XtPtr1
=$a684					Here1 = *	; remember here
>a669	19					.byte CodeLen	;patch wh_CodeLength
.a684					_c:
>a684	65 7c						.word $7c65		; 16 bit signed binary mantissa.  $4000 = +0.5
>a686	f9						.char -7		; 8 bit signed exponent.  $00 = 2**0
>a687	01 ab						.word $ab01		; 16 bit signed binary mantissa.  $4000 = +0.5
>a689	fe						.char -2		; 8 bit signed exponent.  $00 = 2**0
>a68a	00					.byte 0			; end
>a68b	45 43 73 63			Name0:	.text "ECsc"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=42511					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>a68f	64					.byte (("ECsc"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=40					LinkDisplacement = Nt0-WordListLink
>a690	10					.byte WordFlags	;wh_Flags
>a691	03					.byte 3	;wh_CodeLength
>a692	28					  .byte LinkDisplacement	; offset to previous nt
=$a693					XtPtr1 ::= *
=42511					WordListLink ::= Nt0 ; remember the nt of this word for later
.a693	20 6b a6	jsr $a66b	ECsc:		jsr ESin
.a696	4c 23 8e	jmp $8e23			jmp E1Slash		; 1/SIN(r1)
=6					CodeLen	.var *-XtPtr1
=$a699					Here1 = *	; remember here
>a691	06					.byte CodeLen	;patch wh_CodeLength
>a699	45 43 6f 73			Name0:	.text "ECos"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=42525					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>a69d	64					.byte (("ECos"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=14					LinkDisplacement = Nt0-WordListLink
>a69e	10					.byte WordFlags	;wh_Flags
>a69f	03					.byte 3	;wh_CodeLength
>a6a0	0e					  .byte LinkDisplacement	; offset to previous nt
=$a6a1					XtPtr1 ::= *
=42525					WordListLink ::= Nt0 ; remember the nt of this word for later
.a6a1	20 8d 9e	jsr $9e8d	ECos:		jsr EPiH
.a6a4	20 6c a0	jsr $a06c			jsr EPlus
.a6a7	4c 6b a6	jmp $a66b			jmp ESin
=9					CodeLen	.var *-XtPtr1
=$a6aa					Here1 = *	; remember here
>a69f	09					.byte CodeLen	;patch wh_CodeLength
>a6aa	45 53 65 63			Name0:	.text "ESec"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=42542					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>a6ae	64					.byte (("ESec"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=17					LinkDisplacement = Nt0-WordListLink
>a6af	10					.byte WordFlags	;wh_Flags
>a6b0	03					.byte 3	;wh_CodeLength
>a6b1	11					  .byte LinkDisplacement	; offset to previous nt
=$a6b2					XtPtr1 ::= *
=42542					WordListLink ::= Nt0 ; remember the nt of this word for later
.a6b2	20 a1 a6	jsr $a6a1	ESec:		jsr ECos
.a6b5	4c 23 8e	jmp $8e23			jmp E1Slash		; 1/COS(r1)
=6					CodeLen	.var *-XtPtr1
=$a6b8					Here1 = *	; remember here
>a6b0	06					.byte CodeLen	;patch wh_CodeLength
>a6b8	45 53 69 6e 43 6f 73		Name0:	.text "ESinCos"	;  name of word as a string, ending at wh_NameLastChar
=7					NameLength = *-Name0
=42559					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>a6bf	67					.byte (("ESinCos"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=17					LinkDisplacement = Nt0-WordListLink
>a6c0	10					.byte WordFlags	;wh_Flags
>a6c1	03					.byte 3	;wh_CodeLength
>a6c2	11					  .byte LinkDisplacement	; offset to previous nt
=$a6c3					XtPtr1 ::= *
=42559					WordListLink ::= Nt0 ; remember the nt of this word for later
.a6c3	20 53 85	jsr $8553	ESinCos:	jsr FDup
.a6c6	20 3d 96	jsr $963d			jsr FSin
.a6c9	20 d7 85	jsr $85d7			jsr FSwap
.a6cc	4c 81 96	jmp $9681			jmp FCos
=12					CodeLen	.var *-XtPtr1
=$a6cf					Here1 = *	; remember here
>a6c1	0c					.byte CodeLen	;patch wh_CodeLength
>a6cf	45 54 61 6e			Name0:	.text "ETan"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=42579					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>a6d3	c4					.byte (("ETan"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=20					LinkDisplacement = Nt0-WordListLink
>a6d4	10					.byte WordFlags	;wh_Flags
>a6d5	03					.byte 3	;wh_CodeLength
>a6d6	14					  .byte LinkDisplacement	; offset to previous nt
=$a6d7					XtPtr1 ::= *
=42579					WordListLink ::= Nt0 ; remember the nt of this word for later
.a6d7	20 ff a5	jsr $a5ff	ETan:		jsr EAReduce
.a6da	90 06		bcc $a6e2			bcc _30
.a6dc	20 e2 a6	jsr $a6e2			jsr _30
.a6df	4c c5 a0	jmp $a0c5			jmp ENegate
.a6e2					_30:
.a6e2	20 13 9b	jsr $9b13			jsr EDup
.a6e5	20 df a0	jsr $a0df			jsr EAbs
.a6e8	20 9c 9e	jsr $9e9c			jsr EPiQ
.a6eb	20 ed 9c	jsr $9ced			jsr ELe
.a6ee	e8		inx				inx			; pop f
.a6ef	e8		inx				inx
.a6f0	b5 24		lda $24,x			lda DStack+0,x
.a6f2	d0 19		bne $a70d			bne ETanM
.a6f4	20 8d 9e	jsr $9e8d			jsr EPiH
.a6f7	a4 54		ldy $54				ldy FIndex		; get sign
.a6f9	b9 5f 00	lda $005f,y			lda FSMant0,y
.a6fc	10 03		bpl $a701			bpl +
.a6fe	20 c5 a0	jsr $a0c5			jsr ENegate
.a701					+
.a701	20 7d 9b	jsr $9b7d			jsr ESwap
.a704	20 9c a0	jsr $a09c			jsr EMinus
.a707	20 0d a7	jsr $a70d			jsr ETanM
.a70a	4c 23 8e	jmp $8e23			jmp E1Slash
=54					CodeLen	.var *-XtPtr1
=$a70d					Here1 = *	; remember here
>a6d5	36					.byte CodeLen	;patch wh_CodeLength
.a70d	20 13 9b	jsr $9b13	ETanM:		jsr EDup
.a710	20 bd 8d	jsr $8dbd			jsr ESqr		; x x^2
.a713	a9 23		lda #$23			lda #<_c
.a715	a0 a7		ldy #$a7			ldy #>_c
.a717	20 8a a4	jsr $a48a			jsr EMPolyYA
.a71a	20 4d 8d	jsr $8d4d			jsr EStar
.a71d	20 90 a0	jsr $a090			jsr E1Plus		; c0 1.0
.a720	4c 4d 8d	jmp $8d4d			jmp EStar
=76					CodeLen	.var *-XtPtr1
=$a723					Here1 = *	; remember here
>a6d5	4c					.byte CodeLen	;patch wh_CodeLength
.a723					_c:
>a723	b6 64						.word $64b6		; 16 bit signed binary mantissa.  $4000 = +0.5
>a725	fd						.char -3		; 8 bit signed exponent.  $00 = 2**0
>a726	50 73						.word $7350		; 16 bit signed binary mantissa.  $4000 = +0.5
>a728	fd						.char -3		; 8 bit signed exponent.  $00 = 2**0
>a729	09 56						.word $5609		; 16 bit signed binary mantissa.  $4000 = +0.5
>a72b	ff						.char -1		; 8 bit signed exponent.  $00 = 2**0
>a72c	00					.byte 0			; end
>a72d	45 43 6f 74			Name0:	.text "ECot"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=42673					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>a731	84					.byte (("ECot"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=94					LinkDisplacement = Nt0-WordListLink
>a732	10					.byte WordFlags	;wh_Flags
>a733	03					.byte 3	;wh_CodeLength
>a734	5e					  .byte LinkDisplacement	; offset to previous nt
=$a735					XtPtr1 ::= *
=42673					WordListLink ::= Nt0 ; remember the nt of this word for later
.a735	20 d7 a6	jsr $a6d7	ECot:		jsr ETan
.a738	4c 23 8e	jmp $8e23			jmp E1Slash	; =1/TAN(r1)
=6					CodeLen	.var *-XtPtr1
=$a73b					Here1 = *	; remember here
>a733	06					.byte CodeLen	;patch wh_CodeLength
>a73b	45 41 43 6f 73			Name0:	.text "EACos"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=42688					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>a740	65					.byte (("EACos"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=15					LinkDisplacement = Nt0-WordListLink
>a741	10					.byte WordFlags	;wh_Flags
>a742	03					.byte 3	;wh_CodeLength
>a743	0f					  .byte LinkDisplacement	; offset to previous nt
=$a744					XtPtr1 ::= *
=42688					WordListLink ::= Nt0 ; remember the nt of this word for later
.a744	a4 54		ldy $54		EACos:		ldy FIndex
.a746	b9 5f 00	lda $005f,y			lda FSMant0,y
.a749	08		php				php			; save sign
.a74a	20 df a0	jsr $a0df			jsr EAbs
.a74d	a9 70		lda #$70			lda #<_c
.a74f	a0 a7		ldy #$a7			ldy #>_c
.a751	20 8a a4	jsr $a48a			jsr EMPolyYA
.a754	20 7d 9b	jsr $9b7d			jsr ESwap
.a757	20 c5 a0	jsr $a0c5			jsr ENegate
.a75a	20 90 a0	jsr $a090			jsr E1Plus
.a75d	20 9b a1	jsr $a19b			jsr ESqrt
.a760	20 4d 8d	jsr $8d4d			jsr EStar
.a763	28		plp				plp			; was r1 negative?
.a764	10 09		bpl $a76f			bpl +
.a766	20 7e 9e	jsr $9e7e			jsr EPi
.a769	20 7d 9b	jsr $9b7d			jsr ESwap
.a76c	20 9c a0	jsr $a09c			jsr EMinus
.a76f					+
=43					CodeLen	.var *-XtPtr1
=$a76f					Here1 = *	; remember here
>a742	2b					.byte CodeLen	;patch wh_CodeLength
.a76f	60		rts				rts
.a770					_c:
>a770	e6 b2						.word $b2e6		; 16 bit signed binary mantissa.  $4000 = +0.5
>a772	fb						.char -5		; 8 bit signed exponent.  $00 = 2**0
>a773	92 4c						.word $4c92		; 16 bit signed binary mantissa.  $4000 = +0.5
>a775	fd						.char -3		; 8 bit signed exponent.  $00 = 2**0
>a776	2f 93						.word $932f		; 16 bit signed binary mantissa.  $4000 = +0.5
>a778	fe						.char -2		; 8 bit signed exponent.  $00 = 2**0
>a779	88 64						.word $6488		; 16 bit signed binary mantissa.  $4000 = +0.5
>a77b	01						.char 1		; 8 bit signed exponent.  $00 = 2**0
>a77c	00					.byte 0			; end
>a77d	45 41 53 65 63			Name0:	.text "EASec"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=42754					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>a782	65					.byte (("EASec"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=66					LinkDisplacement = Nt0-WordListLink
>a783	10					.byte WordFlags	;wh_Flags
>a784	03					.byte 3	;wh_CodeLength
>a785	42					  .byte LinkDisplacement	; offset to previous nt
=$a786					XtPtr1 ::= *
=42754					WordListLink ::= Nt0 ; remember the nt of this word for later
.a786	20 23 8e	jsr $8e23	EASec:		jsr E1Slash
.a789	4c 44 a7	jmp $a744			jmp EACos
=6					CodeLen	.var *-XtPtr1
=$a78c					Here1 = *	; remember here
>a784	06					.byte CodeLen	;patch wh_CodeLength
>a78c	45 41 53 69 6e			Name0:	.text "EASin"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=42769					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>a791	c5					.byte (("EASin"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=15					LinkDisplacement = Nt0-WordListLink
>a792	10					.byte WordFlags	;wh_Flags
>a793	03					.byte 3	;wh_CodeLength
>a794	0f					  .byte LinkDisplacement	; offset to previous nt
=$a795					XtPtr1 ::= *
=42769					WordListLink ::= Nt0 ; remember the nt of this word for later
.a795	20 44 a7	jsr $a744	EASin:		jsr EACos
.a798	20 c5 a0	jsr $a0c5			jsr ENegate
.a79b	20 8d 9e	jsr $9e8d			jsr EPiH
.a79e	4c 6c a0	jmp $a06c			jmp EPlus
=12					CodeLen	.var *-XtPtr1
=$a7a1					Here1 = *	; remember here
>a793	0c					.byte CodeLen	;patch wh_CodeLength
>a7a1	45 41 43 73 63			Name0:	.text "EACsc"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=42790					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>a7a6	65					.byte (("EACsc"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=21					LinkDisplacement = Nt0-WordListLink
>a7a7	10					.byte WordFlags	;wh_Flags
>a7a8	03					.byte 3	;wh_CodeLength
>a7a9	15					  .byte LinkDisplacement	; offset to previous nt
=$a7aa					XtPtr1 ::= *
=42790					WordListLink ::= Nt0 ; remember the nt of this word for later
.a7aa	20 23 8e	jsr $8e23	EACsc:		jsr E1Slash
.a7ad	4c 95 a7	jmp $a795			jmp EASin
=6					CodeLen	.var *-XtPtr1
=$a7b0					Here1 = *	; remember here
>a7a8	06					.byte CodeLen	;patch wh_CodeLength
>a7b0	45 41 54 61 6e			Name0:	.text "EATan"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=42805					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>a7b5	c5					.byte (("EATan"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=15					LinkDisplacement = Nt0-WordListLink
>a7b6	10					.byte WordFlags	;wh_Flags
>a7b7	03					.byte 3	;wh_CodeLength
>a7b8	0f					  .byte LinkDisplacement	; offset to previous nt
=$a7b9					XtPtr1 ::= *
=42805					WordListLink ::= Nt0 ; remember the nt of this word for later
.a7b9					EATan:
.a7b9	a4 54		ldy $54				ldy FIndex
.a7bb	b9 55 00	lda $0055,y			lda FSExp,y		; Abs(r1)<1 ?
.a7be	30 1b		bmi $a7db			bmi EATanM
.a7c0	f0 19		beq $a7db			beq EATanM
.a7c2	b9 5f 00	lda $005f,y			lda FSMant0,y		; save sign
.a7c5	08		php				php
.a7c6	20 23 8e	jsr $8e23			jsr E1Slash
.a7c9	20 db a7	jsr $a7db			jsr EATanM
.a7cc	20 c5 a0	jsr $a0c5			jsr ENegate
.a7cf	20 8d 9e	jsr $9e8d			jsr EPiH
.a7d2	28		plp				plp
.a7d3	10 03		bpl $a7d8			bpl _18
.a7d5	20 c5 a0	jsr $a0c5			jsr ENegate
.a7d8	4c 6c a0	jmp $a06c	_18:		jmp EPlus
.a7db	20 13 9b	jsr $9b13	EATanM:		jsr EDup		; x x
.a7de	20 bd 8d	jsr $8dbd			jsr ESqr		; x xsqr
.a7e1	a9 f1		lda #$f1			lda #<_c
.a7e3	a0 a7		ldy #$a7			ldy #>_c
.a7e5	20 8a a4	jsr $a48a			jsr EMPolyYA
.a7e8	20 4d 8d	jsr $8d4d			jsr EStar		; x poly
.a7eb	20 90 a0	jsr $a090			jsr E1Plus		; x poly
.a7ee	4c 4d 8d	jmp $8d4d			jmp EStar
.a7f1					_c:
>a7f1	4f a9						.word $a94f		; 16 bit signed binary mantissa.  $4000 = +0.5
>a7f3	fc						.char -4		; 8 bit signed exponent.  $00 = 2**0
>a7f4	8e 4e						.word $4e8e		; 16 bit signed binary mantissa.  $4000 = +0.5
>a7f6	fe						.char -2		; 8 bit signed exponent.  $00 = 2**0
>a7f7	9f ac						.word $ac9f		; 16 bit signed binary mantissa.  $4000 = +0.5
>a7f9	ff						.char -1		; 8 bit signed exponent.  $00 = 2**0
>a7fa	00					.byte 0			; end
>a7fb	45 41 43 6f 74			Name0:	.text "EACot"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=42880					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>a800	85					.byte (("EACot"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=75					LinkDisplacement = Nt0-WordListLink
>a801	10					.byte WordFlags	;wh_Flags
>a802	03					.byte 3	;wh_CodeLength
>a803	4b					  .byte LinkDisplacement	; offset to previous nt
=$a804					XtPtr1 ::= *
=42880					WordListLink ::= Nt0 ; remember the nt of this word for later
.a804	20 23 8e	jsr $8e23	EACot:		jsr E1Slash
.a807	4c b9 a7	jmp $a7b9			jmp EATan
=6					CodeLen	.var *-XtPtr1
=$a80a					Here1 = *	; remember here
>a802	06					.byte CodeLen	;patch wh_CodeLength
>a80a	45 41 54 61 6e 32		Name0:	.text "EATan2"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=42896					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>a810	46					.byte (("EATan2"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=16					LinkDisplacement = Nt0-WordListLink
>a811	10					.byte WordFlags	;wh_Flags
>a812	03					.byte 3	;wh_CodeLength
>a813	10					  .byte LinkDisplacement	; offset to previous nt
=$a814					XtPtr1 ::= *
=42896					WordListLink ::= Nt0 ; remember the nt of this word for later
.a814	a4 54		ldy $54		EATan2:		ldy FIndex
.a816	b9 5f 00	lda $005f,y			lda FSMant0+0,y	; get rx sign
.a819	f0 1c		beq $a837			beq _rxzero
.a81b	0a		asl a				asl a		;   C=rx sign
.a81c	b9 60 00	lda $0060,y			lda FSMant0+1,y	;   N=ry sign
.a81f	08		php				php		; save signs
.a820	20 c9 8d	jsr $8dc9			jsr ESlash
.a823	20 b9 a7	jsr $a7b9			jsr EATan
.a826	28		plp				plp		; pop signs
.a827	b0 01		bcs $a82a			bcs _rxneg
.a829	60		rts		_rts:		rts
.a82a	08		php		_rxneg:		php
.a82b	20 fe 88	jsr $88fe			jsr FPi
.a82e	28		plp				plp
.a82f	10 03		bpl $a834			bpl +
.a831	20 c5 a0	jsr $a0c5			jsr ENegate
.a834	4c 6c a0	jmp $a06c	+		jmp EPlus
.a837	e6 54		inc $54		_rxzero:	inc FIndex	; FDrop rx
.a839	b9 5f 00	lda $005f,y			lda FSMant0,y
.a83c	08		php				php
.a83d	e6 54		inc $54				inc FIndex	; FDrop ry
.a83f	20 8d 9e	jsr $9e8d			jsr EPiH
.a842	28		plp				plp
.a843	10 e4		bpl $a829			bpl _rts
.a845	4c c5 a0	jmp $a0c5			jmp ENegate
=52					CodeLen	.var *-XtPtr1
=$a848					Here1 = *	; remember here
>a812	34					.byte CodeLen	;patch wh_CodeLength
>a848	45 53 67 6e			Name0:	.text "ESgn"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=42956					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>a84c	c4					.byte (("ESgn"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=60					LinkDisplacement = Nt0-WordListLink
>a84d	10					.byte WordFlags	;wh_Flags
>a84e	03					.byte 3	;wh_CodeLength
>a84f	3c					  .byte LinkDisplacement	; offset to previous nt
=$a850					XtPtr1 ::= *
=42956					WordListLink ::= Nt0 ; remember the nt of this word for later
.a850	a4 54		ldy $54		ESgn:		ldy FIndex
.a852	b9 5f 00	lda $005f,y			lda FSMant0,y
.a855	f0 0a		beq $a861			beq _zero
.a857	e6 54		inc $54				inc FIndex
.a859	b9 5f 00	lda $005f,y			lda FSMant0,y
.a85c	30 04		bmi $a862			bmi EM1
.a85e	4c 63 9e	jmp $9e63			jmp E1
.a861	60		rts		_zero:		rts
=18					CodeLen	.var *-XtPtr1
=$a862					Here1 = *	; remember here
>a84e	12					.byte CodeLen	;patch wh_CodeLength
.a862	a9 80		lda #$80	EM1:		lda #$80
.a864	a0 00		ldy #$00			ldy #0
.a866	4c 11 9e	jmp $9e11			jmp ELitYA
>a869	45 53 69 6e 48			Name0:	.text "ESinH"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=42990					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>a86e	05					.byte (("ESinH"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=34					LinkDisplacement = Nt0-WordListLink
>a86f	10					.byte WordFlags	;wh_Flags
>a870	03					.byte 3	;wh_CodeLength
>a871	22					  .byte LinkDisplacement	; offset to previous nt
=$a872					XtPtr1 ::= *
=42990					WordListLink ::= Nt0 ; remember the nt of this word for later
.a872	20 13 9b	jsr $9b13	ESinH:		jsr EDup
.a875	20 85 a5	jsr $a585			jsr EExp
.a878	20 7d 9b	jsr $9b7d			jsr ESwap
.a87b	20 c5 a0	jsr $a0c5			jsr ENegate
.a87e	20 85 a5	jsr $a585			jsr EExp
.a881	20 9c a0	jsr $a09c			jsr EMinus
.a884	4c 10 9f	jmp $9f10			jmp E2Slash
=21					CodeLen	.var *-XtPtr1
=$a887					Here1 = *	; remember here
>a870	15					.byte CodeLen	;patch wh_CodeLength
>a887	45 43 73 63 48			Name0:	.text "ECscH"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=43020					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>a88c	05					.byte (("ECscH"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=30					LinkDisplacement = Nt0-WordListLink
>a88d	10					.byte WordFlags	;wh_Flags
>a88e	03					.byte 3	;wh_CodeLength
>a88f	1e					  .byte LinkDisplacement	; offset to previous nt
=$a890					XtPtr1 ::= *
=43020					WordListLink ::= Nt0 ; remember the nt of this word for later
.a890	20 72 a8	jsr $a872	ECscH:		jsr ESinH
.a893	4c 23 8e	jmp $8e23			jmp E1Slash
=6					CodeLen	.var *-XtPtr1
=$a896					Here1 = *	; remember here
>a88e	06					.byte CodeLen	;patch wh_CodeLength
>a896	45 43 6f 73 48			Name0:	.text "ECosH"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=43035					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>a89b	05					.byte (("ECosH"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=15					LinkDisplacement = Nt0-WordListLink
>a89c	10					.byte WordFlags	;wh_Flags
>a89d	03					.byte 3	;wh_CodeLength
>a89e	0f					  .byte LinkDisplacement	; offset to previous nt
=$a89f					XtPtr1 ::= *
=43035					WordListLink ::= Nt0 ; remember the nt of this word for later
.a89f	20 13 9b	jsr $9b13	ECosH:		jsr EDup
.a8a2	20 85 a5	jsr $a585			jsr EExp
.a8a5	20 7d 9b	jsr $9b7d			jsr ESwap
.a8a8	20 c5 a0	jsr $a0c5			jsr ENegate
.a8ab	20 85 a5	jsr $a585			jsr EExp
.a8ae	20 6c a0	jsr $a06c			jsr EPlus
.a8b1	4c 10 9f	jmp $9f10			jmp E2Slash
=21					CodeLen	.var *-XtPtr1
=$a8b4					Here1 = *	; remember here
>a89d	15					.byte CodeLen	;patch wh_CodeLength
>a8b4	45 53 65 63 48			Name0:	.text "ESecH"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=43065					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>a8b9	05					.byte (("ESecH"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=30					LinkDisplacement = Nt0-WordListLink
>a8ba	10					.byte WordFlags	;wh_Flags
>a8bb	03					.byte 3	;wh_CodeLength
>a8bc	1e					  .byte LinkDisplacement	; offset to previous nt
=$a8bd					XtPtr1 ::= *
=43065					WordListLink ::= Nt0 ; remember the nt of this word for later
.a8bd	20 9f a8	jsr $a89f	ESecH:		jsr ECosH
.a8c0	4c 23 8e	jmp $8e23			jmp E1Slash
=6					CodeLen	.var *-XtPtr1
=$a8c3					Here1 = *	; remember here
>a8bb	06					.byte CodeLen	;patch wh_CodeLength
>a8c3	45 54 61 6e 48			Name0:	.text "ETanH"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=43080					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>a8c8	05					.byte (("ETanH"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=15					LinkDisplacement = Nt0-WordListLink
>a8c9	10					.byte WordFlags	;wh_Flags
>a8ca	03					.byte 3	;wh_CodeLength
>a8cb	0f					  .byte LinkDisplacement	; offset to previous nt
=$a8cc					XtPtr1 ::= *
=43080					WordListLink ::= Nt0 ; remember the nt of this word for later
.a8cc	20 13 9b	jsr $9b13	ETanH:		jsr EDup
.a8cf	20 c5 a0	jsr $a0c5			jsr ENegate	; X -X
.a8d2	20 85 a5	jsr $a585			jsr EExp	; X Exp(-X)
.a8d5	20 7d 9b	jsr $9b7d			jsr ESwap	; Exp(-X) X
.a8d8	20 85 a5	jsr $a585			jsr EExp	; Exp(-X) Exp(X)
.a8db	20 2e 9b	jsr $9b2e			jsr EOver	; Exp(-X) Exp(X) Exp(-X)
.a8de	20 6c a0	jsr $a06c			jsr EPlus	; Exp(-X) Exp(X)+Exp(-X)
.a8e1	20 c9 8d	jsr $8dc9			jsr ESlash	; Exp(-X)/(Exp(X)+Exp(-X))
.a8e4	20 05 9f	jsr $9f05			jsr E2Star	; Exp(-X)/(Exp(X)+Exp(-X))*2
.a8e7	20 c5 a0	jsr $a0c5			jsr ENegate
.a8ea	4c 90 a0	jmp $a090			jmp E1Plus
=33					CodeLen	.var *-XtPtr1
=$a8ed					Here1 = *	; remember here
>a8ca	21					.byte CodeLen	;patch wh_CodeLength
>a8ed	45 43 6f 74 48			Name0:	.text "ECotH"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=43122					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>a8f2	05					.byte (("ECotH"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=42					LinkDisplacement = Nt0-WordListLink
>a8f3	10					.byte WordFlags	;wh_Flags
>a8f4	03					.byte 3	;wh_CodeLength
>a8f5	2a					  .byte LinkDisplacement	; offset to previous nt
=$a8f6					XtPtr1 ::= *
=43122					WordListLink ::= Nt0 ; remember the nt of this word for later
.a8f6	20 cc a8	jsr $a8cc	ECotH:		jsr ETanH
.a8f9	4c 23 8e	jmp $8e23			jmp E1Slash
=6					CodeLen	.var *-XtPtr1
=$a8fc					Here1 = *	; remember here
>a8f4	06					.byte CodeLen	;patch wh_CodeLength
>a8fc	45 41 53 69 6e 48		Name0:	.text "EASinH"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=43138					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>a902	06					.byte (("EASinH"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=16					LinkDisplacement = Nt0-WordListLink
>a903	10					.byte WordFlags	;wh_Flags
>a904	03					.byte 3	;wh_CodeLength
>a905	10					  .byte LinkDisplacement	; offset to previous nt
=$a906					XtPtr1 ::= *
=43138					WordListLink ::= Nt0 ; remember the nt of this word for later
.a906	20 13 9b	jsr $9b13	EASinH:		jsr EDup	; X X
.a909	20 bd 8d	jsr $8dbd			jsr ESqr	; X X*X
.a90c	20 90 a0	jsr $a090			jsr E1Plus	; X X*X+1
.a90f	20 9b a1	jsr $a19b			jsr ESqrt	; X sqrt(X*X+1)
.a912	20 6c a0	jsr $a06c			jsr EPlus	;
.a915	4c 0c a5	jmp $a50c			jmp ELn
=18					CodeLen	.var *-XtPtr1
=$a918					Here1 = *	; remember here
>a904	12					.byte CodeLen	;patch wh_CodeLength
>a918	45 41 43 73 63 48		Name0:	.text "EACscH"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=43166					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>a91e	06					.byte (("EACscH"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=28					LinkDisplacement = Nt0-WordListLink
>a91f	10					.byte WordFlags	;wh_Flags
>a920	03					.byte 3	;wh_CodeLength
>a921	1c					  .byte LinkDisplacement	; offset to previous nt
=$a922					XtPtr1 ::= *
=43166					WordListLink ::= Nt0 ; remember the nt of this word for later
.a922	20 23 8e	jsr $8e23	EACscH:		jsr E1Slash
.a925	4c 06 a9	jmp $a906			jmp EASinH
=6					CodeLen	.var *-XtPtr1
=$a928					Here1 = *	; remember here
>a920	06					.byte CodeLen	;patch wh_CodeLength
>a928	45 41 43 6f 73 48		Name0:	.text "EACosH"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=43182					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>a92e	06					.byte (("EACosH"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=16					LinkDisplacement = Nt0-WordListLink
>a92f	10					.byte WordFlags	;wh_Flags
>a930	03					.byte 3	;wh_CodeLength
>a931	10					  .byte LinkDisplacement	; offset to previous nt
=$a932					XtPtr1 ::= *
=43182					WordListLink ::= Nt0 ; remember the nt of this word for later
.a932	20 13 9b	jsr $9b13	EACosH:		jsr EDup
.a935	20 bd 8d	jsr $8dbd			jsr ESqr
.a938	20 b4 a0	jsr $a0b4			jsr E1Minus
.a93b	20 9b a1	jsr $a19b			jsr ESqrt
.a93e	20 6c a0	jsr $a06c			jsr EPlus
.a941	4c 0c a5	jmp $a50c			jmp ELn
=18					CodeLen	.var *-XtPtr1
=$a944					Here1 = *	; remember here
>a930	12					.byte CodeLen	;patch wh_CodeLength
>a944	45 41 53 65 63 48		Name0:	.text "EASecH"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=43210					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>a94a	06					.byte (("EASecH"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=28					LinkDisplacement = Nt0-WordListLink
>a94b	10					.byte WordFlags	;wh_Flags
>a94c	03					.byte 3	;wh_CodeLength
>a94d	1c					  .byte LinkDisplacement	; offset to previous nt
=$a94e					XtPtr1 ::= *
=43210					WordListLink ::= Nt0 ; remember the nt of this word for later
.a94e	20 23 8e	jsr $8e23	EASecH:		jsr E1Slash
.a951	4c 32 a9	jmp $a932			jmp EACosH
=6					CodeLen	.var *-XtPtr1
=$a954					Here1 = *	; remember here
>a94c	06					.byte CodeLen	;patch wh_CodeLength
>a954	45 41 54 61 6e 48		Name0:	.text "EATanH"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=43226					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>a95a	06					.byte (("EATanH"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=16					LinkDisplacement = Nt0-WordListLink
>a95b	10					.byte WordFlags	;wh_Flags
>a95c	03					.byte 3	;wh_CodeLength
>a95d	10					  .byte LinkDisplacement	; offset to previous nt
=$a95e					XtPtr1 ::= *
=43226					WordListLink ::= Nt0 ; remember the nt of this word for later
.a95e	20 13 9b	jsr $9b13	EAtanH:		jsr EDup	; x x
.a961	20 90 a0	jsr $a090			jsr E1Plus	; x x+1
.a964	20 7d 9b	jsr $9b7d			jsr ESwap	; 1+x x
.a967	20 63 9e	jsr $9e63			jsr E1
.a96a	20 7d 9b	jsr $9b7d			jsr ESwap
.a96d	20 9c a0	jsr $a09c			jsr EMinus	; 1+x 1-x
.a970	20 c9 8d	jsr $8dc9			jsr ESlash	; (1+x)/(1-x)
.a973	20 0c a5	jsr $a50c			jsr ELn
.a976	4c 10 9f	jmp $9f10			jmp E2Slash
=27					CodeLen	.var *-XtPtr1
=$a979					Here1 = *	; remember here
>a95c	1b					.byte CodeLen	;patch wh_CodeLength
>a979	45 41 43 6f 74 48		Name0:	.text "EACotH"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=43263					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>a97f	06					.byte (("EACotH"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=37					LinkDisplacement = Nt0-WordListLink
>a980	10					.byte WordFlags	;wh_Flags
>a981	03					.byte 3	;wh_CodeLength
>a982	25					  .byte LinkDisplacement	; offset to previous nt
=$a983					XtPtr1 ::= *
=43263					WordListLink ::= Nt0 ; remember the nt of this word for later
.a983	20 23 8e	jsr $8e23	EACotH: 	jsr E1Slash
.a986	4c 5e a9	jmp $a95e			jmp EATanH
=6					CodeLen	.var *-XtPtr1
=$a989					Here1 = *	; remember here
>a981	06					.byte CodeLen	;patch wh_CodeLength
>a989	45 64				Name0:	.text "Ed"	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=43275					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>a98b	82					.byte (("Ed"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=12					LinkDisplacement = Nt0-WordListLink
>a98c	10					.byte WordFlags	;wh_Flags
>a98d	03					.byte 3	;wh_CodeLength
>a98e	0c					  .byte LinkDisplacement	; offset to previous nt
=$a98f					XtPtr1 ::= *
=43275					WordListLink ::= Nt0 ; remember the nt of this word for later
.a98f	4c 92 a9	jmp $a992	Ed:		jmp ed6502
=3					CodeLen	.var *-XtPtr1
=$a992					Here1 = *	; remember here
>a98d	03					.byte CodeLen	;patch wh_CodeLength
=$1e					ed_head	 = editor1  ; pointer to first list element (addr) (2 bytes)
=$20					ed_cur	 = editor2  ; current line number (1 is first line) (2 bytes)
=$22					ed_flags = editor3  ; Flags used by ed, where
.a992					ed6502:
.a992	ad 00 03	lda $0300			lda base
.a995	85 23		sta $23				sta editor3+1
.a997	20 b6 c1	jsr $c1b6			jsr Decimal
.a99a	a9 00		lda #$00			lda #0
.a99c	85 1e		sta $1e				sta ed_head
.a99e	85 1f		sta $1f				sta ed_head+1
.a9a0	85 20		sta $20				sta ed_cur
.a9a2	85 21		sta $21				sta ed_cur+1
.a9a4	85 22		sta $22				sta ed_flags
.a9a6	20 f7 c7	jsr $c7f7			jsr Zero
.a9a9	20 f7 c7	jsr $c7f7			jsr Zero		; ( addr-t u-t )
.a9ac	20 4c bb	jsr $bb4c			jsr CR
.a9af					ed_input_loop:
.a9af	a9 7e		lda #$7e			lda #$ff-%10000001
.a9b1	25 22		and $22				and ed_flags
.a9b3	85 22		sta $22				sta ed_flags
.a9b5	20 54 ae	jsr $ae54			jsr ed_get_input
.a9b8	a5 06		lda $06				lda ciblen+0
.a9ba	d0 1e		bne $a9da			bne _command_mode
.a9bc	a5 20		lda $20				lda ed_cur+0
.a9be	a4 21		ldy $21				ldy ed_cur+1
.a9c0	20 ba c7	jsr $c7ba			jsr PushYA		; ( addr-t u-t u )
.a9c3	a9 80		lda #$80			lda #%10000000
.a9c5	05 22		ora $22				ora ed_flags
.a9c7	85 22		sta $22				sta ed_flags
.a9c9	20 9a da	jsr $da9a			jsr One_Plus		; ( addr-t u-t u+1 )
.a9cc	20 6f ae	jsr $ae6f			jsr ed_is_valid_line
.a9cf	b0 03		bcs $a9d4			bcs +
.a9d1	4c 44 ae	jmp $ae44			jmp ed_error_1drop	; New line number is not legal, abort
.a9d4					+
.a9d4	20 f7 c7	jsr $c7f7			jsr Zero		; ( addr-t u-t u+1 0 )
.a9d7	4c 99 aa	jmp $aa99			jmp _line_number_only_from_external
.a9da					_command_mode:
.a9da	20 f7 c7	jsr $c7f7			jsr Zero		; parameter 1 is NOS ( addr-t u-t 0 )
.a9dd	20 f7 c7	jsr $c7f7			jsr Zero		; parameter 2 is TOS ( addr-t u-t 0 0 )
.a9e0	a0 00		ldy #$00			ldy #0			; get char
.a9e2	b1 04		lda ($04),y			lda (cib),y
.a9e4	c9 2e		cmp #$2e			cmp #'.'
.a9e6	d0 31		bne $aa19			bne _prefix_dollar
.a9e8	20 63 ae	jsr $ae63			jsr ed_have_text
.a9eb	a5 20		lda $20				lda ed_cur
.a9ed	95 26		sta $26,x			sta DStack+2,x
.a9ef	a5 21		lda $21				lda ed_cur+1
.a9f1	95 27		sta $27,x			sta DStack+3,x		; ( addr-t u-t cur 0 )
.a9f3	a9 80		lda #$80			lda #%10000000
.a9f5	05 22		ora $22				ora ed_flags
.a9f7	85 22		sta $22				sta ed_flags
.a9f9	a5 06		lda $06				lda ciblen
.a9fb	c9 01		cmp #$01			cmp #1			; sets Z if A was 1
.a9fd	d0 03		bne $aa02			bne +
.a9ff	4c 99 aa	jmp $aa99			jmp _line_number_only_from_external
.aa02					+
.aa02	a5 04		lda $04				lda cib+0
.aa04	a4 05		ldy $05				ldy cib+1
.aa06	20 ba c7	jsr $c7ba			jsr PushYA
.aa09	a5 06		lda $06				lda ciblen+0
.aa0b	a4 07		ldy $07				ldy ciblen+1
.aa0d	20 ba c7	jsr $c7ba			jsr PushYA
.aa10	20 74 da	jsr $da74			jsr One_Minus		; ( addr-t u-t para1 0 addr u-1 )
.aa13	20 a5 da	jsr $daa5			jsr NOS_One_Plus	; ( addr-t u-t para1 0 addr+1 u-1 )
.aa16	4c eb aa	jmp $aaeb			jmp _check_for_para2
.aa19					_prefix_dollar:
.aa19	c9 24		cmp #$24			cmp #'$'
.aa1b	d0 1f		bne $aa3c			bne _prefix_percent
.aa1d	20 63 ae	jsr $ae63			jsr ed_have_text
.aa20	e8		inx				inx
.aa21	e8		inx				inx			; ( addr-t u-t 0 )
.aa22	20 90 ae	jsr $ae90			jsr ed_last_line	; ( addr-t u-t 0 para1 )
.aa25	20 f3 df	jsr $dff3			jsr Swap		; ( addr-t u-t para1 0 )
.aa28	a9 80		lda #$80			lda #%10000000
.aa2a	05 22		ora $22				ora ed_flags
.aa2c	85 22		sta $22				sta ed_flags
.aa2e	a5 06		lda $06				lda ciblen
.aa30	c9 01		cmp #$01			cmp #1			; sets Z if A was 1
.aa32	d0 03		bne $aa37			bne +
.aa34	4c 99 aa	jmp $aa99			jmp _line_number_only_from_external
.aa37					+
.aa37	a0 01		ldy #$01			ldy #1
.aa39	4c 61 ab	jmp $ab61			jmp _check_command
.aa3c					_prefix_percent:
.aa3c	c9 25		cmp #$25			cmp #'%'
.aa3e	f0 04		beq $aa44			beq _whole_text
.aa40	c9 2c		cmp #$2c			cmp #','
.aa42	d0 1b		bne $aa5f			bne _prefix_semicolon
.aa44					_whole_text:
.aa44	20 63 ae	jsr $ae63			jsr ed_have_text
.aa47	a9 01		lda #$01			lda #1
.aa49	95 26		sta $26,x			sta DStack+2,x		; LSB of NOS is para 1
.aa4b	a9 00		lda #$00			lda #0
.aa4d	95 27		sta $27,x			sta DStack+3,x		; ( addr-t u-t para1 0 )
.aa4f					_semicolon_entry:
.aa4f	e8		inx				inx
.aa50	e8		inx				inx			; DROP ( addr-t u-t para1 )
.aa51	20 90 ae	jsr $ae90			jsr ed_last_line	  ; ( addr-t u-t para1 para2 )
.aa54	a9 80		lda #$80			lda #%10000000
.aa56	05 22		ora $22				ora ed_flags
.aa58	85 22		sta $22				sta ed_flags
.aa5a	a0 01		ldy #$01			ldy #1
.aa5c	4c 61 ab	jmp $ab61			jmp _check_command
.aa5f					_prefix_semicolon:
.aa5f	c9 3b		cmp #$3b			cmp #';'
.aa61	d0 0e		bne $aa71			bne _prefix_number
.aa63	20 63 ae	jsr $ae63			jsr ed_have_text
.aa66	a5 20		lda $20				lda ed_cur
.aa68	95 26		sta $26,x			sta DStack+2,x
.aa6a	a5 21		lda $21				lda ed_cur+1
.aa6c	95 27		sta $27,x			sta DStack+3,x		; ( addr-t u-t cur 0 )
.aa6e	4c 4f aa	jmp $aa4f			jmp _semicolon_entry
.aa71					_prefix_number:
.aa71	20 f7 c7	jsr $c7f7			jsr Zero
.aa74	20 f7 c7	jsr $c7f7			jsr Zero		; ( addr-t u-t 0 0 0 0 )
.aa77	a5 04		lda $04				lda cib+0
.aa79	a4 05		ldy $05				ldy cib+1
.aa7b	20 ba c7	jsr $c7ba			jsr PushYA
.aa7e	a5 06		lda $06				lda ciblen+0
.aa80	a4 07		ldy $07				ldy ciblen+1
.aa82	20 ba c7	jsr $c7ba			jsr PushYA		; ( addr-t u-t 0 0 0 0 cib ciblen )
.aa85	20 39 c0	jsr $c039			jsr To_Number		; ( addr-t u-t 0 0 ud addr2 u2 )
.aa88	b5 24		lda $24,x			lda DStack+0,x
.aa8a	15 25		ora $25,x			ora DStack+1,x
.aa8c	d0 25		bne $aab3			bne _have_unconverted_chars
.aa8e	20 72 d5	jsr $d572			jsr Two_Drop		; ( addr-t u-t 0 0 ud )
.aa91	20 24 d0	jsr $d024			jsr D_To_S		; ( addr-t u-t 0 0 u )
.aa94	20 d8 de	jsr $ded8			jsr Not_Rot		; ( addr-t u-t u 0 0 )
.aa97	e8		inx				inx
.aa98	e8		inx				inx			; ( addr-t u-t u 0 ) drop through
.aa99					_line_number_only_from_external:
.aa99	20 f3 df	jsr $dff3			jsr Swap		; ( addr-t u-t 0 u )
.aa9c	20 6f ae	jsr $ae6f			jsr ed_is_valid_line
.aa9f	b0 03		bcs $aaa4			bcs +
.aaa1	4c 42 ae	jmp $ae42			jmp ed_error_2drop
.aaa4					+
.aaa4	20 f3 df	jsr $dff3			jsr Swap		; ( addr-t u-t u 0 )
.aaa7	20 cf ae	jsr $aecf			jsr ed_para1_to_cur
.aaaa	a9 80		lda #$80			lda #%10000000
.aaac	05 22		ora $22				ora ed_flags
.aaae	85 22		sta $22				sta ed_flags
.aab0	4c 2d ad	jmp $ad2d			jmp ed_cmd_p_from_external
.aab3					_have_unconverted_chars:
.aab3	a5 06		lda $06				lda ciblen+0
.aab5	d5 24		cmp $24,x			cmp DStack+0,x
.aab7	d0 16		bne $aacf			bne _no_command_yet
.aab9	a5 07		lda $07				lda ciblen+1
.aabb	d5 25		cmp $25,x			cmp DStack+1,x
.aabd	d0 10		bne $aacf			bne _no_command_yet
.aabf	8a		txa				txa
.aac0	18		clc				clc
.aac1	69 08		adc #$08			adc #8
.aac3	aa		tax				tax			; ( addr-t u-t 0 0 )
.aac4	a9 7f		lda #$7f			lda #$ff-%10000000
.aac6	25 22		and $22				and ed_flags
.aac8	85 22		sta $22				sta ed_flags
.aaca	a0 00		ldy #$00			ldy #0
.aacc	4c 61 ab	jmp $ab61			jmp _check_command
.aacf					_no_command_yet:
.aacf	20 42 df	jsr $df42			jsr To_R		; >R ( ... 0 0 ud addr2 ) (R: u2)
.aad2	20 d8 de	jsr $ded8			jsr Not_Rot		; -ROT ( ... 0 0 addr2 ud ) (R: u2)
.aad5	20 24 d0	jsr $d024			jsr D_To_S		; D>S  ( ... 0 0 addr2 para1 ) (R: u2)
.aad8	b5 24		lda $24,x			lda DStack+0,x		; LSB
.aada	95 2a		sta $2a,x			sta DStack+6,x
.aadc	b5 25		lda $25,x			lda DStack+1,x		; MSB
.aade	95 2b		sta $2b,x			sta DStack+7,x		; ( ... para1 0 addr2 para1 ) (R: u2)
.aae0	e8		inx				inx
.aae1	e8		inx				inx			; ( addr-t u-t para1 0 addr2 ) (R: u2)
.aae2	20 60 df	jsr $df60			jsr R_From		; R> ( addr-t u-t para1 0 addr2 u2 ) fall through
.aae5	a9 80		lda #$80			lda #%10000000
.aae7	05 22		ora $22				ora ed_flags
.aae9	85 22		sta $22				sta ed_flags
.aaeb					_check_for_para2:
.aaeb	a1 26		lda ($26,x)			lda (DStack+2,x)
.aaed	c9 2c		cmp #$2c			cmp #','
.aaef	f0 0c		beq $aafd			beq _got_comma
.aaf1	38		sec				sec
.aaf2	a5 06		lda $06				lda ciblen
.aaf4	f5 24		sbc $24,x			sbc DStack+0,x
.aaf6	a8		tay				tay
.aaf7	20 72 d5	jsr $d572			jsr Two_Drop		; Remove the leftover stuff from >NUMBER
.aafa	4c 61 ab	jmp $ab61			jmp _check_command
.aafd					_got_comma:
.aafd	20 a5 da	jsr $daa5			jsr NOS_One_Plus	; ( addr-t u-t para1 0 addr2+1 u2 )
.ab00	20 74 da	jsr $da74			jsr One_Minus		; ( addr-t u-t para1 0 addr2+1 u2-1 )
.ab03	a1 26		lda ($26,x)			lda (DStack+2,x)
.ab05	c9 24		cmp #$24			cmp #'$'
.ab07	d0 16		bne $ab1f			bne _para2_not_dollar
.ab09	38		sec				sec
.ab0a	a5 06		lda $06				lda ciblen
.ab0c	f5 26		sbc $26,x			sbc DStack+2,x
.ab0e	a8		tay				tay
.ab0f	c8		iny				iny
.ab10	98		tya				tya
.ab11	48		pha				pha
.ab12	8a		txa				txa
.ab13	18		clc				clc
.ab14	69 06		adc #$06			adc #6
.ab16	aa		tax				tax			; ( addr-t u-t para1 )
.ab17	20 90 ae	jsr $ae90			jsr ed_last_line	  ; ( addr-t u-t para1 para2 )
.ab1a	68		pla				pla
.ab1b	a8		tay				tay
.ab1c	4c 61 ab	jmp $ab61			jmp _check_command
.ab1f					_para2_not_dollar:
.ab1f	20 42 df	jsr $df42			jsr To_R		; >R ( ... para1 0 addr2+1 ) (R: u2-1)
.ab22	20 f7 c7	jsr $c7f7			jsr Zero		; 0 ( ... para1 0 addr2+1 0 ) (R: u2-1)
.ab25	20 f7 c7	jsr $c7f7			jsr Zero		; 0 ( ... para1 0 addr2+1 0 0 ) (R: u2-1)
.ab28	20 b3 de	jsr $deb3			jsr Rot		; ROT ( ... para1 0 0 0 addr2+1 ) (R: u2-1)
.ab2b	20 60 df	jsr $df60			jsr R_From		; R> ( ... para1 0 0 0 addr2+1 u2-1)
.ab2e	20 d2 df	jsr $dfd2			jsr Dup		; DUP ( ... para1 0 0 0 addr2+1 u2-1 u2-1)
.ab31	20 42 df	jsr $df42			jsr To_R		; >R ( ... para1 0 0 0 addr2+1 u2-1 ) (R: u2-1)
.ab34	20 39 c0	jsr $c039			jsr To_Number	; >NUMBER ( ... para1 0 ud addr3 u3 ) (R: u2-1)
.ab37	20 d2 df	jsr $dfd2			jsr Dup		; DUP ( ... para1 0 ud addr3 u3 u3 ) (R: u2-1)
.ab3a	20 60 df	jsr $df60			jsr R_From		; R> ( ... para1 0 ud addr3 u3 u3 u2-1 )
.ab3d	20 7e d8	jsr $d87e			jsr Equal		; = ( ... para1 0 ud addr3 u3 f )
.ab40	b5 24		lda $24,x			lda DStack+0,x
.ab42	15 25		ora $25,x			ora DStack+1,x
.ab44	f0 08		beq $ab4e			beq _second_number
.ab46	8a		txa				txa
.ab47	18		clc				clc
.ab48	69 0c		adc #$0c			adc #12
.ab4a	aa		tax				tax			; back to ( addr-t u-t )
.ab4b	4c 46 ae	jmp $ae46			jmp ed_error
.ab4e					_second_number:
.ab4e	e8		inx				inx
.ab4f	e8		inx				inx			; ( addr-t u-t para1 0 ud addr3 u3 )
.ab50	38		sec				sec
.ab51	a5 06		lda $06				lda ciblen
.ab53	f5 24		sbc $24,x			sbc DStack+0,x
.ab55	48		pha				pha
.ab56	20 72 d5	jsr $d572			jsr Two_drop		; 2DROP ( addr-t u-t para1 0 ud )
.ab59	20 24 d0	jsr $d024			jsr D_To_S		; D>S  ( addr-t u-t para1 0 para2 )
.ab5c	20 cd d9	jsr $d9cd			jsr Nip			; NIP ( addr-t u-t para1 para2 )
.ab5f	68		pla				pla
.ab60	a8		tay				tay
.ab61					_check_command:
.ab61	24 22		bit $22				bit ed_flags
.ab63	30 08		bmi $ab6d			bmi _check_command_have_arg
.ab65	a5 20		lda $20				lda ed_cur+0
.ab67	95 26		sta $26,x			sta DStack+2,x
.ab69	a5 21		lda $21				lda ed_cur+1
.ab6b	95 27		sta $27,x			sta DStack+3,x
.ab6d					_check_command_have_arg:
.ab6d	b1 04		lda ($04),y			lda (cib),y		; get mystery char from input
.ab6f	85 14		sta $14				sta tmp1+0
.ab71	85 15		sta $15				sta tmp1+1		; We need X for awhile, so it has to
.ab73	a2 ff		ldx #$ff			ldx #$ff		; for each char
.ab75	e8		inx		_cmd_loop:	inx			;   next char
.ab76	bd f3 ae	lda $aef3,x			lda ed_cmd_list,x
.ab79	f0 13		beq $ab8e			beq _illegal_command	;   end of list?
.ab7b	c5 14		cmp $14				cmp tmp1+0
.ab7d	d0 f6		bne $ab75			bne _cmd_loop		;   not found?
.ab7f	8a		txa				txa
.ab80	0a		asl a				asl
.ab81	aa		tax				tax			; X * 2 for table
.ab82	bd ff ae	lda $aeff,x			lda ed_cmd_table+1,x
.ab85	48		pha				pha
.ab86	bd fe ae	lda $aefe,x			lda ed_Cmd_table+0,x
.ab89	48		pha				pha
.ab8a	a6 15		ldx $15				ldx tmp1+1		; restore X
.ab8c	08		php				php
.ab8d	40		rti				rti			; jump to command routine
.ab8e					_illegal_command:
.ab8e	4c 42 ae	jmp $ae42			jmp ed_error_2drop
.ab91					ed_next_command:
.ab91	20 72 d5	jsr $d572			jsr Two_Drop		; ( addr-t u-t ) Fall through
.ab94					_next_command_empty:
.ab94	4c af a9	jmp $a9af			jmp ed_input_loop
.ab97					ed_all_done:
.ab97	a9 00		lda #$00			lda #0
.ab99	85 06		sta $06				sta ciblen
.ab9b	85 07		sta $07				sta ciblen+1
.ab9d	20 72 d5	jsr $d572			jsr Two_drop			; ( addr-t u-t )
.aba0	a5 23		lda $23				lda editor3+1
.aba2	8d 00 03	sta $0300			sta base
.aba5	60		rts				rts
.aba6					ed_cmd_a:
.aba6	e8		inx				inx
.aba7	e8		inx				inx			;  DROP ( addr-t u-t para1 )
.aba8					ed_entry_cmd_i:
.aba8					ed_cmd_a_have_para:
.aba8	20 b4 ae	jsr $aeb4			jsr ed_num_to_addr	  ;  ( addr-t u-t addr1 )
.abab	20 4c bb	jsr $bb4c			jsr CR
.abae					_next_string_loop:
.abae	20 54 ae	jsr $ae54			jsr ed_get_input
.abb1	a0 00		ldy #$00			ldy #0
.abb3	b1 04		lda ($04),y			lda (cib),y
.abb5	c9 2e		cmp #$2e			cmp #'.'
.abb7	d0 18		bne $abd1			bne _add_line
.abb9	a4 06		ldy $06				ldy ciblen
.abbb	c0 01		cpy #$01			cpy #1
.abbd	d0 12		bne $abd1			bne _add_line
.abbf	a4 07		ldy $07				ldy ciblen+1
.abc1	d0 0e		bne $abd1			bne _add_line
.abc3	e8		inx				inx
.abc4	e8		inx				inx
.abc5	a9 40		lda #$40			lda #%01000000
.abc7	05 22		ora $22				ora ed_flags
.abc9	85 22		sta $22				sta ed_flags
.abcb	20 4c bb	jsr $bb4c			jsr CR
.abce	4c af a9	jmp $a9af			jmp ed_input_loop
.abd1					_add_line:
.abd1	20 d2 df	jsr $dfd2			jsr Dup			; ( addr-t u-t addr1 addr1 )
.abd4	20 67 da	jsr $da67			jsr Here		; ( addr-t u-t addr1 addr1 here )
.abd7	20 f3 df	jsr $dff3			jsr Swap		; ( addr-t u-t addr1 here addr1 )
.abda	20 fa de	jsr $defa			jsr Fetch		; ( addr-t u-t addr1 here addr2 )
.abdd	20 52 dd	jsr $dd52			jsr Comma		; ( addr-t u-t addr1 here )
.abe0	20 1a dd	jsr $dd1a			jsr Tuck		; TUCK ( addr-t u-t here addr1 here )
.abe3	20 f3 df	jsr $dff3			jsr Swap		; ( addr-t u-t here here addr1 )
.abe6	20 13 df	jsr $df13			jsr Store		; ( addr-t u-t here )
.abe9	20 67 da	jsr $da67			jsr Here		; HERE ( addr-t u-t here here2)
.abec	a9 04		lda #$04			lda #4
.abee	20 b7 d0	jsr $d0b7			jsr Allot_ZA
.abf1	e6 20		inc $20				inc ed_cur
.abf3	d0 02		bne $abf7			bne +
.abf5	e6 21		inc $21				inc ed_cur+1
.abf7					+
.abf7	20 67 da	jsr $da67			jsr Here	; ( addr-t u-t here here2 here3 )
.abfa	a5 04		lda $04				lda cib+0
.abfc	a4 05		ldy $05				ldy cib+1
.abfe	20 ba c7	jsr $c7ba			jsr PushYA	; ( addr-t u-t here here2 here3 cib )
.ac01	20 a9 df	jsr $dfa9			jsr Over	; ( addr-t u-t here here2 here3 cib here3 )
.ac04	a5 06		lda $06				lda ciblen+0
.ac06	a4 07		ldy $07				ldy ciblen+1
.ac08	20 ba c7	jsr $c7ba			jsr PushYA	; ( addr-t u-t here here2 here3 cib here3 ciblen )
.ac0b	20 64 bd	jsr $bd64			jsr Move	; ( addr-t u-t here here2 here3 )
.ac0e	18		clc				clc
.ac0f	a5 00		lda $00				lda cp
.ac11	65 06		adc $06				adc ciblen
.ac13	85 00		sta $00				sta cp
.ac15	90 06		bcc $ac1d			bcc +
.ac17	a5 01		lda $01				lda cp+1
.ac19	65 07		adc $07				adc ciblen+1
.ac1b	85 01		sta $01				sta cp+1
.ac1d					+
.ac1d	20 a9 df	jsr $dfa9			jsr Over		; ( addr-t u-t here here2 here3 here2 )
.ac20	20 13 df	jsr $df13			jsr Store		; ( addr-t u-t here here2 )
.ac23	20 46 da	jsr $da46			jsr Cell_Plus		; ( addr-t u-t here here2+2 )
.ac26	20 d2 df	jsr $dfd2			jsr Dup			; ( addr-t u-t here here2+2 here2+2 )
.ac29	a5 06		lda $06				lda ciblen
.ac2b	95 26		sta $26,x			sta DStack+2,x
.ac2d	a5 07		lda $07				lda ciblen+1
.ac2f	95 27		sta $27,x			sta DStack+3,x		; ( addr-t u-t here ciblen here2+2 )
.ac31	20 13 df	jsr $df13			jsr Store		; ( addr-t u-t here )
.ac34	20 4c bb	jsr $bb4c			jsr CR			; Add a line feed for visuals
.ac37	4c ae ab	jmp $abae			jmp _next_string_loop
.ac3a					ed_cmd_d:
.ac3a	20 63 ae	jsr $ae63			jsr ed_have_text
.ac3d	20 a6 ae	jsr $aea6			jsr ed_no_line_zero
.ac40	b5 24		lda $24,x			lda DStack+0,x
.ac42	15 25		ora $25,x			ora DStack+1,x
.ac44	d0 09		bne $ac4f			bne +
.ac46	20 a9 df	jsr $dfa9			jsr Over		; ( addr-t u-t para1 0 para1 )
.ac49	20 84 ac	jsr $ac84			jsr _cmd_d_common	; ( addr-t u-t para1 0 )
.ac4c	4c 78 ac	jmp $ac78			jmp _cmd_d_done
.ac4f					+
.ac4f	20 6f ae	jsr $ae6f			jsr ed_is_valid_line	  ; result is in C flag
.ac52	b0 03		bcs $ac57			bcs _cmd_d_loop
.ac54	4c 42 ae	jmp $ae42			jmp ed_error_2drop
.ac57					_cmd_d_loop:
.ac57	b5 24		lda $24,x			lda DStack+0,x		; para1 > para2 ?
.ac59	d5 26		cmp $26,x			cmp DStack+2,x
.ac5b	b5 25		lda $25,x			lda DStack+1,x
.ac5d	f5 27		sbc $27,x			sbc DStack+3,x
.ac5f	90 0c		bcc $ac6d			bcc _cmd_d_done_with_flag
.ac61	20 d2 df	jsr $dfd2			jsr Dup		; DUP ( addr-t u-t para1 para2 para2 )
.ac64	20 84 ac	jsr $ac84			jsr _cmd_d_common	; ( addr-t u-t para1 para2 )
.ac67	20 74 da	jsr $da74			jsr One_minus	; 1- ( addr-t u-t para1 para2-1 )
.ac6a	4c 57 ac	jmp $ac57			jmp _cmd_d_loop
.ac6d					_cmd_d_done_with_flag:
.ac6d	20 81 da	jsr $da81			jsr NOS_One_Minus
.ac70	b5 26		lda $26,x			lda DStack+2,x
.ac72	85 20		sta $20				sta ed_cur
.ac74	b5 27		lda $27,x			lda DStack+3,x
.ac76	85 21		sta $21				sta ed_cur+1		; drop through to _cmd_d_done
.ac78					_cmd_d_done:
.ac78	a9 40		lda #$40			lda #%01000000
.ac7a	05 22		ora $22				ora ed_flags
.ac7c	85 22		sta $22				sta ed_flags
.ac7e	20 4c bb	jsr $bb4c			jsr CR
.ac81	4c 91 ab	jmp $ab91			jmp ed_next_command
.ac84					_cmd_d_common:
.ac84	20 d2 df	jsr $dfd2			jsr Dup			; ( addr-t u-t u u )
.ac87	20 b4 ae	jsr $aeb4			jsr ed_num_to_addr	; ( addr-t u-t u addr )
.ac8a	20 fa de	jsr $defa			jsr Fetch		; ( addr-t u-t u addr1 )
.ac8d	20 f3 df	jsr $dff3			jsr Swap		; ( addr-t u-t addr1 u )
.ac90	20 74 da	jsr $da74			jsr One_minus		; ( addr-t u-t addr1 u-1 )
.ac93	20 b4 ae	jsr $aeb4			jsr ed_num_to_addr	; ( addr-t u-t addr1 addr-1 )
.ac96	4c 13 df	jmp $df13			jmp Store		; ( addr-t u-t )
.ac99					ed_cmd_equ:
.ac99	a5 1e		lda $1e				lda ed_head
.ac9b	05 1f		ora $1f				ora ed_head+1
.ac9d	d0 06		bne $aca5			bne _cmd_equ_have_text
.ac9f	20 f7 c7	jsr $c7f7			jsr Zero		; ( addr-t u-t para1 para2 0 )
.aca2	4c c5 ac	jmp $acc5			jmp _cmd_equ_done
.aca5					_cmd_equ_have_text:
.aca5	20 a6 ae	jsr $aea6			jsr ed_no_line_zero
.aca8	24 22		bit $22				bit ed_flags
.acaa	30 0a		bmi $acb6			bmi _cmd_equ_have_para
.acac	a5 20		lda $20				lda ed_cur+0		; ( addr-t u-t para1 para2 ? )
.acae	a4 21		ldy $21				ldy ed_cur+1
.acb0	20 ba c7	jsr $c7ba			jsr PushYA
.acb3	4c c5 ac	jmp $acc5			jmp _cmd_equ_done	; ( addr-t u-t para1 para2 cur )
.acb6					_cmd_equ_have_para:
.acb6	b5 24		lda $24,x			lda DStack+0,x
.acb8	15 25		ora $25,x			ora DStack+1,x
.acba	d0 06		bne $acc2			bne _cmd_equ_two_paras
.acbc	20 a9 df	jsr $dfa9			jsr Over		; ( addr-t u-t para1 para2 para1)
.acbf	4c c5 ac	jmp $acc5			jmp _cmd_equ_done
.acc2					_cmd_equ_two_paras:
.acc2	20 d2 df	jsr $dfd2			jsr Dup			; ( addr-t u-t para1 para2 para2) drop through
.acc5					_cmd_equ_done:
.acc5	20 4c bb	jsr $bb4c			jsr CR			; number goes on new line
.acc8	20 52 dc	jsr $dc52			jsr U_Dot		; ( addr-t u-t para1 para2 )
.accb	20 4c bb	jsr $bb4c			jsr CR
.acce	4c 91 ab	jmp $ab91			jmp ed_next_command
.acd1					ed_cmd_f:
.acd1	24 22		bit $22				bit ed_flags
.acd3	30 18		bmi $aced			bmi _cmd_f_have_para
.acd5	20 4c bb	jsr $bb4c			jsr CR
.acd8	20 42 df	jsr $df42			jsr To_R		; ( addr-t u-t 0 ) ( R: 0 )
.acdb	20 b3 de	jsr $deb3			jsr Rot			; ( u-t 0 addr-t ) ( R: 0 )
.acde	20 d2 df	jsr $dfd2			jsr Dup			; ( u-t 0 addr-t addr-t ) ( R: 0 )
.ace1	20 52 dc	jsr $dc52			jsr U_Dot		; ( u-t 0 addr-t ) ( R: 0 )
.ace4	20 d8 de	jsr $ded8			jsr Not_Rot		; ( addr-t u-t 0 ) ( R: 0 )
.ace7	20 60 df	jsr $df60			jsr R_From		; ( addr-t u-t 0 0 )
.acea	4c fe ac	jmp $acfe			jmp _cmd_f_done
.aced					_cmd_f_have_para:
.aced	20 a9 df	jsr $dfa9			jsr Over
.acf0	20 4c bb	jsr $bb4c			jsr CR
.acf3	20 52 dc	jsr $dc52			jsr U_Dot
.acf6	b5 26		lda $26,x			lda DStack+2,x
.acf8	95 2a		sta $2a,x			sta DStack+6,x
.acfa	b5 27		lda $27,x			lda DStack+3,x
.acfc	95 2b		sta $2b,x			sta DStack+7,x		; fall through to _cmd_f_done
.acfe					_cmd_f_done:
.acfe	20 4c bb	jsr $bb4c			jsr CR
.ad01	4c 91 ab	jmp $ab91			jmp ed_next_command
.ad04					ed_cmd_i:
.ad04	e8		inx				inx
.ad05	e8		inx				inx			;  DROP ( addr-t u-t para1 )
.ad06	24 22		bit $22				bit ed_flags
.ad08	30 08		bmi $ad12			bmi _cmd_i_have_para
.ad0a	a5 20		lda $20				lda ed_cur
.ad0c	95 24		sta $24,x			sta DStack+0,x
.ad0e	a5 21		lda $21				lda ed_cur+1
.ad10	95 25		sta $25,x			sta DStack+1,x		;  ( addr-t u-t cur ) drop through
.ad12					_cmd_i_have_para:
.ad12	b5 24		lda $24,x			lda DStack+0,x
.ad14	15 25		ora $25,x			ora DStack+1,x
.ad16	f0 09		beq $ad21			beq _cmd_i_done
.ad18	20 74 da	jsr $da74			jsr One_minus		; ( addr-t u-t para1-1 )
.ad1b	20 f7 c7	jsr $c7f7			jsr Zero		; ( addr-t u-t para1-1 0 )
.ad1e	20 b3 d9	jsr $d9b3			jsr Max			; ( addr-t u-t para1-1 | 0 )
.ad21					_cmd_i_done:
.ad21	4c a8 ab	jmp $aba8			jmp ed_entry_cmd_i
.ad24					ed_cmd_n:
.ad24	a9 01		lda #$01			lda #%00000001
.ad26	05 22		ora $22				ora ed_flags
.ad28	85 22		sta $22				sta ed_flags
.ad2a	4c 33 ad	jmp $ad33			jmp ed_cmd_p_entry_for_cmd_n
.ad2d					ed_cmd_p:
.ad2d					ed_cmd_p_from_external:
.ad2d	a9 fe		lda #$fe			lda #$ff-%00000001
.ad2f	25 22		and $22				and ed_flags
.ad31	85 22		sta $22				sta ed_flags
.ad33					ed_cmd_p_entry_for_cmd_n:
.ad33	20 63 ae	jsr $ae63			jsr ed_have_text
.ad36	20 a6 ae	jsr $aea6			jsr ed_no_line_zero
.ad39	20 4c bb	jsr $bb4c			jsr CR
.ad3c	b5 24		lda $24,x			lda DStack+0,x
.ad3e	15 25		ora $25,x			ora DStack+1,x
.ad40	d0 11		bne $ad53			bne _cmd_p_loop
.ad42	b5 26		lda $26,x			lda DStack+2,x
.ad44	85 20		sta $20				sta ed_cur
.ad46	b5 27		lda $27,x			lda DStack+3,x
.ad48	85 21		sta $21				sta ed_cur+1
.ad4a	20 a9 df	jsr $dfa9			jsr Over		; ( addr-t u-t para1 para2 para1 )
.ad4d	20 74 ad	jsr $ad74			jsr _cmd_p_common	; ( addr-t u-t para1 para2 )
.ad50	4c 71 ad	jmp $ad71			jmp _cmd_p_all_done
.ad53					_cmd_p_loop:
.ad53	b5 24		lda $24,x			lda DStack+0,x		; para1 > para2 ?
.ad55	d5 26		cmp $26,x			cmp DStack+2,x
.ad57	b5 25		lda $25,x			lda DStack+1,x
.ad59	f5 27		sbc $27,x			sbc DStack+3,x
.ad5b	90 0c		bcc $ad69			bcc _cmd_p_done
.ad5d	20 a9 df	jsr $dfa9			jsr Over		; ( addr-t u-t para1 para2 para1 )
.ad60	20 74 ad	jsr $ad74			jsr _cmd_p_common	; ( addr-t u-t para1 para2 )
.ad63	20 a5 da	jsr $daa5			jsr NOS_One_Plus
.ad66	4c 53 ad	jmp $ad53			jmp _cmd_p_loop
.ad69					_cmd_p_done:
.ad69	b5 24		lda $24,x			lda DStack+0,x
.ad6b	85 20		sta $20				sta ed_cur
.ad6d	b5 25		lda $25,x			lda DStack+1,x
.ad6f	85 21		sta $21				sta ed_cur+1
.ad71					_cmd_p_all_done:
.ad71	4c 91 ab	jmp $ab91			jmp ed_next_command
.ad74					_cmd_p_common:
.ad74	a5 22		lda $22				lda ed_flags
.ad76	4a		lsr a				lsr			; bit 0 now in carry
.ad77	90 0b		bcc $ad84			bcc _cmd_p_common_no_num
.ad79	20 d2 df	jsr $dfd2			jsr Dup			; ( addr-t u-t para1 para1 )
.ad7c	20 52 dc	jsr $dc52			jsr U_Dot		; ( addr-t u-t para1 )
.ad7f	a9 09		lda #$09			lda #AscHT
.ad81	20 21 de	jsr $de21			jsr Emit_A
.ad84					_cmd_p_common_no_num:
.ad84	20 b4 ae	jsr $aeb4			jsr ed_num_to_addr	  ; ( addr-t u-t addr )
.ad87	4c d8 ae	jmp $aed8			jmp ed_print_addr
.ad8a					ed_cmd_q:
.ad8a	24 22		bit $22				bit ed_flags		; bit 6 is change flag
.ad8c	50 03		bvc $ad91			bvc +
.ad8e	4c 42 ae	jmp $ae42			jmp ed_error_2drop
.ad91					+
.ad91	4c 97 ab	jmp $ab97			jmp ed_all_done		   ; can't fall thru because of PLX
.ad94					ed_cmd_qq:
.ad94	4c 97 ab	jmp $ab97			jmp ed_all_done
.ad97					ed_cmd_w:
.ad97	20 63 ae	jsr $ae63			jsr ed_have_text
.ad9a	24 22		bit $22				bit ed_flags		; parameter given?
.ad9c	30 12		bmi $adb0			bmi _cmd_w_have_para
.ad9e	b5 2b		lda $2b,x			lda DStack+7,x		; $0000 thru $00ff ?
.ada0	d0 03		bne $ada5			bne +
.ada2	4c 42 ae	jmp $ae42			jmp ed_error_2drop
.ada5					+
.ada5	b5 2a		lda $2a,x			lda DStack+6,x
.ada7	95 26		sta $26,x			sta DStack+2,x
.ada9	b5 2b		lda $2b,x			lda DStack+7,x
.adab	95 27		sta $27,x			sta DStack+3,x		; ( addr-t u-t addr-t ? )
.adad	4c b8 ad	jmp $adb8			jmp _cmd_w_para_ready
.adb0					_cmd_w_have_para:
.adb0	b5 26		lda $26,x			lda DStack+2,x
.adb2	95 2a		sta $2a,x			sta DStack+6,x
.adb4	b5 27		lda $27,x			lda DStack+3,x
.adb6	95 2b		sta $2b,x			sta DStack+7,x		; drop through to _cmd_w_para_ready
.adb8					_cmd_w_para_ready:
.adb8	a9 1e		lda #$1e			lda #<ed_head
.adba	95 24		sta $24,x			sta DStack+0,x
.adbc	a9 00		lda #$00			lda #>ed_head
.adbe	95 25		sta $25,x			sta DStack+1,x		; ( addr-t u-t addr-t addr-h )
.adc0	20 a9 df	jsr $dfa9			jsr Over		; ( addr-t u-t addr-t addr-h addr-t )
.adc3	20 42 df	jsr $df42			jsr To_R		; ( addr-t u-t addr-t addr-h ) ( R: addr-t )
.adc6					_cmd_w_loop:
.adc6	20 fa de	jsr $defa			jsr Fetch		; ( addr-t u-t addr-t addr1 ) ( R: addr-t )
.adc9	b5 24		lda $24,x			lda DStack+0,x
.adcb	15 25		ora $25,x			ora DStack+1,x
.adcd	f0 4d		beq $ae1c			beq _cmd_w_eol
.adcf	20 f6 dc	jsr $dcf6			jsr Two_dup		; ( addr-t addr-1 addr-t addr-1 ) ( R: addr-t addr-1 addr-t )
.add2	20 a4 d6	jsr $d6a4			jsr Two_to_r		; ( addr-t addr-1 ) (R: ... )
.add5	20 46 da	jsr $da46			jsr Cell_Plus		; ( addr-t addr1+2 ) (R: ... )
.add8	20 d2 df	jsr $dfd2			jsr Dup			; ( addr-t addr1+2 addr1+2 ) ( R: ... )
.addb	20 fa de	jsr $defa			jsr Fetch		; ( addr-t addr1+2 addr-s ) ( R: ... )
.adde	20 f3 df	jsr $dff3			jsr Swap		; ( addr-t addr-s addr1+2 ) ( R: ... )
.ade1	20 46 da	jsr $da46			jsr Cell_Plus		; ( addr-t addr-s addr1+2 ) (R: ... )
.ade4	20 fa de	jsr $defa			jsr Fetch		; ( addr-t addr-s u-s ) ( R: ... )
.ade7	20 d8 de	jsr $ded8			jsr Not_Rot		; ( u-s addr-t addr-s ) ( R: ... )
.adea	20 f3 df	jsr $dff3			jsr Swap		; ( u-s addr-s addr-t ) ( R: ... )
.aded	20 b3 de	jsr $deb3			jsr Rot			; (addr-s addr-t u-s ) ( R: ... )
.adf0	20 d2 df	jsr $dfd2			jsr Dup			; (addr-s addr-t u-s u-s ) ( R: ... )
.adf3	20 42 df	jsr $df42			jsr To_R		; (addr-s addr-t u-s ) ( R: ... u-s )
.adf6	20 64 bd	jsr $bd64			jsr Move		; ( )( R: addr-t addr-1 addr-t )
.adf9	20 60 df	jsr $df60			jsr R_From		; ( u-s )  ( R: addr-t addr-h addr-t )
.adfc	20 80 d6	jsr $d680			jsr Two_r_from		; ( u-s addr-t addr-h ) ( R: addr-t )
.adff	20 d8 de	jsr $ded8			jsr Not_Rot		; ( addr-h u-s addr-t ) ( R: addr-t )
.ae02	20 ef db	jsr $dbef			jsr Plus		; ( addr-h addr-t1 ) ( R: addr-t )
.ae05	20 d2 df	jsr $dfd2			jsr Dup			; ( addr-h addr-t1 addr-t1 ) ( R: addr-t )
.ae08	a9 0a		lda #$0a			lda #AscLF
.ae0a	20 e9 c7	jsr $c7e9			jsr PushZA		; ( addr-h addr-t1 addr-t1 c ) ( R: addr-t )
.ae0d	20 f3 df	jsr $dff3			jsr Swap		; ( addr-h addr-t1 c addr-t1 ) ( R: addr-t )
.ae10	20 13 df	jsr $df13			jsr Store		; ( addr-h addr-t1 ) ( R: addr-t )
.ae13	20 9a da	jsr $da9a			jsr One_plus		; ( addr-h addr-t1+1 ) ( R: addr-t )
.ae16	20 f3 df	jsr $dff3			jsr Swap		; ( addr-t1+1 addr-h ) ( R: addr-t )
.ae19	4c c6 ad	jmp $adc6			jmp _cmd_w_loop
.ae1c					_cmd_w_eol:
.ae1c	20 f3 df	jsr $dff3			jsr Swap		; ( addr-t u-t addr-n addr-tn ) ( R: addr-t )
.ae1f	20 60 df	jsr $df60			jsr R_From		; ( addr-t u-t addr-n addr-tn addr-t )
.ae22	20 08 dc	jsr $dc08			jsr Minus		; ( addr-t u-t addr-n u )
.ae25	b5 24		lda $24,x			lda DStack+0,x
.ae27	95 28		sta $28,x			sta DStack+4,x
.ae29	b5 25		lda $25,x			lda DStack+1,x
.ae2b	95 29		sta $29,x			sta DStack+5,x		; ( addr-t u addr-n u )
.ae2d	20 4c bb	jsr $bb4c			jsr CR
.ae30	20 d2 df	jsr $dfd2			jsr Dup			; ( addr-t u addr-n u u )
.ae33	20 52 dc	jsr $dc52			jsr U_Dot		; ( addr-t u addr-n u )
.ae36	20 4c bb	jsr $bb4c			jsr CR
.ae39	a9 bf		lda #$bf			lda #$ff-%01000000
.ae3b	25 22		and $22				and ed_flags
.ae3d	85 22		sta $22				sta ed_flags
.ae3f	4c 91 ab	jmp $ab91			jmp ed_next_command
.ae42					ed_error_2drop:
.ae42	e8		inx				inx			; Drop para2
.ae43	e8		inx				inx
.ae44					ed_error_1drop:
.ae44	e8		inx				inx			; Drop para1
.ae45	e8		inx				inx
.ae46					ed_error:
.ae46	20 4c bb	jsr $bb4c			jsr CR
.ae49	a9 3f		lda #$3f			lda #'?'
.ae4b	20 21 de	jsr $de21			jsr Emit_A
.ae4e	20 4c bb	jsr $bb4c			jsr CR
.ae51	4c af a9	jmp $a9af			jmp ed_input_loop
.ae54					ed_get_input:
.ae54	20 97 d2	jsr $d297			jsr Refill		;  ( addr-t u-t f )
.ae57	b5 24		lda $24,x			lda DStack+0,x
.ae59	d0 05		bne $ae60			bne +
.ae5b	68		pla				pla
.ae5c	68		pla				pla
.ae5d	4c 44 ae	jmp $ae44			jmp ed_error_1drop
.ae60					+
.ae60	e8		inx				inx
.ae61	e8		inx				inx
.ae62	60		rts				rts
.ae63					ed_have_text:
.ae63	a5 1e		lda $1e				lda ed_head
.ae65	05 1f		ora $1f				ora ed_head+1
.ae67	d0 05		bne $ae6e			bne +
.ae69	68		pla				pla
.ae6a	68		pla				pla
.ae6b	4c 46 ae	jmp $ae46			jmp ed_error
.ae6e					+
.ae6e	60		rts				rts
.ae6f					ed_is_valid_line:
.ae6f	38		sec				sec				; default is legal line number
.ae70	b5 24		lda $24,x			lda DStack+0,x
.ae72	15 25		ora $25,x			ora DStack+1,x
.ae74	f0 18		beq $ae8e			beq _nope_zero	; ( n )
.ae76	20 d2 df	jsr $dfd2			jsr Dup				; ( n n )
.ae79	20 90 ae	jsr $ae90			jsr ed_last_line		; ( n n last )
.ae7c	20 f3 df	jsr $dff3			jsr Swap			; ( n last n )
.ae7f	20 b2 d8	jsr $d8b2			jsr Less_Than			; ( n f )
.ae82	b5 24		lda $24,x			lda DStack+0,x			; 0 flag is good
.ae84	15 25		ora $25,x			ora DStack+1,x
.ae86	d0 04		bne $ae8c			bne _too_small
.ae88	e8		inx				inx
.ae89	e8		inx				inx			; DROP flag ( n )
.ae8a	38		sec				sec			; signal valid
.ae8b	60		rts				rts
.ae8c					_too_small:
.ae8c	e8		inx				inx
.ae8d	e8		inx				inx
.ae8e					_nope_zero:
.ae8e	18		clc				clc			; signal not valid
.ae8f	60		rts				rts
.ae90					ed_last_line:
.ae90	20 f7 c7	jsr $c7f7			jsr Zero		; Set counter to zero
.ae93	a9 1e		lda #$1e			lda #ed_head
.ae95	20 e9 c7	jsr $c7e9			jsr PushZA		; ( count addr )
.ae98					_loop:
.ae98	20 fa de	jsr $defa			jsr Fetch		; ( count addr|0 )
.ae9b	b5 25		lda $25,x			lda DStack+1,x		; at end-of-list?
.ae9d	f0 06		beq $aea5			beq _done
.ae9f	20 a5 da	jsr $daa5			jsr NOS_One_Plus	; Increase counter
.aea2	4c 98 ae	jmp $ae98			jmp _loop		; continue
.aea5					_done:
.aea5	60		rts				rts
.aea6					ed_no_line_zero:
.aea6	b5 26		lda $26,x			lda DStack+2,x
.aea8	15 27		ora $27,x			ora DStack+3,x
.aeaa	d0 07		bne $aeb3			bne _done
.aeac	24 22		bit $22				bit ed_flags
.aeae	10 03		bpl $aeb3			bpl _done
.aeb0	4c 42 ae	jmp $ae42			jmp ed_error_2drop
.aeb3					_done:
.aeb3	60		rts				rts
.aeb4					ed_num_to_addr:
.aeb4	a9 1e		lda #$1e			lda #ed_head
.aeb6	20 e9 c7	jsr $c7e9			jsr PushZA		; ( u addr-h )
.aeb9	4c c6 ae	jmp $aec6			jmp _test
.aebc					_loop:
.aebc	20 fa de	jsr $defa			jsr Fetch		; @ ( u addr1 )
.aebf	b5 25		lda $25,x			lda DStack+1,x		; at end of list?
.aec1	f0 09		beq $aecc			beq _finished
.aec3	20 81 da	jsr $da81			jsr NOS_One_Minus	; decrement the line count
.aec6	b5 26		lda $26,x	_test:		lda DStack+2,x		; is the nth element we're looking for?
.aec8	15 27		ora $27,x			ora DStack+3,x
.aeca	d0 f0		bne $aebc			bne _loop
.aecc					_finished:
.aecc	4c cd d9	jmp $d9cd			jmp Nip			; ( addr )
.aecf					ed_para1_to_cur:
.aecf	b5 26		lda $26,x			lda DStack+2,x
.aed1	85 20		sta $20				sta ed_cur
.aed3	b5 27		lda $27,x			lda DStack+3,x
.aed5	85 21		sta $21				sta ed_cur+1
.aed7	60		rts				rts
.aed8					ed_print_addr:
.aed8	20 46 da	jsr $da46			jsr Cell_Plus		; ( addr+2 )
.aedb	20 d2 df	jsr $dfd2			jsr Dup			; ( addr+2 addr+2 )
.aede	20 46 da	jsr $da46			jsr Cell_Plus		; ( addr+2 addr+4 )
.aee1	20 fa de	jsr $defa			jsr Fetch		; ( addr+2 u-s )
.aee4	20 f3 df	jsr $dff3			jsr Swap		; ( u-s addr+2 )
.aee7	20 fa de	jsr $defa			jsr Fetch		; ( u-s addr-s )
.aeea	20 f3 df	jsr $dff3			jsr Swap		; ( addr-s u-s )
.aeed	20 39 de	jsr $de39			jsr Type
.aef0	4c 4c bb	jmp $bb4c			jmp CR
>aef3	61 66 69 64 70 6e 3d 77		ed_cmd_list:	.text "afidpn=wqQ", 0
>aefb	71 51 00
.aefe					ed_cmd_table:
>aefe	a6 ab d1 ac 04 ad 3a ac				.word ed_cmd_a, ed_cmd_f, ed_cmd_i, ed_cmd_d, ed_cmd_p, ed_cmd_n
>af06	2d ad 24 ad
>af0a	99 ac 97 ad 8a ad 94 ad				.word ed_cmd_equ, ed_cmd_w, ed_cmd_q, ed_cmd_qq
.af12					ed6502_end:
>af12	53 65 65 4c 61 74 65 73		Name0:	.text "SeeLatest"	;  name of word as a string, ending at wh_NameLastChar
>af1a	74
=9					NameLength = *-Name0
=44699					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>af1b	89					.byte (("SeeLatest"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=1424					LinkDisplacement = Nt0-WordListLink
=$11						  WordFlags ::= WordFlags | FP
>af1c	11					.byte WordFlags	;wh_Flags
>af1d	03					.byte 3	;wh_CodeLength
>af1e	0b a9					  .word WordListLink
=$af20					XtPtr1 ::= *
=44699					WordListLink ::= Nt0 ; remember the nt of this word for later
.af20	20 59 ca	jsr $ca59	SeeLatest:	jsr current_to_dp
.af23	a5 10		lda $10				lda dp+0
.af25	a4 11		ldy $11				ldy dp+1
.af27	20 ba c7	jsr $c7ba			jsr PushYA
.af2a	4c 37 af	jmp $af37			jmp See3
=13					CodeLen	.var *-XtPtr1
=$af2d					Here1 = *	; remember here
>af1d	0d					.byte CodeLen	;patch wh_CodeLength
>af2d	53 65 65			Name0:	.text "See"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=44720					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>af30	a3					.byte (("See"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=21					LinkDisplacement = Nt0-WordListLink
>af31	10					.byte WordFlags	;wh_Flags
>af32	03					.byte 3	;wh_CodeLength
>af33	15					  .byte LinkDisplacement	; offset to previous nt
=$af34					XtPtr1 ::= *
=44720					WordListLink ::= Nt0 ; remember the nt of this word for later
.af34					See:
.af34	20 4c cc	jsr $cc4c			jsr Tick_Nt		; ( nt )
.af37	20 4c bb	jsr $bb4c	See3:		jsr CR
.af3a	ad 00 03	lda $0300			lda base		; Save the current number base
.af3d	48		pha				pha
.af3e	a9 d3		lda #$d3			lda #<str_see_nt	; print nt
.af40	a0 ea		ldy #$ea			ldy #>str_see_nt
.af42	20 55 de	jsr $de55			jsr Print_ASCIIZ_YA_no_lf
.af45	20 d2 df	jsr $dfd2			jsr Dup			; ( nt nt )
.af48	20 ec b8	jsr $b8ec			jsr Dot_Hex
.af4b	20 2d de	jsr $de2d			jsr Space		; ( nt )
.af4e	20 d2 df	jsr $dfd2			jsr Dup			; ( nt nt )
.af51	20 ae cd	jsr $cdae			jsr Name_To_Int		; ( nt xt )
.af54	a9 d9		lda #$d9			lda #<str_see_xt	; print xt
.af56	a0 ea		ldy #$ea			ldy #>str_see_xt
.af58	20 55 de	jsr $de55			jsr Print_ASCIIZ_YA_no_lf
.af5b	20 d2 df	jsr $dfd2			jsr Dup			; ( nt xt xt )
.af5e	20 ec b8	jsr $b8ec			jsr Dot_Hex
.af61	20 4c bb	jsr $bb4c			jsr CR			; ( nt xt )
.af64	a9 cc		lda #$cc			lda #<str_see_flags
.af66	a0 ea		ldy #$ea			ldy #>str_see_flags
.af68	20 55 de	jsr $de55			jsr Print_ASCIIZ_YA_no_lf
.af6b	20 a9 df	jsr $dfa9			jsr Over		; ( nt xt nt )
.af6e	a9 81		lda #$81			lda #Wh_Flags
.af70	20 48 da	jsr $da48			jsr Plus_A		; ( nt xt ^flags )
.af73	a1 24		lda ($24,x)			lda (DStack+0,x)	; ( nt xt ^flags )
.af75	95 24		sta $24,x			sta DStack+0,x		; ( nt xt flags )
.af77	a0 0e		ldy #$0e			ldy #2*7		; for bit 7..0
.af79	20 2d de	jsr $de2d	_flag_loop:	jsr Space
.af7c	b9 e0 af	lda $afe0,y			lda _FlagLabels+0,y	;   print label
.af7f	20 21 de	jsr $de21			jsr Emit_A
.af82	b9 e1 af	lda $afe1,y			lda _FlagLabels+1,y
.af85	20 21 de	jsr $de21			jsr Emit_A
.af88	a9 3d		lda #$3d			lda #'='
.af8a	20 21 de	jsr $de21			jsr Emit_A
.af8d	16 24		asl $24,x			asl DStack+0,x		;   c = flag, rotate the rest
.af8f	a9 00		lda #$00			lda #0
.af91	69 30		adc #$30			adc #'0'
.af93	20 21 de	jsr $de21			jsr Emit_A
.af96	88		dey				dey
.af97	88		dey				dey
.af98	10 df		bpl $af79			bpl _flag_loop
.af9a	e8		inx				inx
.af9b	e8		inx				inx			; ( nt xt )
.af9c	20 4c bb	jsr $bb4c			jsr CR
.af9f	a9 df		lda #$df			lda #<str_see_size	; print size
.afa1	a0 ea		ldy #$ea			ldy #>str_see_size
.afa3	20 55 de	jsr $de55			jsr Print_ASCIIZ_YA_no_lf
.afa6	20 f3 df	jsr $dff3			jsr Swap		; ( xt nt )
.afa9	20 05 bb	jsr $bb05			jsr WordSize		; ( xt u )
.afac	20 b6 c1	jsr $c1b6			jsr Decimal
.afaf	b5 24		lda $24,x			lda DStack+0,x		; if = 255
.afb1	c9 ff		cmp #$ff			cmp #$ff
.afb3	d0 11		bne $afc6			bne _size5
.afb5	20 bd c8	jsr $c8bd			jsr sliteral_runtime	;   type "large"
.afb8	4c c0 af	jmp $afc0			  jmp _size2
>afbb	6c 61 72 67 65					  .text "large"
.afc0	20 39 de	jsr $de39	_size2:		jsr Type
.afc3	4c cc af	jmp $afcc			jmp _size9		;  else
.afc6	20 d2 df	jsr $dfd2	_size5:		jsr Dup			;    type size
.afc9	20 52 dc	jsr $dc52			jsr U_Dot
.afcc					_size9:
.afcc	20 4c bb	jsr $bb4c			jsr CR
.afcf	68		pla				pla			; restore base
.afd0	8d 00 03	sta $0300			sta base
.afd3	20 f6 dc	jsr $dcf6			jsr Two_dup
.afd6	20 46 b8	jsr $b846			jsr Dump		; dump
.afd9	20 4c bb	jsr $bb4c			jsr CR
.afdc	20 5f e8	jsr $e85f			jsr DisAsm		; disassemble
=171					CodeLen	.var *-XtPtr1
=$afdf					Here1 = *	; remember here
>af32	ab					.byte CodeLen	;patch wh_CodeLength
.afdf	60		rts				rts
>afe0	46 50 44 42 43 4f 49 4d		_FlagLabels:	.text "FPDBCOIMNNANUF__"
>afe8	4e 4e 41 4e 55 46 5f 5f
>aff0	46 6f 72 74 68 2d 57 6f		Name0:	.text "Forth-WordList"	;  name of word as a string, ending at wh_NameLastChar
>aff8	72 64 4c 69 73 74
=14					NameLength = *-Name0
=44926					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>affe	8e					.byte (("Forth-WordList"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=206					LinkDisplacement = Nt0-WordListLink
>afff	10					.byte WordFlags	;wh_Flags
>b000	03					.byte 3	;wh_CodeLength
>b001	ce					  .byte LinkDisplacement	; offset to previous nt
=$b002					XtPtr1 ::= *
=44926					WordListLink ::= Nt0 ; remember the nt of this word for later
.b002	4c f7 c7	jmp $c7f7	Forth_WordList:	jmp Zero
=3					CodeLen	.var *-XtPtr1
=$b005					Here1 = *	; remember here
>b000	03					.byte CodeLen	;patch wh_CodeLength
>b005	45 64 69 74 6f 72 2d 57		Name0:	.text "Editor-WordList"	;  name of word as a string, ending at wh_NameLastChar
>b00d	6f 72 64 4c 69 73 74
=15					NameLength = *-Name0
=44948					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>b014	8f					.byte (("Editor-WordList"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=22					LinkDisplacement = Nt0-WordListLink
>b015	10					.byte WordFlags	;wh_Flags
>b016	03					.byte 3	;wh_CodeLength
>b017	16					  .byte LinkDisplacement	; offset to previous nt
=$b018					XtPtr1 ::= *
=44948					WordListLink ::= Nt0 ; remember the nt of this word for later
.b018	4c 00 c8	jmp $c800	Editor_WordList: jmp One
=3					CodeLen	.var *-XtPtr1
=$b01b					Here1 = *	; remember here
>b016	03					.byte CodeLen	;patch wh_CodeLength
>b01b	41 73 73 65 6d 62 6c 65		Name0:	.text "Assembler-WordList"	;  name of word as a string, ending at wh_NameLastChar
>b023	72 2d 57 6f 72 64 4c 69 73 74
=18					NameLength = *-Name0
=44973					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>b02d	92					.byte (("Assembler-WordList"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=25					LinkDisplacement = Nt0-WordListLink
>b02e	10					.byte WordFlags	;wh_Flags
>b02f	03					.byte 3	;wh_CodeLength
>b030	19					  .byte LinkDisplacement	; offset to previous nt
=$b031					XtPtr1 ::= *
=44973					WordListLink ::= Nt0 ; remember the nt of this word for later
.b031	4c 09 c8	jmp $c809	Assembler_WordList: jmp Two
=3					CodeLen	.var *-XtPtr1
=$b034					Here1 = *	; remember here
>b02f	03					.byte CodeLen	;patch wh_CodeLength
>b034	52 6f 6f 74 2d 57 6f 72		Name0:	.text "Root-Wordlist"	;  name of word as a string, ending at wh_NameLastChar
>b03c	64 6c 69 73 74
=13					NameLength = *-Name0
=44993					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>b041	8d					.byte (("Root-Wordlist"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=20					LinkDisplacement = Nt0-WordListLink
>b042	10					.byte WordFlags	;wh_Flags
>b043	03					.byte 3	;wh_CodeLength
>b044	14					  .byte LinkDisplacement	; offset to previous nt
=$b045					XtPtr1 ::= *
=44993					WordListLink ::= Nt0 ; remember the nt of this word for later
.b045	a9 03		lda #$03	Root_WordList:	lda #wid_Root
.b047	4c e9 c7	jmp $c7e9			jmp PushZA
=5					CodeLen	.var *-XtPtr1
=$b04a					Here1 = *	; remember here
>b043	05					.byte CodeLen	;patch wh_CodeLength
>b04a	57 6f 72 64 4c 69 73 74		Name0:	.text "WordList"	;  name of word as a string, ending at wh_NameLastChar
=8					NameLength = *-Name0
=45010					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>b052	88					.byte (("WordList"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=17					LinkDisplacement = Nt0-WordListLink
>b053	10					.byte WordFlags	;wh_Flags
>b054	03					.byte 3	;wh_CodeLength
>b055	11					  .byte LinkDisplacement	; offset to previous nt
=$b056					XtPtr1 ::= *
=45010					WordListLink ::= Nt0 ; remember the nt of this word for later
.b056	ad 11 03	lda $0311	WordList:	lda Num_wordlistsV	; Get the current number of wordlists
.b059	c9 0c		cmp #$0c			cmp #max_wordlists	; already full?
.b05b	b0 06		bcs $b063			bcs _err
.b05d	ee 11 03	inc $0311			inc Num_WordlistsV	; increment wordlist count
.b060	4c e9 c7	jmp $c7e9			jmp PushZA		; put it on the stack as wid.
.b063	a9 66		lda #$66	_err:		lda #$100+err_TooManyWordlists	;   throw an error
.b065	4c 68 c4	jmp $c468			jmp ThrowA
=18					CodeLen	.var *-XtPtr1
=$b068					Here1 = *	; remember here
>b054	12					.byte CodeLen	;patch wh_CodeLength
>b068	44 65 66 69 6e 69 74 69		Name0:	.text "Definitions"	;  name of word as a string, ending at wh_NameLastChar
>b070	6f 6e 73
=11					NameLength = *-Name0
=45043					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>b073	6b					.byte (("Definitions"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=33					LinkDisplacement = Nt0-WordListLink
>b074	10					.byte WordFlags	;wh_Flags
>b075	03					.byte 3	;wh_CodeLength
>b076	21					  .byte LinkDisplacement	; offset to previous nt
=$b077					XtPtr1 ::= *
=45043					WordListLink ::= Nt0 ; remember the nt of this word for later
.b077	ad 2b 03	lda $032b	Definitions:	lda Search_OrderV+0	; Transfer SEARCH_ORDER[0] to
.b07a	8d 10 03	sta $0310			sta CurrentV		;   byte variable CURRENT.
=6					CodeLen	.var *-XtPtr1
=$b07d					Here1 = *	; remember here
>b075	06					.byte CodeLen	;patch wh_CodeLength
.b07d	60		rts				rts
>b07e	53 65 74 2d 43 75 72 72		Name0:	.text "Set-Current"	;  name of word as a string, ending at wh_NameLastChar
>b086	65 6e 74
=11					NameLength = *-Name0
=45065					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>b089	8b					.byte (("Set-Current"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=22					LinkDisplacement = Nt0-WordListLink
>b08a	10					.byte WordFlags	;wh_Flags
>b08b	03					.byte 3	;wh_CodeLength
>b08c	16					  .byte LinkDisplacement	; offset to previous nt
=$b08d					XtPtr1 ::= *
=45065					WordListLink ::= Nt0 ; remember the nt of this word for later
.b08d	20 c8 c3	jsr $c3c8	Set_Current:	jsr PopA	; pop wid
.b090	8d 10 03	sta $0310			sta CurrentV	; only the LSB is used.
=6					CodeLen	.var *-XtPtr1
=$b093					Here1 = *	; remember here
>b08b	06					.byte CodeLen	;patch wh_CodeLength
.b093	60		rts				rts
>b094	47 65 74 2d 43 75 72 72		Name0:	.text "Get-Current"	;  name of word as a string, ending at wh_NameLastChar
>b09c	65 6e 74
=11					NameLength = *-Name0
=45087					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>b09f	8b					.byte (("Get-Current"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=22					LinkDisplacement = Nt0-WordListLink
>b0a0	10					.byte WordFlags	;wh_Flags
>b0a1	03					.byte 3	;wh_CodeLength
>b0a2	16					  .byte LinkDisplacement	; offset to previous nt
=$b0a3					XtPtr1 ::= *
=45087					WordListLink ::= Nt0 ; remember the nt of this word for later
.b0a3					Get_Current:
.b0a3	ad 10 03	lda $0310			lda CurrentV
.b0a6	4c e9 c7	jmp $c7e9			jmp PushZA	; CURRENT is a byte variable
=6					CodeLen	.var *-XtPtr1
=$b0a9					Here1 = *	; remember here
>b0a1	06					.byte CodeLen	;patch wh_CodeLength
>b0a9	4f 72 64 65 72			Name0:	.text "Order"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=45102					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>b0ae	45					.byte (("Order"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=15					LinkDisplacement = Nt0-WordListLink
>b0af	10					.byte WordFlags	;wh_Flags
>b0b0	03					.byte 3	;wh_CodeLength
>b0b1	0f					  .byte LinkDisplacement	; offset to previous nt
=$b0b2					XtPtr1 ::= *
=45102					WordListLink ::= Nt0 ; remember the nt of this word for later
.b0b2					Order:
.b0b2	20 4c bb	jsr $bb4c			jsr CR
.b0b5	a0 00		ldy #$00			ldy #0			; for each search_orderV entry
.b0b7	f0 0b		beq $b0c4			beq _test
.b0b9	98		tya		_loop:		tya
.b0ba	48		pha				pha
.b0bb	b9 2b 03	lda $032b,y			lda Search_orderV,y
.b0be	20 cf b0	jsr $b0cf			jsr print_wid_stringA	; internal helper function
.b0c1	68		pla				pla
.b0c2	a8		tay				tay
.b0c3	c8		iny				iny			;  next
.b0c4	cc 2a 03	cpy $032a	_test:		cpy Num_orderV
.b0c7	90 f0		bcc $b0b9			bcc _loop
.b0c9	20 4c bb	jsr $bb4c			jsr CR
.b0cc	ad 10 03	lda $0310			lda CurrentV		; print the current wordlist.
.b0cf					print_wid_stringA:
.b0cf	c9 04		cmp #$04			cmp #wid_Root+1		; do we have a string?
.b0d1	90 06		bcc $b0d9			bcc _string
.b0d3	20 e9 c7	jsr $c7e9			jsr PushZA		; print the WID number
.b0d6	4c 52 dc	jmp $dc52			jmp U_Dot		; JSR/RTS
.b0d9	0a		asl a		_string:	asl			; Get the word index based on WID 0 to 3
.b0da	a8		tay				tay
.b0db	ca		dex				dex			; TOS= word nt
.b0dc	ca		dex				dex
.b0dd	b9 f5 b0	lda $b0f5,y			lda _wid_Table+0,y
.b0e0	95 24		sta $24,x			sta DStack+0,x
.b0e2	b9 f6 b0	lda $b0f6,y			lda _wid_Table+1,y
.b0e5	95 25		sta $25,x			sta DStack+1,x		; ( nt )
.b0e7	20 f7 cd	jsr $cdf7			jsr Name_To_String	; ( addr u )
.b0ea	a9 f7		lda #$f7			lda #$100-9		;   cut off "_wordlist"
.b0ec	20 8a da	jsr $da8a			jsr Minus_A
.b0ef	20 39 de	jsr $de39			jsr Type		; Print
.b0f2	4c 2d de	jmp $de2d			jmp Space
=67					CodeLen	.var *-XtPtr1
=$b0f5					Here1 = *	; remember here
>b0b0	43					.byte CodeLen	;patch wh_CodeLength
.b0f5					_wid_Table:
>b0f5	7e af					.word forth_wordlist-wh_LinkNt-1	; WID 0:
>b0f7	94 af					.word editor_wordlist-wh_LinkNt-1	; WID 1:
>b0f9	ad af					.word assembler_wordlist-wh_LinkNt-1	; WID 2:
>b0fb	c1 af					.word root_wordlist-wh_LinkNt-1		; WID 3:
>b0fd	46 6f 72 74 68			Name0:	.text "Forth"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=45186					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>b102	05					.byte (("Forth"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=84					LinkDisplacement = Nt0-WordListLink
>b103	10					.byte WordFlags	;wh_Flags
>b104	03					.byte 3	;wh_CodeLength
>b105	54					  .byte LinkDisplacement	; offset to previous nt
=$b106					XtPtr1 ::= *
=45186					WordListLink ::= Nt0 ; remember the nt of this word for later
.b106	a9 00		lda #$00	Forth:		lda #wid_Forth
.b108	8d 2b 03	sta $032b			sta Search_OrderV+0
=5					CodeLen	.var *-XtPtr1
=$b10b					Here1 = *	; remember here
>b104	05					.byte CodeLen	;patch wh_CodeLength
.b10b	60		rts				rts
>b10c	50 72 65 76 69 6f 75 73		Name0:	.text "Previous"	;  name of word as a string, ending at wh_NameLastChar
=8					NameLength = *-Name0
=45204					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>b114	68					.byte (("Previous"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=18					LinkDisplacement = Nt0-WordListLink
>b115	10					.byte WordFlags	;wh_Flags
>b116	03					.byte 3	;wh_CodeLength
>b117	12					  .byte LinkDisplacement	; offset to previous nt
=$b118					XtPtr1 ::= *
=45204					WordListLink ::= Nt0 ; remember the nt of this word for later
.b118	20 96 b1	jsr $b196	Previous:	jsr Get_Order
.b11b	20 cd d9	jsr $d9cd			jsr Nip
.b11e	20 74 da	jsr $da74			jsr One_minus
.b121	4c 6f b1	jmp $b16f			jmp Set_Order
=12					CodeLen	.var *-XtPtr1
=$b124					Here1 = *	; remember here
>b116	0c					.byte CodeLen	;patch wh_CodeLength
>b124	41 6c 73 6f			Name0:	.text "Also"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=45224					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>b128	e4					.byte (("Also"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=20					LinkDisplacement = Nt0-WordListLink
>b129	10					.byte WordFlags	;wh_Flags
>b12a	03					.byte 3	;wh_CodeLength
>b12b	14					  .byte LinkDisplacement	; offset to previous nt
=$b12c					XtPtr1 ::= *
=45224					WordListLink ::= Nt0 ; remember the nt of this word for later
.b12c	20 96 b1	jsr $b196	Also:		jsr Get_Order
.b12f	20 a9 df	jsr $dfa9			jsr Over
.b132	20 f3 df	jsr $dff3			jsr Swap
.b135	20 9a da	jsr $da9a			jsr One_plus
.b138	4c 6f b1	jmp $b16f			jmp Set_Order
=15					CodeLen	.var *-XtPtr1
=$b13b					Here1 = *	; remember here
>b12a	0f					.byte CodeLen	;patch wh_CodeLength
>b13b	3e 4f 72 64 65 72		Name0:	.text ">Order"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=45249					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>b141	46					.byte ((">Order"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=25					LinkDisplacement = Nt0-WordListLink
>b142	10					.byte WordFlags	;wh_Flags
>b143	03					.byte 3	;wh_CodeLength
>b144	19					  .byte LinkDisplacement	; offset to previous nt
=$b145					XtPtr1 ::= *
=45249					WordListLink ::= Nt0 ; remember the nt of this word for later
.b145	20 2c b1	jsr $b12c	To_Order:	jsr Also		; make room in search list
.b148	20 c8 c3	jsr $c3c8			jsr PopA
.b14b	8d 2b 03	sta $032b			sta Search_OrderV+0	; set 1st search entry
=9					CodeLen	.var *-XtPtr1
=$b14e					Here1 = *	; remember here
>b143	09					.byte CodeLen	;patch wh_CodeLength
.b14e	60		rts				rts
>b14f	4f 6e 6c 79			Name0:	.text "Only"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=45267					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>b153	24					.byte (("Only"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=18					LinkDisplacement = Nt0-WordListLink
>b154	10					.byte WordFlags	;wh_Flags
>b155	03					.byte 3	;wh_CodeLength
>b156	12					  .byte LinkDisplacement	; offset to previous nt
=$b157					XtPtr1 ::= *
=45267					WordListLink ::= Nt0 ; remember the nt of this word for later
.b157	a9 01		lda #$01	Only:		lda #1
.b159	8d 2a 03	sta $032a			sta Num_orderV	; set count
.b15c	a9 03		lda #$03			lda #wid_Root
.b15e	8d 2b 03	sta $032b			sta Search_OrderV+0 ; set 1st search entry
=10					CodeLen	.var *-XtPtr1
=$b161					Here1 = *	; remember here
>b155	0a					.byte CodeLen	;patch wh_CodeLength
.b161	60		rts				rts
>b162	53 65 74 2d 4f 72 64 65		Name0:	.text "Set-Order"	;  name of word as a string, ending at wh_NameLastChar
>b16a	72
=9					NameLength = *-Name0
=45291					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>b16b	49					.byte (("Set-Order"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=24					LinkDisplacement = Nt0-WordListLink
>b16c	10					.byte WordFlags	;wh_Flags
>b16d	03					.byte 3	;wh_CodeLength
>b16e	18					  .byte LinkDisplacement	; offset to previous nt
=$b16f					XtPtr1 ::= *
=45291					WordListLink ::= Nt0 ; remember the nt of this word for later
.b16f					Set_Order:
.b16f	20 c8 c3	jsr $c3c8			jsr PopA	; pop count
.b172	a8		tay				tay		; was it -1 ?
.b173	30 e2		bmi $b157			bmi Only
.b175	8d 2a 03	sta $032a			sta Num_orderV	; Set #ORDER - the number of wordlists in the search order.
.b178	a0 00		ldy #$00			ldy #0
.b17a	f0 07		beq $b183			beq _test
.b17c					_loop:
.b17c	20 c8 c3	jsr $c3c8			jsr PopA		; The search order is a byte array
.b17f	99 2b 03	sta $032b,y			sta Search_OrderV,y	; so only save the LSB
.b182	c8		iny				iny
.b183					_test:
.b183	cc 2a 03	cpy $032a			cpy Num_orderV
.b186	d0 f4		bne $b17c			bne _loop
=25					CodeLen	.var *-XtPtr1
=$b188					Here1 = *	; remember here
>b16d	19					.byte CodeLen	;patch wh_CodeLength
.b188	60		rts				rts
>b189	47 65 74 2d 4f 72 64 65		Name0:	.text "Get-Order"	;  name of word as a string, ending at wh_NameLastChar
>b191	72
=9					NameLength = *-Name0
=45330					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>b192	49					.byte (("Get-Order"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=39					LinkDisplacement = Nt0-WordListLink
>b193	10					.byte WordFlags	;wh_Flags
>b194	03					.byte 3	;wh_CodeLength
>b195	27					  .byte LinkDisplacement	; offset to previous nt
=$b196					XtPtr1 ::= *
=45330					WordListLink ::= Nt0 ; remember the nt of this word for later
.b196					Get_Order:
.b196	ac 2a 03	ldy $032a			ldy Num_OrderV	; Get #ORDER - the number of wordlists in the search order.
.b199	f0 09		beq $b1a4			beq _done	; If zero, there are no wordlists.
.b19b					_loop:
.b19b	b9 2a 03	lda $032a,y			lda Search_OrderV-1,y	; Put that wordlist id on the stack.
.b19e	20 e9 c7	jsr $c7e9			jsr PushZA
.b1a1	88		dey				dey
.b1a2	d0 f7		bne $b19b			bne _loop		; See if that was the last one to process (first in the list).
.b1a4					_done:
.b1a4	ad 2a 03	lda $032a			lda Num_OrderV		; Push the number of items
.b1a7	4c e9 c7	jmp $c7e9			jmp PushZA
=20					CodeLen	.var *-XtPtr1
=$b1aa					Here1 = *	; remember here
>b194	14					.byte CodeLen	;patch wh_CodeLength
>b1aa	53 65 61 72 63 68 2d 57		Name0:	.text "Search-Wordlist"	;  name of word as a string, ending at wh_NameLastChar
>b1b2	6f 72 64 6c 69 73 74
=15					NameLength = *-Name0
=45369					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>b1b9	8f					.byte (("Search-Wordlist"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=39					LinkDisplacement = Nt0-WordListLink
>b1ba	10					.byte WordFlags	;wh_Flags
>b1bb	03					.byte 3	;wh_CodeLength
>b1bc	27					  .byte LinkDisplacement	; offset to previous nt
=$b1bd					XtPtr1 ::= *
=45369					WordListLink ::= Nt0 ; remember the nt of this word for later
.b1bd					Search_WordList:
.b1bd	20 c8 c3	jsr $c3c8			jsr PopA		; Pop wid
.b1c0	48		pha				pha			; ( addr u )
.b1c1	20 a7 cc	jsr $cca7			jsr swl_prepare 	; ( )
.b1c4	68		pla				pla			; get wid
.b1c5	20 d0 cc	jsr $ccd0			jsr swl_search_wordlist ; tmp1= nt of matching word
.b1c8	f0 11		beq $b1db			beq _NotFound
.b1ca	20 b1 cd	jsr $cdb1			jsr Name_To_Int_T	; ( xt )
.b1cd	a0 81		ldy #$81			ldy #Wh_Flags		; get flags
.b1cf	b1 14		lda ($14),y			lda (tmp1),y
.b1d1	29 08		and #$08			and #IM
.b1d3	d0 03		bne $b1d8			bne _immediate		; bit set, we're immediate
.b1d5	4c c9 c7	jmp $c7c9			jmp True		; Word is not immediate, return -1
.b1d8	4c 00 c8	jmp $c800	_immediate:	jmp One			; Word is immediate, return 1
.b1db	4c f7 c7	jmp $c7f7	_NotFound:	jmp Zero		; Word not found, return 0
=33					CodeLen	.var *-XtPtr1
=$b1de					Here1 = *	; remember here
>b1bb	21					.byte CodeLen	;patch wh_CodeLength
>0339					BlockReadV: .word ?	; Vector to block reading routine
>033b					BlockWriteV: .word ?	; Vector to block writing routine
>033d					BuffBlockNumV: .word ?	; Block number current in BlockBuffer
>033f					BuffStatusV: .word ?	; Status of BlockBuffer (bit 0 = used, bit 1 = dirty)
>0341					BlockBuffer: .fill 1024
.b1de					BlockInit:
.b1de	a9 00		lda #$00			lda #0
.b1e0	8d 3f 03	sta $033f			sta BuffStatusV
.b1e3	a9 30		lda #$30			lda #<Platform_Block_Read
.b1e5	a0 f1		ldy #$f1			ldy #>Platform_Block_Read
.b1e7	8d 39 03	sta $0339			sta BlockReadV+0
.b1ea	8c 3a 03	sty $033a			sty BlockReadV+1
.b1ed	a9 30		lda #$30			lda #<Platform_Block_Write
.b1ef	a0 f1		ldy #$f1			ldy #>Platform_Block_Write
.b1f1	8d 3b 03	sta $033b			sta BlockWriteV+0
.b1f4	8c 3c 03	sty $033c			sty BlockWriteV+1
.b1f7	60		rts				rts
>0741					RamDriveV: .word ?	; ptr to RamDrive storage area
=0					io_blk_status = 0
=0					io_blk_action = 0
=0					io_blk_number = 0
=0					io_blk_buffer = 0
>b1f8	42 6c 6f 63 6b 2d 52 61		Name0:	.text "Block-RamDrive-Init"	;  name of word as a string, ending at wh_NameLastChar
>b200	6d 44 72 69 76 65 2d 49 6e 69 74
=19					NameLength = *-Name0
=45451					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>b20b	93					.byte (("Block-RamDrive-Init"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=80					WordFlags ::= UF+NN	; modifiable copy, remember for later
=82					LinkDisplacement = Nt0-WordListLink
>b20c	50					.byte WordFlags	;wh_Flags
>b20d	03					.byte 3	;wh_CodeLength
>b20e	52					  .byte LinkDisplacement	; offset to previous nt
=$b20f					XtPtr1 ::= *
=45451					WordListLink ::= Nt0 ; remember the nt of this word for later
.b20f					Block_RamDrive_Init:
.b20f	a9 0a		lda #$0a			lda #10			; Calculate how many bytes are needed for numblocks blocks
.b211	20 8c db	jsr $db8c			jsr LShift_A
.b214	20 67 da	jsr $da67			jsr Here		; ( size addr )
.b217	8d 41 07	sta $0741			sta RamDriveV+0
.b21a	8c 42 07	sty $0742			sty RamDriveV+1
.b21d	20 a9 df	jsr $dfa9			jsr Over
.b220	20 c6 d0	jsr $d0c6			jsr Allot		; Create ramdrive buffer
.b223	20 f3 df	jsr $dff3			jsr Swap		; blank the buffer
.b226	20 3d ce	jsr $ce3d			jsr Blank
.b229	a9 3e		lda #$3e			lda #<_read		; set block read vector
.b22b	a0 b2		ldy #$b2			ldy #>_read
.b22d	8d 39 03	sta $0339			sta BlockReadV+0
.b230	8c 3a 03	sty $033a			sty BlockReadV+1
.b233	a9 4e		lda #$4e			lda #<_write		; set block write vector
.b235	a0 b2		ldy #$b2			ldy #>_write
.b237	8d 3b 03	sta $033b			sta BlockWriteV+0
.b23a	8c 3c 03	sty $033c			sty BlockWriteV+1
.b23d	60		rts				rts
=47					CodeLen	.var *-XtPtr1
=$b23e					Here1 = *	; remember here
>b20d	2f					.byte CodeLen	;patch wh_CodeLength
.b23e					_read:
.b23e	20 5b b2	jsr $b25b			jsr _addr
.b241	20 f3 df	jsr $dff3			jsr Swap
.b244	a9 00		lda #$00			lda #0
.b246	a0 04		ldy #$04			ldy #>1024
.b248	20 ba c7	jsr $c7ba			jsr PushYA
.b24b	4c 64 bd	jmp $bd64			jmp Move
.b24e					_write:
.b24e	20 5b b2	jsr $b25b			jsr _addr
.b251	a9 00		lda #$00			lda #0
.b253	a0 04		ldy #$04			ldy #>1024
.b255	20 ba c7	jsr $c7ba			jsr PushYA
.b258	4c 64 bd	jmp $bd64			jmp Move
.b25b					_addr:
.b25b	a9 0a		lda #$0a			lda #10
.b25d	20 8c db	jsr $db8c			jsr LShift_A
.b260	20 72 b2	jsr $b272			jsr RamDrive
.b263	4c ef db	jmp $dbef			jmp Plus
>b266	52 61 6d 44 72 69 76 65		Name0:	.text "RamDrive"	;  name of word as a string, ending at wh_NameLastChar
=8					NameLength = *-Name0
=45550					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>b26e	a8					.byte (("RamDrive"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=99					LinkDisplacement = Nt0-WordListLink
>b26f	10					.byte WordFlags	;wh_Flags
>b270	03					.byte 3	;wh_CodeLength
>b271	63					  .byte LinkDisplacement	; offset to previous nt
=$b272					XtPtr1 ::= *
=45550					WordListLink ::= Nt0 ; remember the nt of this word for later
.b272	ad 41 07	lda $0741	RamDrive:	lda RamDriveV+0
.b275	ac 42 07	ldy $0742			ldy RamDriveV+1
.b278	4c ba c7	jmp $c7ba			jmp PushYA
=9					CodeLen	.var *-XtPtr1
=$b27b					Here1 = *	; remember here
>b270	09					.byte CodeLen	;patch wh_CodeLength
>b27b	42 75 66 66 53 74 61 74		Name0:	.text "BuffStatus"	;  name of word as a string, ending at wh_NameLastChar
>b283	75 73
=10					NameLength = *-Name0
=45573					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>b285	6a					.byte (("BuffStatus"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=23					LinkDisplacement = Nt0-WordListLink
>b286	10					.byte WordFlags	;wh_Flags
>b287	03					.byte 3	;wh_CodeLength
>b288	17					  .byte LinkDisplacement	; offset to previous nt
=$b289					XtPtr1 ::= *
=45573					WordListLink ::= Nt0 ; remember the nt of this word for later
.b289	a0 03		ldy #$03	BuffStatus:	ldy #>BuffStatusV
.b28b	a9 3f		lda #$3f			lda #<BuffStatusV
.b28d	4c ba c7	jmp $c7ba			jmp PushYA
=7					CodeLen	.var *-XtPtr1
=$b290					Here1 = *	; remember here
>b287	07					.byte CodeLen	;patch wh_CodeLength
>b290	42 75 66 66 42 6c 6f 63		Name0:	.text "BuffBlockNum"	;  name of word as a string, ending at wh_NameLastChar
>b298	6b 4e 75 6d
=12					NameLength = *-Name0
=45596					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>b29c	ac					.byte (("BuffBlockNum"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=23					LinkDisplacement = Nt0-WordListLink
>b29d	10					.byte WordFlags	;wh_Flags
>b29e	03					.byte 3	;wh_CodeLength
>b29f	17					  .byte LinkDisplacement	; offset to previous nt
=$b2a0					XtPtr1 ::= *
=45596					WordListLink ::= Nt0 ; remember the nt of this word for later
.b2a0	a0 03		ldy #$03	BuffBlockNum:	ldy #>BuffBlockNumV
.b2a2	a9 3d		lda #$3d			lda #<BuffBlockNumV
.b2a4	4c ba c7	jmp $c7ba			jmp PushYA
=7					CodeLen	.var *-XtPtr1
=$b2a7					Here1 = *	; remember here
>b29e	07					.byte CodeLen	;patch wh_CodeLength
>b2a7	42 6c 6b 42 75 66 66 65		Name0:	.text "BlkBuffer"	;  name of word as a string, ending at wh_NameLastChar
>b2af	72
=9					NameLength = *-Name0
=45616					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>b2b0	49					.byte (("BlkBuffer"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=20					LinkDisplacement = Nt0-WordListLink
>b2b1	10					.byte WordFlags	;wh_Flags
>b2b2	03					.byte 3	;wh_CodeLength
>b2b3	14					  .byte LinkDisplacement	; offset to previous nt
=$b2b4					XtPtr1 ::= *
=45616					WordListLink ::= Nt0 ; remember the nt of this word for later
.b2b4	a0 03		ldy #$03	BlkBuffer:	ldy #>BlockBuffer
.b2b6	a9 41		lda #$41			lda #<BlockBuffer
.b2b8	4c ba c7	jmp $c7ba			jmp PushYA
=7					CodeLen	.var *-XtPtr1
=$b2bb					Here1 = *	; remember here
>b2b2	07					.byte CodeLen	;patch wh_CodeLength
>b2bb	53 63 72			Name0:	.text "Scr"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=45630					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>b2be	43					.byte (("Scr"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=14					LinkDisplacement = Nt0-WordListLink
>b2bf	10					.byte WordFlags	;wh_Flags
>b2c0	03					.byte 3	;wh_CodeLength
>b2c1	0e					  .byte LinkDisplacement	; offset to previous nt
=$b2c2					XtPtr1 ::= *
=45630					WordListLink ::= Nt0 ; remember the nt of this word for later
.b2c2	a0 03		ldy #$03	Scr:		ldy #>ScrV
.b2c4	a9 0e		lda #$0e			lda #<ScrV
.b2c6	4c ba c7	jmp $c7ba			jmp PushYA
=7					CodeLen	.var *-XtPtr1
=$b2c9					Here1 = *	; remember here
>b2c0	07					.byte CodeLen	;patch wh_CodeLength
>b2c9	42 6c 6b			Name0:	.text "Blk"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=45644					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>b2cc	63					.byte (("Blk"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=14					LinkDisplacement = Nt0-WordListLink
>b2cd	10					.byte WordFlags	;wh_Flags
>b2ce	03					.byte 3	;wh_CodeLength
>b2cf	0e					  .byte LinkDisplacement	; offset to previous nt
=$b2d0					XtPtr1 ::= *
=45644					WordListLink ::= Nt0 ; remember the nt of this word for later
.b2d0	a0 03		ldy #$03	Blk:		ldy #>BlkV
.b2d2	a9 0c		lda #$0c			lda #<BlkV
.b2d4	4c ba c7	jmp $c7ba			jmp PushYA
=7					CodeLen	.var *-XtPtr1
=$b2d7					Here1 = *	; remember here
>b2ce	07					.byte CodeLen	;patch wh_CodeLength
>b2d7	42 6c 6f 63 6b 2d 57 72		Name0:	.text "Block-Write"	;  name of word as a string, ending at wh_NameLastChar
>b2df	69 74 65
=11					NameLength = *-Name0
=45666					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>b2e2	ab					.byte (("Block-Write"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=22					LinkDisplacement = Nt0-WordListLink
>b2e3	10					.byte WordFlags	;wh_Flags
>b2e4	03					.byte 3	;wh_CodeLength
>b2e5	16					  .byte LinkDisplacement	; offset to previous nt
=$b2e6					XtPtr1 ::= *
=45666					WordListLink ::= Nt0 ; remember the nt of this word for later
.b2e6	6c 3b 03	jmp ($033b)	Block_Write:	jmp (BlockWriteV)	; Execute the BLOCK-READ-VECTOR
=3					CodeLen	.var *-XtPtr1
=$b2e9					Here1 = *	; remember here
>b2e4	03					.byte CodeLen	;patch wh_CodeLength
>b2e9	42 6c 6f 63 6b 2d 52 65		Name0:	.text "Block-Read"	;  name of word as a string, ending at wh_NameLastChar
>b2f1	61 64
=10					NameLength = *-Name0
=45683					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>b2f3	8a					.byte (("Block-Read"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=17					LinkDisplacement = Nt0-WordListLink
>b2f4	10					.byte WordFlags	;wh_Flags
>b2f5	03					.byte 3	;wh_CodeLength
>b2f6	11					  .byte LinkDisplacement	; offset to previous nt
=$b2f7					XtPtr1 ::= *
=45683					WordListLink ::= Nt0 ; remember the nt of this word for later
.b2f7	6c 39 03	jmp ($0339)	Block_Read:	jmp (BlockReadV)	; Execute the BLOCK-READ-VECTOR
=3					CodeLen	.var *-XtPtr1
=$b2fa					Here1 = *	; remember here
>b2f5	03					.byte CodeLen	;patch wh_CodeLength
>b2fa	42 6c 6f 63 6b 2d 57 72		Name0:	.text "Block-Write-Vector"	;  name of word as a string, ending at wh_NameLastChar
>b302	69 74 65 2d 56 65 63 74 6f 72
=18					NameLength = *-Name0
=45708					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>b30c	52					.byte (("Block-Write-Vector"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=25					LinkDisplacement = Nt0-WordListLink
>b30d	10					.byte WordFlags	;wh_Flags
>b30e	03					.byte 3	;wh_CodeLength
>b30f	19					  .byte LinkDisplacement	; offset to previous nt
=$b310					XtPtr1 ::= *
=45708					WordListLink ::= Nt0 ; remember the nt of this word for later
.b310					Block_Write_Vector:
.b310	a0 03		ldy #$03			ldy #>BlockWriteV
.b312	a9 3b		lda #$3b			lda #<BlockWriteV	; Get the BLOCK-WRITE-VECTOR address
.b314	4c ba c7	jmp $c7ba			jmp PushYA
=7					CodeLen	.var *-XtPtr1
=$b317					Here1 = *	; remember here
>b30e	07					.byte CodeLen	;patch wh_CodeLength
>b317	42 6c 6f 63 6b 2d 52 65		Name0:	.text "Block-Read-Vector"	;  name of word as a string, ending at wh_NameLastChar
>b31f	61 64 2d 56 65 63 74 6f 72
=17					NameLength = *-Name0
=45736					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>b328	51					.byte (("Block-Read-Vector"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=28					LinkDisplacement = Nt0-WordListLink
>b329	10					.byte WordFlags	;wh_Flags
>b32a	03					.byte 3	;wh_CodeLength
>b32b	1c					  .byte LinkDisplacement	; offset to previous nt
=$b32c					XtPtr1 ::= *
=45736					WordListLink ::= Nt0 ; remember the nt of this word for later
.b32c					Block_Read_Vector:
.b32c	a0 03		ldy #$03			ldy #>BlockReadV
.b32e	a9 39		lda #$39			lda #<BlockReadV	; Get the BLOCK-READ-VECTOR address
.b330	4c ba c7	jmp $c7ba			jmp PushYA
=7					CodeLen	.var *-XtPtr1
=$b333					Here1 = *	; remember here
>b32a	07					.byte CodeLen	;patch wh_CodeLength
>b333	53 61 76 65 2d 42 75 66		Name0:	.text "Save-Buffers"	;  name of word as a string, ending at wh_NameLastChar
>b33b	66 65 72 73
=12					NameLength = *-Name0
=45759					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>b33f	6c					.byte (("Save-Buffers"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=0					WordFlags ::= 0	; modifiable copy, remember for later
=23					LinkDisplacement = Nt0-WordListLink
>b340	00					.byte WordFlags	;wh_Flags
>b341	03					.byte 3	;wh_CodeLength
>b342	17					  .byte LinkDisplacement	; offset to previous nt
=$b343					XtPtr1 ::= *
=45759					WordListLink ::= Nt0 ; remember the nt of this word for later
.b343					Save_Buffers:
.b343	ad 3f 03	lda $033f			lda BuffStatusV+0 ; Only bits 0 and 1 are used, so only
.b346	c9 03		cmp #$03			cmp #3		; LSB is needed.
.b348	d0 11		bne $b35b			bne _done	; Either not used or not dirty = done!
.b34a	20 b4 b2	jsr $b2b4			jsr BlkBuffer
.b34d	20 a0 b2	jsr $b2a0			jsr BuffBlockNum
.b350	20 fa de	jsr $defa			jsr Fetch
.b353	20 e6 b2	jsr $b2e6			jsr Block_Write
.b356	a9 01		lda #$01			lda #1
.b358	8d 3f 03	sta $033f			sta BuffStatusV+0
.b35b					_done:
=24					CodeLen	.var *-XtPtr1
=$b35b					Here1 = *	; remember here
>b341	18					.byte CodeLen	;patch wh_CodeLength
.b35b	60		rts				rts
>b35c	42 6c 6f 63 6b			Name0:	.text "Block"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=45793					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>b361	65					.byte (("Block"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=0					WordFlags ::= 0	; modifiable copy, remember for later
=34					LinkDisplacement = Nt0-WordListLink
>b362	00					.byte WordFlags	;wh_Flags
>b363	03					.byte 3	;wh_CodeLength
>b364	22					  .byte LinkDisplacement	; offset to previous nt
=$b365					XtPtr1 ::= *
=45793					WordListLink ::= Nt0 ; remember the nt of this word for later
.b365					Block:
.b365	ad 3d 03	lda $033d			lda BuffBlockNumV+0	; check the LSB
.b368	d5 24		cmp $24,x			cmp DStack+0,x
.b36a	d0 0e		bne $b37a			bne _not_in_buffer
.b36c	ad 3e 03	lda $033e			lda BuffBlockNumV+1	; check the MSB
.b36f	d5 25		cmp $25,x			cmp DStack+1,x
.b371	d0 07		bne $b37a			bne _not_in_buffer
.b373	ad 3f 03	lda $033f			lda BuffStatusV+0
.b376	29 01		and #$01			and #1		; Check the in-use flag (bit 0)
.b378	d0 2d		bne $b3a7			bne _done	; It's already in the buffer and in use.
.b37a					_not_in_buffer:
.b37a	ad 3f 03	lda $033f			lda BuffStatusV+0 ; Only bits 0 and 1 are used, so only
.b37d	c9 03		cmp #$03			cmp #3		; LSB is needed.
.b37f	d0 0c		bne $b38d			bne _buffer_available ; Unused or not dirty = available
.b381	20 b4 b2	jsr $b2b4			jsr BlkBuffer
.b384	20 a0 b2	jsr $b2a0			jsr BuffBlockNum
.b387	20 fa de	jsr $defa			jsr Fetch
.b38a	20 e6 b2	jsr $b2e6			jsr Block_Write
.b38d					_buffer_available:
.b38d	b5 24		lda $24,x			lda DStack+0,x
.b38f	8d 3d 03	sta $033d			sta BuffBlockNumV+0
.b392	b5 25		lda $25,x			lda DStack+1,x
.b394	8d 3e 03	sta $033e			sta BuffBlockNumV+1
.b397	20 b4 b2	jsr $b2b4			jsr BlkBuffer
.b39a	20 f3 df	jsr $dff3			jsr Swap
.b39d	20 f7 b2	jsr $b2f7			jsr Block_Read
.b3a0	a9 01		lda #$01			lda #1
.b3a2	8d 3f 03	sta $033f			sta BuffStatusV+0
.b3a5	ca		dex				dex
.b3a6	ca		dex				dex
.b3a7					_done:
.b3a7	a9 41		lda #$41			lda #<BlockBuffer
.b3a9	95 24		sta $24,x			sta DStack+0,x
.b3ab	a9 03		lda #$03			lda #>BlockBuffer
.b3ad	95 25		sta $25,x			sta DStack+1,x
=74					CodeLen	.var *-XtPtr1
=$b3af					Here1 = *	; remember here
>b363	4a					.byte CodeLen	;patch wh_CodeLength
.b3af	60		rts				rts
>b3b0	55 70 64 61 74 65		Name0:	.text "Update"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=45878					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>b3b6	a6					.byte (("Update"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=0					WordFlags ::= 0	; modifiable copy, remember for later
=85					LinkDisplacement = Nt0-WordListLink
>b3b7	00					.byte WordFlags	;wh_Flags
>b3b8	03					.byte 3	;wh_CodeLength
>b3b9	55					  .byte LinkDisplacement	; offset to previous nt
=$b3ba					XtPtr1 ::= *
=45878					WordListLink ::= Nt0 ; remember the nt of this word for later
.b3ba					Update:
.b3ba	ad 3f 03	lda $033f			lda BuffStatusV+0
.b3bd	09 02		ora #$02			ora #2		; Turn on dirty flag (bit 2)
.b3bf	8d 3f 03	sta $033f			sta BuffStatusV+0
=8					CodeLen	.var *-XtPtr1
=$b3c2					Here1 = *	; remember here
>b3b8	08					.byte CodeLen	;patch wh_CodeLength
.b3c2	60		rts				rts
>b3c3	42 75 66 66 65 72		Name0:	.text "Buffer"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=45897					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>b3c9	46					.byte (("Buffer"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=19					LinkDisplacement = Nt0-WordListLink
>b3ca	10					.byte WordFlags	;wh_Flags
>b3cb	03					.byte 3	;wh_CodeLength
>b3cc	13					  .byte LinkDisplacement	; offset to previous nt
=$b3cd					XtPtr1 ::= *
=45897					WordListLink ::= Nt0 ; remember the nt of this word for later
.b3cd					Buffer:
.b3cd	ad 3f 03	lda $033f			lda BuffStatusV+0 ; Only bits 0 and 1 are used, so only
.b3d0	c9 03		cmp #$03			cmp #3		; LSB is needed.
.b3d2	d0 0c		bne $b3e0			bne _buffer_available ; Unused or not dirty = available
.b3d4	20 b4 b2	jsr $b2b4			jsr BlkBuffer
.b3d7	20 a0 b2	jsr $b2a0			jsr BuffBlockNum
.b3da	20 fa de	jsr $defa			jsr Fetch
.b3dd	20 e6 b2	jsr $b2e6			jsr Block_Write
.b3e0					_buffer_available:
.b3e0	b5 24		lda $24,x			lda DStack+0,x
.b3e2	8d 3d 03	sta $033d			sta BuffBlockNumV+0
.b3e5	b5 25		lda $25,x			lda DStack+1,x
.b3e7	8d 3e 03	sta $033e			sta BuffBlockNumV+1
.b3ea	a9 01		lda #$01			lda #1
.b3ec	8d 3f 03	sta $033f			sta BuffStatusV+0
.b3ef					_done:
.b3ef	a9 41		lda #$41			lda #<BlockBuffer
.b3f1	95 24		sta $24,x			sta DStack+0,x
.b3f3	a9 03		lda #$03			lda #>BlockBuffer
.b3f5	95 25		sta $25,x			sta DStack+1,x
=42					CodeLen	.var *-XtPtr1
=$b3f7					Here1 = *	; remember here
>b3cb	2a					.byte CodeLen	;patch wh_CodeLength
.b3f7	60		rts				rts
>b3f8	45 6d 70 74 79 2d 42 75		Name0:	.text "Empty-Buffers"	;  name of word as a string, ending at wh_NameLastChar
>b400	66 66 65 72 73
=13					NameLength = *-Name0
=45957					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>b405	6d					.byte (("Empty-Buffers"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=60					LinkDisplacement = Nt0-WordListLink
>b406	10					.byte WordFlags	;wh_Flags
>b407	03					.byte 3	;wh_CodeLength
>b408	3c					  .byte LinkDisplacement	; offset to previous nt
=$b409					XtPtr1 ::= *
=45957					WordListLink ::= Nt0 ; remember the nt of this word for later
.b409	a9 00		lda #$00	Empty_Buffers:	lda #0		; Set the buffer status to empty.
.b40b	8d 3f 03	sta $033f			sta BuffStatusV+0 ; Only LSB is used.
=5					CodeLen	.var *-XtPtr1
=$b40e					Here1 = *	; remember here
>b407	05					.byte CodeLen	;patch wh_CodeLength
.b40e	60		rts				rts
>b40f	46 6c 75 73 68			Name0:	.text "Flush"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=45972					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>b414	05					.byte (("Flush"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=15					LinkDisplacement = Nt0-WordListLink
>b415	10					.byte WordFlags	;wh_Flags
>b416	03					.byte 3	;wh_CodeLength
>b417	0f					  .byte LinkDisplacement	; offset to previous nt
=$b418					XtPtr1 ::= *
=45972					WordListLink ::= Nt0 ; remember the nt of this word for later
.b418	20 43 b3	jsr $b343	Flush:		jsr Save_Buffers
.b41b	4c 09 b4	jmp $b409			jmp Empty_Buffers
=6					CodeLen	.var *-XtPtr1
=$b41e					Here1 = *	; remember here
>b416	06					.byte CodeLen	;patch wh_CodeLength
>b41e	4c 6f 61 64			Name0:	.text "Load"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=45986					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>b422	84					.byte (("Load"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=14					LinkDisplacement = Nt0-WordListLink
>b423	10					.byte WordFlags	;wh_Flags
>b424	03					.byte 3	;wh_CodeLength
>b425	0e					  .byte LinkDisplacement	; offset to previous nt
=$b426					XtPtr1 ::= *
=45986					WordListLink ::= Nt0 ; remember the nt of this word for later
.b426					Load:
.b426	20 0c c4	jsr $c40c			jsr underflow_1
.b429	ad 0d 03	lda $030d			lda BlkV+1		; Save the current value of BLK on the return stack.
.b42c	48		pha				pha
.b42d	ad 0c 03	lda $030c			lda BlkV+0
.b430	48		pha				pha
.b431	b5 24		lda $24,x			lda DStack+0,x		; Set BLK to the given block/screen number.
.b433	8d 0c 03	sta $030c			sta BlkV+0
.b436	b5 25		lda $25,x			lda DStack+1,x
.b438	8d 0d 03	sta $030d			sta BlkV+1
.b43b	20 65 b3	jsr $b365			jsr Block		; Load that block into a buffer
.b43e	a9 00		lda #$00			lda #<1024		; block length.
.b440	a0 04		ldy #$04			ldy #>1024
.b442	20 ba c7	jsr $c7ba			jsr PushYA
.b445	38		sec				sec		; Set a flag to not zero BLK
.b446	20 ed bf	jsr $bfed			jsr load_evaluate
.b449	68		pla				pla
.b44a	8d 0c 03	sta $030c			sta BlkV+0
.b44d	68		pla				pla
.b44e	8d 0d 03	sta $030d			sta BlkV+1
.b451	0d 0c 03	ora $030c			ora BlkV+0
.b454	f0 13		beq $b469			beq _done
.b456	ad 0c 03	lda $030c			lda BlkV+0
.b459	ac 0d 03	ldy $030d			ldy BlkV+1
.b45c	20 ba c7	jsr $c7ba			jsr PushYA
.b45f	20 65 b3	jsr $b365			jsr Block
.b462	20 e3 c3	jsr $c3e3			jsr PopYA	; Pop the buffer address.
.b465	85 04		sta $04				sta cib+0
.b467	84 05		sty $05				sty cib+1
.b469					_done:
=67					CodeLen	.var *-XtPtr1
=$b469					Here1 = *	; remember here
>b424	43					.byte CodeLen	;patch wh_CodeLength
.b469	60		rts				rts
>b46a	54 68 72 75			Name0:	.text "Thru"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=46062					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>b46e	a4					.byte (("Thru"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=76					LinkDisplacement = Nt0-WordListLink
>b46f	10					.byte WordFlags	;wh_Flags
>b470	03					.byte 3	;wh_CodeLength
>b471	4c					  .byte LinkDisplacement	; offset to previous nt
=$b472					XtPtr1 ::= *
=46062					WordListLink ::= Nt0 ; remember the nt of this word for later
.b472	20 20 c4	jsr $c420	Thru:		jsr underflow_2
.b475	20 42 df	jsr $df42			jsr To_R
.b478					_loop:
.b478	b5 25		lda $25,x			lda DStack+1,x		; copy to return stack
.b47a	48		pha				pha
.b47b	b5 24		lda $24,x			lda DStack+0,x
.b47d	48		pha				pha
.b47e	20 26 b4	jsr $b426			jsr Load		; Load this screen.
.b481	20 60 df	jsr $df60			jsr R_From		; Get the screen # we just loaded.
.b484	20 9a da	jsr $da9a			jsr One_plus		; increment
.b487	86 14		stx $14				stx tmp1
.b489	ba		tsx				tsx
.b48a	8a		txa				txa
.b48b	a8		tay				tay
.b48c	a6 14		ldx $14				ldx tmp1
.b48e	b9 01 01	lda $0101,y			lda RStack+1,y
.b491	d5 24		cmp $24,x			cmp DStack+0,x
.b493	b9 02 01	lda $0102,y			lda RStack+2,y
.b496	f5 25		sbc $25,x			sbc DStack+1,x
.b498	b0 de		bcs $b478			bcs _loop
.b49a	e8		inx				inx			; Drop index
.b49b	e8		inx				inx
.b49c	68		pla				pla			; RDrop limit
.b49d	68		pla				pla
=44					CodeLen	.var *-XtPtr1
=$b49e					Here1 = *	; remember here
>b470	2c					.byte CodeLen	;patch wh_CodeLength
.b49e	60		rts				rts
>b49f	4c 69 73 74			Name0:	.text "List"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=46115					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>b4a3	84					.byte (("List"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=53					LinkDisplacement = Nt0-WordListLink
>b4a4	10					.byte WordFlags	;wh_Flags
>b4a5	03					.byte 3	;wh_CodeLength
>b4a6	35					  .byte LinkDisplacement	; offset to previous nt
=$b4a7					XtPtr1 ::= *
=46115					WordListLink ::= Nt0 ; remember the nt of this word for later
.b4a7	20 e3 c3	jsr $c3e3	List:		jsr PopYA	; Save the screen number
.b4aa	8d 0e 03	sta $030e			sta ScrV+0
.b4ad	8c 0f 03	sty $030f			sty ScrV+1
.b4b0					ListScr:
.b4b0	20 c2 b2	jsr $b2c2			jsr Scr
.b4b3	20 fa de	jsr $defa			jsr Fetch
.b4b6	20 65 b3	jsr $b365			jsr Block	; Get the current screen contents.
.b4b9	20 4c bb	jsr $bb4c			jsr CR
.b4bc	20 bd c8	jsr $c8bd			jsr SLiteral_Runtime
.b4bf	4c ca b4	jmp $b4ca			  jmp +				; for SLiteral_Runtime
>b4c2	53 63 72 65 65 6e 20 23				  .text "Screen #"		; for SLiteral_Runtime
.b4ca					+
.b4ca	20 39 de	jsr $de39			jsr Type
.b4cd	20 c2 b2	jsr $b2c2			jsr Scr		; print screen number
.b4d0	20 fa de	jsr $defa			jsr Fetch
.b4d3	a9 04		lda #$04			lda #4		;    in 4 positions
.b4d5	20 84 dc	jsr $dc84			jsr U_Dot_R_A
.b4d8	a9 00		lda #$00			lda #0			; line #
.b4da					_line_loop:
.b4da	48		pha				pha
.b4db	20 4c bb	jsr $bb4c			jsr CR
.b4de	68		pla				pla		; Print the line number
.b4df	48		pha				pha
.b4e0	20 e9 c7	jsr $c7e9			jsr PushZA
.b4e3	a9 02		lda #$02			lda #2		;   in 2 positions
.b4e5	20 84 dc	jsr $dc84			jsr U_Dot_R_A
.b4e8	20 2d de	jsr $de2d			jsr Space
.b4eb	20 d2 df	jsr $dfd2			jsr Dup		; Print one line using the address on the stack.
.b4ee	a9 40		lda #$40			lda #64
.b4f0	20 e9 c7	jsr $c7e9			jsr PushZA
.b4f3	20 39 de	jsr $de39			jsr Type
.b4f6	a9 40		lda #$40			lda #64		; move address to the next line.
.b4f8	20 48 da	jsr $da48			jsr Plus_A
.b4fb	68		pla				pla		; Increment the line number
.b4fc	18		clc				clc
.b4fd	69 01		adc #$01			adc #1
.b4ff	c9 10		cmp #$10			cmp #16		; See if we are done.
.b501	d0 d7		bne $b4da			bne _line_loop
.b503	e8		inx				inx		; Drop the address
.b504	e8		inx				inx
.b505	4c 4c bb	jmp $bb4c			jmp CR
=97					CodeLen	.var *-XtPtr1
=$b508					Here1 = *	; remember here
>b4a5	61					.byte CodeLen	;patch wh_CodeLength
>b508	44 65 66 65 72			Name0:	.text "Defer"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=46221					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>b50d	45					.byte (("Defer"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=106					LinkDisplacement = Nt0-WordListLink
>b50e	10					.byte WordFlags	;wh_Flags
>b50f	03					.byte 3	;wh_CodeLength
>b510	6a					  .byte LinkDisplacement	; offset to previous nt
=$b511					XtPtr1 ::= *
=46221					WordListLink ::= Nt0 ; remember the nt of this word for later
.b511					Defer:
.b511	20 20 d1	jsr $d120			jsr Header_Comma	; compile word header
.b514	a9 1e		lda #$1e			lda #<_undefined	; compile "jmp _undefined" (patched later)
.b516	a0 b5		ldy #$b5			ldy #>_undefined
.b518	20 8e dd	jsr $dd8e			jsr Jmp_Comma_YA
.b51b	4c e0 cb	jmp $cbe0			jmp adjust_z		; set word length
=13					CodeLen	.var *-XtPtr1
=$b51e					Here1 = *	; remember here
>b50f	0d					.byte CodeLen	;patch wh_CodeLength
.b51e					_undefined:
.b51e	a9 6a		lda #$6a			lda #$100+err_Defer	; throw exception
.b520	4c 68 c4	jmp $c468			jmp ThrowA
>b523	44 65 66 65 72 21		Name0:	.text "Defer!"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=46249					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>b529	26					.byte (("Defer!"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=28					LinkDisplacement = Nt0-WordListLink
>b52a	10					.byte WordFlags	;wh_Flags
>b52b	03					.byte 3	;wh_CodeLength
>b52c	1c					  .byte LinkDisplacement	; offset to previous nt
=$b52d					XtPtr1 ::= *
=46249					WordListLink ::= Nt0 ; remember the nt of this word for later
.b52d	20 e3 c3	jsr $c3e3	Defer_Store:	jsr PopYA		; pop DEFERs xt
.b530	85 14		sta $14		Defer_Store_YA:	sta tmp1+0
.b532	84 15		sty $15				sty tmp1+1
.b534	b5 24		lda $24,x			lda DStack+0,x		; DEFERs JMP abs operand= xt2
.b536	a0 01		ldy #$01			ldy #1
.b538	91 14		sta ($14),y			sta (tmp1),y
.b53a	b5 25		lda $25,x			lda DStack+1,x
.b53c	c8		iny				iny
.b53d	91 14		sta ($14),y			sta (tmp1),y
.b53f	4c 10 e0	jmp $e010			jmp Drop		; Drop xt2
=21					CodeLen	.var *-XtPtr1
=$b542					Here1 = *	; remember here
>b52b	15					.byte CodeLen	;patch wh_CodeLength
>b542	44 65 66 65 72 40		Name0:	.text "Defer@"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=46280					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>b548	06					.byte (("Defer@"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=0					WordFlags ::= 0	; modifiable copy, remember for later
=31					LinkDisplacement = Nt0-WordListLink
>b549	00					.byte WordFlags	;wh_Flags
>b54a	03					.byte 3	;wh_CodeLength
>b54b	1f					  .byte LinkDisplacement	; offset to previous nt
=$b54c					XtPtr1 ::= *
=46280					WordListLink ::= Nt0 ; remember the nt of this word for later
.b54c	20 e3 c3	jsr $c3e3	Defer_Fetch:	jsr PopYA	; pop DEFERs xt
.b54f	85 14		sta $14		Defer_Fetch_YA:	sta tmp1+0
.b551	84 15		sty $15				sty tmp1+1
.b553	ca		dex				dex		; push DEFERs JMP abs operand
.b554	ca		dex				dex
.b555	a0 01		ldy #$01			ldy #1
.b557	b1 14		lda ($14),y			lda (tmp1),y
.b559	95 24		sta $24,x			sta DStack+0,x
.b55b	c8		iny				iny
.b55c	b1 14		lda ($14),y			lda (tmp1),y
.b55e	95 25		sta $25,x			sta DStack+1,x
=20					CodeLen	.var *-XtPtr1
=$b560					Here1 = *	; remember here
>b54a	14					.byte CodeLen	;patch wh_CodeLength
.b560	60		rts				rts
>b561	49 73				Name0:	.text "Is"	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=46307					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>b563	62					.byte (("Is"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=24					WordFlags ::= IM+NN	; modifiable copy, remember for later
=27					LinkDisplacement = Nt0-WordListLink
>b564	18					.byte WordFlags	;wh_Flags
>b565	03					.byte 3	;wh_CodeLength
>b566	1b					  .byte LinkDisplacement	; offset to previous nt
=$b567					XtPtr1 ::= *
=46307					WordListLink ::= Nt0 ; remember the nt of this word for later
.b567	20 46 cc	jsr $cc46	Is:		jsr Tick		; get xt of "name"
.b56a	a5 0a		lda $0a				lda state		; Check STATE
.b56c	f0 bf		beq $b52d			beq Defer_Store		; interpreting, put xt in the DEFER word
.b56e					_compiling:
.b56e	20 a1 c7	jsr $c7a1			jsr ldya_immed_comma	; compile LDY #; LDA # of the xt of "name"
.b571	a0 b5		ldy #$b5			ldy #>Defer_Store_YA	; Postpone DEFER! by compiling a JSR to it.
.b573	a9 30		lda #$30			lda #<Defer_Store_YA
.b575	4c 78 dd	jmp $dd78			jmp Jsr_Comma_YA
=17					CodeLen	.var *-XtPtr1
=$b578					Here1 = *	; remember here
>b565	11					.byte CodeLen	;patch wh_CodeLength
>b578	41 63 74 69 6f 6e 2d 4f		Name0:	.text "Action-Of"	;  name of word as a string, ending at wh_NameLastChar
>b580	66
=9					NameLength = *-Name0
=46337					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>b581	c9					.byte (("Action-Of"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=24					WordFlags ::= IM+NN	; modifiable copy, remember for later
=30					LinkDisplacement = Nt0-WordListLink
>b582	18					.byte WordFlags	;wh_Flags
>b583	03					.byte 3	;wh_CodeLength
>b584	1e					  .byte LinkDisplacement	; offset to previous nt
=$b585					XtPtr1 ::= *
=46337					WordListLink ::= Nt0 ; remember the nt of this word for later
.b585					Action_Of:
.b585	20 46 cc	jsr $cc46			jsr Tick		; get xt of "name"
.b588	a5 0a		lda $0a				lda state		; Check STATE
.b58a	f0 c0		beq $b54c			beq Defer_Fetch		; interpreting, get xt in the DEFER word
.b58c					_compiling:
.b58c	20 a1 c7	jsr $c7a1			jsr ldya_immed_comma	; compile LDY #; LDA # of the xt of "name"
.b58f	a0 b5		ldy #$b5			ldy #>Defer_Fetch_YA	; Postpone DEFER@ by compiling a JSR to it.
.b591	a9 4f		lda #$4f			lda #<Defer_Fetch_YA
.b593	4c 78 dd	jmp $dd78			jmp Jsr_Comma_YA
=17					CodeLen	.var *-XtPtr1
=$b596					Here1 = *	; remember here
>b583	11					.byte CodeLen	;patch wh_CodeLength
>b596	55 73 65 72 41 64 64 72		Name0:	.text "UserAddr"	;  name of word as a string, ending at wh_NameLastChar
=8					NameLength = *-Name0
=46366					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>b59e	48					.byte (("UserAddr"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=29					LinkDisplacement = Nt0-WordListLink
>b59f	10					.byte WordFlags	;wh_Flags
>b5a0	03					.byte 3	;wh_CodeLength
>b5a1	1d					  .byte LinkDisplacement	; offset to previous nt
=$b5a2					XtPtr1 ::= *
=46366					WordListLink ::= Nt0 ; remember the nt of this word for later
.b5a2	a0 02		ldy #$02	UserAddr:	ldy #>User0
.b5a4	a9 ff		lda #$ff			lda #<User0
.b5a6	4c ba c7	jmp $c7ba			jmp PushYA
=7					CodeLen	.var *-XtPtr1
=$b5a9					Here1 = *	; remember here
>b5a0	07					.byte CodeLen	;patch wh_CodeLength
>b5a9	42 75 66 66 65 72 3a		Name0:	.text "Buffer:"	;  name of word as a string, ending at wh_NameLastChar
=7					NameLength = *-Name0
=46384					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>b5b0	47					.byte (("Buffer:"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=18					LinkDisplacement = Nt0-WordListLink
>b5b1	10					.byte WordFlags	;wh_Flags
>b5b2	03					.byte 3	;wh_CodeLength
>b5b3	12					  .byte LinkDisplacement	; offset to previous nt
=$b5b4					XtPtr1 ::= *
=46384					WordListLink ::= Nt0 ; remember the nt of this word for later
.b5b4	20 cd d1	jsr $d1cd	Buffer_Colon:	jsr Create
.b5b7	4c c6 d0	jmp $d0c6			jmp Allot
=6					CodeLen	.var *-XtPtr1
=$b5ba					Here1 = *	; remember here
>b5b2	06					.byte CodeLen	;patch wh_CodeLength
>b5ba	43 61 73 65			Name0:	.text "Case"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=46398					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>b5be	a4					.byte (("Case"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=28					WordFlags ::= IM+CO+NN	; modifiable copy, remember for later
=14					LinkDisplacement = Nt0-WordListLink
>b5bf	1c					.byte WordFlags	;wh_Flags
>b5c0	03					.byte 3	;wh_CodeLength
>b5c1	0e					  .byte LinkDisplacement	; offset to previous nt
=$b5c2					XtPtr1 ::= *
=46398					WordListLink ::= Nt0 ; remember the nt of this word for later
.b5c2	4c f7 c7	jmp $c7f7	Case:		jmp Zero	; init jmp fixup chain
=3					CodeLen	.var *-XtPtr1
=$b5c5					Here1 = *	; remember here
>b5c0	03					.byte CodeLen	;patch wh_CodeLength
>b5c5	45 6e 64 43 61 73 65		Name0:	.text "EndCase"	;  name of word as a string, ending at wh_NameLastChar
=7					NameLength = *-Name0
=46412					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>b5cc	a7					.byte (("EndCase"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=28					WordFlags ::= IM+CO+NN	; modifiable copy, remember for later
=14					LinkDisplacement = Nt0-WordListLink
>b5cd	1c					.byte WordFlags	;wh_Flags
>b5ce	03					.byte 3	;wh_CodeLength
>b5cf	0e					  .byte LinkDisplacement	; offset to previous nt
=$b5d0					XtPtr1 ::= *
=46412					WordListLink ::= Nt0 ; remember the nt of this word for later
.b5d0					EndCase:
.b5d0	20 68 dd	jsr $dd68			jsr Drop_Comma
.b5d3					_loop:
.b5d3	b5 25		lda $25,x			lda DStack+1,x	; while addr fixup entries left
.b5d5	f0 06		beq $b5dd			beq _done
.b5d7	20 46 b6	jsr $b646			jsr Then	;   fixup another one
.b5da	4c d3 b5	jmp $b5d3			jmp _loop
.b5dd					_done:
.b5dd	e8		inx				inx		; Drop the 0
.b5de	e8		inx				inx
=15					CodeLen	.var *-XtPtr1
=$b5df					Here1 = *	; remember here
>b5ce	0f					.byte CodeLen	;patch wh_CodeLength
.b5df	60		rts				rts
>b5e0	4f 66				Name0:	.text "Of"	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=46434					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>b5e2	c2					.byte (("Of"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=28					WordFlags ::= IM+CO+NN	; modifiable copy, remember for later
=22					LinkDisplacement = Nt0-WordListLink
>b5e3	1c					.byte WordFlags	;wh_Flags
>b5e4	03					.byte 3	;wh_CodeLength
>b5e5	16					  .byte LinkDisplacement	; offset to previous nt
=$b5e6					XtPtr1 ::= *
=46434					WordListLink ::= Nt0 ; remember the nt of this word for later
.b5e6					Of:
.b5e6	a0 b5		ldy #$b5			ldy #>_runtime		; Check if value is equal to this case.
.b5e8	a9 f0		lda #$f0			lda #<_runtime
.b5ea	20 78 dd	jsr $dd78			jsr Jsr_Comma_YA
.b5ed	4c 14 b6	jmp $b614			jmp zbranch_jmp0_comma	; save addr ptr; compile jmp abs
=10					CodeLen	.var *-XtPtr1
=$b5f0					Here1 = *	; remember here
>b5e4	0a					.byte CodeLen	;patch wh_CodeLength
.b5f0					_runtime:
.b5f0	e8		inx				inx		; Drop x2
.b5f1	e8		inx				inx
.b5f2	b5 22		lda $22,x			lda DStack-2,x	; compare x1 with x2
.b5f4	d5 24		cmp $24,x			cmp DStack+0,x
.b5f6	d0 06		bne $b5fe			bne _NotEq
.b5f8	b5 23		lda $23,x			lda DStack-1,x
.b5fa	d5 25		cmp $25,x			cmp DStack+1,x
.b5fc	f0 30		beq $b62e			beq zbranch_run2 ; Drop x1 & return to after the jmp abs
.b5fe	60		rts		_NotEq:		rts		; return to the jmp abs to next test
>b5ff	45 6e 64 4f 66			Name0:	.text "EndOf"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=46468					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>b604	c5					.byte (("EndOf"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=28					WordFlags ::= IM+CO+NN	; modifiable copy, remember for later
=34					LinkDisplacement = Nt0-WordListLink
>b605	1c					.byte WordFlags	;wh_Flags
>b606	03					.byte 3	;wh_CodeLength
>b607	22					  .byte LinkDisplacement	; offset to previous nt
=$b608					XtPtr1 ::= *
=46468					WordListLink ::= Nt0 ; remember the nt of this word for later
.b608	4c 57 b6	jmp $b657	EndOf:		jmp Else
=3					CodeLen	.var *-XtPtr1
=$b60b					Here1 = *	; remember here
>b606	03					.byte CodeLen	;patch wh_CodeLength
>b60b	49 66				Name0:	.text "If"	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=46477					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>b60d	c2					.byte (("If"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=28					WordFlags ::= IM+CO+NN	; modifiable copy, remember for later
=9					LinkDisplacement = Nt0-WordListLink
>b60e	1c					.byte WordFlags	;wh_Flags
>b60f	03					.byte 3	;wh_CodeLength
>b610	09					  .byte LinkDisplacement	; offset to previous nt
=$b611					XtPtr1 ::= *
=46477					WordListLink ::= Nt0 ; remember the nt of this word for later
.b611					If:
.b611	20 21 b6	jsr $b621	If3:		jsr zbranch_jsr_comma	; Compile a 0BRANCH
.b614					zbranch_jmp0_comma:
.b614	20 67 da	jsr $da67			jsr Here		; save ptr to address for else/then
.b617	20 9a da	jsr $da9a			jsr One_Plus
.b61a	a0 c3		ldy #$c3			ldy #>Abort		; compile jmp abs
.b61c	a9 bb		lda #$bb			lda #<Abort		; THEN or ELSE will fix address later.
.b61e	4c 8e dd	jmp $dd8e			jmp Jmp_Comma_YA
=16					CodeLen	.var *-XtPtr1
=$b621					Here1 = *	; remember here
>b60f	10					.byte CodeLen	;patch wh_CodeLength
=$dd8b					zbranch_jmp_comma = Jmp_Comma		; compile jmp abs
.b621					zbranch_jsr_comma:
.b621	a0 b6		ldy #$b6			ldy #>_runtime
.b623	a9 28		lda #$28			lda #<_runtime
.b625	4c 78 dd	jmp $dd78			jmp Jsr_Comma_YA
.b628					_runtime:
.b628	b5 24		lda $24,x			lda DStack+0,x		;flag is false?
.b62a	15 25		ora $25,x			ora DStack+1,x
.b62c	f0 0d		beq $b63b			beq zbranch_run_done
.b62e	18		clc		zbranch_run2:	clc			; move RTS addr over the next jmp abs.
.b62f	68		pla				pla
.b630	69 03		adc #$03			adc #3
.b632	90 06		bcc $b63a			bcc +
.b634	a8		tay				tay
.b635	68		pla				pla
.b636	69 00		adc #$00			adc #0
.b638	48		pha				pha
.b639	98		tya				tya
.b63a	48		pha		+		pha
.b63b					zbranch_run_done:
.b63b	e8		inx				inx			; Drop f
.b63c	e8		inx				inx
.b63d	60		rts				rts
>b63e	54 68 65 6e			Name0:	.text "Then"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=46530					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>b642	c4					.byte (("Then"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=28					WordFlags ::= IM+CO+NN	; modifiable copy, remember for later
=53					LinkDisplacement = Nt0-WordListLink
>b643	1c					.byte WordFlags	;wh_Flags
>b644	03					.byte 3	;wh_CodeLength
>b645	35					  .byte LinkDisplacement	; offset to previous nt
=$b646					XtPtr1 ::= *
=46530					WordListLink ::= Nt0 ; remember the nt of this word for later
.b646					Then:
.b646	20 67 da	jsr $da67			jsr Here
.b649	20 f3 df	jsr $dff3			jsr Swap
.b64c	4c 13 df	jmp $df13			jmp Store
=9					CodeLen	.var *-XtPtr1
=$b64f					Here1 = *	; remember here
>b644	09					.byte CodeLen	;patch wh_CodeLength
>b64f	45 6c 73 65			Name0:	.text "Else"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=46547					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>b653	a4					.byte (("Else"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=28					WordFlags ::= IM+CO+NN	; modifiable copy, remember for later
=17					LinkDisplacement = Nt0-WordListLink
>b654	1c					.byte WordFlags	;wh_Flags
>b655	03					.byte 3	;wh_CodeLength
>b656	11					  .byte LinkDisplacement	; offset to previous nt
=$b657					XtPtr1 ::= *
=46547					WordListLink ::= Nt0 ; remember the nt of this word for later
.b657					Else:
.b657	20 14 b6	jsr $b614			jsr zbranch_jmp0_comma	; compile jmp 0, push addr of addr
.b65a	20 67 da	jsr $da67			jsr Here
.b65d	20 b3 de	jsr $deb3			jsr Rot
.b660	4c 13 df	jmp $df13			jmp Store
=12					CodeLen	.var *-XtPtr1
=$b663					Here1 = *	; remember here
>b655	0c					.byte CodeLen	;patch wh_CodeLength
>b663	42 65 67 69 6e			Name0:	.text "Begin"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=46568					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>b668	c5					.byte (("Begin"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=28					WordFlags ::= NN+CO+IM	; modifiable copy, remember for later
=21					LinkDisplacement = Nt0-WordListLink
>b669	1c					.byte WordFlags	;wh_Flags
>b66a	03					.byte 3	;wh_CodeLength
>b66b	15					  .byte LinkDisplacement	; offset to previous nt
=$b66c					XtPtr1 ::= *
=46568					WordListLink ::= Nt0 ; remember the nt of this word for later
.b66c	20 67 da	jsr $da67	Begin:		jsr Here	; remember the loop starting location
.b66f	a9 6c		lda #$6c			lda #<Begin	; pairing marker
.b671	4c e9 c7	jmp $c7e9			jmp PushZA
=8					CodeLen	.var *-XtPtr1
=$b674					Here1 = *	; remember here
>b66a	08					.byte CodeLen	;patch wh_CodeLength
>b674	41 67 61 69 6e			Name0:	.text "Again"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=46585					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>b679	c5					.byte (("Again"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=92					WordFlags ::= NN+CO+IM+UF	; modifiable copy, remember for later
=17					LinkDisplacement = Nt0-WordListLink
>b67a	5c					.byte WordFlags	;wh_Flags
>b67b	03					.byte 3	;wh_CodeLength
>b67c	11					  .byte LinkDisplacement	; offset to previous nt
=$b67d					XtPtr1 ::= *
=46585					WordListLink ::= Nt0 ; remember the nt of this word for later
.b67d	20 20 c4	jsr $c420	Again:		jsr underflow_2
.b680	a9 6c		lda #$6c			lda #<Begin	; check pairing
.b682	20 f8 c1	jsr $c1f8			jsr QPairCtlA
.b685	4c 8b dd	jmp $dd8b			jmp Jmp_Comma	; Compile a jmp abs.
=11					CodeLen	.var *-XtPtr1
=$b688					Here1 = *	; remember here
>b67b	0b					.byte CodeLen	;patch wh_CodeLength
>b688	55 6e 74 69 6c			Name0:	.text "Until"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=46605					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>b68d	85					.byte (("Until"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=28					WordFlags ::= IM+CO+NN	; modifiable copy, remember for later
=20					LinkDisplacement = Nt0-WordListLink
>b68e	1c					.byte WordFlags	;wh_Flags
>b68f	03					.byte 3	;wh_CodeLength
>b690	14					  .byte LinkDisplacement	; offset to previous nt
=$b691					XtPtr1 ::= *
=46605					WordListLink ::= Nt0 ; remember the nt of this word for later
.b691	a9 6c		lda #$6c	Until:		lda #<Begin		; check pairing
.b693	20 f8 c1	jsr $c1f8			jsr QPairCtlA
.b696	4c cd b6	jmp $b6cd			jmp ZBranch_Comma	; The address to loop back to is on the stack.
=8					CodeLen	.var *-XtPtr1
=$b699					Here1 = *	; remember here
>b68f	08					.byte CodeLen	;patch wh_CodeLength
>b699	57 68 69 6c 65			Name0:	.text "While"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=46622					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>b69e	a5					.byte (("While"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=28					WordFlags ::= IM+CO+NN	; modifiable copy, remember for later
=17					LinkDisplacement = Nt0-WordListLink
>b69f	1c					.byte WordFlags	;wh_Flags
>b6a0	03					.byte 3	;wh_CodeLength
>b6a1	11					  .byte LinkDisplacement	; offset to previous nt
=$b6a2					XtPtr1 ::= *
=46622					WordListLink ::= Nt0 ; remember the nt of this word for later
.b6a2	a9 6c		lda #$6c	While:		lda #<Begin	; check pairing
.b6a4	20 f8 c1	jsr $c1f8			jsr QPairCtlA
.b6a7	20 11 b6	jsr $b611			jsr If3		; Compile a 0branch & jmp, push addr of addr
.b6aa	20 f3 df	jsr $dff3			jsr Swap	; Swap the two addresses on the stack.
.b6ad	a9 6c		lda #$6c			lda #<Begin	; pairing marker
.b6af	4c e9 c7	jmp $c7e9			jmp PushZA
=16					CodeLen	.var *-XtPtr1
=$b6b2					Here1 = *	; remember here
>b6a0	10					.byte CodeLen	;patch wh_CodeLength
>b6b2	52 65 70 65 61 74		Name0:	.text "Repeat"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=46648					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>b6b8	86					.byte (("Repeat"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=28					WordFlags ::= IM+CO+NN	; modifiable copy, remember for later
=26					LinkDisplacement = Nt0-WordListLink
>b6b9	1c					.byte WordFlags	;wh_Flags
>b6ba	03					.byte 3	;wh_CodeLength
>b6bb	1a					  .byte LinkDisplacement	; offset to previous nt
=$b6bc					XtPtr1 ::= *
=46648					WordListLink ::= Nt0 ; remember the nt of this word for later
.b6bc	a9 6c		lda #$6c	Repeat:		lda #<Begin	; check pairing
.b6be	20 f8 c1	jsr $c1f8			jsr QPairCtlA
.b6c1	20 8b dd	jsr $dd8b			jsr Jmp_Comma	; compile the jmp back
.b6c4	20 67 da	jsr $da67			jsr Here	; patch the WHILE jmp operand
.b6c7	20 f3 df	jsr $dff3			jsr Swap
.b6ca	4c 13 df	jmp $df13			jmp Store
=17					CodeLen	.var *-XtPtr1
=$b6cd					Here1 = *	; remember here
>b6ba	11					.byte CodeLen	;patch wh_CodeLength
.b6cd					ZBranch_Comma:
.b6cd	a9 e8		lda #$e8			lda #$e8		; compile inx; inx
.b6cf	a8		tay				tay
.b6d0	20 55 dd	jsr $dd55			jsr Comma_YA
.b6d3	a9 b5		lda #$b5			lda #$b5		; compile lda DStack-2,x
.b6d5	a0 22		ldy #$22			ldy #DStack-2
.b6d7	20 55 dd	jsr $dd55			jsr Comma_YA
.b6da	a9 15		lda #$15			lda #$15		; compile ora DStack-1,x
.b6dc	a0 23		ldy #$23			ldy #DStack-1
.b6de	20 55 dd	jsr $dd55			jsr Comma_YA
.b6e1	a9 f0		lda #$f0			lda #$f0		; BEQ
.b6e3	d0 0e		bne $b6f3			bne Branch_CommaA
>b6e5	42 72 61 6e 63 68 2c		Name0:	.text "Branch,"	;  name of word as a string, ending at wh_NameLastChar
=7					NameLength = *-Name0
=46700					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>b6ec	87					.byte (("Branch,"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=52					LinkDisplacement = Nt0-WordListLink
>b6ed	10					.byte WordFlags	;wh_Flags
>b6ee	03					.byte 3	;wh_CodeLength
>b6ef	34					  .byte LinkDisplacement	; offset to previous nt
=$b6f0					XtPtr1 ::= *
=46700					WordListLink ::= Nt0 ; remember the nt of this word for later
.b6f0	20 c8 c3	jsr $c3c8			jsr PopA		; pop opcode to A
.b6f3					Branch_CommaA:
.b6f3	48		pha				pha			; save branch opcode
.b6f4	38		sec				sec			; AY= displacement+2
.b6f5	b5 24		lda $24,x			lda DStack+0,x
.b6f7	e5 00		sbc $00				sbc cp+0
.b6f9	a8		tay				tay
.b6fa	b5 25		lda $25,x			lda DStack+1,x
.b6fc	e5 01		sbc $01				sbc cp+1
.b6fe	c9 ff		cmp #$ff			cmp #$ff		; offset maybe in range?
.b700	f0 0b		beq $b70d			beq _rev
.b702	68		pla		_2byte:		pla			; restore branch opcode
.b703	49 20		eor #$20			eor #$20		; reverse branch sense
.b705	a0 03		ldy #$03			ldy #3			; compile Bcc *+5
.b707	20 55 dd	jsr $dd55			jsr Comma_YA
.b70a	4c 8b dd	jmp $dd8b			jmp Jmp_Comma		; compile JMP abs
.b70d	c0 82		cpy #$82	_rev:		cpy #$80+2		; offset in range?
.b70f	90 f1		bcc $b702			bcc _2byte
.b711	e8		inx		_1byte:		inx			; Drop address
.b712	e8		inx				inx
.b713	88		dey				dey			; fix displacement
.b714	88		dey				dey
.b715	68		pla				pla			; restore branch opcode
.b716	4c 55 dd	jmp $dd55			jmp Comma_YA		; compile Bcc
>b719	57 6f 72 64			Name0:	.text "Word"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=46749					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>b71d	84					.byte (("Word"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=49					LinkDisplacement = Nt0-WordListLink
>b71e	10					.byte WordFlags	;wh_Flags
>b71f	03					.byte 3	;wh_CodeLength
>b720	31					  .byte LinkDisplacement	; offset to previous nt
=$b721					XtPtr1 ::= *
=46749					WordListLink ::= Nt0 ; remember the nt of this word for later
.b721					Word:
.b721	20 0c c4	jsr $c40c			jsr underflow_1
.b724	a4 08		ldy $08				ldy toin+0		; >IN
.b726	c4 06		cpy $06		_DelimLoop:	cpy ciblen+0		; quit if end of input
.b728	f0 09		beq $b733			beq _found_char
.b72a	b1 04		lda ($04),y			lda (cib),y
.b72c	d5 24		cmp $24,x			cmp DStack+0,x		; ASCII of delimiter
.b72e	d0 03		bne $b733			bne _found_char
.b730	c8		iny				iny
.b731	d0 f3		bne $b726			bne _DelimLoop
.b733					_found_char:
.b733	84 08		sty $08				sty toin+0		; Save index of where word starts
.b735	20 ce ca	jsr $cace			jsr Parse		; The real work is done by parse
.b738	20 c8 c3	jsr $c3c8			jsr PopA		; pop u
.b73b	85 16		sta $16				sta tmp2+0
.b73d	20 ee c3	jsr $c3ee			jsr PopTmp1		; pop addr
.b740	20 67 da	jsr $da67			jsr Here		; Return caddr
.b743	a5 16		lda $16				lda tmp2+0
.b745	a0 00		ldy #$00			ldy #0			; Save length of string
.b747	f0 03		beq $b74c			beq _CopyStart
.b749	b1 14		lda ($14),y	_CopyLoop:	lda (tmp1),y
.b74b	c8		iny				iny
.b74c	20 3e dd	jsr $dd3e	_CopyStart:	jsr C_Comma_A
.b74f	c4 16		cpy $16				cpy tmp2+0
.b751	90 f6		bcc $b749			bcc _CopyLoop
=50					CodeLen	.var *-XtPtr1
=$b753					Here1 = *	; remember here
>b71f	32					.byte CodeLen	;patch wh_CodeLength
.b753	60		rts				rts
>b754	28				Name0:	.text "("	;  name of word as a string, ending at wh_NameLastChar
=1					NameLength = *-Name0
=46805					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>b755	01					.byte (("("[-1]&7)<<5)+NameLength	;wh_HashNameLen
=24					WordFlags ::= IM+NN	; modifiable copy, remember for later
=56					LinkDisplacement = Nt0-WordListLink
>b756	18					.byte WordFlags	;wh_Flags
>b757	03					.byte 3	;wh_CodeLength
>b758	38					  .byte LinkDisplacement	; offset to previous nt
=$b759					XtPtr1 ::= *
=46805					WordListLink ::= Nt0 ; remember the nt of this word for later
.b759	a9 29		lda #$29	Paren:		lda #')'		; separator
.b75b	20 d1 ca	jsr $cad1			jsr Parse_A		; get string
.b75e	4c 72 d5	jmp $d572			jmp Two_drop		; 2Drop the result.
=8					CodeLen	.var *-XtPtr1
=$b761					Here1 = *	; remember here
>b757	08					.byte CodeLen	;patch wh_CodeLength
>b761	2e 28				Name0:	.text ".("	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=46819					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>b763	02					.byte ((".("[-1]&7)<<5)+NameLength	;wh_HashNameLen
=24					WordFlags ::= IM+NN	; modifiable copy, remember for later
=14					LinkDisplacement = Nt0-WordListLink
>b764	18					.byte WordFlags	;wh_Flags
>b765	03					.byte 3	;wh_CodeLength
>b766	0e					  .byte LinkDisplacement	; offset to previous nt
=$b767					XtPtr1 ::= *
=46819					WordListLink ::= Nt0 ; remember the nt of this word for later
.b767	a9 29		lda #$29	Dot_paren:	lda #')'		; separator
.b769	20 d1 ca	jsr $cad1			jsr Parse_A		; get string
.b76c	4c 39 de	jmp $de39			jmp Type		; type the string
=8					CodeLen	.var *-XtPtr1
=$b76f					Here1 = *	; remember here
>b765	08					.byte CodeLen	;patch wh_CodeLength
>b76f	48 61 73 68			Name0:	.text "Hash"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=46835					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>b773	04					.byte (("Hash"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=16					LinkDisplacement = Nt0-WordListLink
>b774	10					.byte WordFlags	;wh_Flags
>b775	03					.byte 3	;wh_CodeLength
>b776	10					  .byte LinkDisplacement	; offset to previous nt
=$b777					XtPtr1 ::= *
=46835					WordListLink ::= Nt0 ; remember the nt of this word for later
.b777	20 c8 c3	jsr $c3c8	Hash:		jsr PopA		; save length
.b77a	85 16		sta $16				sta tmp2+0
.b77c	b5 24		lda $24,x			lda DStack+0,x		; copy addr
.b77e	b4 25		ldy $25,x			ldy DStack+1,x
.b780	85 14		sta $14				sta tmp1+0
.b782	84 15		sty $15				sty tmp1+1
.b784	a9 b3		lda #$b3			lda #$b3		; init hash
.b786	95 24		sta $24,x			sta DStack+0,x
.b788	95 25		sta $25,x			sta DStack+1,x
.b78a	a0 00		ldy #$00			ldy #0			; for each char
.b78c	f0 15		beq $b7a3			beq _next
.b78e	b1 14		lda ($14),y	_loop:		lda (tmp1),y		;   get char
.b790	c9 61		cmp #$61			cmp #'a'		;   uppercase
.b792	90 06		bcc $b79a			bcc _3
.b794	c9 7b		cmp #$7b			cmp #'z'+1
.b796	b0 02		bcs $b79a			bcs _3
.b798	29 df		and #$df			and #$df
.b79a	16 24		asl $24,x	_3:		asl DStack+0,x		;   add to hash
.b79c	36 25		rol $25,x			rol DStack+1,x
.b79e	75 24		adc $24,x			adc DStack+0,x
.b7a0	95 24		sta $24,x			sta DStack+0,x
.b7a2	c8		iny				iny
.b7a3	c4 16		cpy $16		_Next:		cpy tmp2+0
.b7a5	90 e7		bcc $b78e			bcc _loop
=48					CodeLen	.var *-XtPtr1
=$b7a7					Here1 = *	; remember here
>b775	30					.byte CodeLen	;patch wh_CodeLength
.b7a7	60		rts				rts
>b7a8	45 6e 76 69 72 6f 6e 6d		Name0:	.text "Environment?"	;  name of word as a string, ending at wh_NameLastChar
>b7b0	65 6e 74 3f
=12					NameLength = *-Name0
=46900					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>b7b4	ec					.byte (("Environment?"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=65					LinkDisplacement = Nt0-WordListLink
>b7b5	10					.byte WordFlags	;wh_Flags
>b7b6	03					.byte 3	;wh_CodeLength
>b7b7	41					  .byte LinkDisplacement	; offset to previous nt
=$b7b8					XtPtr1 ::= *
=46900					WordListLink ::= Nt0 ; remember the nt of this word for later
.b7b8					Environment_Q:
.b7b8	20 77 b7	jsr $b777			jsr Hash		; ( hash )
.b7bb	a0 00		ldy #$00			ldy #0			; Y= table index
.b7bd	f0 0a		beq $b7c9			beq _entry_test
.b7bf	98		tya		_entry_next:	tya
.b7c0	c0 34		cpy #$34			cpy #_table_dbl		; if double
.b7c2	90 02		bcc $b7c6			bcc +
.b7c4	69 01		adc #$01			adc #6-4-1		;   skip double
.b7c6	69 04		adc #$04	+		adc #4			;   skip single
.b7c8	a8		tay		_3:		tay
.b7c9	b9 fd b7	lda $b7fd,y	_entry_test:	lda _Table+0,y		; match?
.b7cc	f0 28		beq $b7f6			beq _notfound
.b7ce	d5 24		cmp $24,x			cmp DStack+0,x
.b7d0	d0 ed		bne $b7bf			bne _entry_next
.b7d2	b9 fe b7	lda $b7fe,y			lda _Table+1,y
.b7d5	d5 25		cmp $25,x			cmp DStack+1,x
.b7d7	d0 e6		bne $b7bf			bne _entry_next
.b7d9	b9 ff b7	lda $b7ff,y			lda _Table+2,y
.b7dc	95 24		sta $24,x			sta DStack+0,x
.b7de	b9 00 b8	lda $b800,y			lda _Table+3,y
.b7e1	95 25		sta $25,x			sta DStack+1,x
.b7e3	c0 34		cpy #$34			cpy #_table_dbl		; single or double data?
.b7e5	90 0c		bcc $b7f3			bcc _single
.b7e7	ca		dex				dex			;  push 2nd cell
.b7e8	ca		dex				dex
.b7e9	b9 01 b8	lda $b801,y			lda _Table+4,y
.b7ec	95 24		sta $24,x			sta DStack+0,x
.b7ee	b9 02 b8	lda $b802,y			lda _Table+5,y
.b7f1	95 25		sta $25,x			sta DStack+1,x
.b7f3					_single:
.b7f3	4c c9 c7	jmp $c7c9			jmp True		; return True
.b7f6					_notfound:
.b7f6	a9 00		lda #$00			lda #0			; return 0
.b7f8	95 24		sta $24,x			sta DStack+0,x
.b7fa	95 25		sta $25,x			sta DStack+1,x
.b7fc	60		rts				rts
=69					CodeLen	.var *-XtPtr1
=$b7fd					Here1 = *	; remember here
>b7b6	45					.byte CodeLen	;patch wh_CodeLength
.b7fd					_Table:
>b7fd	5e e6 ff 7f				.word $e65e,$7fff	; "/COUNTED-STRING"
>b801	be 79 ff 00				.word $79BE,$ff		; "/HOLD"
>b805	b9 3c 54 00				.word $3cb9,padoffset	; "/PAD"
>b809	8b 81 08 00				.word $818b,8		; "ADDRESS-UNIT-BITS"
>b80d	57 fc 00 00				.word $fc57,0		; "FLOORED"	we have symmetric)
>b811	4f fb ff 00				.word $fb4f,$ff		; "MAX-CHAR"
>b815	56 7f ff 7f				.word $7f56,$7fff	; "MAX-N"
>b819	5d 7f ff ff				.word $7f5d,$ffff	; "MAX-U"
>b81d	38 ce 80 00				.word $ce38,$80		; "RETURN-STACK-CELLS"
>b821	f2 c0 18 00				.word $c0f2,DDim	; "STACK-CELLS"
>b825	36 e3 09 00				.word $e336,9		; "WORDLISTS"
>b829	4a f2 ff ff				.word $f24a,$ffff	; "FLOATING"		flag	no	   floating-point word set present
>b82d	01 99 0a 00				.word $9901,FDim	; "FLOATING-STACK"	n	yes	   If n = zero, floating-point numbers are
=52					_table_dbl = *-_Table	; These return a double-cell number
>b831	4c 7f ff ff ff 7f			.word $7f4c,$ffff,$7fff	; "MAX-D"
>b837	fe fe ff ff ff ff			.word $fefe,$ffff,$ffff	; "MAX-UD"
>b83d	00					.byte 0		; end of list
>b83e	44 75 6d 70			Name0:	.text "Dump"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=47042					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>b842	04					.byte (("Dump"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=142					LinkDisplacement = Nt0-WordListLink
>b843	10					.byte WordFlags	;wh_Flags
>b844	03					.byte 3	;wh_CodeLength
>b845	8e					  .byte LinkDisplacement	; offset to previous nt
=$b846					XtPtr1 ::= *
=47042					WordListLink ::= Nt0 ; remember the nt of this word for later
.b846	20 20 c4	jsr $c420	Dump:		jsr underflow_2
.b849	ca		dex				dex			; alloc work area
.b84a	ca		dex				dex
.b84b					_row:
.b84b	20 4c bb	jsr $bb4c			jsr CR
.b84e	b5 29		lda $29,x			lda DStack+5,x		; print address number
.b850	20 ce b8	jsr $b8ce			jsr C_Dot_Hex_A
.b853	b5 28		lda $28,x			lda DStack+4,x
.b855	20 ce b8	jsr $b8ce			jsr C_Dot_Hex_A
.b858	20 2d de	jsr $de2d			jsr Space
.b85b	20 2d de	jsr $de2d			jsr Space
.b85e	a9 00		lda #$00			lda #0
.b860	95 24		sta $24,x			sta DStack+0,x
.b862					_loop:
.b862	b5 26		lda $26,x			lda DStack+2,x
.b864	15 27		ora $27,x			ora DStack+3,x
.b866	f0 36		beq $b89e			beq _all_printed
.b868	a1 28		lda ($28,x)			lda (DStack+4,x)
.b86a	20 ce b8	jsr $b8ce			jsr C_Dot_Hex_A
.b86d	20 2d de	jsr $de2d			jsr Space
.b870	a1 28		lda ($28,x)			lda (DStack+4,x)
.b872	20 f4 b8	jsr $b8f4			jsr is_printable
.b875	b0 02		bcs $b879			bcs _printable
.b877	a9 2e		lda #$2e			lda #'.'		 ; Print dot if not printable
.b879					_printable:
.b879	b4 24		ldy $24,x			ldy DStack+0,x
.b87b	91 00		sta ($00),y			sta (cp),y
.b87d	c0 07		cpy #$07			cpy #7
.b87f	d0 03		bne $b884			bne +
.b881	20 2d de	jsr $de2d			jsr Space
.b884					+
.b884	f6 28		inc $28,x			inc DStack+4,x
.b886	d0 02		bne $b88a			bne +
.b888	f6 29		inc $29,x			inc DStack+5,x
.b88a					+
.b88a	20 81 da	jsr $da81			jsr NOS_One_Minus	; loop counter
.b88d	f6 24		inc $24,x			inc DStack+0,x
.b88f	b5 24		lda $24,x			lda DStack+0,x
.b891	c9 10		cmp #$10			cmp #16
.b893	90 cd		bcc $b862			bcc _loop		; next byte
.b895	20 2d de	jsr $de2d			jsr Space
.b898	20 ad b8	jsr $b8ad			jsr dump_print_ascii
.b89b	4c 4b b8	jmp $b84b			jmp _row		; new row
.b89e					_all_printed:
.b89e	b5 24		lda $24,x			lda DStack+0,x
.b8a0	f0 06		beq $b8a8			beq _done
.b8a2	20 2d de	jsr $de2d			jsr Space
.b8a5	20 ad b8	jsr $b8ad			jsr dump_print_ascii
.b8a8					_done:
.b8a8	e8		inx				inx			; drop work area
.b8a9	e8		inx				inx
.b8aa	4c 72 d5	jmp $d572			jmp Two_drop		; one byte less than 4x INX
.b8ad					dump_print_ascii:
.b8ad	a0 00		ldy #$00			ldy #0
.b8af					_loop:
.b8af	b1 00		lda ($00),y			lda (cp),y
.b8b1	20 21 de	jsr $de21			jsr Emit_A
.b8b4	c8		iny				iny
.b8b5	c0 08		cpy #$08			cpy #8
.b8b7	d0 03		bne $b8bc			bne +
.b8b9	20 2d de	jsr $de2d			jsr Space
.b8bc					+
.b8bc	98		tya				tya
.b8bd	d5 24		cmp $24,x			cmp DStack+0,x
.b8bf	90 ee		bcc $b8af			bcc _loop
.b8c1	60		rts				rts
=124					CodeLen	.var *-XtPtr1
=$b8c2					Here1 = *	; remember here
>b844	7c					.byte CodeLen	;patch wh_CodeLength
>b8c2	43 2e 48 65 78			Name0:	.text "C.Hex"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=47175					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>b8c7	05					.byte (("C.Hex"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=133					LinkDisplacement = Nt0-WordListLink
>b8c8	10					.byte WordFlags	;wh_Flags
>b8c9	03					.byte 3	;wh_CodeLength
>b8ca	85					  .byte LinkDisplacement	; offset to previous nt
=$b8cb					XtPtr1 ::= *
=47175					WordListLink ::= Nt0 ; remember the nt of this word for later
.b8cb	20 c8 c3	jsr $c3c8	C_Dot_Hex:	jsr PopA
.b8ce	48		pha		C_Dot_Hex_A:	pha
.b8cf	4a		lsr a				lsr		; convert high nibble first
.b8d0	4a		lsr a				lsr
.b8d1	4a		lsr a				lsr
.b8d2	4a		lsr a				lsr
.b8d3	20 d7 b8	jsr $b8d7			jsr _nibble_to_ascii
.b8d6	68		pla				pla
.b8d7					_nibble_to_ascii:
.b8d7	29 0f		and #$0f			and #$0F	; only use lower nibble
.b8d9	c9 0a		cmp #$0a			cmp #9+1
.b8db	90 02		bcc $b8df			bcc +
.b8dd	69 06		adc #$06			adc #6
.b8df	69 30		adc #$30	+		adc #'0'
.b8e1	4c 21 de	jmp $de21			jmp Emit_A
=25					CodeLen	.var *-XtPtr1
=$b8e4					Here1 = *	; remember here
>b8c9	19					.byte CodeLen	;patch wh_CodeLength
>b8e4	2e 48 65 78			Name0:	.text ".Hex"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=47208					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>b8e8	04					.byte ((".Hex"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=33					LinkDisplacement = Nt0-WordListLink
>b8e9	10					.byte WordFlags	;wh_Flags
>b8ea	03					.byte 3	;wh_CodeLength
>b8eb	21					  .byte LinkDisplacement	; offset to previous nt
=$b8ec					XtPtr1 ::= *
=47208					WordListLink ::= Nt0 ; remember the nt of this word for later
.b8ec	b5 25		lda $25,x	Dot_Hex:	lda DStack+1,x	; do hi byte
.b8ee	20 ce b8	jsr $b8ce			jsr C_Dot_Hex_A
.b8f1	4c cb b8	jmp $b8cb			jmp C_Dot_Hex	; do lo byte
=8					CodeLen	.var *-XtPtr1
=$b8f4					Here1 = *	; remember here
>b8ea	08					.byte CodeLen	;patch wh_CodeLength
.b8f4					is_printable:
.b8f4	c9 20		cmp #$20	                cmp #AscSP              ; $20
.b8f6	90 07		bcc $b8ff	                bcc _done
.b8f8	c9 80		cmp #$80	                cmp #$7F + 1             ; '~'
.b8fa	b0 02		bcs $b8fe	                bcs _failed
.b8fc	38		sec		                sec
.b8fd	60		rts		                rts
.b8fe	18		clc		_failed:	clc
.b8ff	60		rts		_done:		rts
>b900	2e 53				Name0:	.text ".S"	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=47234					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>b902	62					.byte ((".S"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=26					LinkDisplacement = Nt0-WordListLink
>b903	10					.byte WordFlags	;wh_Flags
>b904	03					.byte 3	;wh_CodeLength
>b905	1a					  .byte LinkDisplacement	; offset to previous nt
=$b906					XtPtr1 ::= *
=47234					WordListLink ::= Nt0 ; remember the nt of this word for later
.b906					Dot_s:
.b906	a9 3c		lda #$3c			lda #'<'
.b908	20 21 de	jsr $de21			jsr Emit_A
.b90b	20 61 d2	jsr $d261			jsr Depth	; ( -- u )
.b90e	20 6b dc	jsr $dc6b			jsr print_u
.b911	a9 3e		lda #$3e			lda #'>'
.b913	20 21 de	jsr $de21			jsr Emit_A
.b916	20 2d de	jsr $de2d			jsr Space
.b919	a0 30		ldy #$30			ldy #DDim*2		; for each cell on the stack
.b91b	88		dey		_loop:		dey
.b91c	88		dey				dey
.b91d	86 14		stx $14				stx tmp1
.b91f	c4 14		cpy $14				cpy tmp1
.b921	90 15		bcc $b938			bcc _done
.b923	98		tya				tya			; save index
.b924	48		pha				pha
.b925	ca		dex				dex			; push stack[index]
.b926	ca		dex				dex
.b927	b9 24 00	lda $0024,y			lda DStack+0,y
.b92a	95 24		sta $24,x			sta DStack+0,x
.b92c	b9 25 00	lda $0025,y			lda DStack+1,y
.b92f	95 25		sta $25,x			sta DStack+1,x
.b931	20 21 dc	jsr $dc21			jsr Dot
.b934	68		pla				pla			; restore index
.b935	a8		tay				tay
.b936	d0 e3		bne $b91b			bne _loop
.b938					_done:
=50					CodeLen	.var *-XtPtr1
=$b938					Here1 = *	; remember here
>b904	32					.byte CodeLen	;patch wh_CodeLength
.b938	60		rts				rts
>b939	43 6f 6d 70 61 72 65		Name0:	.text "Compare"	;  name of word as a string, ending at wh_NameLastChar
=7					NameLength = *-Name0
=47296					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>b940	a7					.byte (("Compare"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=80					WordFlags ::= UF+NN	; modifiable copy, remember for later
=62					LinkDisplacement = Nt0-WordListLink
>b941	50					.byte WordFlags	;wh_Flags
>b942	03					.byte 3	;wh_CodeLength
>b943	3e					  .byte LinkDisplacement	; offset to previous nt
=$b944					XtPtr1 ::= *
=47296					WordListLink ::= Nt0 ; remember the nt of this word for later
.b944					Compare:
.b944	20 2a c4	jsr $c42a			jsr underflow_4
.b947	b5 24		lda $24,x			lda DStack+0,x		; tmp3+1= u2.lo
.b949	85 19		sta $19				sta tmp3+1
.b94b	b5 26		lda $26,x			lda DStack+2,x		; tmp2= addr2
.b94d	b4 27		ldy $27,x			ldy DStack+3,x
.b94f	85 16		sta $16				sta tmp2+0
.b951	84 17		sty $17				sty tmp2+1
.b953	b5 28		lda $28,x			lda DStack+4,x		; tmp3+0= u1.lo
.b955	85 18		sta $18				sta tmp3+0
.b957	b5 2a		lda $2a,x			lda DStack+6,x		; tmp1= addr1
.b959	b4 2b		ldy $2b,x			ldy DStack+7,x
.b95b	85 14		sta $14				sta tmp1+0
.b95d	84 15		sty $15				sty tmp1+1
.b95f	a0 00		ldy #$00			ldy #0		; for each char
.b961					_loop:
.b961	c4 18		cpy $18				cpy tmp3+0	; string1 empty?
.b963	f0 13		beq $b978			beq _str1
.b965					_L1:
.b965	c4 19		cpy $19				cpy tmp3+1	; string2 empty?
.b967	f0 27		beq $b990			beq _str2
.b969					_L2:
.b969	b1 14		lda ($14),y			lda (tmp1),y	; Are they different?
.b96b	d1 16		cmp ($16),y			cmp (tmp2),y
.b96d	d0 19		bne $b988			bne _neq
.b96f	c8		iny				iny		; to next char
.b970	d0 ef		bne $b961			bne _loop
.b972	e6 15		inc $15				inc tmp1+1	; to next page
.b974	e6 17		inc $17				inc tmp2+1
.b976	d0 e9		bne $b961			bne _loop
.b978	d6 29		dec $29,x	_str1:		dec DStack+5,x	; string1 really empty?
.b97a	10 e9		bpl $b965			bpl _L1
.b97c	c4 19		cpy $19				cpy tmp3+1	; string2 empty?
.b97e	d0 0a		bne $b98a			bne _less
.b980	b5 25		lda $25,x			lda DStack+1,x
.b982	d0 06		bne $b98a			bne _less
.b984	a9 00		lda #$00	_equal:		lda #0		; Return 0
.b986	f0 0e		beq $b996			beq _gt2
.b988	b0 0a		bcs $b994	_neq:		bcs _greater
.b98a	a9 ff		lda #$ff	_less:		lda #$FF	; Return -1
.b98c	95 2a		sta $2a,x			sta DStack+6,x
.b98e	d0 0a		bne $b99a			bne _done
.b990	d6 25		dec $25,x	_str2:		dec DStack+1,x	; is string2 empty?
.b992	10 d5		bpl $b969			bpl _L2
.b994	a9 01		lda #$01	_greater:	lda #1		; Return 1
.b996	95 2a		sta $2a,x	_gt2:		sta DStack+6,x
.b998	a9 00		lda #$00			lda #0
.b99a	95 2b		sta $2b,x	_done:		sta DStack+7,x
.b99c	8a		txa				txa		; Remove all but the result from the stack.
.b99d	18		clc				clc
.b99e	69 06		adc #$06			adc #6
.b9a0	aa		tax				tax
=93					CodeLen	.var *-XtPtr1
=$b9a1					Here1 = *	; remember here
>b942	5d					.byte CodeLen	;patch wh_CodeLength
.b9a1	60		rts				rts
>b9a2	53 65 61 72 63 68		Name0:	.text "Search"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=47400					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>b9a8	06					.byte (("Search"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=104					LinkDisplacement = Nt0-WordListLink
>b9a9	10					.byte WordFlags	;wh_Flags
>b9aa	03					.byte 3	;wh_CodeLength
>b9ab	68					  .byte LinkDisplacement	; offset to previous nt
=$b9ac					XtPtr1 ::= *
=47400					WordListLink ::= Nt0 ; remember the nt of this word for later
.b9ac					Search:
.b9ac	20 2a c4	jsr $c42a			jsr underflow_4
.b9af	b5 24		lda $24,x			lda DStack+0,x
.b9b1	15 25		ora $25,x			ora DStack+1,x
.b9b3	d0 09		bne $b9be			bne _start_search
.b9b5	e8		inx				inx		; Drop u2
.b9b6	e8		inx				inx
.b9b7	a9 ff		lda #$ff			lda #$FF	; overwrite addr2 with a true flag
.b9b9	95 24		sta $24,x			sta DStack+0,x
.b9bb	95 25		sta $25,x			sta DStack+1,x
.b9bd	60		rts				rts
.b9be					_start_search:
.b9be	20 f7 c7	jsr $c7f7			jsr Zero
.b9c1					_search_loop:
.b9c1	18		clc				clc
.b9c2	b5 24		lda $24,x			lda DStack+0,x
.b9c4	75 26		adc $26,x			adc DStack+2,x
.b9c6	85 14		sta $14				sta tmp1+0
.b9c8	b5 25		lda $25,x			lda DStack+1,x
.b9ca	75 27		adc $27,x			adc DStack+3,x
.b9cc	85 15		sta $15				sta tmp1+1
.b9ce	d5 2b		cmp $2b,x			cmp DStack+7,x
.b9d0	90 13		bcc $b9e5			bcc _init_comparison ; Obviously less
.b9d2	d0 06		bne $b9da			bne _not_found
.b9d4	b5 2a		lda $2a,x			lda DStack+6,x
.b9d6	c5 14		cmp $14				cmp tmp1
.b9d8	b0 0b		bcs $b9e5			bcs _init_comparison
.b9da					_not_found:
.b9da	e8		inx				inx		; Remove offset
.b9db	e8		inx				inx
.b9dc	e8		inx				inx		; Remove u2
.b9dd	e8		inx				inx
.b9de	a9 00		lda #$00			lda #0
.b9e0	95 24		sta $24,x			sta DStack+0,x	; Turn addr2 into a false flag
.b9e2	95 25		sta $25,x			sta DStack+1,x
.b9e4	60		rts				rts
.b9e5					_init_comparison:
.b9e5	18		clc				clc
.b9e6	b5 2c		lda $2c,x			lda DStack+8,x
.b9e8	75 24		adc $24,x			adc DStack+0,x
.b9ea	85 14		sta $14				sta tmp1
.b9ec	b5 2d		lda $2d,x			lda DStack+9,x
.b9ee	75 25		adc $25,x			adc DStack+1,x
.b9f0	85 15		sta $15				sta tmp1+1
.b9f2	b5 28		lda $28,x			lda DStack+4,x
.b9f4	85 16		sta $16				sta tmp2
.b9f6	b5 29		lda $29,x			lda DStack+5,x
.b9f8	85 17		sta $17				sta tmp2+1
.b9fa	b5 26		lda $26,x			lda DStack+2,x
.b9fc	85 18		sta $18				sta tmp3+0
.b9fe	b5 27		lda $27,x			lda DStack+3,x
.ba00	85 19		sta $19				sta tmp3+1
.ba02					_comparison_loop:
.ba02	a0 00		ldy #$00			ldy #0
.ba04	b1 14		lda ($14),y			lda (tmp1),y
.ba06	d1 16		cmp ($16),y			cmp (tmp2),y
.ba08	f0 06		beq $ba10			beq _letters_match
.ba0a	20 9a da	jsr $da9a			jsr One_plus
.ba0d	4c c1 b9	jmp $b9c1			jmp _search_loop
.ba10					_letters_match:
.ba10	e6 14		inc $14				inc tmp1
.ba12	d0 02		bne $ba16			bne +
.ba14	e6 15		inc $15				inc tmp1+1
.ba16					+
.ba16	e6 16		inc $16				inc tmp2
.ba18	d0 02		bne $ba1c			bne +
.ba1a	e6 17		inc $17				inc tmp2+1
.ba1c					+
.ba1c	a5 18		lda $18				lda tmp3
.ba1e	d0 02		bne $ba22			bne +
.ba20	c6 19		dec $19				dec tmp3+1
.ba22					+
.ba22	c6 18		dec $18				dec tmp3
.ba24	a5 18		lda $18				lda tmp3
.ba26	05 19		ora $19				ora tmp3+1
.ba28	d0 d8		bne $ba02			bne _comparison_loop ; Check the next letter
.ba2a	18		clc				clc
.ba2b	b5 24		lda $24,x			lda DStack+0,x
.ba2d	75 2c		adc $2c,x			adc DStack+8,x
.ba2f	95 2c		sta $2c,x			sta DStack+8,x
.ba31	b5 25		lda $25,x			lda DStack+1,x
.ba33	75 2d		adc $2d,x			adc DStack+9,x
.ba35	95 2d		sta $2d,x			sta DStack+9,x
.ba37	38		sec				sec
.ba38	b5 2a		lda $2a,x			lda DStack+6,x
.ba3a	f5 24		sbc $24,x			sbc DStack+0,x
.ba3c	95 2a		sta $2a,x			sta DStack+6,x
.ba3e	b5 2b		lda $2b,x			lda DStack+7,x
.ba40	f5 25		sbc $25,x			sbc DStack+1,x
.ba42	95 2b		sta $2b,x			sta DStack+7,x
.ba44	e8		inx				inx		; drop offset
.ba45	e8		inx				inx
.ba46	e8		inx				inx		; drop u2
.ba47	e8		inx				inx
.ba48	a9 ff		lda #$ff			lda #$FF
.ba4a	95 24		sta $24,x			sta DStack+0,x	; Turn addr2 into a true flag.
.ba4c	95 25		sta $25,x			sta DStack+1,x
=162					CodeLen	.var *-XtPtr1
=$ba4e					Here1 = *	; remember here
>b9aa	a2					.byte CodeLen	;patch wh_CodeLength
.ba4e	60		rts				rts
>ba4f	4d 61 72 6b 65 72		Name0:	.text "Marker"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=47573					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>ba55	46					.byte (("Marker"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=24					WordFlags ::= IM+NN	; modifiable copy, remember for later
=173					LinkDisplacement = Nt0-WordListLink
>ba56	18					.byte WordFlags	;wh_Flags
>ba57	03					.byte 3	;wh_CodeLength
>ba58	ad					  .byte LinkDisplacement	; offset to previous nt
=$ba59					XtPtr1 ::= *
=47573					WordListLink ::= Nt0 ; remember the nt of this word for later
.ba59					Marker:
.ba59	20 67 da	jsr $da67			jsr Here		; Save original CP, which
.ba5c	20 2e d1	jsr $d12e			jsr Header_Build	; compile a word header, but don't link into wordlist
.ba5f	a0 ba		ldy #$ba			ldy #>_runtime		; compile JSR _runtime
.ba61	a9 79		lda #$79			lda #<_runtime
.ba63	20 78 dd	jsr $dd78			jsr Jsr_Comma_YA
.ba66	20 52 dd	jsr $dd52			jsr Comma		; Append original CP
.ba69	a0 00		ldy #$00			ldy #0			; Start at CURRENT
.ba6b	b9 10 03	lda $0310,y	_loop:		lda CurrentV,y
.ba6e	20 3e dd	jsr $dd3e			jsr C_Comma_A
.ba71	c8		iny				iny
.ba72	c0 24		cpy #$24			cpy #MarkEnd-CurrentV	; One past the end of the search order.
.ba74	90 f5		bcc $ba6b			bcc _loop
.ba76	4c 23 d1	jmp $d123			jmp Header_Link		; link built header into current dictionary
=32					CodeLen	.var *-XtPtr1
=$ba79					Here1 = *	; remember here
>ba57	20					.byte CodeLen	;patch wh_CodeLength
.ba79					_runtime:
.ba79	68		pla				pla		; Pop the RTS address off the stack
.ba7a	85 14		sta $14				sta tmp1+0
.ba7c	68		pla				pla
.ba7d	85 15		sta $15				sta tmp1+1
.ba7f	a0 01		ldy #$01			ldy #1		; start just aftet JSR _runtime
.ba81	b1 14		lda ($14),y			lda (tmp1),y	; CP was stored first
.ba83	85 00		sta $00				sta cp+0
.ba85	c8		iny				iny
.ba86	b1 14		lda ($14),y			lda (tmp1),y
.ba88	85 01		sta $01				sta cp+1
.ba8a	c8		iny				iny
.ba8b					_rloop:
.ba8b	b1 14		lda ($14),y			lda (tmp1),y
.ba8d	99 0d 03	sta $030d,y			sta CurrentV-2-1,y
.ba90	c8		iny				iny
.ba91	c0 27		cpy #$27			cpy #MarkEnd-CurrentV+2+1 ; One past the end of the search order.
.ba93	90 f6		bcc $ba8b			bcc _rloop
.ba95	60		rts				rts
>ba96	57 6f 72 64 73			Name0:	.text "Words"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=47643					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>ba9b	65					.byte (("Words"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=70					LinkDisplacement = Nt0-WordListLink
>ba9c	10					.byte WordFlags	;wh_Flags
>ba9d	03					.byte 3	;wh_CodeLength
>ba9e	46					  .byte LinkDisplacement	; offset to previous nt
=$ba9f					XtPtr1 ::= *
=47643					WordListLink ::= Nt0 ; remember the nt of this word for later
.ba9f					Words:
.ba9f	a9 ff		lda #$ff			lda #$ff
.baa1	20 e9 c7	jsr $c7e9			jsr PushZA		; Alloc space for line size & wordlist #
.baa4	ca		dex				dex			; Alloc space for a nt
.baa5	ca		dex				dex
.baa6					_wordlist_next:
.baa6	20 4c bb	jsr $bb4c			jsr CR			; start wordlist on new line
.baa9	f6 26		inc $26,x			inc DStack+2,x		; step to next search wordlist
.baab	b4 26		ldy $26,x			ldy DStack+2,x		; Y= wordlist index
.baad	cc 2a 03	cpy $032a			cpy Num_OrderV
.bab0	b0 44		bcs $baf6			bcs _wordslist_done	; ran out of search wordlist entries?
.bab2	b9 2b 03	lda $032b,y			lda Search_OrderV,y	; A= SEARCH-ORDER[Y]	Get the current wordlist id
.bab5	0a		asl a				asl			; TOS= WORDLISTS[A]
.bab6	a8		tay				tay
.bab7	b9 12 03	lda $0312,y			lda WordlistsV+0,y
.baba	95 24		sta $24,x			sta DStack+0,x
.babc	b9 13 03	lda $0313,y			lda WordlistsV+1,y
.babf	95 25		sta $25,x			sta DStack+1,x
.bac1	f0 e3		beq $baa6			beq _wordlist_next	; end of list?
.bac3					_word_loop:
.bac3	20 d2 df	jsr $dfd2			jsr Dup			; ( wordlist# nt nt )
.bac6	20 f7 cd	jsr $cdf7			jsr Name_To_String	; ( wordlist# nt addr u )
.bac9	b5 2b		lda $2b,x			lda DStack+7,x
.bacb	38		sec				sec			; don't forget the space between words
.bacc	75 24		adc $24,x			adc DStack+0,x
.bace	c9 4e		cmp #$4e			cmp #MAX_LINE_LENGTH-1
.bad0	90 05		bcc $bad7			bcc +
.bad2	20 4c bb	jsr $bb4c			jsr CR
.bad5	b5 24		lda $24,x			lda DStack+0,x		; After going to next line, start
.bad7	95 2b		sta $2b,x	+		sta DStack+7,x
.bad9	20 39 de	jsr $de39			jsr Type		; ( wordlist# nt )
.badc	20 2d de	jsr $de2d			jsr Space
.badf	b5 24		lda $24,x			lda DStack+0,x
.bae1	85 14		sta $14				sta tmp1+0
.bae3	b5 25		lda $25,x			lda DStack+1,x
.bae5	85 15		sta $15				sta tmp1+1
.bae7	20 95 82	jsr $8295			jsr LinkNext		; tmp1= next word nt in list
.baea	a5 14		lda $14				lda tmp1+0
.baec	95 24		sta $24,x			sta DStack+0,x
.baee	a5 15		lda $15				lda tmp1+1
.baf0	95 25		sta $25,x			sta DStack+1,x
.baf2	d0 cf		bne $bac3			bne _word_loop		; end of list?
.baf4	f0 b0		beq $baa6			beq _wordlist_next
.baf6					_wordslist_done:
.baf6	4c 72 d5	jmp $d572			jmp Two_Drop
=90					CodeLen	.var *-XtPtr1
=$baf9					Here1 = *	; remember here
>ba9d	5a					.byte CodeLen	;patch wh_CodeLength
>baf9	57 6f 72 64 53 69 7a 65		Name0:	.text "WordSize"	;  name of word as a string, ending at wh_NameLastChar
=8					NameLength = *-Name0
=47745					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>bb01	a8					.byte (("WordSize"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=102					LinkDisplacement = Nt0-WordListLink
>bb02	10					.byte WordFlags	;wh_Flags
>bb03	03					.byte 3	;wh_CodeLength
>bb04	66					  .byte LinkDisplacement	; offset to previous nt
=$bb05					XtPtr1 ::= *
=47745					WordListLink ::= Nt0 ; remember the nt of this word for later
.bb05	20 ee c3	jsr $c3ee	WordSize:	jsr PopTmp1
.bb08	a0 82		ldy #$82			ldy #Wh_CodeLength
.bb0a	b1 14		lda ($14),y			lda (tmp1),y
.bb0c	4c e9 c7	jmp $c7e9			jmp PushZA
=10					CodeLen	.var *-XtPtr1
=$bb0f					Here1 = *	; remember here
>bb03	0a					.byte CodeLen	;patch wh_CodeLength
>bb0f	41 6c 69 67 6e 65 64		Name0:	.text "Aligned"	;  name of word as a string, ending at wh_NameLastChar
=7					NameLength = *-Name0
=47766					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>bb16	87					.byte (("Aligned"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=0					WordFlags ::= 0	; modifiable copy, remember for later
=21					LinkDisplacement = Nt0-WordListLink
>bb17	00					.byte WordFlags	;wh_Flags
>bb18	03					.byte 3	;wh_CodeLength
>bb19	15					  .byte LinkDisplacement	; offset to previous nt
=$bb1a					XtPtr1 ::= *
=47766					WordListLink ::= Nt0 ; remember the nt of this word for later
.bb1a					Aligned:
=0					CodeLen	.var *-XtPtr1
=$bb1a					Here1 = *	; remember here
>bb18	00					.byte CodeLen	;patch wh_CodeLength
.bb1a	60		rts				rts
>bb1b	41 6c 69 67 6e			Name0:	.text "Align"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=47776					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>bb20	c5					.byte (("Align"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=0					WordFlags ::= 0	; modifiable copy, remember for later
=10					LinkDisplacement = Nt0-WordListLink
>bb21	00					.byte WordFlags	;wh_Flags
>bb22	03					.byte 3	;wh_CodeLength
>bb23	0a					  .byte LinkDisplacement	; offset to previous nt
=$bb24					XtPtr1 ::= *
=47776					WordListLink ::= Nt0 ; remember the nt of this word for later
.bb24					Align:
=0					CodeLen	.var *-XtPtr1
=$bb24					Here1 = *	; remember here
>bb22	00					.byte CodeLen	;patch wh_CodeLength
.bb24	60		rts				rts
>bb25	4f 75 74 70 75 74		Name0:	.text "Output"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=47787					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>bb2b	86					.byte (("Output"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=11					LinkDisplacement = Nt0-WordListLink
>bb2c	10					.byte WordFlags	;wh_Flags
>bb2d	03					.byte 3	;wh_CodeLength
>bb2e	0b					  .byte LinkDisplacement	; offset to previous nt
=$bb2f					XtPtr1 ::= *
=47787					WordListLink ::= Nt0 ; remember the nt of this word for later
.bb2f					xt_output:
.bb2f	a0 03		ldy #$03			ldy #>output
.bb31	a9 06		lda #$06			lda #<output
.bb33	4c ba c7	jmp $c7ba			jmp PushYA
=7					CodeLen	.var *-XtPtr1
=$bb36					Here1 = *	; remember here
>bb2d	07					.byte CodeLen	;patch wh_CodeLength
>bb36	49 6e 70 75 74			Name0:	.text "Input"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=47803					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>bb3b	85					.byte (("Input"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=16					LinkDisplacement = Nt0-WordListLink
>bb3c	10					.byte WordFlags	;wh_Flags
>bb3d	03					.byte 3	;wh_CodeLength
>bb3e	10					  .byte LinkDisplacement	; offset to previous nt
=$bb3f					XtPtr1 ::= *
=47803					WordListLink ::= Nt0 ; remember the nt of this word for later
.bb3f	a0 03		ldy #$03	xt_input:	ldy #>input
.bb41	a9 08		lda #$08			lda #<input
.bb43	4c ba c7	jmp $c7ba			jmp PushYA
=7					CodeLen	.var *-XtPtr1
=$bb46					Here1 = *	; remember here
>bb3d	07					.byte CodeLen	;patch wh_CodeLength
>bb46	43 52				Name0:	.text "CR"	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=47816					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>bb48	42					.byte (("CR"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>bb49	10					.byte WordFlags	;wh_Flags
>bb4a	03					.byte 3	;wh_CodeLength
>bb4b	0d					  .byte LinkDisplacement	; offset to previous nt
=$bb4c					XtPtr1 ::= *
=47816					WordListLink ::= Nt0 ; remember the nt of this word for later
.bb4c					CR:
.bb4c	a9 0d		lda #$0d			lda #AscCR
.bb4e	20 21 de	jsr $de21			jsr Emit_A
.bb51	a9 0a		lda #$0a			lda #AscLF
.bb53	20 21 de	jsr $de21			jsr Emit_A
=10					CodeLen	.var *-XtPtr1
=$bb56					Here1 = *	; remember here
>bb4a	0a					.byte CodeLen	;patch wh_CodeLength
.bb56	60		rts				rts
>bb57	50 61 67 65			Name0:	.text "Page"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=47835					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>bb5b	a4					.byte (("Page"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=19					LinkDisplacement = Nt0-WordListLink
>bb5c	10					.byte WordFlags	;wh_Flags
>bb5d	03					.byte 3	;wh_CodeLength
>bb5e	13					  .byte LinkDisplacement	; offset to previous nt
=$bb5f					XtPtr1 ::= *
=47835					WordListLink ::= Nt0 ; remember the nt of this word for later
.bb5f	20 bd c8	jsr $c8bd	Page:		jsr SLiteral_Runtime
.bb62	4c 6f bb	jmp $bb6f			  jmp +
>bb65	1b 5b 32 4a					  .text AscESC,"[2J"	; ANSI clear screen
>bb69	1b 5b 31 3b 31 48				  .text AscESC,"[1;1H"	; move cursor to top left of screen
.bb6f	4c 39 de	jmp $de39	+		jmp Type
=19					CodeLen	.var *-XtPtr1
=$bb72					Here1 = *	; remember here
>bb5d	13					.byte CodeLen	;patch wh_CodeLength
>bb72	41 74 2d 58 59			Name0:	.text "At-XY"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=47863					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>bb77	25					.byte (("At-XY"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=28					LinkDisplacement = Nt0-WordListLink
>bb78	10					.byte WordFlags	;wh_Flags
>bb79	03					.byte 3	;wh_CodeLength
>bb7a	1c					  .byte LinkDisplacement	; offset to previous nt
=$bb7b					XtPtr1 ::= *
=47863					WordListLink ::= Nt0 ; remember the nt of this word for later
.bb7b					At_XY:
.bb7b	20 20 c4	jsr $c420			jsr underflow_2
.bb7e	ad 00 03	lda $0300			lda base	; Save the BASE
.bb81	48		pha				pha
.bb82	20 b6 c1	jsr $c1b6			jsr Decimal	; ANSI escape code values need to be in decimal.
.bb85	a9 1b		lda #$1b			lda #AscESC
.bb87	20 21 de	jsr $de21			jsr Emit_A
.bb8a	a9 5b		lda #$5b			lda #'['
.bb8c	20 21 de	jsr $de21			jsr Emit_A
.bb8f	f6 24		inc $24,x			inc DStack+0,x	; AT-XY is zero based, but ANSI is 1 based
.bb91	20 6b dc	jsr $dc6b			jsr print_u
.bb94	a9 3b		lda #$3b			lda #';'
.bb96	20 21 de	jsr $de21			jsr Emit_A
.bb99	f6 24		inc $24,x			inc DStack+0,x	; AT-XY is zero based, but ANSI is 1 based
.bb9b	20 6b dc	jsr $dc6b			jsr print_u
.bb9e	a9 48		lda #$48			lda #'H'
.bba0	20 21 de	jsr $de21			jsr Emit_A
.bba3	68		pla				pla		; Restore the base
.bba4	8d 00 03	sta $0300			sta base
=44					CodeLen	.var *-XtPtr1
=$bba7					Here1 = *	; remember here
>bb79	2c					.byte CodeLen	;patch wh_CodeLength
.bba7	60		rts				rts
>bba8	50 61 64			Name0:	.text "Pad"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=47915					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>bbab	83					.byte (("Pad"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=0					WordFlags ::= 0	; modifiable copy, remember for later
=52					LinkDisplacement = Nt0-WordListLink
>bbac	00					.byte WordFlags	;wh_Flags
>bbad	03					.byte 3	;wh_CodeLength
>bbae	34					  .byte LinkDisplacement	; offset to previous nt
=$bbaf					XtPtr1 ::= *
=47915					WordListLink ::= Nt0 ; remember the nt of this word for later
.bbaf	ca		dex		Pad:		dex		; push cp+PadOffset
.bbb0	ca		dex				dex
.bbb1	18		clc				clc
.bbb2	a5 00		lda $00				lda cp+0
.bbb4	69 54		adc #$54			adc #PadOffset
.bbb6	95 24		sta $24,x			sta DStack+0,x
.bbb8	a5 01		lda $01				lda cp+1
.bbba	69 00		adc #$00			adc #0
.bbbc	95 25		sta $25,x			sta DStack+1,x
=15					CodeLen	.var *-XtPtr1
=$bbbe					Here1 = *	; remember here
>bbad	0f					.byte CodeLen	;patch wh_CodeLength
.bbbe	60		rts				rts
>bbbf	3c 23				Name0:	.text "<#"	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=47937					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>bbc1	62					.byte (("<#"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=0					WordFlags ::= 0	; modifiable copy, remember for later
=22					LinkDisplacement = Nt0-WordListLink
>bbc2	00					.byte WordFlags	;wh_Flags
>bbc3	03					.byte 3	;wh_CodeLength
>bbc4	16					  .byte LinkDisplacement	; offset to previous nt
=$bbc5					XtPtr1 ::= *
=47937					WordListLink ::= Nt0 ; remember the nt of this word for later
.bbc5					Less_Number_Sign:
.bbc5	a9 54		lda #$54			lda #PadOffset		; init hold buffer index
.bbc7	8d 34 03	sta $0334			sta ToHold
=5					CodeLen	.var *-XtPtr1
=$bbca					Here1 = *	; remember here
>bbc3	05					.byte CodeLen	;patch wh_CodeLength
.bbca	60		rts				rts
>bbcb	23 3e				Name0:	.text "#>"	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=47949					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>bbcd	c2					.byte (("#>"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=12					LinkDisplacement = Nt0-WordListLink
>bbce	10					.byte WordFlags	;wh_Flags
>bbcf	03					.byte 3	;wh_CodeLength
>bbd0	0c					  .byte LinkDisplacement	; offset to previous nt
=$bbd1					XtPtr1 ::= *
=47949					WordListLink ::= Nt0 ; remember the nt of this word for later
.bbd1					Number_Sign_Greater:
.bbd1	20 20 c4	jsr $c420			jsr underflow_2		; double number
.bbd4	18		clc				clc			; addr= cp + ToHold
.bbd5	a5 00		lda $00				lda cp+0
.bbd7	6d 34 03	adc $0334			adc ToHold
.bbda	95 26		sta $26,x			sta DStack+2,x
.bbdc	a5 01		lda $01				lda cp+1
.bbde	69 00		adc #$00			adc #0
.bbe0	95 27		sta $27,x			sta DStack+3,x
.bbe2	38		sec				sec			; u= PadOffset - ToHold
.bbe3	a9 54		lda #$54			lda #PadOffset
.bbe5	ed 34 03	sbc $0334			sbc ToHold
.bbe8	95 24		sta $24,x			sta DStack+0,x
.bbea	a9 00		lda #$00			lda #0
.bbec	95 25		sta $25,x			sta DStack+1,x
=29					CodeLen	.var *-XtPtr1
=$bbee					Here1 = *	; remember here
>bbcf	1d					.byte CodeLen	;patch wh_CodeLength
.bbee	60		rts				rts
>bbef	48 6f 6c 64			Name0:	.text "Hold"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=47987					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>bbf3	84					.byte (("Hold"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=0					WordFlags ::= 0	; modifiable copy, remember for later
=38					LinkDisplacement = Nt0-WordListLink
>bbf4	00					.byte WordFlags	;wh_Flags
>bbf5	03					.byte 3	;wh_CodeLength
>bbf6	26					  .byte LinkDisplacement	; offset to previous nt
=$bbf7					XtPtr1 ::= *
=47987					WordListLink ::= Nt0 ; remember the nt of this word for later
.bbf7	20 c8 c3	jsr $c3c8	Hold:		jsr PopA
.bbfa	ce 34 03	dec $0334	Hold_A:		dec ToHold
.bbfd	ac 34 03	ldy $0334			ldy ToHold
.bc00	91 00		sta ($00),y			sta (cp),y
=11					CodeLen	.var *-XtPtr1
=$bc02					Here1 = *	; remember here
>bbf5	0b					.byte CodeLen	;patch wh_CodeLength
.bc02	60		rts				rts
>bc03	23				Name0:	.text "#"	;  name of word as a string, ending at wh_NameLastChar
=1					NameLength = *-Name0
=48004					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>bc04	61					.byte (("#"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=80					WordFlags ::= UF+NN	; modifiable copy, remember for later
=17					LinkDisplacement = Nt0-WordListLink
>bc05	50					.byte WordFlags	;wh_Flags
>bc06	03					.byte 3	;wh_CodeLength
>bc07	11					  .byte LinkDisplacement	; offset to previous nt
=$bc08					XtPtr1 ::= *
=48004					WordListLink ::= Nt0 ; remember the nt of this word for later
.bc08					Number_Sign:
.bc08	20 20 c4	jsr $c420			jsr underflow_2		; double number
.bc0b	a9 00		lda #$00			lda #0			;   init remainder
.bc0d	18		clc				clc
.bc0e	a0 21		ldy #$21			ldy #32+1		;   for each bit
.bc10					_div1:
.bc10	2a		rol a				rol a			;     shift remainder
.bc11	cd 00 03	cmp $0300			cmp base		;     will it fit?
.bc14	90 03		bcc $bc19			bcc _div7
.bc16	ed 00 03	sbc $0300			sbc base
.bc19					_div7:
.bc19	36 26		rol $26,x			rol DStack+2,x		;     shift ud
.bc1b	36 27		rol $27,x			rol DStack+3,x
.bc1d	36 24		rol $24,x			rol DStack+0,x
.bc1f	36 25		rol $25,x			rol DStack+1,x
.bc21	88		dey				dey			;    next bit
.bc22	d0 ec		bne $bc10			bne _div1
.bc24	c9 0a		cmp #$0a			cmp #9+1		; alternatively this could use s_abc_upper
.bc26	90 02		bcc $bc2a			bcc +
.bc28	69 06		adc #$06			adc #7-1
.bc2a	69 30		adc #$30	+		adc #'0'
.bc2c	d0 cc		bne $bbfa			bne Hold_A
=38					CodeLen	.var *-XtPtr1
=$bc2e					Here1 = *	; remember here
>bc06	26					.byte CodeLen	;patch wh_CodeLength
>bc2e	23 53				Name0:	.text "#S"	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=48048					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>bc30	62					.byte (("#S"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=0					WordFlags ::= 0	; modifiable copy, remember for later
=44					LinkDisplacement = Nt0-WordListLink
>bc31	00					.byte WordFlags	;wh_Flags
>bc32	03					.byte 3	;wh_CodeLength
>bc33	2c					  .byte LinkDisplacement	; offset to previous nt
=$bc34					XtPtr1 ::= *
=48048					WordListLink ::= Nt0 ; remember the nt of this word for later
.bc34					Number_Sign_S:
.bc34					_loop:
.bc34	20 08 bc	jsr $bc08			jsr Number_sign	; convert a single number ("#")
.bc37	b5 24		lda $24,x			lda DStack+0,x	; until d is zero
.bc39	15 25		ora $25,x			ora DStack+1,x
.bc3b	15 26		ora $26,x			ora DStack+2,x
.bc3d	15 27		ora $27,x			ora DStack+3,x
.bc3f	d0 f3		bne $bc34			bne _loop
=13					CodeLen	.var *-XtPtr1
=$bc41					Here1 = *	; remember here
>bc32	0d					.byte CodeLen	;patch wh_CodeLength
.bc41	60		rts				rts
>bc42	53 69 67 6e			Name0:	.text "Sign"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=48070					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>bc46	c4					.byte (("Sign"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=22					LinkDisplacement = Nt0-WordListLink
>bc47	10					.byte WordFlags	;wh_Flags
>bc48	03					.byte 3	;wh_CodeLength
>bc49	16					  .byte LinkDisplacement	; offset to previous nt
=$bc4a					XtPtr1 ::= *
=48070					WordListLink ::= Nt0 ; remember the nt of this word for later
.bc4a	20 e3 c3	jsr $c3e3	Sign:		jsr PopYA
.bc4d	98		tya				tya		; test MSB of TOS
.bc4e					Sign_P:
.bc4e	30 01		bmi $bc51			bmi _minus
.bc50	60		rts				rts
.bc51	a9 2d		lda #$2d	_minus:		lda #'-'	; add minus sign
.bc53	d0 a5		bne $bbfa			bne hold_a
=11					CodeLen	.var *-XtPtr1
=$bc55					Here1 = *	; remember here
>bc48	0b					.byte CodeLen	;patch wh_CodeLength
>bc55	43 6c 65 61 76 65		Name0:	.text "Cleave"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=48091					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>bc5b	a6					.byte (("Cleave"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=21					LinkDisplacement = Nt0-WordListLink
>bc5c	10					.byte WordFlags	;wh_Flags
>bc5d	03					.byte 3	;wh_CodeLength
>bc5e	15					  .byte LinkDisplacement	; offset to previous nt
=$bc5f					XtPtr1 ::= *
=48091					WordListLink ::= Nt0 ; remember the nt of this word for later
.bc5f	20 20 c4	jsr $c420	Cleave:		jsr underflow_2
.bc62	20 20 d5	jsr $d520			jsr Minus_leading	; -LEADING ( addr u )
.bc65	20 16 d4	jsr $d416			jsr Input_To_R	; save old imput state
.bc68	b5 24		lda $24,x			lda DStack+0,x	; u is new ciblen
.bc6a	85 06		sta $06				sta ciblen
.bc6c	b5 25		lda $25,x			lda DStack+1,x
.bc6e	85 07		sta $07				sta ciblen+1
.bc70	b5 26		lda $26,x			lda DStack+2,x	; addr is new cib
.bc72	85 04		sta $04				sta cib
.bc74	b5 27		lda $27,x			lda DStack+3,x
.bc76	85 05		sta $05				sta cib+1
.bc78	a9 00		lda #$00			lda #0
.bc7a	85 08		sta $08				sta toin	; >IN pointer is zero
.bc7c	85 09		sta $09				sta toin+1
.bc7e	20 87 ca	jsr $ca87			jsr parse_name	; ( addr u addr-s u-s )
.bc81	b5 24		lda $24,x			lda DStack+0,x
.bc83	15 25		ora $25,x			ora DStack+1,x
.bc85	f0 23		beq $bcaa			beq _done
.bc87	38		sec				sec
.bc88	b5 28		lda $28,x			lda DStack+4,x	; LSB of original u
.bc8a	f5 24		sbc $24,x			sbc DStack+0,x
.bc8c	95 28		sta $28,x			sta DStack+4,x
.bc8e	b5 29		lda $29,x			lda DStack+5,x	; MSB of original u
.bc90	f5 25		sbc $25,x			sbc DStack+1,x
.bc92	95 29		sta $29,x			sta DStack+5,x
.bc94	18		clc				clc
.bc95	b5 2a		lda $2a,x			lda DStack+6,x	; LSB of original addr
.bc97	75 24		adc $24,x			adc DStack+0,x
.bc99	95 2a		sta $2a,x			sta DStack+6,x
.bc9b	b5 2b		lda $2b,x			lda DStack+7,x	; MSB of original addr
.bc9d	75 25		adc $25,x			adc DStack+1,x
.bc9f	95 2b		sta $2b,x			sta DStack+7,x
.bca1	20 84 d5	jsr $d584			jsr Two_swap		; ( addr-s u-s addr u )
.bca4	20 20 d5	jsr $d520			jsr Minus_leading
.bca7	20 84 d5	jsr $d584			jsr Two_swap		; ( addr u addr-s u-s )
.bcaa					_done:
.bcaa	20 37 d4	jsr $d437			jsr R_To_Input
=78					CodeLen	.var *-XtPtr1
=$bcad					Here1 = *	; remember here
>bc5d	4e					.byte CodeLen	;patch wh_CodeLength
.bcad	60		rts				rts
>bcae	48 65 78 53 74 6f 72 65		Name0:	.text "HexStore"	;  name of word as a string, ending at wh_NameLastChar
=8					NameLength = *-Name0
=48182					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>bcb6	a8					.byte (("HexStore"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=91					LinkDisplacement = Nt0-WordListLink
>bcb7	10					.byte WordFlags	;wh_Flags
>bcb8	03					.byte 3	;wh_CodeLength
>bcb9	5b					  .byte LinkDisplacement	; offset to previous nt
=$bcba					XtPtr1 ::= *
=48182					WordListLink ::= Nt0 ; remember the nt of this word for later
.bcba	20 25 c4	jsr $c425	Hexstore:	jsr underflow_3
.bcbd	20 d2 df	jsr $dfd2			jsr Dup		; Save copy of original address
.bcc0	20 a4 d6	jsr $d6a4			jsr Two_to_r		; ( addr1 u1 ) ( R: addr2 addr2 )
.bcc3					_loop:
.bcc3	b5 24		lda $24,x			lda DStack+0,x
.bcc5	15 25		ora $25,x			ora DStack+1,x
.bcc7	f0 37		beq $bd00			beq _done
.bcc9	20 5f bc	jsr $bc5f			jsr Cleave		; ( addr1 u1 addr3 u3 ) ( R: addr2 addr2 )
.bccc	20 a4 d6	jsr $d6a4			jsr Two_to_r
.bccf	20 f7 c7	jsr $c7f7			jsr Zero
.bcd2	20 f7 c7	jsr $c7f7			jsr Zero
.bcd5	20 80 d6	jsr $d680			jsr Two_r_from	; ( addr1 u1 0 0 addr3 u3 ) ( R: addr2 addr2 )
.bcd8	20 39 c0	jsr $c039			jsr To_Number	; ( addr1 u1 n n addr4 u4 ) ( R: addr2 addr2 )
.bcdb	b5 24		lda $24,x			lda DStack+0,x
.bcdd	15 25		ora $25,x			ora DStack+1,x
.bcdf	d0 18		bne $bcf9			bne _have_chars_left
.bce1	20 72 d5	jsr $d572			jsr Two_drop		; ( addr1 u1 n n ) ( R: addr2 addr2 )
.bce4	20 24 d0	jsr $d024			jsr D_To_S		; ( addr1 u1 n ) ( R: addr2 addr2 )
.bce7	20 7b df	jsr $df7b			jsr R_Fetch		; ( addr1 u1 n addr2 ) ( R: addr2 addr2 )
.bcea	20 b7 dd	jsr $ddb7			jsr C_Store		; ( addr1 u1 ) ( R: addr2 addr2 )
.bced	20 60 df	jsr $df60			jsr R_From		; R>
.bcf0	20 9a da	jsr $da9a			jsr One_plus		; 1+
.bcf3	20 42 df	jsr $df42			jsr To_R		; >R ( addr1 u1 ) ( R: addr2+1 addr2 )
.bcf6	4c c3 bc	jmp $bcc3			jmp _loop
.bcf9					_have_chars_left:
.bcf9	8a		txa				txa
.bcfa	18		clc				clc
.bcfb	69 08		adc #$08			adc #8
.bcfd	aa		tax				tax
.bcfe	d0 c3		bne $bcc3			bne _loop
.bd00					_done:
.bd00	e8		inx				inx
.bd01	e8		inx				inx
.bd02	e8		inx				inx
.bd03	e8		inx				inx			; 2DROP
.bd04	20 80 d6	jsr $d680			jsr Two_r_from		; ( addr2+n addr2 )
.bd07	20 f3 df	jsr $dff3			jsr Swap
.bd0a	4c 08 dc	jmp $dc08			jmp Minus		; ( n )
=83					CodeLen	.var *-XtPtr1
=$bd0d					Here1 = *	; remember here
>bcb8	53					.byte CodeLen	;patch wh_CodeLength
.bd0d	4c 2f c4	jmp $c42f	Throw_Stack_24: jmp Throw_Stack
>bd10	57 69 74 68 69 6e		Name0:	.text "Within"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=48278					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>bd16	c6					.byte (("Within"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=96					LinkDisplacement = Nt0-WordListLink
>bd17	10					.byte WordFlags	;wh_Flags
>bd18	03					.byte 3	;wh_CodeLength
>bd19	60					  .byte LinkDisplacement	; offset to previous nt
=$bd1a					XtPtr1 ::= *
=48278					WordListLink ::= Nt0 ; remember the nt of this word for later
.bd1a					Within:
.bd1a	e0 2b		cpx #$2b		cpx #(DDim-3)*2+1	; far enough below end of data stack (& not negative)?
.bd1c	b0 ef		bcs $bd0d		bcs Throw_Stack_24
.bd1e	20 a9 df	jsr $dfa9			jsr Over
.bd21	20 08 dc	jsr $dc08			jsr Minus
.bd24	20 42 df	jsr $df42			jsr To_R
.bd27	20 08 dc	jsr $dc08			jsr Minus
.bd2a	20 60 df	jsr $df60			jsr R_From
.bd2d	4c d4 d8	jmp $d8d4			jmp U_Less_Than
=22					CodeLen	.var *-XtPtr1
=$bd30					Here1 = *	; remember here
>bd18	16					.byte CodeLen	;patch wh_CodeLength
>bd30	5c				Name0:	.text "\"	;  name of word as a string, ending at wh_NameLastChar
=1					NameLength = *-Name0
=48305					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>bd31	81					.byte (("\"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=24					WordFlags ::= IM+NN	; modifiable copy, remember for later
=27					LinkDisplacement = Nt0-WordListLink
>bd32	18					.byte WordFlags	;wh_Flags
>bd33	03					.byte 3	;wh_CodeLength
>bd34	1b					  .byte LinkDisplacement	; offset to previous nt
=$bd35					XtPtr1 ::= *
=48305					WordListLink ::= Nt0 ; remember the nt of this word for later
.bd35					Backslash:
.bd35	ad 0c 03	lda $030c			lda BlkV+0		; interpreting a block?
.bd38	0d 0d 03	ora $030d			ora BlkV+1
.bd3b	f0 16		beq $bd53			beq _not_block
.bd3d	a5 08		lda $08				lda toin+0
.bd3f	29 3f		and #$3f			and #$3F
.bd41	c9 02		cmp #$02			cmp #2
.bd43	90 0d		bcc $bd52			bcc _rts
.bd45	a5 08		lda $08		                lda toin+0		; Move toin to next multiple of 64.
.bd47	29 c0		and #$c0	                and #$C0        	;   Clear lower bits to move to beginning of line.
.bd49	18		clc		                clc             	;   Add $40 (64 decimal) to move to next line.
.bd4a	69 40		adc #$40	                adc #$40
.bd4c	85 08		sta $08		                sta toin+0
.bd4e	90 02		bcc $bd52	                bcc _rts
.bd50	e6 09		inc $09		                inc toin+1
.bd52	60		rts		_rts:		rts
.bd53					_not_block:
.bd53	a5 06		lda $06		                lda ciblen+0		; consume the remainder of the line
.bd55	85 08		sta $08		                sta toin+0
.bd57	a5 07		lda $07		                lda ciblen+1
.bd59	85 09		sta $09		                sta toin+1
=38					CodeLen	.var *-XtPtr1
=$bd5b					Here1 = *	; remember here
>bd33	26					.byte CodeLen	;patch wh_CodeLength
.bd5b	60		rts				rts
>bd5c	4d 6f 76 65			Name0:	.text "Move"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=48352					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>bd60	a4					.byte (("Move"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=47					LinkDisplacement = Nt0-WordListLink
>bd61	10					.byte WordFlags	;wh_Flags
>bd62	03					.byte 3	;wh_CodeLength
>bd63	2f					  .byte LinkDisplacement	; offset to previous nt
=$bd64					XtPtr1 ::= *
=48352					WordListLink ::= Nt0 ; remember the nt of this word for later
.bd64					Move:
.bd64	b5 27		lda $27,x			lda DStack+3,x		; MSB of addr2
.bd66	d5 29		cmp $29,x			cmp DStack+5,x		; MSB of addr1
.bd68	d0 04		bne $bd6e			bne _ne
.bd6a	b5 26		lda $26,x			lda DStack+2,x		; LSB of addr2
.bd6c	d5 28		cmp $28,x			cmp DStack+4,x		; LSB of addr1
.bd6e	90 59		bcc $bdc9	_ne:		bcc CMove
.bd70	d0 10		bne $bd82			bne CMove_up
.bd72	8a		txa		ThreeDrop:	txa		; drop three entries from Data Stack
.bd73	18		clc				clc
.bd74	69 06		adc #$06			adc #6
.bd76	aa		tax				tax
=19					CodeLen	.var *-XtPtr1
=$bd77					Here1 = *	; remember here
>bd62	13					.byte CodeLen	;patch wh_CodeLength
.bd77	60		rts				rts
>bd78	43 4d 6f 76 65 3e		Name0:	.text "CMove>"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=48382					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>bd7e	c6					.byte (("CMove>"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=30					LinkDisplacement = Nt0-WordListLink
>bd7f	10					.byte WordFlags	;wh_Flags
>bd80	03					.byte 3	;wh_CodeLength
>bd81	1e					  .byte LinkDisplacement	; offset to previous nt
=$bd82					XtPtr1 ::= *
=48382					WordListLink ::= Nt0 ; remember the nt of this word for later
.bd82					CMove_up:
.bd82	e0 2b		cpx #$2b		cpx #(DDim-3)*2+1	; far enough below end of data stack (& not negative)?
.bd84	b0 37		bcs $bdbd		bcs Throw_Stack_14
.bd86	b5 26		lda $26,x			lda DStack+2,x
.bd88	85 16		sta $16				sta tmp2	; use tmp2 because easier to remember
.bd8a	b5 27		lda $27,x			lda DStack+3,x
.bd8c	18		clc				clc
.bd8d	75 25		adc $25,x			adc DStack+1,x
.bd8f	85 17		sta $17				sta tmp2+1	; point to last page of destination
.bd91	b5 28		lda $28,x			lda DStack+4,x
.bd93	85 14		sta $14				sta tmp1	; use tmp1 because easier to remember
.bd95	b5 29		lda $29,x			lda DStack+5,x
.bd97	18		clc				clc
.bd98	75 25		adc $25,x			adc DStack+1,x
.bd9a	85 15		sta $15				sta tmp1+1	; point to last page of source
.bd9c	f6 25		inc $25,x			inc DStack+1,x	; allows us to use bne with dec DStack+1,x below
.bd9e	b4 24		ldy $24,x			ldy DStack+0,x	; length of last page
.bda0	f0 10		beq $bdb2			beq _nopartial
.bda2					_outerloop:
.bda2	88		dey				dey
.bda3	f0 07		beq $bdac			beq _finishpage
.bda5					_innerloop:
.bda5	b1 14		lda ($14),y			lda (tmp1),y
.bda7	91 16		sta ($16),y			sta (tmp2),y
.bda9	88		dey				dey
.bdaa	d0 f9		bne $bda5			bne _innerloop
.bdac					_finishpage:
.bdac	a0 00		ldy #$00			ldy #0
.bdae	b1 14		lda ($14),y			lda (tmp1),y	; handle y = 0 separately
.bdb0	91 16		sta ($16),y			sta (tmp2),y
.bdb2					_nopartial:
.bdb2	c6 15		dec $15				dec tmp1+1	; back up to previous pages
.bdb4	c6 17		dec $17				dec tmp2+1
.bdb6	d6 25		dec $25,x			dec DStack+1,x
.bdb8	d0 e8		bne $bda2			bne _outerloop
.bdba					_done:
.bdba	4c 72 bd	jmp $bd72			jmp ThreeDrop	; clear up the stack and leave
=59					CodeLen	.var *-XtPtr1
=$bdbd					Here1 = *	; remember here
>bd80	3b					.byte CodeLen	;patch wh_CodeLength
.bdbd	4c 2f c4	jmp $c42f	Throw_Stack_14: jmp Throw_Stack
>bdc0	43 4d 6f 76 65			Name0:	.text "CMove"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=48453					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>bdc5	a5					.byte (("CMove"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=71					LinkDisplacement = Nt0-WordListLink
>bdc6	10					.byte WordFlags	;wh_Flags
>bdc7	03					.byte 3	;wh_CodeLength
>bdc8	47					  .byte LinkDisplacement	; offset to previous nt
=$bdc9					XtPtr1 ::= *
=48453					WordListLink ::= Nt0 ; remember the nt of this word for later
.bdc9					CMove:
.bdc9	e0 2b		cpx #$2b		cpx #(DDim-3)*2+1	; far enough below end of data stack (& not negative)?
.bdcb	b0 f0		bcs $bdbd		bcs Throw_Stack_14
.bdcd	b5 26		lda $26,x			lda DStack+2,x
.bdcf	85 16		sta $16				sta tmp2+0	; use tmp2 because easier to remember
.bdd1	b5 27		lda $27,x			lda DStack+3,x
.bdd3	85 17		sta $17				sta tmp2+1
.bdd5	b5 28		lda $28,x			lda DStack+4,x
.bdd7	85 14		sta $14				sta tmp1+0	; use tmp1 because easier to remember
.bdd9	b5 29		lda $29,x			lda DStack+5,x
.bddb	85 15		sta $15				sta tmp1+1
.bddd	a0 00		ldy #$00			ldy #0
.bddf	b5 25		lda $25,x			lda DStack+1,x	; number of whole pages to move
.bde1	f0 0f		beq $bdf2			beq _dopartial
.bde3					_page:
.bde3	b1 14		lda ($14),y			lda (tmp1),y
.bde5	91 16		sta ($16),y			sta (tmp2),y
.bde7	c8		iny				iny
.bde8	d0 f9		bne $bde3			bne _page
.bdea	e6 15		inc $15				inc tmp1+1
.bdec	e6 17		inc $17				inc tmp2+1
.bdee	d6 25		dec $25,x			dec DStack+1,x
.bdf0	d0 f1		bne $bde3			bne _page
.bdf2					_dopartial:
.bdf2	b5 24		lda $24,x			lda DStack+0,x	; length of last page
.bdf4	f0 09		beq $bdff			beq _done
.bdf6					_partial:
.bdf6	b1 14		lda ($14),y			lda (tmp1),y
.bdf8	91 16		sta ($16),y			sta (tmp2),y
.bdfa	c8		iny				iny
.bdfb	d6 24		dec $24,x			dec DStack+0,x
.bdfd	d0 f7		bne $bdf6			bne _partial
.bdff	4c 72 bd	jmp $bd72	_done:		jmp ThreeDrop	; clear the stack
=57					CodeLen	.var *-XtPtr1
=$be02					Here1 = *	; remember here
>bdc7	39					.byte CodeLen	;patch wh_CodeLength
>be02	55 4d 2a			Name0:	.text "UM*"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=48517					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>be05	43					.byte (("UM*"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=64					LinkDisplacement = Nt0-WordListLink
>be06	10					.byte WordFlags	;wh_Flags
>be07	03					.byte 3	;wh_CodeLength
>be08	40					  .byte LinkDisplacement	; offset to previous nt
=$be09					XtPtr1 ::= *
=48517					WordListLink ::= Nt0 ; remember the nt of this word for later
.be09					UM_Star:
.be09	e0 2d		cpx #$2d		cpx #(DDim-2)*2+1	; far enough below end of data stack (& not negative)?
.be0b	b0 b0		bcs $bdbd		bcs Throw_Stack_14
.be0d	18		clc				clc		; tmp2= divsor-1
.be0e	b5 24		lda $24,x			lda DStack+0,x
.be10	e9 00		sbc #$00			sbc #0
.be12	85 16		sta $16				sta tmp2+0
.be14	b5 25		lda $25,x			lda DStack+1,x
.be16	e9 00		sbc #$00			sbc #0
.be18	85 17		sta $17				sta tmp2+1
.be1a	90 2e		bcc $be4a			bcc _zero	; is divisor zero?
.be1c	a9 00		lda #$00			lda #0
.be1e	85 14		sta $14				sta tmp1
.be20	86 18		stx $18				stx tmp3	; tested for exit from outer loop
.be22	ca		dex				dex
.be23	ca		dex				dex
.be24					_outer_loop:
.be24	a0 08		ldy #$08			ldy #8		; counter inner loop
.be26	56 28		lsr $28,x			lsr DStack+4,x	; think "DStack+2,x" then later "DStack+3,x"
.be28					_inner_loop:
.be28	90 0c		bcc $be36			bcc _no_add
.be2a	85 15		sta $15				sta tmp1+1	; save time, don't CLC
.be2c	a5 14		lda $14				lda tmp1
.be2e	65 16		adc $16				adc tmp2
.be30	85 14		sta $14				sta tmp1
.be32	a5 15		lda $15				lda tmp1+1
.be34	65 17		adc $17				adc tmp2+1
.be36					_no_add:
.be36	6a		ror a				ror
.be37	66 14		ror $14				ror tmp1
.be39	76 28		ror $28,x			ror DStack+4,x	; think "DStack+2,x" then later "DStack+3,x"
.be3b	88		dey				dey
.be3c	d0 ea		bne $be28			bne _inner_loop ; go back for one more shift?
.be3e	e8		inx				inx
.be3f	e4 18		cpx $18				cpx tmp3
.be41	d0 e1		bne $be24			bne _outer_loop ; go back for eight more shifts?
.be43	95 25		sta $25,x			sta DStack+1,x
.be45	a5 14		lda $14				lda tmp1
.be47	95 24		sta $24,x			sta DStack+0,x
.be49	60		rts				rts
.be4a	a9 00		lda #$00	_zero:		lda #0
.be4c	95 26		sta $26,x			sta DStack+2,x
.be4e	95 27		sta $27,x			sta DStack+3,x
.be50	60		rts				rts
=72					CodeLen	.var *-XtPtr1
=$be51					Here1 = *	; remember here
>be07	48					.byte CodeLen	;patch wh_CodeLength
>be51	4d 2a				Name0:	.text "M*"	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=48595					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>be53	42					.byte (("M*"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=78					LinkDisplacement = Nt0-WordListLink
>be54	10					.byte WordFlags	;wh_Flags
>be55	03					.byte 3	;wh_CodeLength
>be56	4e					  .byte LinkDisplacement	; offset to previous nt
=$be57					XtPtr1 ::= *
=48595					WordListLink ::= Nt0 ; remember the nt of this word for later
.be57					M_Star:
.be57	e0 2d		cpx #$2d		cpx #(DDim-2)*2+1	; far enough below end of data stack (& not negative)?
.be59	b0 6b		bcs $bec6		bcs Throw_Stack_15
.be5b	b5 25		lda $25,x			lda DStack+1,x	; MSB of n1
.be5d	55 27		eor $27,x			eor DStack+3,x	; MSB of n2
.be5f	08		php				php
.be60	20 02 d7	jsr $d702			jsr Abs
.be63	20 f3 df	jsr $dff3			jsr Swap
.be66	20 02 d7	jsr $d702			jsr Abs
.be69	20 09 be	jsr $be09			jsr UM_Star		; ( d )
.be6c	28		plp				plp			; handle the sign
.be6d	10 03		bpl $be72			bpl +
.be6f	4c 19 d7	jmp $d719			jmp DNegate
.be72					+
=27					CodeLen	.var *-XtPtr1
=$be72					Here1 = *	; remember here
>be55	1b					.byte CodeLen	;patch wh_CodeLength
.be72	60		rts				rts
>be73	2a				Name0:	.text "*"	;  name of word as a string, ending at wh_NameLastChar
=1					NameLength = *-Name0
=48628					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>be74	41					.byte (("*"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=0					WordFlags ::= 0	; modifiable copy, remember for later
=33					LinkDisplacement = Nt0-WordListLink
>be75	00					.byte WordFlags	;wh_Flags
>be76	03					.byte 3	;wh_CodeLength
>be77	21					  .byte LinkDisplacement	; offset to previous nt
=$be78					XtPtr1 ::= *
=48628					WordListLink ::= Nt0 ; remember the nt of this word for later
.be78					Star:
.be78	20 09 be	jsr $be09			jsr UM_Star
.be7b	e8		inx				inx		; D>S	drop hi cell
.be7c	e8		inx				inx
=5					CodeLen	.var *-XtPtr1
=$be7d					Here1 = *	; remember here
>be76	05					.byte CodeLen	;patch wh_CodeLength
.be7d	60		rts				rts
>be7e	55 4d 2f 4d 6f 64		Name0:	.text "UM/Mod"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=48644					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>be84	86					.byte (("UM/Mod"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=16					LinkDisplacement = Nt0-WordListLink
>be85	10					.byte WordFlags	;wh_Flags
>be86	03					.byte 3	;wh_CodeLength
>be87	10					  .byte LinkDisplacement	; offset to previous nt
=$be88					XtPtr1 ::= *
=48644					WordListLink ::= Nt0 ; remember the nt of this word for later
.be88					UM_Slash_Mod:
.be88	e0 2b		cpx #$2b		cpx #(DDim-3)*2+1	; far enough below end of data stack (& not negative)?
.be8a	b0 3a		bcs $bec6		bcs Throw_Stack_15
.be8c	b5 24		lda $24,x			lda DStack+0,x		; catch division by zero
.be8e	15 25		ora $25,x			ora DStack+1,x
.be90	f0 2f		beq $bec1			beq _DivByZero
.be92	a0 10		ldy #$10			ldy #16			; for 16 bits
.be94					_loop:
.be94	36 28		rol $28,x			rol DStack+4,x		;   rotate low cell of dividend one bit left
.be96	36 29		rol $29,x			rol DStack+5,x
.be98	36 26		rol $26,x			rol DStack+2,x		;   rotate high cell of dividend one bit left
.be9a	36 27		rol $27,x			rol DStack+3,x
.be9c	b0 0a		bcs $bea8			bcs _subtract		;   overflow?
.be9e	b5 26		lda $26,x			lda DStack+2,x		;   dividend.hi >= divisor?
.bea0	d5 24		cmp $24,x			cmp DStack+0,x
.bea2	b5 27		lda $27,x			lda DStack+3,x
.bea4	f5 25		sbc $25,x			sbc DStack+1,x
.bea6	90 0d		bcc $beb5			bcc _next
.bea8	b5 26		lda $26,x	_subtract:	lda DStack+2,x		;   dividend.hi -= divisor
.beaa	f5 24		sbc $24,x			sbc DStack+0,x
.beac	95 26		sta $26,x			sta DStack+2,x
.beae	b5 27		lda $27,x			lda DStack+3,x
.beb0	f5 25		sbc $25,x			sbc DStack+1,x
.beb2	95 27		sta $27,x			sta DStack+3,x
.beb4	38		sec				sec			;   it always fits
.beb5	88		dey		_next:		dey			;  next
.beb6	d0 dc		bne $be94			bne _loop
.beb8	36 28		rol $28,x			rol DStack+4,x		; finish rotating quotient bit in
.beba	36 29		rol $29,x			rol DStack+5,x
.bebc	e8		inx				inx			; drop divisor
.bebd	e8		inx				inx
.bebe	4c f3 df	jmp $dff3			jmp Swap
.bec1	a9 f6		lda #$f6	_DivByZero:	lda #$100+err_DivideBy0
.bec3	4c 68 c4	jmp $c468			jmp ThrowA
=62					CodeLen	.var *-XtPtr1
=$bec6					Here1 = *	; remember here
>be86	3e					.byte CodeLen	;patch wh_CodeLength
.bec6	4c 2f c4	jmp $c42f	Throw_Stack_15: jmp Throw_Stack
>bec9	53 4d 2f 52 65 6d		Name0:	.text "SM/Rem"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=48719					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>becf	a6					.byte (("SM/Rem"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=75					LinkDisplacement = Nt0-WordListLink
>bed0	10					.byte WordFlags	;wh_Flags
>bed1	03					.byte 3	;wh_CodeLength
>bed2	4b					  .byte LinkDisplacement	; offset to previous nt
=$bed3					XtPtr1 ::= *
=48719					WordListLink ::= Nt0 ; remember the nt of this word for later
.bed3					SM_Slash_Rem:
.bed3	e0 2b		cpx #$2b		cpx #(DDim-3)*2+1	; far enough below end of data stack (& not negative)?
.bed5	b0 ef		bcs $bec6		bcs Throw_Stack_15
.bed7	b5 27		lda $27,x			lda DStack+3,x
.bed9	08		php				php
.beda	55 25		eor $25,x			eor DStack+1,x
.bedc	08		php				php
.bedd	20 02 d7	jsr $d702			jsr Abs
.bee0	e8		inx				inx		; pretend we pushed n1 to R
.bee1	e8		inx				inx
.bee2	20 35 d7	jsr $d735			jsr DAbs
.bee5	ca		dex				dex
.bee6	ca		dex				dex
.bee7	20 88 be	jsr $be88			jsr UM_Slash_Mod	; UM/MOD
.beea	28		plp				plp
.beeb	10 03		bpl $bef0			bpl +
.beed	20 e9 d6	jsr $d6e9			jsr Negate
.bef0					+
.bef0	28		plp				plp
.bef1	10 07		bpl $befa			bpl _done
.bef3	e8		inx				inx		; pretend we pushed quotient to R
.bef4	e8		inx				inx
.bef5	20 e9 d6	jsr $d6e9			jsr Negate
.bef8	ca		dex				dex
.bef9	ca		dex				dex
.befa					_done:
=39					CodeLen	.var *-XtPtr1
=$befa					Here1 = *	; remember here
>bed1	27					.byte CodeLen	;patch wh_CodeLength
.befa	60		rts				rts
>befb	46 4d 2f 4d 6f 64		Name0:	.text "FM/Mod"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=48769					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>bf01	86					.byte (("FM/Mod"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=50					LinkDisplacement = Nt0-WordListLink
>bf02	10					.byte WordFlags	;wh_Flags
>bf03	03					.byte 3	;wh_CodeLength
>bf04	32					  .byte LinkDisplacement	; offset to previous nt
=$bf05					XtPtr1 ::= *
=48769					WordListLink ::= Nt0 ; remember the nt of this word for later
.bf05					FM_Slash_Mod:
.bf05	e0 2b		cpx #$2b		cpx #(DDim-3)*2+1	; far enough below end of data stack (& not negative)?
.bf07	b0 bd		bcs $bec6		bcs Throw_Stack_15
.bf09	b5 25		lda $25,x			lda DStack+1,x	; MSB of n1
.bf0b	08		php				php		;  save sign
.bf0c	10 0a		bpl $bf18			bpl +
.bf0e	20 e9 d6	jsr $d6e9			jsr Negate	; NEGATE
.bf11	e8		inx				inx
.bf12	e8		inx				inx
.bf13	20 19 d7	jsr $d719			jsr DNegate	; DNEGATE
.bf16	ca		dex				dex
.bf17	ca		dex				dex
.bf18					+
.bf18	b5 27		lda $27,x			lda DStack+3,x	; MSB of high word of d
.bf1a	10 0d		bpl $bf29			bpl +
.bf1c	18		clc				clc
.bf1d	b5 24		lda $24,x			lda DStack+0,x	; LSB of n1
.bf1f	75 26		adc $26,x			adc DStack+2,x	; LSB of dh
.bf21	95 26		sta $26,x			sta DStack+2,x
.bf23	b5 25		lda $25,x			lda DStack+1,x	; MSB of n1
.bf25	75 27		adc $27,x			adc DStack+3,x	; MSB of dh
.bf27	95 27		sta $27,x			sta DStack+3,x
.bf29					+
.bf29	20 88 be	jsr $be88			jsr UM_Slash_Mod	; ( d n1 -- rem n2 )
.bf2c	28		plp				plp
.bf2d	10 07		bpl $bf36			bpl +
.bf2f	e8		inx				inx		; pretend that we SWAP
.bf30	e8		inx				inx
.bf31	20 e9 d6	jsr $d6e9			jsr Negate
.bf34	ca		dex				dex
.bf35	ca		dex				dex
.bf36					+
=49					CodeLen	.var *-XtPtr1
=$bf36					Here1 = *	; remember here
>bf03	31					.byte CodeLen	;patch wh_CodeLength
.bf36	60		rts				rts
>bf37	2f 4d 6f 64			Name0:	.text "/Mod"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=48827					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>bf3b	84					.byte (("/Mod"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=58					LinkDisplacement = Nt0-WordListLink
>bf3c	10					.byte WordFlags	;wh_Flags
>bf3d	03					.byte 3	;wh_CodeLength
>bf3e	3a					  .byte LinkDisplacement	; offset to previous nt
=$bf3f					XtPtr1 ::= *
=48827					WordListLink ::= Nt0 ; remember the nt of this word for later
.bf3f	20 d2 df	jsr $dfd2	Slash_Mod:	jsr Dup			; ( n1 n_div n_div )
.bf42	a0 00		ldy #$00			ldy #0			; sign extend n1
.bf44	b5 29		lda $29,x			lda DStack+5,x
.bf46	10 01		bpl $bf49			bpl +
.bf48	88		dey				dey
.bf49	94 26		sty $26,x	+		sty DStack+2,x
.bf4b	94 27		sty $27,x			sty DStack+3,x		; ( d1 n_div )
.bf4d	4c d3 be	jmp $bed3			jmp SM_Slash_Rem	; SM/REM
=17					CodeLen	.var *-XtPtr1
=$bf50					Here1 = *	; remember here
>bf3d	11					.byte CodeLen	;patch wh_CodeLength
>bf50	2f				Name0:	.text "/"	;  name of word as a string, ending at wh_NameLastChar
=1					NameLength = *-Name0
=48849					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>bf51	e1					.byte (("/"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=22					LinkDisplacement = Nt0-WordListLink
>bf52	10					.byte WordFlags	;wh_Flags
>bf53	03					.byte 3	;wh_CodeLength
>bf54	16					  .byte LinkDisplacement	; offset to previous nt
=$bf55					XtPtr1 ::= *
=48849					WordListLink ::= Nt0 ; remember the nt of this word for later
.bf55	20 3f bf	jsr $bf3f	Slash:		jsr Slash_Mod
.bf58	4c cd d9	jmp $d9cd			jmp Nip		; Nip remainder
=6					CodeLen	.var *-XtPtr1
=$bf5b					Here1 = *	; remember here
>bf53	06					.byte CodeLen	;patch wh_CodeLength
>bf5b	4d 6f 64			Name0:	.text "Mod"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=48862					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>bf5e	83					.byte (("Mod"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=0					WordFlags ::= 0	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>bf5f	00					.byte WordFlags	;wh_Flags
>bf60	03					.byte 3	;wh_CodeLength
>bf61	0d					  .byte LinkDisplacement	; offset to previous nt
=$bf62					XtPtr1 ::= *
=48862					WordListLink ::= Nt0 ; remember the nt of this word for later
.bf62	20 3f bf	jsr $bf3f	Mod:		jsr Slash_Mod
.bf65	e8		inx				inx		; Drop quotient
.bf66	e8		inx				inx
=5					CodeLen	.var *-XtPtr1
=$bf67					Here1 = *	; remember here
>bf60	05					.byte CodeLen	;patch wh_CodeLength
.bf67	60		rts				rts
>bf68	2a 2f 4d 6f 64			Name0:	.text "*/Mod"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=48877					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>bf6d	85					.byte (("*/Mod"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=15					LinkDisplacement = Nt0-WordListLink
>bf6e	10					.byte WordFlags	;wh_Flags
>bf6f	03					.byte 3	;wh_CodeLength
>bf70	0f					  .byte LinkDisplacement	; offset to previous nt
=$bf71					XtPtr1 ::= *
=48877					WordListLink ::= Nt0 ; remember the nt of this word for later
.bf71					Star_Slash_Mod:
.bf71	20 25 c4	jsr $c425			jsr underflow_3
.bf74	20 42 df	jsr $df42			jsr To_R
.bf77	20 57 be	jsr $be57			jsr M_Star
.bf7a	20 60 df	jsr $df60			jsr R_From
.bf7d	4c d3 be	jmp $bed3			jmp SM_Slash_Rem
=15					CodeLen	.var *-XtPtr1
=$bf80					Here1 = *	; remember here
>bf6f	0f					.byte CodeLen	;patch wh_CodeLength
>bf80	2a 2f				Name0:	.text "*/"	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=48898					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>bf82	e2					.byte (("*/"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=21					LinkDisplacement = Nt0-WordListLink
>bf83	10					.byte WordFlags	;wh_Flags
>bf84	03					.byte 3	;wh_CodeLength
>bf85	15					  .byte LinkDisplacement	; offset to previous nt
=$bf86					XtPtr1 ::= *
=48898					WordListLink ::= Nt0 ; remember the nt of this word for later
.bf86					Star_Slash:
.bf86	20 71 bf	jsr $bf71			jsr Star_Slash_Mod
.bf89	4c cd d9	jmp $d9cd			jmp Nip			; mod
=6					CodeLen	.var *-XtPtr1
=$bf8c					Here1 = *	; remember here
>bf84	06					.byte CodeLen	;patch wh_CodeLength
>bf8c	4d 2a 2f			Name0:	.text "M*/"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=48911					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>bf8f	e3					.byte (("M*/"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>bf90	10					.byte WordFlags	;wh_Flags
>bf91	03					.byte 3	;wh_CodeLength
>bf92	0d					  .byte LinkDisplacement	; offset to previous nt
=$bf93					XtPtr1 ::= *
=48911					WordListLink ::= Nt0 ; remember the nt of this word for later
.bf93					m_star_slash:
.bf93	20 2a c4	jsr $c42a	                jsr underflow_4
.bf96	b5 25		lda $25,x			lda DStack+1,x		; calc result sign
.bf98	55 27		eor $27,x			eor DStack+3,x
.bf9a	55 29		eor $29,x			eor DStack+5,x
.bf9c	08		php				php
.bf9d	20 02 d7	jsr $d702	                jsr Abs			; Abs
.bfa0	20 42 df	jsr $df42	                jsr To_R		; >R		( d1 n1 ) ( R: sign abs(n2) )
.bfa3	20 02 d7	jsr $d702	                jsr Abs			; Abs
.bfa6	20 42 df	jsr $df42	                jsr To_R		; >R		( d1 ) ( R: sign abs(n2) abs(n1) )
.bfa9	20 35 d7	jsr $d735	                jsr DAbs		; DAbs		( abs(d1) ) ( R: sign abs(n2) abs(n1) )
.bfac	20 f3 df	jsr $dff3	                jsr Swap		; Swap
.bfaf	20 7b df	jsr $df7b	                jsr R_Fetch		; R@
.bfb2	20 09 be	jsr $be09	                jsr UM_Star		; UM*
.bfb5	20 b3 de	jsr $deb3	                jsr Rot			; Rot
.bfb8	20 60 df	jsr $df60	                jsr R_From		; R>
.bfbb	20 09 be	jsr $be09	                jsr UM_Star		; UM*
.bfbe	20 b3 de	jsr $deb3	                jsr Rot			; Rot
.bfc1	20 b6 da	jsr $dab6	                jsr UMPlus		; 0 D+
.bfc4	20 7b df	jsr $df7b	                jsr R_Fetch		; R@
.bfc7	20 88 be	jsr $be88	                jsr UM_Slash_Mod	; UM/Mod
.bfca	20 d8 de	jsr $ded8	                jsr Not_Rot		; Rot Rot
.bfcd	20 60 df	jsr $df60	                jsr R_From		; R>
.bfd0	20 88 be	jsr $be88	                jsr UM_Slash_Mod	; UM/Mod
.bfd3	20 cd d9	jsr $d9cd	                jsr Nip			; Swap Drop
.bfd6	20 f3 df	jsr $dff3	                jsr Swap		; Swap
.bfd9	28		plp				plp
.bfda	10 03		bpl $bfdf			bpl _rts		; ... 0< if ...
.bfdc	4c 19 d7	jmp $d719	                jmp DNegate
.bfdf	60		rts		_rts:		rts
=77					CodeLen	.var *-XtPtr1
=$bfe0					Here1 = *	; remember here
>bf91	4d					.byte CodeLen	;patch wh_CodeLength
>bfe0	45 76 61 6c 75 61 74 65		Name0:	.text "Evaluate"	;  name of word as a string, ending at wh_NameLastChar
=8					NameLength = *-Name0
=49000					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>bfe8	a8					.byte (("Evaluate"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=89					LinkDisplacement = Nt0-WordListLink
>bfe9	10					.byte WordFlags	;wh_Flags
>bfea	03					.byte 3	;wh_CodeLength
>bfeb	59					  .byte LinkDisplacement	; offset to previous nt
=$bfec					XtPtr1 ::= *
=49000					WordListLink ::= Nt0 ; remember the nt of this word for later
.bfec					Evaluate:
.bfec	18		clc				clc			; signal to zero BLK.
.bfed					load_evaluate:
.bfed	ad 0d 03	lda $030d			lda BlkV+1	; Save the current value of BLK on the return stack.
.bff0	48		pha				pha
.bff1	ad 0c 03	lda $030c			lda BlkV+0
.bff4	48		pha				pha
.bff5	b0 08		bcs $bfff			bcs +		; See if we should zero BLK.
.bff7	a9 00		lda #$00			lda #0		; Set BLK to zero.
.bff9	8d 0c 03	sta $030c			sta BlkV+0
.bffc	8d 0d 03	sta $030d			sta BlkV+1
.bfff					+
.bfff	20 16 d4	jsr $d416			jsr Input_To_R	; Save the input state to the Return Stack
.c002	a9 ff		lda #$ff			lda #$ff	; SOURCE-ID= -1
.c004	85 02		sta $02				sta insrc+0
.c006	85 03		sta $03				sta insrc+1
.c008	a9 00		lda #$00			lda #0		; >IN= zero
.c00a	85 08		sta $08				sta toin+0
.c00c	85 09		sta $09				sta toin+1
.c00e	20 e3 c3	jsr $c3e3			jsr PopYA	; ciblen= string length (u)
.c011	85 06		sta $06				sta ciblen+0
.c013	84 07		sty $07				sty ciblen+1
.c015	20 e3 c3	jsr $c3e3			jsr PopYA	; cib= string addr
.c018	85 04		sta $04				sta cib+0
.c01a	84 05		sty $05				sty cib+1
.c01c	20 20 c5	jsr $c520			jsr interpret	; ( -- )
.c01f	20 37 d4	jsr $d437			jsr R_To_Input	; restore input state
.c022	68		pla				pla		; Restore BLK from the return stack.
.c023	8d 0c 03	sta $030c			sta BlkV+0
.c026	68		pla				pla
.c027	8d 0d 03	sta $030d			sta BlkV+1
=62					CodeLen	.var *-XtPtr1
=$c02a					Here1 = *	; remember here
>bfea	3e					.byte CodeLen	;patch wh_CodeLength
.c02a	60		rts				rts
.c02b	4c 2f c4	jmp $c42f	Throw_Stack_11: jmp Throw_Stack
>c02e	3e 4e 75 6d 62 65 72		Name0:	.text ">Number"	;  name of word as a string, ending at wh_NameLastChar
=7					NameLength = *-Name0
=49077					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>c035	47					.byte ((">Number"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=77					LinkDisplacement = Nt0-WordListLink
>c036	10					.byte WordFlags	;wh_Flags
>c037	03					.byte 3	;wh_CodeLength
>c038	4d					  .byte LinkDisplacement	; offset to previous nt
=$c039					XtPtr1 ::= *
=49077					WordListLink ::= Nt0 ; remember the nt of this word for later
.c039					To_Number:
.c039	e0 29		cpx #$29		cpx #(DDim-4)*2+1	; far enough below end of data stack (& not negative)?
.c03b	b0 ee		bcs $c02b		bcs Throw_Stack_11
.c03d	b5 24		lda $24,x			lda DStack+0,x		; no chars left?
.c03f	f0 72		beq $c0b3			beq _done
.c041					_Char_loop:
.c041	a1 26		lda ($26,x)			lda (DStack+2,x)		; Get next character
.c043	c9 30		cmp #$30			cmp #'0'		; convert to value (Digit_Question)
.c045	90 6c		bcc $c0b3			bcc _done
.c047	c9 3a		cmp #$3a			cmp #'9'+1
.c049	90 08		bcc $c053			bcc _digit
.c04b	29 df		and #$df			and #$df		;   ASCII uppercase
.c04d	c9 41		cmp #$41			cmp #'A'
.c04f	90 62		bcc $c0b3			bcc _done
.c051	e9 07		sbc #$07			sbc #7 ;'A'-'0'-10	;   to make 'A'=10 below
.c053	38		sec		_digit:		sec
.c054	e9 30		sbc #$30			sbc #'0'
.c056	cd 00 03	cmp $0300			cmp base		; must be < base
.c059	b0 58		bcs $c0b3			bcs _done
.c05b	48		pha				pha			; Save char value
.c05c	20 a5 d5	jsr $d5a5			jsr Two_Over		;   copy ud to work (multiplicand)
.c05f	a9 00		lda #$00			lda #0			;   zero ud (product)
.c061	95 2c		sta $2c,x			sta DStack+8,x
.c063	95 2d		sta $2d,x			sta DStack+9,x
.c065	95 2e		sta $2e,x			sta DStack+10,x
.c067	95 2f		sta $2f,x			sta DStack+11,x
.c069	ad 00 03	lda $0300			lda base		;   get multiplier
.c06c	d0 23		bne $c091			bne _Mul_Test
.c06e	48		pha		_Mul_Add:	pha			;   save multiplier
.c06f	18		clc				clc			;   ud += work
.c070	b5 26		lda $26,x			lda DStack+2,x
.c072	75 2e		adc $2e,x			adc DStack+10,x
.c074	95 2e		sta $2e,x			sta DStack+10,x
.c076	b5 27		lda $27,x			lda DStack+3,x
.c078	75 2f		adc $2f,x			adc DStack+11,x
.c07a	95 2f		sta $2f,x			sta DStack+11,x
.c07c	b5 24		lda $24,x			lda DStack+0,x
.c07e	75 2c		adc $2c,x			adc DStack+8,x
.c080	95 2c		sta $2c,x			sta DStack+8,x
.c082	b5 25		lda $25,x			lda DStack+1,x
.c084	75 2d		adc $2d,x			adc DStack+9,x
.c086	95 2d		sta $2d,x			sta DStack+9,x
.c088	68		pla				pla			;   restore multiplier
.c089	16 26		asl $26,x	_Mul_Shift:	asl DStack+2,x		;   work <<= 1
.c08b	36 27		rol $27,x			rol DStack+3,x
.c08d	36 24		rol $24,x			rol DStack+0,x
.c08f	36 25		rol $25,x			rol DStack+1,x
.c091	4a		lsr a		_Mul_Test:	lsr a			;   shift multiplier
.c092	b0 da		bcs $c06e			bcs _Mul_Add
.c094	d0 f3		bne $c089			bne _Mul_Shift
.c096	e8		inx				inx			;   2Drop work
.c097	e8		inx				inx
.c098	e8		inx				inx
.c099	e8		inx				inx
.c09a	68		pla				pla			; recover value
.c09b	18		clc				clc			; add to ud
.c09c	75 2a		adc $2a,x			adc DStack+6,x
.c09e	95 2a		sta $2a,x			sta DStack+6,x
.c0a0	90 0a		bcc $c0ac			bcc +
.c0a2	f6 2b		inc $2b,x			inc DStack+7,x
.c0a4	d0 06		bne $c0ac			bne +
.c0a6	f6 28		inc $28,x			inc DStack+4,x
.c0a8	d0 02		bne $c0ac			bne +
.c0aa	f6 29		inc $29,x			inc DStack+5,x
.c0ac					+
.c0ac	20 a5 da	jsr $daa5			jsr NOS_One_Plus	; consume the char
.c0af	d6 24		dec $24,x			dec DStack+0,x
.c0b1	d0 8e		bne $c041			bne _Char_loop
.c0b3					_done:
=122					CodeLen	.var *-XtPtr1
=$c0b3					Here1 = *	; remember here
>c037	7a					.byte CodeLen	;patch wh_CodeLength
.c0b3	60		rts				rts
>c0b4	4e 75 6d 62 65 72		Name0:	.text "Number"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=49210					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>c0ba	46					.byte (("Number"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=80					WordFlags ::= UF+NN	; modifiable copy, remember for later
=133					LinkDisplacement = Nt0-WordListLink
>c0bb	50					.byte WordFlags	;wh_Flags
>c0bc	03					.byte 3	;wh_CodeLength
>c0bd	85					  .byte LinkDisplacement	; offset to previous nt
=$c0be					XtPtr1 ::= *
=49210					WordListLink ::= Nt0 ; remember the nt of this word for later
.c0be					Number:
.c0be	20 20 c4	jsr $c420			jsr underflow_2
.c0c1	a9 00		lda #$00			lda #0
.c0c3	85 1a		sta $1a				sta tmp4+0	; flag for double
.c0c5	85 1b		sta $1b				sta tmp4+1	; flag for minus
.c0c7	ad 00 03	lda $0300			lda base
.c0ca	48		pha				pha
.c0cb	20 f6 dc	jsr $dcf6			jsr Two_dup		; ( addr u addr u )
.c0ce	a1 26		lda ($26,x)			lda (DStack+2,x)	; get 1st char
.c0d0	20 92 c1	jsr $c192			jsr _MinusCheck		; a minus sign?
.c0d3	a0 0a		ldy #$0a			ldy #10			; decimal?
.c0d5	c9 23		cmp #$23			cmp #'#'
.c0d7	f0 35		beq $c10e			beq _base_changed
.c0d9	a0 10		ldy #$10			ldy #16			; hex?
.c0db	c9 24		cmp #$24			cmp #'$'
.c0dd	f0 2f		beq $c10e			beq _base_changed
.c0df	a0 02		ldy #$02			ldy #2			; binary?
.c0e1	c9 25		cmp #$25			cmp #'%'
.c0e3	f0 29		beq $c10e			beq _base_changed
.c0e5	c9 27		cmp #$27			cmp #$27		; ASCII for "'"
.c0e7	d0 2f		bne $c118			bne _check_dot
.c0e9	b5 24		lda $24,x			lda DStack+0,x	; length=3 ?
.c0eb	c9 03		cmp #$03			cmp #3
.c0ed	d0 1c		bne $c10b			bne _not_a_char
.c0ef	b5 26		lda $26,x			lda DStack+2,x	; LSB of address
.c0f1	85 1c		sta $1c				sta tmp5
.c0f3	b5 27		lda $27,x			lda DStack+3,x
.c0f5	85 1d		sta $1d				sta tmp5+1
.c0f7	a0 02		ldy #$02			ldy #2
.c0f9	b1 1c		lda ($1c),y			lda (tmp5),y
.c0fb	c9 27		cmp #$27			cmp #$27	; ASCII for "'"
.c0fd	d0 0c		bne $c10b			bne _not_a_char
.c0ff	88		dey				dey		; The char we want is between the single quotes.
.c100	b1 1c		lda ($1c),y			lda (tmp5),y
.c102	95 26		sta $26,x			sta DStack+2,x
.c104	a9 00		lda #$00			lda #0
.c106	95 27		sta $27,x			sta DStack+3,x
.c108	4c 67 c1	jmp $c167			jmp _drop_original_string ; Single flag will drop the TOS for us.
.c10b					_not_a_char:
.c10b	4c 44 c1	jmp $c144			jmp _number_error
.c10e					_base_changed:
.c10e	8c 00 03	sty $0300			sty base	; Switch to the new base
.c111	20 a5 da	jsr $daa5			jsr NOS_One_Plus ; start one character later
.c114	d6 24		dec $24,x			dec DStack+0,x	; decrease string length by one
.c116	a1 26		lda ($26,x)			lda (DStack+2,x) ; Load the first char again
.c118					_check_dot:
.c118	20 92 c1	jsr $c192			jsr _MinusCheck
.c11b	b5 26		lda $26,x			lda DStack+2,x	; LSB of address
.c11d	85 1c		sta $1c				sta tmp5
.c11f	b5 27		lda $27,x			lda DStack+3,x
.c121	85 1d		sta $1d				sta tmp5+1
.c123	b4 24		ldy $24,x			ldy DStack+0,x	; Y now points to the first character after the string,
.c125	88		dey				dey		; but we need the last character
.c126	b1 1c		lda ($1c),y			lda (tmp5),y
.c128	c9 2e		cmp #$2e			cmp #'.'
.c12a	d0 04		bne $c130			bne _main
.c12c	c6 1a		dec $1a				dec tmp4	; Flag the fact
.c12e	d6 24		dec $24,x			dec DStack+0,x	; reduce string length by one
.c130					_main:
.c130	20 f6 dc	jsr $dcf6			jsr Two_Dup
.c133	a9 00		lda #$00			lda #0
.c135	95 28		sta $28,x			sta DStack+4,x	; clear ud
.c137	95 29		sta $29,x			sta DStack+5,x
.c139	95 2a		sta $2a,x			sta DStack+6,x
.c13b	95 2b		sta $2b,x			sta DStack+7,x
.c13d	20 39 c0	jsr $c039			jsr To_Number	; ( ud addr u -- ud addr u )
.c140	b5 24		lda $24,x			lda DStack+0,x
.c142	f0 1f		beq $c163			beq _all_converted
.c144					_number_error:
.c144	20 72 d5	jsr $d572			jsr Two_drop	; >NUMBER modified addr u
.c147	20 72 d5	jsr $d572			jsr Two_drop	; ud   (partially converted number)
.c14a	a9 3e		lda #$3e			lda #'>'	; print the unknown
.c14c	20 21 de	jsr $de21			jsr Emit_A	; word using the original addr u we saved at the beginning.
.c14f	20 39 de	jsr $de39			jsr Type
.c152	a9 3c		lda #$3c			lda #'<'
.c154	20 21 de	jsr $de21			jsr Emit_A
.c157	20 2d de	jsr $de2d			jsr Space
.c15a	68		pla				pla		; restore base
.c15b	8d 00 03	sta $0300			sta base
.c15e	a9 f3		lda #$f3			lda #$100+err_UndefinedWord
.c160	4c 68 c4	jmp $c468			jmp ThrowA
.c163					_all_converted:
.c163	e8		inx				inx		; Drop the current addr u
.c164	e8		inx				inx
.c165	e8		inx				inx
.c166	e8		inx				inx
.c167					_drop_original_string:
.c167	20 ed cf	jsr $cfed			jsr TwoNip	 ; Drop the original addr u
.c16a	a5 1a		lda $1a				lda tmp4	; flag for double
.c16c	f0 10		beq $c17e			beq _single
.c16e	a9 20		lda #$20			lda #%00100000
.c170	05 0c		ora $0c				ora status
.c172	85 0c		sta $0c				sta status
.c174	a5 1b		lda $1b				lda tmp4+1
.c176	f0 15		beq $c18d			beq _done	; no minus, all done
.c178	20 19 d7	jsr $d719			jsr DNegate
.c17b	4c 8d c1	jmp $c18d			jmp _done
.c17e					_single:
.c17e	e8		inx				inx		; convert ud to u
.c17f	e8		inx				inx
.c180	a9 df		lda #$df			lda #$ff-%00100000
.c182	25 0c		and $0c				and status
.c184	85 0c		sta $0c				sta status
.c186	a5 1b		lda $1b				lda tmp4+1
.c188	f0 03		beq $c18d			beq _done	; no minus, all done
.c18a	20 e9 d6	jsr $d6e9			jsr Negate
.c18d					_done:
.c18d	68		pla				pla
.c18e	8d 00 03	sta $0300			sta base
=211					CodeLen	.var *-XtPtr1
=$c191					Here1 = *	; remember here
>c0bc	d3					.byte CodeLen	;patch wh_CodeLength
.c191	60		rts				rts
.c192					_MinusCheck:
.c192	c9 2d		cmp #$2d			cmp #'-'		; a minus sign?
.c194	d0 09		bne $c19f			bne +
.c196	c6 1b		dec $1b				dec tmp4+1		; set flag
.c198	20 a5 da	jsr $daa5			jsr NOS_One_Plus	; start one character later
.c19b	d6 24		dec $24,x			dec DStack+0,x		; decrease string length by one
.c19d	a1 26		lda ($26,x)			lda (DStack+2,x)	; get next char
.c19f	60		rts		+		rts
>c1a0	48 65 78			Name0:	.text "Hex"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=49443					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>c1a3	03					.byte (("Hex"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=233					LinkDisplacement = Nt0-WordListLink
>c1a4	10					.byte WordFlags	;wh_Flags
>c1a5	03					.byte 3	;wh_CodeLength
>c1a6	e9					  .byte LinkDisplacement	; offset to previous nt
=$c1a7					XtPtr1 ::= *
=49443					WordListLink ::= Nt0 ; remember the nt of this word for later
.c1a7	a9 10		lda #$10	Hex:		lda #16
.c1a9	d0 0d		bne $c1b8			bne Decimal_a
=4					CodeLen	.var *-XtPtr1
=$c1ab					Here1 = *	; remember here
>c1a5	04					.byte CodeLen	;patch wh_CodeLength
>c1ab	44 65 63 69 6d 61 6c		Name0:	.text "Decimal"	;  name of word as a string, ending at wh_NameLastChar
=7					NameLength = *-Name0
=49458					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>c1b2	87					.byte (("Decimal"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=0					WordFlags ::= 0	; modifiable copy, remember for later
=15					LinkDisplacement = Nt0-WordListLink
>c1b3	00					.byte WordFlags	;wh_Flags
>c1b4	03					.byte 3	;wh_CodeLength
>c1b5	0f					  .byte LinkDisplacement	; offset to previous nt
=$c1b6					XtPtr1 ::= *
=49458					WordListLink ::= Nt0 ; remember the nt of this word for later
.c1b6	a9 0a		lda #$0a	Decimal:	lda #10
.c1b8	8d 00 03	sta $0300	Decimal_a:	sta base+0
.c1bb	a9 00		lda #$00			lda #0
.c1bd	8d 01 03	sta $0301			sta base+1		; paranoid
=10					CodeLen	.var *-XtPtr1
=$c1c0					Here1 = *	; remember here
>c1b4	0a					.byte CodeLen	;patch wh_CodeLength
.c1c0	60		rts				rts
>c1c1	42 61 73 65			Name0:	.text "Base"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=49477					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>c1c5	a4					.byte (("Base"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=19					LinkDisplacement = Nt0-WordListLink
>c1c6	10					.byte WordFlags	;wh_Flags
>c1c7	03					.byte 3	;wh_CodeLength
>c1c8	13					  .byte LinkDisplacement	; offset to previous nt
=$c1c9					XtPtr1 ::= *
=49477					WordListLink ::= Nt0 ; remember the nt of this word for later
.c1c9	a0 03		ldy #$03			ldy #>base
.c1cb	a9 00		lda #$00			lda #<base
.c1cd	4c ba c7	jmp $c7ba			jmp PushYA
=7					CodeLen	.var *-XtPtr1
=$c1d0					Here1 = *	; remember here
>c1c7	07					.byte CodeLen	;patch wh_CodeLength
.c1d0	4c 2f c4	jmp $c42f	Throw_Stack_10: jmp Throw_Stack
>c1d3	43 6f 75 6e 74			Name0:	.text "Count"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=49496					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>c1d8	85					.byte (("Count"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=19					LinkDisplacement = Nt0-WordListLink
>c1d9	10					.byte WordFlags	;wh_Flags
>c1da	03					.byte 3	;wh_CodeLength
>c1db	13					  .byte LinkDisplacement	; offset to previous nt
=$c1dc					XtPtr1 ::= *
=49496					WordListLink ::= Nt0 ; remember the nt of this word for later
.c1dc					Count:
.c1dc	e0 2f		cpx #$2f		cpx #(DDim-1)*2+1	; far enough below end of data stack (& not negative)?
.c1de	b0 f0		bcs $c1d0		bcs Throw_Stack_10
.c1e0	a1 24		lda ($24,x)			lda (DStack+0,x)	; A= number of characters
.c1e2	f6 24		inc $24,x			inc DStack+0,x		; move start address up by one
.c1e4	d0 02		bne $c1e8			bne +
.c1e6	f6 25		inc $25,x			inc DStack+1,x
.c1e8					+
.c1e8	4c e9 c7	jmp $c7e9			jmp PushZA		; push number of characters, return
=15					CodeLen	.var *-XtPtr1
=$c1eb					Here1 = *	; remember here
>c1da	0f					.byte CodeLen	;patch wh_CodeLength
>c1eb	3f 50 61 69 72 43 74 6c		Name0:	.text "?PairCtlA"	;  name of word as a string, ending at wh_NameLastChar
>c1f3	41
=9					NameLength = *-Name0
=49524					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>c1f4	29					.byte (("?PairCtlA"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=28					LinkDisplacement = Nt0-WordListLink
>c1f5	10					.byte WordFlags	;wh_Flags
>c1f6	03					.byte 3	;wh_CodeLength
>c1f7	1c					  .byte LinkDisplacement	; offset to previous nt
=$c1f8					XtPtr1 ::= *
=49524					WordListLink ::= Nt0 ; remember the nt of this word for later
.c1f8	d5 24		cmp $24,x	QPairCtlA:	cmp DStack+0,x
.c1fa	f0 05		beq $c201			beq _8
.c1fc	a9 ea		lda #$ea			lda #$100+err_ControlMismatch
.c1fe	4c 68 c4	jmp $c468			jmp ThrowA
.c201	e8		inx		_8:		inx
.c202	e8		inx				inx	; Drop n
.c203	60		rts				rts
=12					CodeLen	.var *-XtPtr1
=$c204					Here1 = *	; remember here
>c1f6	0c					.byte CodeLen	;patch wh_CodeLength
>0743					DoLeave  .word ?	; head of leave addr patch chain
>0745					DoStkIndex: .byte ?
>0746					DoIndexL: .fill DoStkDim
>074e					DoIndexH: .fill DoStkDim
>0756					DoFufaL:  .fill DoStkDim
>075e					DoFufaH:  .fill DoStkDim
>c204	3f 44 6f			Name0:	.text "?Do"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=49543					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>c207	e3					.byte (("?Do"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=28					WordFlags ::= CO+IM+NN	; modifiable copy, remember for later
=19					LinkDisplacement = Nt0-WordListLink
>c208	1c					.byte WordFlags	;wh_Flags
>c209	03					.byte 3	;wh_CodeLength
>c20a	13					  .byte LinkDisplacement	; offset to previous nt
=$c20b					XtPtr1 ::= *
=49543					WordListLink ::= Nt0 ; remember the nt of this word for later
.c20b					Question_Do:
.c20b	20 45 c3	jsr $c345			jsr Do_Leave_Init
.c20e	a9 22		lda #$22			lda #<_runtime
.c210	a0 c2		ldy #$c2			ldy #>_runtime
.c212	20 78 dd	jsr $dd78			jsr Jsr_Comma_YA	; compile JSR _runtime
.c215	a9 d0		lda #$d0			lda #$d0		; compile BNE *+5
.c217	a0 03		ldy #$03			ldy #3
.c219	20 55 dd	jsr $dd55			jsr Comma_YA
.c21c	20 28 c3	jsr $c328			jsr Leave		; compile JMP leave
.c21f	4c 3f c2	jmp $c23f			jmp Do_8		; finish
=23					CodeLen	.var *-XtPtr1
=$c222					Here1 = *	; remember here
>c209	17					.byte CodeLen	;patch wh_CodeLength
.c222					_runtime:
.c222	20 47 c2	jsr $c247			jsr Do_Runtime	; start normally (we assume TOS!=NOS)
.c225	a5 12		lda $12				lda DoIndex+0	; Are TOS and NOS equal?
.c227	f0 01		beq $c22a			beq _2
.c229	60		rts				rts		; return Z=0 to signal continue
.c22a	a5 13		lda $13		_2:		lda DoIndex+1
.c22c	c9 80		cmp #$80			cmp #$80
.c22e	60		rts				rts		; return Z
>c22f	44 6f				Name0:	.text "Do"	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=49585					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>c231	e2					.byte (("Do"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=28					WordFlags ::= CO+IM+NN	; modifiable copy, remember for later
=42					LinkDisplacement = Nt0-WordListLink
>c232	1c					.byte WordFlags	;wh_Flags
>c233	03					.byte 3	;wh_CodeLength
>c234	2a					  .byte LinkDisplacement	; offset to previous nt
=$c235					XtPtr1 ::= *
=49585					WordListLink ::= Nt0 ; remember the nt of this word for later
.c235					Do:
.c235	20 45 c3	jsr $c345			jsr Do_Leave_Init
.c238	a9 47		lda #$47			lda #<Do_runtime
.c23a	a0 c2		ldy #$c2			ldy #>Do_runtime
.c23c	20 78 dd	jsr $dd78			jsr Jsr_Comma_YA	; compile JSR _runtime
.c23f	20 67 da	jsr $da67	Do_8:		jsr Here		; remember loop body start addr
.c242	a9 35		lda #$35			lda #<Do		; identifier
.c244	4c e9 c7	jmp $c7e9			jmp PushZA
=18					CodeLen	.var *-XtPtr1
=$c247					Here1 = *	; remember here
>c233	12					.byte CodeLen	;patch wh_CodeLength
.c247					Do_Runtime:
.c247	ce 45 07	dec $0745			dec DoStkIndex		; alloc DO stack entry
.c24a	ac 45 07	ldy $0745			ldy DoStkIndex
.c24d	30 2d		bmi $c27c			bmi _TooDeep
.c24f	a5 12		lda $12				lda DoIndex+0		; save previous DoIndex
.c251	99 46 07	sta $0746,y			sta DoIndexL,y
.c254	a5 13		lda $13				lda DoIndex+1
.c256	99 4e 07	sta $074e,y			sta DoIndexH,y
.c259	38		sec				sec			; fudge factor (FUFA)= $8000 - limit
.c25a	a9 00		lda #$00			lda #0			;   the number that will trip the overflow flag
.c25c	f5 26		sbc $26,x			sbc DStack+2,x
.c25e	99 56 07	sta $0756,y			sta DoFuFaL,y
.c261	a9 80		lda #$80			lda #$80
.c263	f5 27		sbc $27,x			sbc DStack+3,x
.c265	99 5e 07	sta $075e,y			sta DoFuFaH,y
.c268	18		clc				clc			; index= FUFA plus original index
.c269	b5 24		lda $24,x			lda DStack+0,x
.c26b	79 56 07	adc $0756,y			adc DoFuFaL,y
.c26e	85 12		sta $12				sta DoIndex+0
.c270	b5 25		lda $25,x			lda DStack+1,x
.c272	79 5e 07	adc $075e,y			adc DoFuFaH,y
.c275	85 13		sta $13				sta DoIndex+1
.c277	e8		inx				inx			; Drop orig index
.c278	e8		inx				inx
.c279	e8		inx				inx			; Drop orig limit
.c27a	e8		inx				inx
.c27b	60		rts				rts			; return
.c27c	a9 f9		lda #$f9	_TooDeep:	lda #$100+err_DoLoop_TooDeep
.c27e	20 68 c4	jsr $c468			jsr ThrowA
>c281	4c 6f 6f 70			Name0:	.text "Loop"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=49669					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>c285	04					.byte (("Loop"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=28					WordFlags ::= CO+IM+NN	; modifiable copy, remember for later
=84					LinkDisplacement = Nt0-WordListLink
>c286	1c					.byte WordFlags	;wh_Flags
>c287	03					.byte 3	;wh_CodeLength
>c288	54					  .byte LinkDisplacement	; offset to previous nt
=$c289					XtPtr1 ::= *
=49669					WordListLink ::= Nt0 ; remember the nt of this word for later
.c289					Loop:
.c289	a9 8f		lda #$8f			lda #<_Runtime
.c28b	a0 c2		ldy #$c2			ldy #>_Runtime
.c28d	d0 1b		bne $c2aa			bne Plus_Loop_5
=6					CodeLen	.var *-XtPtr1
=$c28f					Here1 = *	; remember here
>c287	06					.byte CodeLen	;patch wh_CodeLength
.c28f					_Runtime:
.c28f	e6 12		inc $12				inc DoIndex+0
.c291	f0 02		beq $c295			beq _Runtime2
.c293	b8		clv				clv			; return V=0 to signal loop back
.c294	60		rts				rts
.c295	18		clc		_Runtime2:	clc
.c296	a5 13		lda $13				lda DoIndex+1		; handle carry from lo byte
.c298	69 01		adc #$01			adc #1
.c29a	85 13		sta $13				sta DoIndex+1
.c29c	60		rts				rts			; return V to signal loop back
>c29d	2b 4c 6f 6f 70			Name0:	.text "+Loop"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=49698					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>c2a2	05					.byte (("+Loop"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=28					WordFlags ::= CO+IM+NN	; modifiable copy, remember for later
=29					LinkDisplacement = Nt0-WordListLink
>c2a3	1c					.byte WordFlags	;wh_Flags
>c2a4	03					.byte 3	;wh_CodeLength
>c2a5	1d					  .byte LinkDisplacement	; offset to previous nt
=$c2a6					XtPtr1 ::= *
=49698					WordListLink ::= Nt0 ; remember the nt of this word for later
.c2a6					Plus_Loop:
.c2a6	a9 b4		lda #$b4			lda #<Plus_Loop_Runtime
.c2a8	a0 c2		ldy #$c2			ldy #>Plus_Loop_Runtime
.c2aa	20 ca c2	jsr $c2ca	Plus_Loop_5:	jsr Loop_End		; compile JSR _runtime, BVC back
.c2ad	a9 0e		lda #$0e			lda #<Unloop ;(Unloop-wh_LinkNt-1)
.c2af	a0 c3		ldy #$c3			ldy #>Unloop ;(Unloop-wh_LinkNt-1)
.c2b1	4c 78 dd	jmp $dd78			jmp Jsr_Comma_YA ;Compile_Comma_NT_YA ; compile Unloop, return
=14					CodeLen	.var *-XtPtr1
=$c2b4					Here1 = *	; remember here
>c2a4	0e					.byte CodeLen	;patch wh_CodeLength
.c2b4					Plus_Loop_Runtime:
.c2b4	e0 2f		cpx #$2f		cpx #(DDim-1)*2+1	; far enough below end of data stack (& not negative)?
.c2b6	b0 0f		bcs $c2c7		bcs Throw_Stack_12
.c2b8	b5 24		lda $24,x			lda DStack+0,x		; DoIndex += step
.c2ba	65 12		adc $12				adc DoIndex+0
.c2bc	85 12		sta $12				sta DoIndex+0
.c2be	b5 25		lda $25,x			lda DStack+1,x
.c2c0	65 13		adc $13				adc DoIndex+1
.c2c2	85 13		sta $13				sta DoIndex+1
.c2c4	e8		inx				inx			; Drop step
.c2c5	e8		inx				inx
.c2c6	60		rts				rts			; return V=0 to signal loop back
.c2c7	4c 2f c4	jmp $c42f	Throw_Stack_12: jmp Throw_Stack
.c2ca					Loop_End:
.c2ca	20 78 dd	jsr $dd78			jsr Jsr_Comma_YA	; compile JSR runtime
.c2cd	a9 35		lda #$35			lda #<Do		; check id
.c2cf	20 f8 c1	jsr $c1f8	Loop_End_3:	jsr QPairCtlA
.c2d2	a9 50		lda #$50			lda #$50		; compile BVC body
.c2d4	20 f3 b6	jsr $b6f3			jsr Branch_CommaA
.c2d7	ac 43 07	ldy $0743			ldy DoLeave+0		; for each leave addr entry
.c2da	ad 44 07	lda $0744			lda DoLeave+1
.c2dd	f0 1b		beq $c2fa			beq _p9
.c2df	84 14		sty $14		_p1:		sty tmp1+0		;   save entry pointer
.c2e1	85 15		sta $15				sta tmp1+1
.c2e3	a0 01		ldy #$01			ldy #1			;   save link
.c2e5	b1 14		lda ($14),y			lda (tmp1),y
.c2e7	48		pha				pha
.c2e8	88		dey				dey
.c2e9	b1 14		lda ($14),y			lda (tmp1),y
.c2eb	48		pha				pha
.c2ec	a5 00		lda $00				lda cp+0		;   patch addr
.c2ee	91 14		sta ($14),y			sta (tmp1),y
.c2f0	a5 01		lda $01				lda cp+1
.c2f2	c8		iny				iny
.c2f3	91 14		sta ($14),y			sta (tmp1),y
.c2f5	68		pla				pla			;   get saved link
.c2f6	a8		tay				tay
.c2f7	68		pla				pla
.c2f8	d0 e5		bne $c2df			bne _p1
.c2fa					_p9:
.c2fa	20 e3 c3	jsr $c3e3			jsr PopYA		; restore DoLeave
.c2fd	8d 43 07	sta $0743			sta DoLeave+0
.c300	8c 44 07	sty $0744			sty DoLeave+1
.c303	60		rts				rts
>c304	55 6e 6c 6f 6f 70		Name0:	.text "Unloop"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=49802					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>c30a	06					.byte (("Unloop"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$04					WordFlags ::= CO	; modifiable copy, remember for later
=104					LinkDisplacement = Nt0-WordListLink
>c30b	04					.byte WordFlags	;wh_Flags
>c30c	03					.byte 3	;wh_CodeLength
>c30d	68					  .byte LinkDisplacement	; offset to previous nt
=$c30e					XtPtr1 ::= *
=49802					WordListLink ::= Nt0 ; remember the nt of this word for later
.c30e					Unloop:
.c30e	ac 45 07	ldy $0745			ldy DoStkIndex
.c311	b9 46 07	lda $0746,y			lda DoIndexL,y	; restore Index
.c314	85 12		sta $12				sta DoIndex+0
.c316	b9 4e 07	lda $074e,y			lda DoIndexH,y
.c319	85 13		sta $13				sta DoIndex+1
.c31b	ee 45 07	inc $0745			inc DoStkIndex	; drop Do stack entry
=16					CodeLen	.var *-XtPtr1
=$c31e					Here1 = *	; remember here
>c30c	10					.byte CodeLen	;patch wh_CodeLength
.c31e	60		rts				rts
>c31f	4c 65 61 76 65			Name0:	.text "Leave"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=49828					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>c324	a5					.byte (("Leave"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=28					WordFlags ::= IM+NN+CO	; modifiable copy, remember for later
=26					LinkDisplacement = Nt0-WordListLink
>c325	1c					.byte WordFlags	;wh_Flags
>c326	03					.byte 3	;wh_CodeLength
>c327	1a					  .byte LinkDisplacement	; offset to previous nt
=$c328					XtPtr1 ::= *
=49828					WordListLink ::= Nt0 ; remember the nt of this word for later
.c328					Leave:
.c328	a9 4c		lda #$4c			lda #$4c	; JMP abs
.c32a	20 3e dd	jsr $dd3e			jsr C_Comma_A
.c32d	a5 01		lda $01				lda cp+1	; save cp
.c32f	48		pha				pha
.c330	a5 00		lda $00				lda cp+0
.c332	48		pha				pha
.c333	ad 43 07	lda $0743			lda DoLeave+0	; compile DoLeave link, patched later
.c336	ac 44 07	ldy $0744			ldy DoLeave+1
.c339	20 55 dd	jsr $dd55			jsr Comma_YA
.c33c	68		pla				pla		; update DoLeave
.c33d	8d 43 07	sta $0743			sta DoLeave+0
.c340	68		pla				pla
.c341	8d 44 07	sta $0744			sta DoLeave+1
=28					CodeLen	.var *-XtPtr1
=$c344					Here1 = *	; remember here
>c326	1c					.byte CodeLen	;patch wh_CodeLength
.c344	60		rts				rts
.c345					Do_Leave_Init:
.c345	ad 43 07	lda $0743			lda DoLeave+0
.c348	ac 44 07	ldy $0744			ldy DoLeave+1
.c34b	20 ba c7	jsr $c7ba			jsr PushYA	; save old leave head
.c34e	a9 00		lda #$00			lda #0		; init
.c350	8d 44 07	sta $0744			sta DoLeave+1
.c353	60		rts				rts
>c354	49				Name0:	.text "I"	;  name of word as a string, ending at wh_NameLastChar
=1					NameLength = *-Name0
=49877					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>c355	21					.byte (("I"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$04					WordFlags ::= CO	; modifiable copy, remember for later
=49					LinkDisplacement = Nt0-WordListLink
>c356	04					.byte WordFlags	;wh_Flags
>c357	03					.byte 3	;wh_CodeLength
>c358	31					  .byte LinkDisplacement	; offset to previous nt
=$c359					XtPtr1 ::= *
=49877					WordListLink ::= Nt0 ; remember the nt of this word for later
.c359	ac 45 07	ldy $0745	I:		ldy DoStkIndex
.c35c	ca		dex				dex
.c35d	ca		dex				dex
.c35e	38		sec				sec		; n= fudged index - fudge factor (FUFA)
.c35f	a5 12		lda $12				lda DoIndex+0
.c361	f9 56 07	sbc $0756,y			sbc DoFuFaL,y
.c364	95 24		sta $24,x			sta DStack+0,x
.c366	a5 13		lda $13				lda DoIndex+1
.c368	f9 5e 07	sbc $075e,y			sbc DoFuFaH,y
.c36b	95 25		sta $25,x			sta DStack+1,x
=20					CodeLen	.var *-XtPtr1
=$c36d					Here1 = *	; remember here
>c357	14					.byte CodeLen	;patch wh_CodeLength
.c36d	60		rts				rts
>c36e	4a				Name0:	.text "J"	;  name of word as a string, ending at wh_NameLastChar
=1					NameLength = *-Name0
=49903					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>c36f	41					.byte (("J"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$04					WordFlags ::= CO	; modifiable copy, remember for later
=26					LinkDisplacement = Nt0-WordListLink
>c370	04					.byte WordFlags	;wh_Flags
>c371	03					.byte 3	;wh_CodeLength
>c372	1a					  .byte LinkDisplacement	; offset to previous nt
=$c373					XtPtr1 ::= *
=49903					WordListLink ::= Nt0 ; remember the nt of this word for later
.c373	ac 45 07	ldy $0745	J:		ldy DoStkIndex
.c376	ca		dex				dex
.c377	ca		dex				dex
.c378	38		sec				sec		; n= 2nd fudged index - 2nd fudge factor (FUFA)
.c379	b9 46 07	lda $0746,y			lda DoIndexL+0,y	; LSB
.c37c	f9 57 07	sbc $0757,y			sbc DoFufaL+1,y
.c37f	95 24		sta $24,x			sta DStack+0,x
.c381	b9 4e 07	lda $074e,y			lda DoIndexH+0,y	; MSB
.c384	f9 5f 07	sbc $075f,y			sbc DoFufaH+1,y
.c387	95 25		sta $25,x			sta DStack+1,x
=22					CodeLen	.var *-XtPtr1
=$c389					Here1 = *	; remember here
>c371	16					.byte CodeLen	;patch wh_CodeLength
.c389	60		rts				rts
>c38a	41 62 6f 72 74 22		Name0:	.text 'Abort"'	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=49936					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>c390	46					.byte (('Abort"'[-1]&7)<<5)+NameLength	;wh_HashNameLen
=28					WordFlags ::= CO+IM+NN	; modifiable copy, remember for later
=33					LinkDisplacement = Nt0-WordListLink
>c391	1c					.byte WordFlags	;wh_Flags
>c392	03					.byte 3	;wh_CodeLength
>c393	21					  .byte LinkDisplacement	; offset to previous nt
=$c394					XtPtr1 ::= *
=49936					WordListLink ::= Nt0 ; remember the nt of this word for later
.c394					Abort_Quote:
.c394	20 0f c9	jsr $c90f			jsr S_Quote		; compile the string literal
.c397	a0 c3		ldy #$c3			ldy #>_runtime		; compile JSR runtime, return
.c399	a9 9e		lda #$9e			lda #<_runtime
.c39b	4c 78 dd	jmp $dd78			jmp Jsr_Comma_YA
=10					CodeLen	.var *-XtPtr1
=$c39e					Here1 = *	; remember here
>c392	0a					.byte CodeLen	;patch wh_CodeLength
.c39e					_runtime:
.c39e	b5 28		lda $28,x			lda DStack+4,x
.c3a0	15 29		ora $29,x			ora DStack+5,x
.c3a2	d0 03		bne $c3a7			bne _do_abort	; true?
.c3a4	4c 72 bd	jmp $bd72			jmp ThreeDrop	; Drop three entries from the Data Stack
.c3a7					_do_abort:
.c3a7	20 39 de	jsr $de39			jsr Type	; print string
.c3aa	20 4c bb	jsr $bb4c			jsr CR		; We follow Gforth in going to a new line
.c3ad	a9 fe		lda #$fe			lda #$100+err_AbortQuote
.c3af	4c 68 c4	jmp $c468			jmp ThrowA
>c3b2	41 62 6f 72 74			Name0:	.text "Abort"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=49975					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>c3b7	85					.byte (("Abort"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=39					LinkDisplacement = Nt0-WordListLink
>c3b8	10					.byte WordFlags	;wh_Flags
>c3b9	03					.byte 3	;wh_CodeLength
>c3ba	27					  .byte LinkDisplacement	; offset to previous nt
=$c3bb					XtPtr1 ::= *
=49975					WordListLink ::= Nt0 ; remember the nt of this word for later
.c3bb	a9 ff		lda #$ff	Abort:		lda #$100+err_Abort
.c3bd	4c 68 c4	jmp $c468			jmp ThrowA
=5					CodeLen	.var *-XtPtr1
=$c3c0					Here1 = *	; remember here
>c3b9	05					.byte CodeLen	;patch wh_CodeLength
>c3c0	50 6f 70 41			Name0:	.text "PopA"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=49988					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>c3c4	24					.byte (("PopA"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>c3c5	10					.byte WordFlags	;wh_Flags
>c3c6	03					.byte 3	;wh_CodeLength
>c3c7	0d					  .byte LinkDisplacement	; offset to previous nt
=$c3c8					XtPtr1 ::= *
=49988					WordListLink ::= Nt0 ; remember the nt of this word for later
.c3c8					PopA:
.c3c8	e0 2f		cpx #$2f		cpx #(DDim-1)*2+1	; far enough below end of data stack (& not negative)?
.c3ca	b0 63		bcs $c42f		bcs Throw_Stack
.c3cc	b5 24		lda $24,x			lda DStack+0,x		; pop TOS to A (1 byte)
.c3ce	e8		inx				inx
.c3cf	e8		inx				inx
=8					CodeLen	.var *-XtPtr1
=$c3d0					Here1 = *	; remember here
>c3c6	08					.byte CodeLen	;patch wh_CodeLength
.c3d0	60		rts		                rts
.c3d1					PopA2:
.c3d1	e0 2d		cpx #$2d		cpx #(DDim-2)*2+1	; far enough below end of data stack (& not negative)?
.c3d3	b0 5a		bcs $c42f		bcs Throw_Stack
.c3d5	b5 24		lda $24,x			lda DStack+0,x		; pop TOS to A (1 byte)
.c3d7	e8		inx				inx
.c3d8	e8		inx				inx
.c3d9	60		rts		                rts
>c3da	50 6f 70 59 41			Name0:	.text "PopYA"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=50015					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>c3df	25					.byte (("PopYA"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=27					LinkDisplacement = Nt0-WordListLink
>c3e0	10					.byte WordFlags	;wh_Flags
>c3e1	03					.byte 3	;wh_CodeLength
>c3e2	1b					  .byte LinkDisplacement	; offset to previous nt
=$c3e3					XtPtr1 ::= *
=50015					WordListLink ::= Nt0 ; remember the nt of this word for later
.c3e3					PopYA:
.c3e3	e0 2f		cpx #$2f		cpx #(DDim-1)*2+1	; far enough below end of data stack (& not negative)?
.c3e5	b0 48		bcs $c42f		bcs Throw_Stack
.c3e7	b5 24		lda $24,x			lda DStack+0,x		; pop TOS to YA
.c3e9	b4 25		ldy $25,x			ldy DStack+1,x
.c3eb	e8		inx				inx
.c3ec	e8		inx				inx
=10					CodeLen	.var *-XtPtr1
=$c3ed					Here1 = *	; remember here
>c3e1	0a					.byte CodeLen	;patch wh_CodeLength
.c3ed	60		rts				rts
.c3ee					PopTmp1:
.c3ee	e0 2f		cpx #$2f		cpx #(DDim-1)*2+1	; far enough below end of data stack (& not negative)?
.c3f0	b0 3d		bcs $c42f		bcs Throw_Stack
.c3f2	b5 24		lda $24,x			lda DStack+0,x	; PopYA
.c3f4	b4 25		ldy $25,x			ldy DStack+1,x
.c3f6	e8		inx				inx
.c3f7	e8		inx				inx
.c3f8	85 14		sta $14				sta tmp1+0
.c3fa	84 15		sty $15				sty tmp1+1
.c3fc	60		rts				rts
>c3fd	75 6e 64 65 72 66 6c 6f		Name0:	.text "underflow_1"	;  name of word as a string, ending at wh_NameLastChar
>c405	77 5f 31
=11					NameLength = *-Name0
=50056					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>c408	2b					.byte (("underflow_1"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=41					LinkDisplacement = Nt0-WordListLink
>c409	10					.byte WordFlags	;wh_Flags
>c40a	03					.byte 3	;wh_CodeLength
>c40b	29					  .byte LinkDisplacement	; offset to previous nt
=$c40c					XtPtr1 ::= *
=50056					WordListLink ::= Nt0 ; remember the nt of this word for later
.c40c					underflow_1:
.c40c	e0 2f		cpx #$2f		cpx #(DDim-1)*2+1	; far enough below end of data stack (& not negative)?
.c40e	b0 1f		bcs $c42f		bcs Throw_Stack
=4					CodeLen	.var *-XtPtr1
=$c410					Here1 = *	; remember here
>c40a	04					.byte CodeLen	;patch wh_CodeLength
.c410	60		rts				rts
>c411	75 6e 64 65 72 66 6c 6f		Name0:	.text "underflow_2"	;  name of word as a string, ending at wh_NameLastChar
>c419	77 5f 32
=11					NameLength = *-Name0
=50076					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>c41c	4b					.byte (("underflow_2"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=20					LinkDisplacement = Nt0-WordListLink
>c41d	10					.byte WordFlags	;wh_Flags
>c41e	03					.byte 3	;wh_CodeLength
>c41f	14					  .byte LinkDisplacement	; offset to previous nt
=$c420					XtPtr1 ::= *
=50076					WordListLink ::= Nt0 ; remember the nt of this word for later
.c420					underflow_2:
.c420	e0 2d		cpx #$2d		cpx #(DDim-2)*2+1	; far enough below end of data stack (& not negative)?
.c422	b0 0b		bcs $c42f		bcs Throw_Stack
=4					CodeLen	.var *-XtPtr1
=$c424					Here1 = *	; remember here
>c41e	04					.byte CodeLen	;patch wh_CodeLength
.c424	60		rts		                rts
.c425					underflow_3:
.c425	e0 2b		cpx #$2b		cpx #(DDim-3)*2+1	; far enough below end of data stack (& not negative)?
.c427	b0 06		bcs $c42f		bcs Throw_Stack
.c429	60		rts		                rts
.c42a					underflow_4:
.c42a	e0 29		cpx #$29		cpx #(DDim-4)*2+1	; far enough below end of data stack (& not negative)?
.c42c	b0 01		bcs $c42f		bcs Throw_Stack
.c42e	60		rts		                rts
.c42f					Throw_Stack:
.c42f	30 04		bmi $c435			bmi _over
.c431	a9 fc		lda #$fc			lda #$100+err_Stack_Underflow
.c433	d0 33		bne $c468			bne ThrowA
.c435	a9 fd		lda #$fd	_over:		lda #$100+err_Stack_Overflow
.c437	d0 2f		bne $c468			bne ThrowA
.c439					Throw_FPStack:
.c439	30 04		bmi $c43f			bmi _over
.c43b	a9 d3		lda #$d3			lda #$100+err_FPStackUnderflow
.c43d	d0 29		bne $c468			bne ThrowA
.c43f	a9 d4		lda #$d4	_over:		lda #$100+err_FPStackOverflow
.c441	d0 25		bne $c468			bne ThrowA
.c443					Throw_FpOutOfRange:
.c443	a9 d5		lda #$d5			lda #$100+err_FpOutOfRange
.c445	d0 21		bne $c468			bne ThrowA
>c447	3f 53 74 61 63 6b		Name0:	.text "?Stack"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=50125					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>c44d	66					.byte (("?Stack"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=49					LinkDisplacement = Nt0-WordListLink
>c44e	10					.byte WordFlags	;wh_Flags
>c44f	03					.byte 3	;wh_CodeLength
>c450	31					  .byte LinkDisplacement	; offset to previous nt
=$c451					XtPtr1 ::= *
=50125					WordListLink ::= Nt0 ; remember the nt of this word for later
.c451					QStack:
.c451	e0 31		cpx #$31		cpx #(DDim-0)*2+1	; far enough below end of data stack (& not negative)?
.c453	b0 da		bcs $c42f		bcs Throw_Stack
.c455	a4 54		ldy $54				ldy FIndex		; check floating point stack
.c457	c0 0b		cpy #$0b			cpy #FDim+1
.c459	b0 de		bcs $c439			bcs Throw_FPStack
=10					CodeLen	.var *-XtPtr1
=$c45b					Here1 = *	; remember here
>c44f	0a					.byte CodeLen	;patch wh_CodeLength
.c45b	60		rts				rts			; all OK
>c45c	54 68 72 6f 77			Name0:	.text "Throw"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=50145					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>c461	e5					.byte (("Throw"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=20					LinkDisplacement = Nt0-WordListLink
>c462	10					.byte WordFlags	;wh_Flags
>c463	03					.byte 3	;wh_CodeLength
>c464	14					  .byte LinkDisplacement	; offset to previous nt
=$c465					XtPtr1 ::= *
=50145					WordListLink ::= Nt0 ; remember the nt of this word for later
.c465	20 c8 c3	jsr $c3c8	Throw:		jsr PopA		; pop n
.c468	20 93 c4	jsr $c493	ThrowA:		jsr Type_Exception_Text_A ; print the associated error string
.c46b	a2 30		ldx #$30			ldx #DDim*2		; reset data stack (in case of underflow)
.c46d					Abort_Core:
.c46d	20 bd c8	jsr $c8bd			jsr SLiteral_runtime
.c470	4c 76 c4	jmp $c476			  jmp +
>c473	3f 00 20					  .text "?",0," "	; signal an error to the simulator
.c476	20 39 de	jsr $de39	+		jsr Type
.c479	20 60 df	jsr $df60			jsr R_From		; show return stack TOS
.c47c	20 98 81	jsr $8198			jsr TypeSymbol
.c47f	20 7b df	jsr $df7b			jsr R_Fetch		; show return stack NOS
.c482	20 98 81	jsr $8198			jsr TypeSymbol
.c485	20 4c bb	jsr $bb4c			jsr CR
.c488					Abort_Core2:
.c488	a9 08		lda #$08			lda #DoStkDim		; init do stack
.c48a	8d 45 07	sta $0745			sta DoStkIndex
.c48d	20 d6 c4	jsr $c4d6			jsr Empty_Stack		; empty the Data Stack & FP stack
.c490	4c e5 c4	jmp $c4e5			jmp Quit		; continue into QUIT.
.c493					Type_Exception_Text_A:
.c493	85 16		sta $16				sta tmp2+0	; save error code
.c495	a9 e7		lda #$e7			lda #<Exception_Text_List
.c497	a0 ea		ldy #$ea			ldy #>Exception_Text_List	; for each table entry
.c499	85 18		sta $18				sta tmp3+0
.c49b	84 19		sty $19				sty tmp3+1
.c49d	a0 00		ldy #$00	_TestEntry:	ldy #0		;   code match?
.c49f	b1 18		lda ($18),y			lda (tmp3),y
.c4a1	f0 1a		beq $c4bd			beq _NotFound
.c4a3	c5 16		cmp $16				cmp tmp2+0
.c4a5	f0 11		beq $c4b8			beq _Found
.c4a7	c8		iny		-		iny		;   step to end of entry
.c4a8	b1 18		lda ($18),y			lda (tmp3),y
.c4aa	d0 fb		bne $c4a7			bne -
.c4ac	98		tya				tya		;   step to next entry
.c4ad	38		sec				sec
.c4ae	65 18		adc $18				adc tmp3+0
.c4b0	85 18		sta $18				sta tmp3+0
.c4b2	90 e9		bcc $c49d			bcc _TestEntry
.c4b4	e6 19		inc $19				inc tmp3+1
.c4b6	d0 e5		bne $c49d			bne _TestEntry
.c4b8					_Found:
.c4b8	a0 01		ldy #$01			ldy #1
.c4ba	4c 5b de	jmp $de5b			jmp Print_ASCIIZ_tmp3_no_lf
.c4bd	a0 ff		ldy #$ff	_NotFound:	ldy #$ff		; print code
.c4bf	a5 16		lda $16				lda tmp2+0
.c4c1	20 ba c7	jsr $c7ba			jsr PushYA
.c4c4	4c 21 dc	jmp $dc21			jmp Dot
=98					CodeLen	.var *-XtPtr1
=$c4c7					Here1 = *	; remember here
>c463	62					.byte CodeLen	;patch wh_CodeLength
>c4c7	45 6d 70 74 79 2d 53 74		Name0:	.text "Empty-Stack"	;  name of word as a string, ending at wh_NameLastChar
>c4cf	61 63 6b
=11					NameLength = *-Name0
=50258					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>c4d2	6b					.byte (("Empty-Stack"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=113					LinkDisplacement = Nt0-WordListLink
>c4d3	10					.byte WordFlags	;wh_Flags
>c4d4	03					.byte 3	;wh_CodeLength
>c4d5	71					  .byte LinkDisplacement	; offset to previous nt
=$c4d6					XtPtr1 ::= *
=50258					WordListLink ::= Nt0 ; remember the nt of this word for later
.c4d6	a2 30		ldx #$30	Empty_Stack:	ldx #DDim*2	; init data stack
.c4d8	a9 0a		lda #$0a			lda #FDim	; init FP stack
.c4da	85 54		sta $54				sta FIndex
=6					CodeLen	.var *-XtPtr1
=$c4dc					Here1 = *	; remember here
>c4d4	06					.byte CodeLen	;patch wh_CodeLength
.c4dc	60		rts				rts
>c4dd	51 75 69 74			Name0:	.text "Quit"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=50273					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>c4e1	84					.byte (("Quit"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=15					LinkDisplacement = Nt0-WordListLink
>c4e2	10					.byte WordFlags	;wh_Flags
>c4e3	03					.byte 3	;wh_CodeLength
>c4e4	0f					  .byte LinkDisplacement	; offset to previous nt
=$c4e5					XtPtr1 ::= *
=50273					WordListLink ::= Nt0 ; remember the nt of this word for later
.c4e5					Quit:
.c4e5	8a		txa				txa		; Save the DStack index
.c4e6	a2 ff		ldx #$ff			ldx #rsp0	; Set the return stack ptr
.c4e8	9a		txs				txs
.c4e9	aa		tax				tax		; Restore the DStack index.
.c4ea	a9 00		lda #$00			lda #0		; SOURCE-ID= zero (keyboard input)
.c4ec	85 02		sta $02				sta insrc+0
.c4ee	85 03		sta $03				sta insrc+1
.c4f0	20 33 c7	jsr $c733			jsr Left_Bracket_NoCheck ; switch to interpret state
.c4f3					_get_line:
.c4f3	a9 00		lda #$00			lda #<buffer0	; input buffer, this is paranoid
.c4f5	85 04		sta $04				sta cib+0
.c4f7	a9 02		lda #$02			lda #>buffer0
.c4f9	85 05		sta $05				sta cib+1
.c4fb	20 97 d2	jsr $d297			jsr Refill		; ( -- f )
.c4fe	b5 24		lda $24,x			lda DStack+0,x
.c500	d0 05		bne $c507			bne +
.c502	a9 6b		lda #$6b			lda #$100+err_Refill	; REFILL returned a FALSE flag, something went wrong
.c504	4c 68 c4	jmp $c468			jmp ThrowA
.c507	e8		inx		+		inx			; drop the flag
.c508	e8		inx				inx
.c509	20 20 c5	jsr $c520			jsr interpret
.c50c	a5 0a		lda $0a				lda state
.c50e	d0 06		bne $c516			bne _print_compiled
.c510	a9 b3		lda #$b3			lda #<str_ok
.c512	a0 ea		ldy #$ea			ldy #>str_ok
.c514	d0 04		bne $c51a			bne _print
.c516	a9 b7		lda #$b7	_print_compiled: lda #<str_compiled	; "compile" string
.c518	a0 ea		ldy #$ea			ldy #>str_compiled
.c51a	20 66 de	jsr $de66	_print:		jsr Print_ASCIIZ_YA
.c51d	4c f3 c4	jmp $c4f3			jmp _get_line
=59					CodeLen	.var *-XtPtr1
=$c520					Here1 = *	; remember here
>c4e3	3b					.byte CodeLen	;patch wh_CodeLength
.c520					Interpret:
.c520					_loop:
.c520	20 51 c4	jsr $c451			jsr QStack		; check stack bounds
.c523	20 87 ca	jsr $ca87			jsr parse_name		; ( "string" -- addr u )
.c526	b5 24		lda $24,x	                lda DStack+0,x		; empty line?
.c528	f0 53		beq $c57d	                beq _line_done
.c52a	20 f6 dc	jsr $dcf6			jsr Two_dup		; ( addr u -- addr u addr u )
.c52d	20 6c cc	jsr $cc6c			jsr Find_Name		; ( addr u addr u -- addr u nt|0 )
.c530	b5 25		lda $25,x			lda DStack+1,x		; word found?
.c532	d0 1b		bne $c54f			bne _got_name_token
.c534	e8		inx		                inx                     ; ( addr u 0 -- addr u )
.c535	e8		inx		                inx
.c536	20 be c0	jsr $c0be	                jsr Number           ; ( addr u -- u|d )
.c539	a5 0a		lda $0a		                lda state		; interpreting?
.c53b	f0 e3		beq $c520	                beq _loop		;   we're done
.c53d	a9 20		lda #$20	                lda #$20		; double cell number?
.c53f	24 0c		bit $0c		                bit status
.c541	f0 06		beq $c549	                beq _single_number
.c543	20 8b c7	jsr $c78b			jsr Two_literal		; compile a double number
.c546	4c 20 c5	jmp $c520			jmp _loop
.c549	20 57 c7	jsr $c757	_single_number:	jsr Literal		; compile a single number
.c54c	4c 20 c5	jmp $c520			jmp _loop
.c54f					_got_name_token:
.c54f	20 cd d9	jsr $d9cd			jsr Nip
.c552	20 cd d9	jsr $d9cd			jsr Nip			; ( nt )
.c555	85 14		sta $14				sta tmp1+0		; save a work copy of nt
.c557	84 15		sty $15				sty tmp1+1
.c559	a0 81		ldy #$81			ldy #Wh_Flags		; get word flags, we'll need them shortly
.c55b	b1 14		lda ($14),y			lda (tmp1),y		;    using saved nt
.c55d	a4 0a		ldy $0a				ldy state		; interpreting or compiling?
.c55f	d0 12		bne $c573			bne _compile
.c561	29 04		and #$04			and #CO			; is the word COMPILE-ONLY?
.c563	f0 05		beq $c56a			beq _execute
.c565	a9 f2		lda #$f2			lda #$100+err_CompileOnly ;   complain & quit
.c567	20 68 c4	jsr $c468			jsr ThrowA
.c56a	20 ae cd	jsr $cdae	_execute:	jsr Name_To_Int		; ( nt -- xt )
.c56d	20 77 de	jsr $de77			jsr Execute		; EXECUTE the xt that is TOS
.c570	4c 20 c5	jmp $c520	                jmp _loop
.c573					_compile:
.c573	29 08		and #$08			and #IM			; is the word IMMEDIATE?
.c575	d0 f3		bne $c56a			bne _execute		;   IMMEDIATE word, execute now
.c577	20 a2 c6	jsr $c6a2			jsr Compile_Comma_NT	; Compile the nt into the Dictionary
.c57a	4c 20 c5	jmp $c520			jmp _loop
.c57d					_line_done:
.c57d	e8		inx				inx			; drop stuff from PARSE_NAME
.c57e	e8		inx				inx
.c57f	e8		inx				inx
.c580	e8		inx				inx
.c581	60		rts				rts
>c582	49 6d 6d 65 64 69 61 74		Name0:	.text "Immediate"	;  name of word as a string, ending at wh_NameLastChar
>c58a	65
=9					NameLength = *-Name0
=50443					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>c58b	a9					.byte (("Immediate"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=170					LinkDisplacement = Nt0-WordListLink
>c58c	10					.byte WordFlags	;wh_Flags
>c58d	03					.byte 3	;wh_CodeLength
>c58e	aa					  .byte LinkDisplacement	; offset to previous nt
=$c58f					XtPtr1 ::= *
=50443					WordListLink ::= Nt0 ; remember the nt of this word for later
.c58f	a9 08		lda #$08	Immediate:	lda #IM
.c591	48		pha		SetFlag:	pha
.c592	20 59 ca	jsr $ca59			jsr current_to_dp
.c595	a0 81		ldy #$81			ldy #Wh_Flags
.c597	68		pla				pla
.c598	11 10		ora ($10),y			ora (dp),y
.c59a	91 10		sta ($10),y			sta (dp),y
=13					CodeLen	.var *-XtPtr1
=$c59c					Here1 = *	; remember here
>c58d	0d					.byte CodeLen	;patch wh_CodeLength
.c59c	60		rts				rts
>c59d	43 6f 6d 70 69 6c 65 2d		Name0:	.text "Compile-only"	;  name of word as a string, ending at wh_NameLastChar
>c5a5	6f 6e 6c 79
=12					NameLength = *-Name0
=50473					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>c5a9	2c					.byte (("Compile-only"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=30					LinkDisplacement = Nt0-WordListLink
>c5aa	10					.byte WordFlags	;wh_Flags
>c5ab	03					.byte 3	;wh_CodeLength
>c5ac	1e					  .byte LinkDisplacement	; offset to previous nt
=$c5ad					XtPtr1 ::= *
=50473					WordListLink ::= Nt0 ; remember the nt of this word for later
.c5ad	a9 04		lda #$04	Compile_Only:	lda #CO
.c5af	d0 e0		bne $c591			bne SetFlag
=4					CodeLen	.var *-XtPtr1
=$c5b1					Here1 = *	; remember here
>c5ab	04					.byte CodeLen	;patch wh_CodeLength
>c5b1	6e 65 76 65 72 2d 6e 61		Name0:	.text "never-native"	;  name of word as a string, ending at wh_NameLastChar
>c5b9	74 69 76 65
=12					NameLength = *-Name0
=50493					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>c5bd	ac					.byte (("never-native"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=20					LinkDisplacement = Nt0-WordListLink
>c5be	10					.byte WordFlags	;wh_Flags
>c5bf	03					.byte 3	;wh_CodeLength
>c5c0	14					  .byte LinkDisplacement	; offset to previous nt
=$c5c1					XtPtr1 ::= *
=50493					WordListLink ::= Nt0 ; remember the nt of this word for later
.c5c1	20 59 ca	jsr $ca59	Never_Native:	jsr current_to_dp
.c5c4	a0 81		ldy #$81			ldy #Wh_Flags
.c5c6	b1 10		lda ($10),y			lda (dp),y
.c5c8	09 10		ora #$10			ora #NN		; set NN flag
.c5ca	29 df		and #$df			and #$ff-AN	; clear AN flag
.c5cc	91 10		sta ($10),y			sta (dp),y
=13					CodeLen	.var *-XtPtr1
=$c5ce					Here1 = *	; remember here
>c5bf	0d					.byte CodeLen	;patch wh_CodeLength
.c5ce	60		rts				rts
>c5cf	61 6c 77 61 79 73 2d 6e		Name0:	.text "always-native"	;  name of word as a string, ending at wh_NameLastChar
>c5d7	61 74 69 76 65
=13					NameLength = *-Name0
=50524					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>c5dc	ad					.byte (("always-native"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=31					LinkDisplacement = Nt0-WordListLink
>c5dd	10					.byte WordFlags	;wh_Flags
>c5de	03					.byte 3	;wh_CodeLength
>c5df	1f					  .byte LinkDisplacement	; offset to previous nt
=$c5e0					XtPtr1 ::= *
=50524					WordListLink ::= Nt0 ; remember the nt of this word for later
.c5e0	20 59 ca	jsr $ca59	Always_Native:	jsr current_to_dp
.c5e3	a0 81		ldy #$81			ldy #Wh_Flags
.c5e5	b1 10		lda ($10),y			lda (dp),y
.c5e7	09 20		ora #$20			ora #AN		; Make sure AN flag is set
.c5e9	29 ef		and #$ef			and #$ff-NN	; and NN flag is clear.
.c5eb	91 10		sta ($10),y			sta (dp),y
=13					CodeLen	.var *-XtPtr1
=$c5ed					Here1 = *	; remember here
>c5de	0d					.byte CodeLen	;patch wh_CodeLength
.c5ed	60		rts				rts
>c5ee	61 6c 6c 6f 77 2d 6e 61		Name0:	.text "allow-native"	;  name of word as a string, ending at wh_NameLastChar
>c5f6	74 69 76 65
=12					NameLength = *-Name0
=50554					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>c5fa	ac					.byte (("allow-native"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=30					LinkDisplacement = Nt0-WordListLink
>c5fb	10					.byte WordFlags	;wh_Flags
>c5fc	03					.byte 3	;wh_CodeLength
>c5fd	1e					  .byte LinkDisplacement	; offset to previous nt
=$c5fe					XtPtr1 ::= *
=50554					WordListLink ::= Nt0 ; remember the nt of this word for later
.c5fe	20 59 ca	jsr $ca59	Allow_Native:	jsr current_to_dp
.c601	a0 81		ldy #$81			ldy #Wh_Flags	; offset for status byte
.c603	b1 10		lda ($10),y			lda (dp),y
.c605	29 cf		and #$cf			and #$ff-NN-AN	; AN and NN flag is clear.
.c607	91 10		sta ($10),y			sta (dp),y
=11					CodeLen	.var *-XtPtr1
=$c609					Here1 = *	; remember here
>c5fc	0b					.byte CodeLen	;patch wh_CodeLength
.c609	60		rts				rts
>c60a	6e 63 2d 6c 69 6d 69 74		Name0:	.text "nc-limit"	;  name of word as a string, ending at wh_NameLastChar
=8					NameLength = *-Name0
=50578					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>c612	88					.byte (("nc-limit"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=24					LinkDisplacement = Nt0-WordListLink
>c613	10					.byte WordFlags	;wh_Flags
>c614	03					.byte 3	;wh_CodeLength
>c615	18					  .byte LinkDisplacement	; offset to previous nt
=$c616					XtPtr1 ::= *
=50578					WordListLink ::= Nt0 ; remember the nt of this word for later
.c616	a0 03		ldy #$03			ldy #>nc_limit
.c618	a9 02		lda #$02			lda #<nc_limit
.c61a	4c ba c7	jmp $c7ba			jmp PushYA
=7					CodeLen	.var *-XtPtr1
=$c61d					Here1 = *	; remember here
>c614	07					.byte CodeLen	;patch wh_CodeLength
>c61d	73 74 72 69 70 2d 75 6e		Name0:	.text "strip-underflow"	;  name of word as a string, ending at wh_NameLastChar
>c625	64 65 72 66 6c 6f 77
=15					NameLength = *-Name0
=50604					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>c62c	ef					.byte (("strip-underflow"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=26					LinkDisplacement = Nt0-WordListLink
>c62d	10					.byte WordFlags	;wh_Flags
>c62e	03					.byte 3	;wh_CodeLength
>c62f	1a					  .byte LinkDisplacement	; offset to previous nt
=$c630					XtPtr1 ::= *
=50604					WordListLink ::= Nt0 ; remember the nt of this word for later
.c630	a0 03		ldy #$03			ldy #>uf_strip
.c632	a9 04		lda #$04			lda #<uf_strip
.c634	4c ba c7	jmp $c7ba			jmp PushYA
=7					CodeLen	.var *-XtPtr1
=$c637					Here1 = *	; remember here
>c62e	07					.byte CodeLen	;patch wh_CodeLength
>c637	70 6f 73 74 70 6f 6e 65		Name0:	.text "postpone"	;  name of word as a string, ending at wh_NameLastChar
=8					NameLength = *-Name0
=50623					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>c63f	a8					.byte (("postpone"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=28					WordFlags ::= IM+CO+NN	; modifiable copy, remember for later
=19					LinkDisplacement = Nt0-WordListLink
>c640	1c					.byte WordFlags	;wh_Flags
>c641	03					.byte 3	;wh_CodeLength
>c642	13					  .byte LinkDisplacement	; offset to previous nt
=$c643					XtPtr1 ::= *
=50623					WordListLink ::= Nt0 ; remember the nt of this word for later
.c643					Postpone:
.c643	20 b8 ca	jsr $cab8			jsr parse_name_check	; get name string
.c646	20 9a cc	jsr $cc9a			jsr find_name_check	; lookup name
.c649	a0 81		ldy #$81			ldy #Wh_Flags		; IMMEDIATE word?
.c64b	b1 14		lda ($14),y			lda (tmp1),y		;    using saved nt
.c64d	29 08		and #$08			and #IM
.c64f	f0 03		beq $c654			beq _not_immediate
.c651	4c a2 c6	jmp $c6a2			jmp Compile_Comma_NT	; compile it as if it was not IMMEDIATE
.c654					_not_immediate:
.c654	20 a1 c7	jsr $c7a1			jsr LDYA_Immed_Comma		; compile LDA #; LDY # with nt of the word
.c657	a0 c6		ldy #$c6			ldy #>Compile_Comma_NT_YA	; compile COMPILE,
.c659	a9 a5		lda #$a5			lda #<Compile_Comma_NT_YA
.c65b	4c 78 dd	jmp $dd78			jmp Jsr_Comma_YA
=27					CodeLen	.var *-XtPtr1
=$c65e					Here1 = *	; remember here
>c641	1b					.byte CodeLen	;patch wh_CodeLength
>c65e	52 65 63 75 72 73 65		Name0:	.text "Recurse"	;  name of word as a string, ending at wh_NameLastChar
=7					NameLength = *-Name0
=50661					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>c665	a7					.byte (("Recurse"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=28					WordFlags ::= CO+IM+NN	; modifiable copy, remember for later
=38					LinkDisplacement = Nt0-WordListLink
>c666	1c					.byte WordFlags	;wh_Flags
>c667	03					.byte 3	;wh_CodeLength
>c668	26					  .byte LinkDisplacement	; offset to previous nt
=$c669					XtPtr1 ::= *
=50661					WordListLink ::= Nt0 ; remember the nt of this word for later
.c669					Recurse:
.c669	a5 0e		lda $0e				lda WorkWord+0
.c66b	a4 0f		ldy $0f				ldy WorkWord+1
.c66d	20 ba c7	jsr $c7ba			jsr PushYA
.c670	24 0c		bit $0c				bit status		; does WorkWord contain xt or nt?
.c672	50 10		bvc $c684			bvc _xt
.c674	a0 81		ldy #$81			ldy #wh_Flags		; is it Always-Native ?
.c676	b1 0e		lda ($0e),y			lda (WorkWord),y
.c678	29 20		and #$20			and #AN
.c67a	f0 05		beq $c681			beq _NotAn
.c67c	a9 e5		lda #$e5			lda #$100+err_InvalidRecursion
.c67e	20 68 c4	jsr $c468			jsr ThrowA
.c681					_NotAN:
.c681	20 ae cd	jsr $cdae			jsr Name_To_Int		; convert nt to xt
.c684					_xt:
.c684	4c 75 dd	jmp $dd75			jmp Jsr_Comma		; compile JSR xt, return
=30					CodeLen	.var *-XtPtr1
=$c687					Here1 = *	; remember here
>c667	1e					.byte CodeLen	;patch wh_CodeLength
>c687	43 6f 6d 70 69 6c 65 2c		Name0:	.text "Compile,"	;  name of word as a string, ending at wh_NameLastChar
=8					NameLength = *-Name0
=50703					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>c68f	88					.byte (("Compile,"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=42					LinkDisplacement = Nt0-WordListLink
>c690	10					.byte WordFlags	;wh_Flags
>c691	03					.byte 3	;wh_CodeLength
>c692	2a					  .byte LinkDisplacement	; offset to previous nt
=$c693					XtPtr1 ::= *
=50703					WordListLink ::= Nt0 ; remember the nt of this word for later
.c693					Compile_Comma:
.c693	20 d2 df	jsr $dfd2			jsr Dup			; ( xt xt )
.c696	20 5d cd	jsr $cd5d			jsr Int_To_Name		; ( xt nt )	does a dictionary search, tmp1=nt
.c699	e8		inx				inx			; drop nt
.c69a	e8		inx				inx
.c69b	a5 15		lda $15				lda tmp1+1
.c69d	d0 0a		bne $c6a9			bne Compile_Comma_NT_Tmp1
.c69f	4c 75 dd	jmp $dd75			jmp Jsr_Comma		; compile jsr, return
.c6a2					Compile_Comma_NT:
.c6a2	20 e3 c3	jsr $c3e3			jsr PopYA
.c6a5					Compile_Comma_NT_YA:
.c6a5	85 14		sta $14				sta tmp1+0		; tmp1= nt
.c6a7	84 15		sty $15				sty tmp1+1
.c6a9					Compile_Comma_NT_Tmp1:
.c6a9	20 bb cd	jsr $cdbb			jsr NameToIntTmp	; tmp2= xt
.c6ac	a5 16		lda $16				lda tmp2+0
.c6ae	a4 17		ldy $17				ldy tmp2+1
.c6b0	20 ba c7	jsr $c7ba			jsr PushYA		; ( xt )
.c6b3	a0 82		ldy #$82			ldy #wh_CodeLength
.c6b5	b1 14		lda ($14),y			lda (tmp1),y
.c6b7	20 e9 c7	jsr $c7e9			jsr PushZA		; ( xt u )
.c6ba	a0 81		ldy #$81			ldy #Wh_Flags		; save word flags
.c6bc	b1 14		lda ($14),y			lda (tmp1),y
.c6be	29 30		and #$30			and #ST
.c6c0	c9 30		cmp #$30			cmp #ST			; inline & strip RTS addr save/restore?
.c6c2	f0 2d		beq $c6f1			beq _strip
.c6c4	c9 10		cmp #$10			cmp #NN			; Never Native word?
.c6c6	f0 12		beq $c6da			beq _jsr_opt
.c6c8	c9 20		cmp #$20			cmp #AN			; Always Native word?
.c6ca	f0 2f		beq $c6fb			beq _inline
.c6cc	ad 03 03	lda $0303			lda nc_limit+1		; wordsize<=nc_limit?
.c6cf	d0 2a		bne $c6fb			bne _inline
.c6d1	ad 02 03	lda $0302			lda nc_limit+0
.c6d4	d5 24		cmp $24,x			cmp DStack+0,x
.c6d6	f0 02		beq $c6da			beq _jsr_opt
.c6d8	b0 21		bcs $c6fb			bcs _inline
.c6da					_jsr_opt:
.c6da	ad 04 03	lda $0304			lda uf_strip
.c6dd	f0 0d		beq $c6ec			beq _jsr
.c6df	a0 81		ldy #$81			ldy #wh_Flags		; underflow strip & not stack strip?
.c6e1	b1 14		lda ($14),y			lda (tmp1),y
.c6e3	29 40		and #$40			and #UF
.c6e5	f0 05		beq $c6ec			beq _jsr
.c6e7	a9 03		lda #$03			lda #3			;   strip the underflow check
.c6e9	20 55 da	jsr $da55			jsr Nos_Plus_A
.c6ec					_jsr:
.c6ec	e8		inx				inx			; Drop len
.c6ed	e8		inx				inx
.c6ee	4c 75 dd	jmp $dd75			jmp Jsr_Comma		; compile jsr, return
.c6f1					_strip:
.c6f1	a9 06		lda #$06			lda #6			;   Adjust xt: skip over the leading RTS addr save
.c6f3	20 55 da	jsr $da55			jsr Nos_Plus_A
.c6f6	a9 f4		lda #$f4			lda #$100-12		;   Adjust u: omit the leading RTS addr save & trailing RTS addr restore
.c6f8	20 8a da	jsr $da8a			jsr minus_a
.c6fb					_inline:
.c6fb	ad 04 03	lda $0304			lda uf_strip+0		; user wants underflow stripping?
.c6fe	f0 12		beq $c712			beq +
.c700	a0 81		ldy #$81			ldy #wh_Flags		; this word contains underflow checking?
.c702	b1 14		lda ($14),y			lda (tmp1),y
.c704	29 40		and #$40			and #UF
.c706	f0 0a		beq $c712			beq +
.c708	a9 03		lda #$03			lda #3			;   Adjust xt: Start after underflow check
.c70a	20 55 da	jsr $da55			jsr Nos_Plus_A
.c70d	a9 fd		lda #$fd			lda #$100-3		;   Adjust u: omit underflow check
.c70f	20 8a da	jsr $da8a			jsr minus_a
.c712					+
.c712	b5 24		lda $24,x			lda DStack+0,x		; compile code bytes
.c714	f0 0c		beq $c722			beq _copy_end
.c716	a1 26		lda ($26,x)	_copy_loop:	lda (DStack+2,x)
.c718	20 3e dd	jsr $dd3e			jsr C_Comma_A
.c71b	20 a5 da	jsr $daa5			jsr NOS_One_Plus
.c71e	d6 24		dec $24,x			dec DStack+0,x
.c720	d0 f4		bne $c716			bne _copy_loop
.c722					_copy_end:
.c722	4c 72 d5	jmp $d572			jmp Two_drop
=146					CodeLen	.var *-XtPtr1
=$c725					Here1 = *	; remember here
>c691	92					.byte CodeLen	;patch wh_CodeLength
>c725	5b				Name0:	.text "["	;  name of word as a string, ending at wh_NameLastChar
=1					NameLength = *-Name0
=50854					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>c726	61					.byte (("["[-1]&7)<<5)+NameLength	;wh_HashNameLen
=28					WordFlags ::= IM+CO+NN	; modifiable copy, remember for later
=151					LinkDisplacement = Nt0-WordListLink
>c727	1c					.byte WordFlags	;wh_Flags
>c728	03					.byte 3	;wh_CodeLength
>c729	97					  .byte LinkDisplacement	; offset to previous nt
=$c72a					XtPtr1 ::= *
=50854					WordListLink ::= Nt0 ; remember the nt of this word for later
.c72a	a5 0a		lda $0a		Left_Bracket:	lda state+0		; Already in the interpret state?
.c72c	d0 05		bne $c733			bne Left_Bracket_NoCheck
.c72e	a9 69		lda #$69			lda #$100+err_AlreadyInterpreting
.c730	4c 68 c4	jmp $c468			jmp ThrowA
.c733					Left_Bracket_NoCheck:
.c733	a9 00		lda #$00			lda #0
.c735	85 0a		sta $0a		Left_Bracket_3:	sta state+0
.c737	85 0b		sta $0b				sta state+1
=15					CodeLen	.var *-XtPtr1
=$c739					Here1 = *	; remember here
>c728	0f					.byte CodeLen	;patch wh_CodeLength
.c739	60		rts				rts
>c73a	5d				Name0:	.text "]"	;  name of word as a string, ending at wh_NameLastChar
=1					NameLength = *-Name0
=50875					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>c73b	a1					.byte (("]"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=24					WordFlags ::= IM+NN	; modifiable copy, remember for later
=21					LinkDisplacement = Nt0-WordListLink
>c73c	18					.byte WordFlags	;wh_Flags
>c73d	03					.byte 3	;wh_CodeLength
>c73e	15					  .byte LinkDisplacement	; offset to previous nt
=$c73f					XtPtr1 ::= *
=50875					WordListLink ::= Nt0 ; remember the nt of this word for later
.c73f					Right_Bracket:
.c73f	a5 0a		lda $0a				lda state+0		; Already in the compile state?
.c741	f0 05		beq $c748			beq +
.c743	a9 68		lda #$68			lda #$100+err_AlreadyCompiling ;   complain and quit
.c745	4c 68 c4	jmp $c468			jmp ThrowA
.c748					+
.c748	a9 ff		lda #$ff			lda #$FF
.c74a	d0 e9		bne $c735			bne Left_Bracket_3
=13					CodeLen	.var *-XtPtr1
=$c74c					Here1 = *	; remember here
>c73d	0d					.byte CodeLen	;patch wh_CodeLength
>c74c	4c 69 74 65 72 61 6c		Name0:	.text "Literal"	;  name of word as a string, ending at wh_NameLastChar
=7					NameLength = *-Name0
=50899					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>c753	87					.byte (("Literal"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=28					WordFlags ::= IM+CO+NN	; modifiable copy, remember for later
=24					LinkDisplacement = Nt0-WordListLink
>c754	1c					.byte WordFlags	;wh_Flags
>c755	03					.byte 3	;wh_CodeLength
>c756	18					  .byte LinkDisplacement	; offset to previous nt
=$c757					XtPtr1 ::= *
=50899					WordListLink ::= Nt0 ; remember the nt of this word for later
.c757					Literal:
.c757	20 0c c4	jsr $c40c			jsr underflow_1
.c75a	20 60 c7	jsr $c760			jsr LitCompile		; compile load regs, choose a runtime routine
.c75d	4c a5 c6	jmp $c6a5			jmp Compile_Comma_NT_YA ; compile JSR runtime
=9					CodeLen	.var *-XtPtr1
=$c760					Here1 = *	; remember here
>c755	09					.byte CodeLen	;patch wh_CodeLength
.c760					LitCompile:
.c760	b5 25		lda $25,x			lda DStack+1,x		; hi byte zero?
.c762	f0 08		beq $c76c			beq _ZByte
.c764	20 a1 c7	jsr $c7a1			jsr ldya_immed_comma	; compile "ldy #; lda #" using TOS
.c767	a9 36		lda #$36			lda #<(PushYA-wh_LinkNt-1) ; prepare for Compile_Comma_NT_YA or Jmp_Comma_NT_YA
.c769	a0 c7		ldy #$c7			ldy #>(PushYA-wh_LinkNt-1)
.c76b	60		rts				rts
.c76c					_ZByte:
.c76c	b4 24		ldy $24,x			ldy DStack+0,x		; is it 0 ?
.c76e	f0 08		beq $c778			beq _zero
.c770	20 a8 c7	jsr $c7a8			jsr lda_immed_comma	; compile "lda #" using TOS
.c773	a9 65		lda #$65			lda #<(PushZA-wh_LinkNt-1) ; prepare for Jsr_Comma_YA or Jmp_Comma_YA
.c775	a0 c7		ldy #$c7			ldy #>(PushZA-wh_LinkNt-1)
.c777	60		rts				rts
.c778	e8		inx		_zero:		inx			; drop
.c779	e8		inx				inx
.c77a	a9 73		lda #$73			lda #<(Zero-wh_LinkNt-1)	; prepare for Jsr_Comma_YA or Jmp_Comma_YA
.c77c	a0 c7		ldy #$c7			ldy #>(Zero-wh_LinkNt-1)
.c77e	60		rts				rts
>c77f	32 4c 69 74 65 72 61 6c		Name0:	.text "2Literal"	;  name of word as a string, ending at wh_NameLastChar
=8					NameLength = *-Name0
=50951					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>c787	88					.byte (("2Literal"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=24					WordFlags ::= IM+NN	; modifiable copy, remember for later
=52					LinkDisplacement = Nt0-WordListLink
>c788	18					.byte WordFlags	;wh_Flags
>c789	03					.byte 3	;wh_CodeLength
>c78a	34					  .byte LinkDisplacement	; offset to previous nt
=$c78b					XtPtr1 ::= *
=50951					WordListLink ::= Nt0 ; remember the nt of this word for later
.c78b					Two_literal:
.c78b	20 20 c4	jsr $c420			jsr underflow_2 ; check double number
.c78e	20 f3 df	jsr $dff3			jsr Swap
.c791	20 57 c7	jsr $c757			jsr Literal	; do lo cell
.c794	4c 57 c7	jmp $c757			jmp Literal	; do hi cell
=12					CodeLen	.var *-XtPtr1
=$c797					Here1 = *	; remember here
>c789	0c					.byte CodeLen	;patch wh_CodeLength
>c797	4c 44 59 41 2e 23		Name0:	.text "LDYA.#"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=50973					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>c79d	66					.byte (("LDYA.#"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=22					LinkDisplacement = Nt0-WordListLink
>c79e	10					.byte WordFlags	;wh_Flags
>c79f	03					.byte 3	;wh_CodeLength
>c7a0	16					  .byte LinkDisplacement	; offset to previous nt
=$c7a1					XtPtr1 ::= *
=50973					WordListLink ::= Nt0 ; remember the nt of this word for later
.c7a1					ldya_immed_comma:
.c7a1	a9 a0		lda #$a0			lda #$a0		; ldy #
.c7a3	b4 25		ldy $25,x			ldy DStack+1,x
.c7a5	20 55 dd	jsr $dd55			jsr Comma_YA
.c7a8					lda_immed_comma:
.c7a8	a9 a9		lda #$a9			lda #$a9		; lda #
.c7aa	20 3e dd	jsr $dd3e			jsr C_Comma_A
.c7ad	4c 3b dd	jmp $dd3b			jmp C_Comma
=15					CodeLen	.var *-XtPtr1
=$c7b0					Here1 = *	; remember here
>c79f	0f					.byte CodeLen	;patch wh_CodeLength
>c7b0	50 75 73 68 59 41		Name0:	.text "PushYA"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=50998					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>c7b6	26					.byte (("PushYA"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=0					WordFlags ::= 0	; modifiable copy, remember for later
=25					LinkDisplacement = Nt0-WordListLink
>c7b7	00					.byte WordFlags	;wh_Flags
>c7b8	03					.byte 3	;wh_CodeLength
>c7b9	19					  .byte LinkDisplacement	; offset to previous nt
=$c7ba					XtPtr1 ::= *
=50998					WordListLink ::= Nt0 ; remember the nt of this word for later
.c7ba	ca		dex		PushYA:		dex
.c7bb	ca		dex				dex
.c7bc	95 24		sta $24,x			sta DStack+0,x
.c7be	94 25		sty $25,x			sty DStack+1,x
=6					CodeLen	.var *-XtPtr1
=$c7c0					Here1 = *	; remember here
>c7b8	06					.byte CodeLen	;patch wh_CodeLength
.c7c0	60		rts				rts
>c7c1	54 72 75 65			Name0:	.text "True"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=51013					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>c7c5	a4					.byte (("True"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=0					WordFlags ::= 0	; modifiable copy, remember for later
=15					LinkDisplacement = Nt0-WordListLink
>c7c6	00					.byte WordFlags	;wh_Flags
>c7c7	03					.byte 3	;wh_CodeLength
>c7c8	0f					  .byte LinkDisplacement	; offset to previous nt
=$c7c9					XtPtr1 ::= *
=51013					WordListLink ::= Nt0 ; remember the nt of this word for later
.c7c9	a9 ff		lda #$ff	True:		lda #$FF
.c7cb	ca		dex		PushAA:		dex
.c7cc	ca		dex				dex
.c7cd	95 24		sta $24,x			sta DStack+0,x
.c7cf	95 25		sta $25,x			sta DStack+1,x
=8					CodeLen	.var *-XtPtr1
=$c7d1					Here1 = *	; remember here
>c7c7	08					.byte CodeLen	;patch wh_CodeLength
.c7d1	60		rts				rts
>c7d2	46 61 6c 73 65			Name0:	.text "False"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=51031					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>c7d7	a5					.byte (("False"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=18					LinkDisplacement = Nt0-WordListLink
>c7d8	10					.byte WordFlags	;wh_Flags
>c7d9	03					.byte 3	;wh_CodeLength
>c7da	12					  .byte LinkDisplacement	; offset to previous nt
=$c7db					XtPtr1 ::= *
=51031					WordListLink ::= Nt0 ; remember the nt of this word for later
.c7db	a9 00		lda #$00	False:		lda #0
.c7dd	f0 ec		beq $c7cb			beq PushAA
=4					CodeLen	.var *-XtPtr1
=$c7df					Here1 = *	; remember here
>c7d9	04					.byte CodeLen	;patch wh_CodeLength
>c7df	50 75 73 68 5a 41		Name0:	.text "PushZA"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=51045					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>c7e5	26					.byte (("PushZA"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=0					WordFlags ::= 0	; modifiable copy, remember for later
=14					LinkDisplacement = Nt0-WordListLink
>c7e6	00					.byte WordFlags	;wh_Flags
>c7e7	03					.byte 3	;wh_CodeLength
>c7e8	0e					  .byte LinkDisplacement	; offset to previous nt
=$c7e9					XtPtr1 ::= *
=51045					WordListLink ::= Nt0 ; remember the nt of this word for later
.c7e9	ca		dex		PushZA:		dex
.c7ea	ca		dex				dex
.c7eb	95 24		sta $24,x			sta DStack+0,x
.c7ed	a9 00		lda #$00			lda #0
.c7ef	95 25		sta $25,x			sta DStack+1,x
=8					CodeLen	.var *-XtPtr1
=$c7f1					Here1 = *	; remember here
>c7e7	08					.byte CodeLen	;patch wh_CodeLength
.c7f1	60		rts				rts
>c7f2	30				Name0:	.text "0"	;  name of word as a string, ending at wh_NameLastChar
=1					NameLength = *-Name0
=51059					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>c7f3	01					.byte (("0"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=14					LinkDisplacement = Nt0-WordListLink
>c7f4	10					.byte WordFlags	;wh_Flags
>c7f5	03					.byte 3	;wh_CodeLength
>c7f6	0e					  .byte LinkDisplacement	; offset to previous nt
=$c7f7					XtPtr1 ::= *
=51059					WordListLink ::= Nt0 ; remember the nt of this word for later
.c7f7	a9 00		lda #$00	Zero:		lda #0
.c7f9	f0 d0		beq $c7cb			beq PushAA
=4					CodeLen	.var *-XtPtr1
=$c7fb					Here1 = *	; remember here
>c7f5	04					.byte CodeLen	;patch wh_CodeLength
>c7fb	31				Name0:	.text "1"	;  name of word as a string, ending at wh_NameLastChar
=1					NameLength = *-Name0
=51068					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>c7fc	21					.byte (("1"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=9					LinkDisplacement = Nt0-WordListLink
>c7fd	10					.byte WordFlags	;wh_Flags
>c7fe	03					.byte 3	;wh_CodeLength
>c7ff	09					  .byte LinkDisplacement	; offset to previous nt
=$c800					XtPtr1 ::= *
=51068					WordListLink ::= Nt0 ; remember the nt of this word for later
.c800	a9 01		lda #$01	One:		lda #1
.c802	d0 e5		bne $c7e9			bne PushZA
=4					CodeLen	.var *-XtPtr1
=$c804					Here1 = *	; remember here
>c7fe	04					.byte CodeLen	;patch wh_CodeLength
>c804	32				Name0:	.text "2"	;  name of word as a string, ending at wh_NameLastChar
=1					NameLength = *-Name0
=51077					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>c805	41					.byte (("2"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=9					LinkDisplacement = Nt0-WordListLink
>c806	10					.byte WordFlags	;wh_Flags
>c807	03					.byte 3	;wh_CodeLength
>c808	09					  .byte LinkDisplacement	; offset to previous nt
=$c809					XtPtr1 ::= *
=51077					WordListLink ::= Nt0 ; remember the nt of this word for later
.c809	a9 02		lda #$02	Two:		lda #2
.c80b	d0 dc		bne $c7e9			bne PushZA
=4					CodeLen	.var *-XtPtr1
=$c80d					Here1 = *	; remember here
>c807	04					.byte CodeLen	;patch wh_CodeLength
>c80d	42 6c				Name0:	.text "Bl"	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=51087					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>c80f	82					.byte (("Bl"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=10					LinkDisplacement = Nt0-WordListLink
>c810	10					.byte WordFlags	;wh_Flags
>c811	03					.byte 3	;wh_CodeLength
>c812	0a					  .byte LinkDisplacement	; offset to previous nt
=$c813					XtPtr1 ::= *
=51087					WordListLink ::= Nt0 ; remember the nt of this word for later
.c813	a9 20		lda #$20	Bl:		lda #AscSP
.c815	d0 d2		bne $c7e9			bne PushZA
=4					CodeLen	.var *-XtPtr1
=$c817					Here1 = *	; remember here
>c811	04					.byte CodeLen	;patch wh_CodeLength
>c817	3e 49 6e			Name0:	.text ">In"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=51098					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>c81a	c3					.byte ((">In"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=11					LinkDisplacement = Nt0-WordListLink
>c81b	10					.byte WordFlags	;wh_Flags
>c81c	03					.byte 3	;wh_CodeLength
>c81d	0b					  .byte LinkDisplacement	; offset to previous nt
=$c81e					XtPtr1 ::= *
=51098					WordListLink ::= Nt0 ; remember the nt of this word for later
.c81e	a9 08		lda #$08			lda #ToIn
.c820	4c e9 c7	jmp $c7e9			jmp PushZA	; jmp to be a recognizable constant
=5					CodeLen	.var *-XtPtr1
=$c823					Here1 = *	; remember here
>c81c	05					.byte CodeLen	;patch wh_CodeLength
>c823	53 74 61 74 65			Name0:	.text "State"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=51112					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>c828	a5					.byte (("State"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=14					LinkDisplacement = Nt0-WordListLink
>c829	10					.byte WordFlags	;wh_Flags
>c82a	03					.byte 3	;wh_CodeLength
>c82b	0e					  .byte LinkDisplacement	; offset to previous nt
=$c82c					XtPtr1 ::= *
=51112					WordListLink ::= Nt0 ; remember the nt of this word for later
.c82c	a9 0a		lda #$0a			lda #State
.c82e	4c e9 c7	jmp $c7e9			jmp PushZA	; jmp to be a recognizable constant
=5					CodeLen	.var *-XtPtr1
=$c831					Here1 = *	; remember here
>c82a	05					.byte CodeLen	;patch wh_CodeLength
>c831	64 70				Name0:	.text "dp"	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=51123					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>c833	02					.byte (("dp"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=11					LinkDisplacement = Nt0-WordListLink
>c834	10					.byte WordFlags	;wh_Flags
>c835	03					.byte 3	;wh_CodeLength
>c836	0b					  .byte LinkDisplacement	; offset to previous nt
=$c837					XtPtr1 ::= *
=51123					WordListLink ::= Nt0 ; remember the nt of this word for later
.c837	a9 10		lda #$10			lda #dp
.c839	4c e9 c7	jmp $c7e9			jmp PushZA	; jmp to be a recognizable constant
=5					CodeLen	.var *-XtPtr1
=$c83c					Here1 = *	; remember here
>c835	05					.byte CodeLen	;patch wh_CodeLength
>c83c	54 6d 70 31			Name0:	.text "Tmp1"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=51136					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>c840	24					.byte (("Tmp1"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>c841	10					.byte WordFlags	;wh_Flags
>c842	03					.byte 3	;wh_CodeLength
>c843	0d					  .byte LinkDisplacement	; offset to previous nt
=$c844					XtPtr1 ::= *
=51136					WordListLink ::= Nt0 ; remember the nt of this word for later
.c844	a9 14		lda #$14			lda #tmp1
.c846	4c e9 c7	jmp $c7e9			jmp PushZA	; jmp to be a recognizable constant
=5					CodeLen	.var *-XtPtr1
=$c849					Here1 = *	; remember here
>c842	05					.byte CodeLen	;patch wh_CodeLength
>c849	54 6d 70 32			Name0:	.text "Tmp2"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=51149					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>c84d	44					.byte (("Tmp2"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>c84e	10					.byte WordFlags	;wh_Flags
>c84f	03					.byte 3	;wh_CodeLength
>c850	0d					  .byte LinkDisplacement	; offset to previous nt
=$c851					XtPtr1 ::= *
=51149					WordListLink ::= Nt0 ; remember the nt of this word for later
.c851	a9 16		lda #$16			lda #tmp2
.c853	4c e9 c7	jmp $c7e9			jmp PushZA	; jmp to be a recognizable constant
=5					CodeLen	.var *-XtPtr1
=$c856					Here1 = *	; remember here
>c84f	05					.byte CodeLen	;patch wh_CodeLength
>c856	54 6d 70 33			Name0:	.text "Tmp3"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=51162					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>c85a	64					.byte (("Tmp3"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>c85b	10					.byte WordFlags	;wh_Flags
>c85c	03					.byte 3	;wh_CodeLength
>c85d	0d					  .byte LinkDisplacement	; offset to previous nt
=$c85e					XtPtr1 ::= *
=51162					WordListLink ::= Nt0 ; remember the nt of this word for later
.c85e	a9 18		lda #$18			lda #tmp3
.c860	4c e9 c7	jmp $c7e9			jmp PushZA	; jmp to be a recognizable constant
=5					CodeLen	.var *-XtPtr1
=$c863					Here1 = *	; remember here
>c85c	05					.byte CodeLen	;patch wh_CodeLength
>c863	54 6d 70 34			Name0:	.text "Tmp4"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=51175					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>c867	84					.byte (("Tmp4"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>c868	10					.byte WordFlags	;wh_Flags
>c869	03					.byte 3	;wh_CodeLength
>c86a	0d					  .byte LinkDisplacement	; offset to previous nt
=$c86b					XtPtr1 ::= *
=51175					WordListLink ::= Nt0 ; remember the nt of this word for later
.c86b	a9 1a		lda #$1a			lda #tmp4
.c86d	4c e9 c7	jmp $c7e9			jmp PushZA	; jmp to be a recognizable constant
=5					CodeLen	.var *-XtPtr1
=$c870					Here1 = *	; remember here
>c869	05					.byte CodeLen	;patch wh_CodeLength
>c870	53 4c 69 74 65 72 61 6c		Name0:	.text "SLiteral"	;  name of word as a string, ending at wh_NameLastChar
=8					NameLength = *-Name0
=51192					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>c878	88					.byte (("SLiteral"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=92					WordFlags ::= CO+IM+UF+NN	; modifiable copy, remember for later
=17					LinkDisplacement = Nt0-WordListLink
>c879	5c					.byte WordFlags	;wh_Flags
>c87a	03					.byte 3	;wh_CodeLength
>c87b	11					  .byte LinkDisplacement	; offset to previous nt
=$c87c					XtPtr1 ::= *
=51192					WordListLink ::= Nt0 ; remember the nt of this word for later
.c87c					SLiteral:
.c87c	20 20 c4	jsr $c420			jsr underflow_2
.c87f	20 9f c8	jsr $c89f			jsr SLiteral_Start	; compile header
.c882	4c 93 c8	jmp $c893			jmp _Move_Test
.c885	a1 28		lda ($28,x)	_Move_Loop:	lda (DStack+4,x)
.c887	20 3e dd	jsr $dd3e			jsr C_Comma_A
.c88a	f6 28		inc $28,x			inc DStack+4,x
.c88c	d0 02		bne $c890			bne +
.c88e	f6 29		inc $29,x			inc DStack+5,x
.c890					+
.c890	20 81 da	jsr $da81			jsr NOS_One_Minus
.c893	b5 26		lda $26,x	_Move_Test:	lda DStack+2,x
.c895	15 27		ora $27,x			ora DStack+3,x
.c897	d0 ec		bne $c885			bne _Move_Loop
.c899	20 ac c8	jsr $c8ac			jsr SLiteral_End
.c89c	4c 72 d5	jmp $d572			jmp Two_Drop		; clean up and leave
=35					CodeLen	.var *-XtPtr1
=$c89f					Here1 = *	; remember here
>c87a	23					.byte CodeLen	;patch wh_CodeLength
.c89f					SLiteral_Start:
.c89f	a9 bd		lda #$bd			lda #<SLiteral_runtime	; compile JSR SLiteral_Runtime
.c8a1	a0 c8		ldy #$c8			ldy #>SLiteral_runtime
.c8a3	20 78 dd	jsr $dd78			jsr Jsr_Comma_YA
.c8a6	20 67 da	jsr $da67			jsr Here		; push addr of start of JMP
.c8a9	4c 8e dd	jmp $dd8e			jmp Jmp_Comma_YA	; compile JMP around string (dummy addr)
.c8ac					SLiteral_End:
.c8ac	20 9a da	jsr $da9a			jsr One_Plus
.c8af	a5 00		lda $00				lda cp+0		; Update the address of the jump to HERE.
.c8b1	81 24		sta ($24,x)			sta (DStack+0,x)
.c8b3	20 9a da	jsr $da9a			jsr One_Plus
.c8b6	a5 01		lda $01				lda cp+1
.c8b8	81 24		sta ($24,x)			sta (DStack+0,x)
.c8ba	e8		inx				inx			; drop herej
.c8bb	e8		inx				inx
.c8bc	60		rts				rts
.c8bd					SLiteral_Runtime:
.c8bd	86 16		stx $16				stx tmp2	; save data stack index
.c8bf	ba		tsx				tsx
.c8c0	bd 01 01	lda $0101,x	SLiteral_Run2:	lda RStack+1,x	; tmp1= RTS addr
.c8c3	85 14		sta $14				sta tmp1+0
.c8c5	bd 02 01	lda $0102,x			lda RStack+2,x
.c8c8	85 15		sta $15				sta tmp1+1
.c8ca	a6 16		ldx $16				ldx tmp2	; restore data stack index
.c8cc	ca		dex				dex		; push string addr
.c8cd	ca		dex				dex
.c8ce	18		clc				clc
.c8cf	a5 14		lda $14				lda tmp1+0
.c8d1	69 04		adc #$04			adc #3+1	;   just after the following JMP + correcting for JSR behavior
.c8d3	95 24		sta $24,x			sta DStack+0,x
.c8d5	a5 15		lda $15				lda tmp1+1
.c8d7	69 00		adc #$00			adc #0
.c8d9	95 25		sta $25,x			sta DStack+1,x
.c8db	ca		dex				dex		; push string length
.c8dc	ca		dex				dex
.c8dd	38		sec				sec
.c8de	a0 02		ldy #$02			ldy #2		;   = string_end - string_addr
.c8e0	b1 14		lda ($14),y			lda (tmp1),y
.c8e2	f5 26		sbc $26,x			sbc DStack+2,x
.c8e4	95 24		sta $24,x			sta DStack+0,x
.c8e6	c8		iny				iny
.c8e7	b1 14		lda ($14),y			lda (tmp1),y
.c8e9	f5 27		sbc $27,x			sbc DStack+3,x
.c8eb	95 25		sta $25,x			sta DStack+1,x
.c8ed	60		rts				rts
>c8ee	2e 22				Name0:	.text '."'	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=51312					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>c8f0	42					.byte (('."'[-1]&7)<<5)+NameLength	;wh_HashNameLen
=28					WordFlags ::= CO+IM+NN	; modifiable copy, remember for later
=120					LinkDisplacement = Nt0-WordListLink
>c8f1	1c					.byte WordFlags	;wh_Flags
>c8f2	03					.byte 3	;wh_CodeLength
>c8f3	78					  .byte LinkDisplacement	; offset to previous nt
=$c8f4					XtPtr1 ::= *
=51312					WordListLink ::= Nt0 ; remember the nt of this word for later
.c8f4					Dot_quote:
.c8f4	20 0f c9	jsr $c90f			jsr S_Quote		; compile the string literal
.c8f7	a0 de		ldy #$de			ldy #>Type		; compile: print string
.c8f9	a9 39		lda #$39			lda #<Type
.c8fb	4c 78 dd	jmp $dd78			jmp Jsr_Comma_YA
=10					CodeLen	.var *-XtPtr1
=$c8fe					Here1 = *	; remember here
>c8f2	0a					.byte CodeLen	;patch wh_CodeLength
>c8fe	53 5c 22			Name0:	.text 'S\"'	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=51329					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>c901	43					.byte (('S\"'[-1]&7)<<5)+NameLength	;wh_HashNameLen
=24					WordFlags ::= IM+NN	; modifiable copy, remember for later
=17					LinkDisplacement = Nt0-WordListLink
>c902	18					.byte WordFlags	;wh_Flags
>c903	03					.byte 3	;wh_CodeLength
>c904	11					  .byte LinkDisplacement	; offset to previous nt
=$c905					XtPtr1 ::= *
=51329					WordListLink ::= Nt0 ; remember the nt of this word for later
.c905					S_Backslash_Quote:
.c905	a9 ff		lda #$ff			lda #$ff	; Do handle escaped chars.
.c907	d0 08		bne $c911			bne S_Quote_start
=4					CodeLen	.var *-XtPtr1
=$c909					Here1 = *	; remember here
>c903	04					.byte CodeLen	;patch wh_CodeLength
>c909	53 22				Name0:	.text 'S"'	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=51339					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>c90b	42					.byte (('S"'[-1]&7)<<5)+NameLength	;wh_HashNameLen
=24					WordFlags ::= IM+NN	; modifiable copy, remember for later
=10					LinkDisplacement = Nt0-WordListLink
>c90c	18					.byte WordFlags	;wh_Flags
>c90d	03					.byte 3	;wh_CodeLength
>c90e	0a					  .byte LinkDisplacement	; offset to previous nt
=$c90f					XtPtr1 ::= *
=51339					WordListLink ::= Nt0 ; remember the nt of this word for later
.c90f					S_Quote:
.c90f	a9 00		lda #$00			lda #0		; Don't handle escaped chars.
.c911					S_Quote_start:
.c911	48		pha				pha			; save "handle escaped chars" flag
.c912	a5 0a		lda $0a				lda state		; compiling?
.c914	f0 06		beq $c91c			beq _15
.c916	20 9f c8	jsr $c89f			jsr SLiteral_Start	; compile SLiteral header
.c919	4c 1f c9	jmp $c91f			jmp _19
.c91c	20 67 da	jsr $da67	_15:		jsr Here		; remember start addr
.c91f					_19:
.c91f	68		pla				pla			; init t2 flags
.c920	20 e9 c7	jsr $c7e9			jsr PushZA
.c923	20 f7 c7	jsr $c7f7			jsr Zero		; init t3 flags
.c926					_savechars_loop:
.c926	a5 08		lda $08				lda toin+0		; LSB
.c928	c5 06		cmp $06				cmp ciblen+0
.c92a	a5 09		lda $09				lda toin+1		; MSB
.c92c	e5 07		sbc $07				sbc ciblen+1
.c92e	90 10		bcc $c940			bcc _input_fine		; input buffer empty?
.c930	20 97 d2	jsr $d297			jsr Refill		; Refill it  ( -- f )
.c933	b5 24		lda $24,x			lda DStack+0,x		; Check result of refill.
.c935	d0 05		bne $c93c			bne +
.c937	a9 6b		lda #$6b			lda #$100+err_refill	; Something when wrong with refill.
.c939	4c 68 c4	jmp $c468			jmp ThrowA
.c93c	e8		inx		+		inx			; Drop the refill flag
.c93d	e8		inx				inx
.c93e	d0 e6		bne $c926			bne _savechars_loop	; jump back up to the empty check, just in
.c940					_input_fine:
.c940	18		clc				clc			; tmp1= A= the char at Cib+ToIn
.c941	a5 04		lda $04				lda cib+0
.c943	85 14		sta $14				sta tmp1+0
.c945	a5 05		lda $05				lda cib+1
.c947	65 09		adc $09				adc toin+1
.c949	85 15		sta $15				sta tmp1+1
.c94b	a4 08		ldy $08				ldy ToIn
.c94d	b1 14		lda ($14),y			lda (tmp1),y
.c94f	85 14		sta $14				sta tmp1
.c951	e6 08		inc $08				inc toin+0		; Move on to the next character.
.c953	d0 02		bne $c957			bne +
.c955	e6 09		inc $09				inc toin+1
.c957					+
.c957	b4 26		ldy $26,x			ldy DStack+2,x		; handling escaped characters?
.c959	30 03		bmi $c95e			bmi +
.c95b	4c 01 ca	jmp $ca01			jmp _regular_char
.c95e					+
.c95e	b4 27		ldy $27,x			ldy DStack+3,x  		; already seen the backslash?
.c960	30 03		bmi $c965			bmi +
.c962	4c f7 c9	jmp $c9f7			jmp _not_escaped
.c965					+
.c965	84 15		sty $15				sty tmp1+1
.c967	24 15		bit $15				bit tmp1+1		; in the middle of a \x sequence ?
.c969	70 25		bvs $c990			bvs _check_esc_chars
.c96b	a9 01		lda #$01			lda #1
.c96d	24 15		bit $15				bit tmp1+1
.c96f	d0 11		bne $c982			bne _esc_x_second_digit
.c971	c8		iny				iny			; Adjust flag for second digit next time.
.c972	94 27		sty $27,x			sty DStack+3,x
.c974	a5 14		lda $14				lda tmp1+0		; Get the char again.
.c976	20 24 ca	jsr $ca24			jsr convert_hex_value	; Convert to hex
.c979	0a		asl a				asl			; This is the upper nybble, so move it up.
.c97a	0a		asl a				asl
.c97b	0a		asl a				asl
.c97c	0a		asl a				asl
.c97d	95 24		sta $24,x			sta DStack+0,x		; Save it for later.
.c97f	4c 08 ca	jmp $ca08			jmp _next_character
.c982					_esc_x_second_digit:
.c982	a9 00		lda #$00			lda #0			; Clear the escaped character flag
.c984	95 27		sta $27,x			sta DStack+3,x		;   (because we are handling it right here)
.c986	a5 14		lda $14				lda tmp1+0		; Convert to hex
.c988	20 24 ca	jsr $ca24			jsr convert_hex_value
.c98b	15 24		ora $24,x			ora DStack+0,x		; combine with value in t3
.c98d	4c 05 ca	jmp $ca05			jmp _save_character
.c990					_check_esc_chars:
.c990	a0 00		ldy #$00			ldy #0
.c992	94 27		sty $27,x			sty DStack+3,x
.c994	a8		tay				tay
.c995	a9 07		lda #$07			lda #AscBELL	      ; BEL (ASCII value 7)
.c997	c0 61		cpy #$61			cpy #'a'
.c999	f0 6a		beq $ca05			beq _save_character
.c99b	a9 08		lda #$08			lda #AscBS	      ; Backspace (ASCII value 8)
.c99d	c0 62		cpy #$62			cpy #'b'
.c99f	f0 64		beq $ca05			beq _save_character
.c9a1	a9 1b		lda #$1b			lda #AscESC	      ; ESC (ASCII value 27)
.c9a3	c0 65		cpy #$65			cpy #'e'
.c9a5	f0 5e		beq $ca05			beq _save_character
.c9a7	a9 0c		lda #$0c			lda #AscFF	      ; FF (ASCII value 12)
.c9a9	c0 66		cpy #$66			cpy #'f'
.c9ab	f0 58		beq $ca05			beq _save_character
.c9ad	a9 0a		lda #$0a			lda #AscLF	      ; LF (ASCII value 10)
.c9af	c0 6c		cpy #$6c			cpy #'l'
.c9b1	f0 52		beq $ca05			beq _save_character
.c9b3	c0 6e		cpy #$6e			cpy #'n'
.c9b5	f0 4e		beq $ca05			beq _save_character
.c9b7	c0 6d		cpy #$6d			cpy #'m'
.c9b9	d0 09		bne $c9c4			bne +
.c9bb	a9 0d		lda #$0d			lda #AscCR		; CR/LF pair (ASCII values 13, 10)
.c9bd	20 3e dd	jsr $dd3e			jsr C_Comma_A
.c9c0	a9 0a		lda #$0a			lda #AscLF
.c9c2	d0 41		bne $ca05			bne _save_character
.c9c4					+
.c9c4	a9 22		lda #$22			lda #AscDQuote		; Double quote (ASCII value 34)
.c9c6	c0 71		cpy #$71			cpy #'q'
.c9c8	f0 3b		beq $ca05			beq _save_character
.c9ca	c0 22		cpy #$22			cpy #AscDQuote
.c9cc	f0 37		beq $ca05			beq _save_character
.c9ce	a9 0d		lda #$0d			lda #AscCR		; CR (ASCII value 13)
.c9d0	c0 72		cpy #$72			cpy #'r'
.c9d2	f0 31		beq $ca05			beq _save_character
.c9d4	a9 09		lda #$09			lda #AscHT		; Horizontal TAB (ASCII value 9)
.c9d6	c0 74		cpy #$74			cpy #'t'
.c9d8	f0 2b		beq $ca05			beq _save_character
.c9da	a9 0b		lda #$0b			lda #AscVT		; Vertical TAB (ASCII value 11)
.c9dc	c0 76		cpy #$76			cpy #'v'
.c9de	f0 25		beq $ca05			beq _save_character
.c9e0	a9 00		lda #$00			lda #0			; NULL (ASCII value 0)
.c9e2	c0 7a		cpy #$7a			cpy #'z'
.c9e4	f0 1f		beq $ca05			beq _save_character
.c9e6					_check_esc_x:
.c9e6	c0 78		cpy #$78			cpy #'x'
.c9e8	d0 06		bne $c9f0			bne +
.c9ea	a9 be		lda #$be			lda #$BE	; Clear bits 6 and 0
.c9ec	95 27		sta $27,x			sta DStack+3,x
.c9ee	d0 18		bne $ca08			bne _next_character
.c9f0					+
.c9f0	a9 5c		lda #$5c			lda #AscBackslash	; Backslash (ASCII value 92)
.c9f2	c0 5c		cpy #$5c			cpy #AscBackslash
.c9f4	f0 0f		beq $ca05			beq _save_character
.c9f6	98		tya				tya
.c9f7					_not_escaped:
.c9f7	c9 5c		cmp #$5c			cmp #$5C	; The backslash char
.c9f9	d0 06		bne $ca01			bne _regular_char
.c9fb	a9 ff		lda #$ff			lda #$FF
.c9fd	95 27		sta $27,x			sta DStack+3,x
.c9ff	d0 07		bne $ca08			bne _next_character
.ca01					_regular_char:
.ca01	c9 22		cmp #$22			cmp #AscDQuote		; ASCII for "
.ca03	f0 06		beq $ca0b			beq _found_string_end
.ca05					_save_character:
.ca05	20 3e dd	jsr $dd3e			jsr C_Comma_A		; compile this character into the dictionary
.ca08					_next_character:
.ca08	4c 26 c9	jmp $c926			jmp _savechars_loop
.ca0b					_found_string_end:
.ca0b	e8		inx				inx			; Drop t3
.ca0c	e8		inx				inx
.ca0d	a5 0a		lda $0a				lda state		; What happens next depends on the state (which is bad, but
.ca0f	d0 0e		bne $ca1f			bne _cmpl		; that's the way it works at the moment).
.ca11	38		sec				sec			; TOS= length of string = Here - start_addr
.ca12	a5 00		lda $00				lda cp+0
.ca14	f5 26		sbc $26,x			sbc DStack+2,x
.ca16	95 24		sta $24,x			sta DStack+0,x		;   LSB
.ca18	a5 01		lda $01				lda cp+1
.ca1a	f5 27		sbc $27,x			sbc DStack+3,x
.ca1c	95 25		sta $25,x			sta DStack+1,x		;   MSB
.ca1e	60		rts				rts			; ( startaddr u )
.ca1f					_cmpl:
.ca1f	e8		inx				inx			; Drop t2
.ca20	e8		inx				inx
.ca21	4c ac c8	jmp $c8ac			jmp SLiteral_End	; ( jmpaddr )
=277					CodeLen	.var *-XtPtr1
=$ff					CodeLen	 .var $ff
=$ca24					Here1 = *	; remember here
>c90d	ff					.byte CodeLen	;patch wh_CodeLength
.ca24					convert_hex_value:
.ca24	c9 41		cmp #$41			cmp #'A'
.ca26	90 05		bcc $ca2d			bcc _digit
.ca28	29 1f		and #$1f	_alpha:		and #$1F		; Make it uppercase.
.ca2a	69 08		adc #$08			adc #9-1		; gives value 10 for 'A'
.ca2c	60		rts				rts
.ca2d					_digit:
.ca2d	e9 2f		sbc #$2f			sbc #'0'-1
.ca2f	60		rts				rts
>ca30	4c 61 74 65 73 74 58 74		Name0:	.text "LatestXt"	;  name of word as a string, ending at wh_NameLastChar
=8					NameLength = *-Name0
=51640					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>ca38	88					.byte (("LatestXt"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=301					LinkDisplacement = Nt0-WordListLink
=$11						  WordFlags ::= WordFlags | FP
>ca39	11					.byte WordFlags	;wh_Flags
>ca3a	03					.byte 3	;wh_CodeLength
>ca3b	8b c8					  .word WordListLink
=$ca3d					XtPtr1 ::= *
=51640					WordListLink ::= Nt0 ; remember the nt of this word for later
.ca3d	20 4f ca	jsr $ca4f	LatestXt:	jsr LatestNt	; ( nt )
.ca40	4c ae cd	jmp $cdae			jmp Name_To_Int	; ( xt )
=6					CodeLen	.var *-XtPtr1
=$ca43					Here1 = *	; remember here
>ca3a	06					.byte CodeLen	;patch wh_CodeLength
>ca43	4c 61 74 65 73 74 4e 74		Name0:	.text "LatestNt"	;  name of word as a string, ending at wh_NameLastChar
=8					NameLength = *-Name0
=51659					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>ca4b	88					.byte (("LatestNt"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=19					LinkDisplacement = Nt0-WordListLink
>ca4c	10					.byte WordFlags	;wh_Flags
>ca4d	03					.byte 3	;wh_CodeLength
>ca4e	13					  .byte LinkDisplacement	; offset to previous nt
=$ca4f					XtPtr1 ::= *
=51659					WordListLink ::= Nt0 ; remember the nt of this word for later
.ca4f	20 59 ca	jsr $ca59	LatestNt:	jsr current_to_dp
.ca52	a5 10		lda $10				lda dp+0
.ca54	a4 11		ldy $11				ldy dp+1
.ca56	4c ba c7	jmp $c7ba			jmp PushYA
=10					CodeLen	.var *-XtPtr1
=$ca59					Here1 = *	; remember here
>ca4d	0a					.byte CodeLen	;patch wh_CodeLength
.ca59					current_to_dp:
.ca59	ad 10 03	lda $0310			lda CurrentV		; A= current wordlist wid
.ca5c	0a		asl a				asl			; dp= wordlists[A]
.ca5d	a8		tay				tay
.ca5e	b9 12 03	lda $0312,y			lda WordlistsV+0,y
.ca61	85 10		sta $10				sta dp+0
.ca63	b9 13 03	lda $0313,y			lda WordlistsV+1,y
.ca66	85 11		sta $11				sta dp+1
.ca68	60		rts				rts
.ca69					dp_to_current:
.ca69	ad 10 03	lda $0310			lda CurrentV		; A= current wordlist wid
.ca6c	0a		asl a		                asl			; wordlists[A]=dp
.ca6d	a8		tay		                tay
.ca6e	a5 10		lda $10		                lda dp+0
.ca70	99 12 03	sta $0312,y			sta WordlistsV+0,y
.ca73	a5 11		lda $11		                lda dp+1
.ca75	99 13 03	sta $0313,y	                sta WordlistsV+1,y
.ca78	60		rts		                rts
>ca79	50 61 72 73 65 2d 4e 61		Name0:	.text "Parse-Name"	;  name of word as a string, ending at wh_NameLastChar
>ca81	6d 65
=10					NameLength = *-Name0
=51715					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>ca83	aa					.byte (("Parse-Name"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=56					LinkDisplacement = Nt0-WordListLink
>ca84	10					.byte WordFlags	;wh_Flags
>ca85	03					.byte 3	;wh_CodeLength
>ca86	38					  .byte LinkDisplacement	; offset to previous nt
=$ca87					XtPtr1 ::= *
=51715					WordListLink ::= Nt0 ; remember the nt of this word for later
.ca87					Parse_Name:
.ca87	a5 04		lda $04				lda cib+0		; tmp2= cib+(toin & $ff00)
.ca89	85 16		sta $16				sta tmp2+0
.ca8b	18		clc				clc
.ca8c	a5 05		lda $05				lda cib+1
.ca8e	65 09		adc $09				adc toin+1
.ca90	85 17		sta $17				sta tmp2+1
.ca92	a4 08		ldy $08				ldy toin+0		; Y= toin & $00ff
.ca94					_skip_loop:
.ca94	c4 06		cpy $06				cpy ciblen+0		; more chars left?
.ca96	a5 09		lda $09				lda toin+1
.ca98	e5 07		sbc $07				sbc ciblen+1
.ca9a	b0 11		bcs $caad			bcs _empty_line
.ca9c	b1 16		lda ($16),y			lda (tmp2),y		; get cib[toin]
.ca9e	c9 21		cmp #$21			cmp #AscSP+1		; is_whitespace
.caa0	b0 10		bcs $cab2			bcs _char_found
.caa2	c8		iny				iny			; increment toin
.caa3	84 08		sty $08				sty toin+0
.caa5	d0 ed		bne $ca94			bne _skip_loop
.caa7	e6 09		inc $09				inc toin+1
.caa9	e6 17		inc $17				inc tmp2+1
.caab	d0 e7		bne $ca94			bne _skip_loop
.caad					_empty_line:
.caad	ca		dex				dex			; junk address
.caae	ca		dex				dex
.caaf	4c f7 c7	jmp $c7f7			jmp Zero		; length=0
.cab2					_char_found:
.cab2	20 13 c8	jsr $c813			jsr Bl			; push delimiter char
.cab5	4c ce ca	jmp $cace			jmp Parse
=49					CodeLen	.var *-XtPtr1
=$cab8					Here1 = *	; remember here
>ca85	31					.byte CodeLen	;patch wh_CodeLength
.cab8					parse_name_check:
.cab8	20 87 ca	jsr $ca87			jsr parse_name		; get character from string
.cabb	b5 24		lda $24,x			lda DStack+0,x		; empty string?
.cabd	f0 01		beq $cac0			beq _empty
.cabf	60		rts				rts
.cac0	a9 f3		lda #$f3	_empty:		lda #$100+err_UndefinedWord	; complain & abort
.cac2	4c 68 c4	jmp $c468			jmp ThrowA
>cac5	50 61 72 73 65			Name0:	.text "Parse"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=51786					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>caca	a5					.byte (("Parse"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=71					LinkDisplacement = Nt0-WordListLink
>cacb	10					.byte WordFlags	;wh_Flags
>cacc	03					.byte 3	;wh_CodeLength
>cacd	47					  .byte LinkDisplacement	; offset to previous nt
=$cace					XtPtr1 ::= *
=51786					WordListLink ::= Nt0 ; remember the nt of this word for later
.cace	20 c8 c3	jsr $c3c8	Parse:		jsr PopA		; pop c (check for underflow)
.cad1	85 1c		sta $1c		Parse_A:	sta tmp5		; save delimiter
.cad3	ca		dex				dex			; alloc space for addr
.cad4	ca		dex				dex
.cad5	ca		dex				dex			; alloc space for length
.cad6	ca		dex				dex
.cad7	18		clc				clc			; addr= cib+toin
.cad8	a5 08		lda $08				lda toin+0
.cada	65 04		adc $04				adc cib+0
.cadc	95 26		sta $26,x			sta DStack+2,x
.cade	a5 09		lda $09				lda toin+1
.cae0	65 05		adc $05				adc cib+1
.cae2	95 27		sta $27,x			sta DStack+3,x
.cae4	a4 08		ldy $08				ldy toin+0		; Y= toin & $00ff
.cae6	84 14		sty $14				sty tmp1+0
.cae8	a5 04		lda $04				lda cib+0		; tmp2= cib + (toin & $ff00)
.caea	85 16		sta $16				sta tmp2+0
.caec	18		clc				clc
.caed	a5 09		lda $09				lda toin+1		; tmp1= toin
.caef	85 15		sta $15				sta tmp1+1
.caf1	65 05		adc $05				adc cib+1
.caf3	85 17		sta $17				sta tmp2+1
.caf5	a9 00		lda #$00			lda #0		; Initialize the offset we use to adjust EOL or found delimiter
.caf7	85 1d		sta $1d				sta tmp5+1
.caf9					_loop:
.caf9	c4 06		cpy $06				cpy ciblen+0		; end of string?
.cafb	a5 09		lda $09				lda toin+1
.cafd	e5 07		sbc $07				sbc ciblen+1
.caff	b0 1d		bcs $cb1e			bcs _eol
.cb01	a5 1c		lda $1c				lda tmp5+0		; get delimiter
.cb03	c9 20		cmp #$20			cmp #AscSP		; is it whitespace?
.cb05	d0 08		bne $cb0f			bne _not_whitespace
.cb07	b1 16		lda ($16),y			lda (tmp2),y		; get cib[toin]
.cb09	c9 21		cmp #$21			cmp #AscSP+1		; we're looking for all whitespace
.cb0b	90 0f		bcc $cb1c			bcc _found_delimiter
.cb0d	b0 04		bcs $cb13			bcs _not_delimiter
.cb0f	d1 16		cmp ($16),y	_not_whitespace: cmp (tmp2),y		; compare delimter to cib[toin]
.cb11	f0 09		beq $cb1c			beq _found_delimiter
.cb13					_not_delimiter:
.cb13	c8		iny				iny			; next character
.cb14	d0 e3		bne $caf9			bne _loop
.cb16	e6 09		inc $09				inc toin+1
.cb18	e6 17		inc $17				inc tmp2+1
.cb1a	d0 dd		bne $caf9			bne _loop
.cb1c					_found_delimiter:
.cb1c	e6 1d		inc $1d				inc tmp5+1
.cb1e					_eol:
.cb1e	38		sec				sec			; length = toin - tmp1
.cb1f	98		tya				tya
.cb20	e5 14		sbc $14				sbc tmp1+0
.cb22	95 24		sta $24,x			sta DStack+0,x
.cb24	a5 09		lda $09				lda toin+1
.cb26	e5 15		sbc $15				sbc tmp1+1
.cb28	95 25		sta $25,x			sta DStack+1,x
.cb2a	18		clc				clc			; toin = toin + delimiter_offset
.cb2b	98		tya				tya
.cb2c	65 1d		adc $1d				adc tmp5+1
.cb2e	85 08		sta $08				sta toin+0
.cb30	90 02		bcc $cb34			bcc +
.cb32	e6 09		inc $09				inc toin+1
.cb34					+
=102					CodeLen	.var *-XtPtr1
=$cb34					Here1 = *	; remember here
>cacc	66					.byte CodeLen	;patch wh_CodeLength
.cb34	60		rts				rts
>cb35	45 78 65 63 75 74 65 2d		Name0:	.text "Execute-Parsing"	;  name of word as a string, ending at wh_NameLastChar
>cb3d	50 61 72 73 69 6e 67
=15					NameLength = *-Name0
=51908					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>cb44	ef					.byte (("Execute-Parsing"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=122					LinkDisplacement = Nt0-WordListLink
>cb45	10					.byte WordFlags	;wh_Flags
>cb46	03					.byte 3	;wh_CodeLength
>cb47	7a					  .byte LinkDisplacement	; offset to previous nt
=$cb48					XtPtr1 ::= *
=51908					WordListLink ::= Nt0 ; remember the nt of this word for later
.cb48					Execute_parsing:
.cb48	20 25 c4	jsr $c425			jsr underflow_3
.cb4b	20 16 d4	jsr $d416			jsr Input_To_R		; save existing input for later
.cb4e	20 d8 de	jsr $ded8			jsr Not_Rot		; -ROT ( xt addr u )
.cb51	20 e3 c3	jsr $c3e3			jsr PopYA		; TOS is new ciblen
.cb54	85 06		sta $06				sta ciblen+0
.cb56	84 07		sty $07				sty ciblen+1
.cb58	20 e3 c3	jsr $c3e3			jsr PopYA		; NOS is new cib
.cb5b	85 04		sta $04				sta cib+0
.cb5d	84 05		sty $05				sty cib+1
.cb5f	a9 00		lda #$00			lda #0
.cb61	85 08		sta $08				sta toin+0		; Set >IN to zero
.cb63	85 09		sta $09				sta toin+1
.cb65	20 77 de	jsr $de77			jsr Execute
.cb68	20 37 d4	jsr $d437			jsr R_To_Input		; restore
=35					CodeLen	.var *-XtPtr1
=$cb6b					Here1 = *	; remember here
>cb46	23					.byte CodeLen	;patch wh_CodeLength
.cb6b	60		rts				rts
>cb6c	53 6f 75 72 63 65		Name0:	.text "Source"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=51954					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>cb72	a6					.byte (("Source"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=46					LinkDisplacement = Nt0-WordListLink
>cb73	10					.byte WordFlags	;wh_Flags
>cb74	03					.byte 3	;wh_CodeLength
>cb75	2e					  .byte LinkDisplacement	; offset to previous nt
=$cb76					XtPtr1 ::= *
=51954					WordListLink ::= Nt0 ; remember the nt of this word for later
.cb76					Source:
.cb76	a5 04		lda $04				lda cib+0	; push address
.cb78	a4 05		ldy $05				ldy cib+1
.cb7a	20 ba c7	jsr $c7ba			jsr PushYA
.cb7d	a5 06		lda $06				lda ciblen+0	; push size, return
.cb7f	a4 07		ldy $07				ldy ciblen+1
.cb81	4c ba c7	jmp $c7ba			jmp PushYA
=14					CodeLen	.var *-XtPtr1
=$cb84					Here1 = *	; remember here
>cb74	0e					.byte CodeLen	;patch wh_CodeLength
>cb84	53 6f 75 72 63 65 2d 49		Name0:	.text "Source-Id"	;  name of word as a string, ending at wh_NameLastChar
>cb8c	64
=9					NameLength = *-Name0
=51981					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>cb8d	89					.byte (("Source-Id"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=27					LinkDisplacement = Nt0-WordListLink
>cb8e	10					.byte WordFlags	;wh_Flags
>cb8f	03					.byte 3	;wh_CodeLength
>cb90	1b					  .byte LinkDisplacement	; offset to previous nt
=$cb91					XtPtr1 ::= *
=51981					WordListLink ::= Nt0 ; remember the nt of this word for later
.cb91	a5 02		lda $02		Source_Id:	lda insrc+0
.cb93	a4 03		ldy $03				ldy insrc+1
.cb95	4c ba c7	jmp $c7ba			jmp PushYA
=7					CodeLen	.var *-XtPtr1
=$cb98					Here1 = *	; remember here
>cb8f	07					.byte CodeLen	;patch wh_CodeLength
>cb98	45 78 69 74			Name0:	.text "Exit"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=51996					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>cb9c	84					.byte (("Exit"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=36					WordFlags ::= AN+CO	; modifiable copy, remember for later
=15					LinkDisplacement = Nt0-WordListLink
>cb9d	24					.byte WordFlags	;wh_Flags
>cb9e	03					.byte 3	;wh_CodeLength
>cb9f	0f					  .byte LinkDisplacement	; offset to previous nt
=$cba0					XtPtr1 ::= *
=51996					WordListLink ::= Nt0 ; remember the nt of this word for later
.cba0					Exit:
.cba0	60		rts				rts		; keep before WordEnd so it gets inlined
=1					CodeLen	.var *-XtPtr1
=$cba1					Here1 = *	; remember here
>cb9e	01					.byte CodeLen	;patch wh_CodeLength
>cba1	3b				Name0:	.text ";"	;  name of word as a string, ending at wh_NameLastChar
=1					NameLength = *-Name0
=52002					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>cba2	61					.byte ((";"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=28					WordFlags ::= CO+IM+NN	; modifiable copy, remember for later
=6					LinkDisplacement = Nt0-WordListLink
>cba3	1c					.byte WordFlags	;wh_Flags
>cba4	03					.byte 3	;wh_CodeLength
>cba5	06					  .byte LinkDisplacement	; offset to previous nt
=$cba6					XtPtr1 ::= *
=52002					WordListLink ::= Nt0 ; remember the nt of this word for later
.cba6					Semicolon:
.cba6	20 2a c7	jsr $c72a			jsr Left_Bracket	; switch to interpret state
.cba9	24 0c		bit $0c				bit status		; is this a : word or a :NONAME word?
.cbab	70 0c		bvs $cbb9			bvs _colonword
.cbad	a9 60		lda #$60			lda #$60		; compile an RTS
.cbaf	20 3e dd	jsr $dd3e			jsr C_Comma_A
.cbb2	a5 0e		lda $0e				lda WorkWord+0		; push xt, return
.cbb4	a4 0f		ldy $0f				ldy WorkWord+1
.cbb6	4c ba c7	jmp $c7ba			jmp PushYA
.cbb9					_colonword:
.cbb9	10 1a		bpl $cbd5			bpl _new_word	; Bit 7 is clear = new word
.cbbb	a5 0e		lda $0e				lda WorkWord+0		; push our nt
.cbbd	a4 0f		ldy $0f				ldy WorkWord+1
.cbbf	20 fa cd	jsr $cdfa			jsr Name_To_String_YA	; get our name string
.cbc2	a9 c1		lda #$c1			lda #<str_redefined	; string "redefined"
.cbc4	a0 ea		ldy #$ea			ldy #>str_redefined
.cbc6	20 55 de	jsr $de55			jsr Print_ASCIIZ_YA_no_lf
.cbc9	20 39 de	jsr $de39			jsr Type		; print the ofWordEnding word.
.cbcc	20 2d de	jsr $de2d			jsr Space
.cbcf	a9 7f		lda #$7f			lda #$ff-%10000000
.cbd1	25 0c		and $0c				and status
.cbd3	85 0c		sta $0c				sta status
.cbd5					_new_word:
.cbd5	20 23 d1	jsr $d123			jsr Header_Link		; finish linking into current dictionary
.cbd8	20 e0 cb	jsr $cbe0			jsr adjust_z		; fix word length
.cbdb	a9 60		lda #$60			lda #$60		; compile an RTS
.cbdd	4c 3e dd	jmp $dd3e			jmp C_Comma_A
=58					CodeLen	.var *-XtPtr1
=$cbe0					Here1 = *	; remember here
>cba4	3a					.byte CodeLen	;patch wh_CodeLength
.cbe0					adjust_z:
.cbe0	a0 81		ldy #$81			ldy #wh_Flags		; tmp1= xt
.cbe2	b1 10		lda ($10),y			lda (dp),y
.cbe4	29 03		and #$03			and #FP+DB
.cbe6	18		clc				clc
.cbe7	69 84		adc #$84			adc #wh_LinkNt+1
.cbe9	65 10		adc $10				adc dp+0
.cbeb	85 14		sta $14				sta tmp1+0
.cbed	a9 00		lda #$00			lda #0
.cbef	65 11		adc $11				adc dp+1
.cbf1	85 15		sta $15				sta tmp1+1
.cbf3	38		sec				sec			; length= cp-xt
.cbf4	a5 00		lda $00				lda cp+0
.cbf6	e5 14		sbc $14				sbc tmp1+0
.cbf8	a8		tay				tay
.cbf9	a5 01		lda $01				lda cp+1
.cbfb	e5 15		sbc $15				sbc tmp1+1
.cbfd	f0 0c		beq $cc0b			beq _short		; length > $ff ?
.cbff	a0 81		ldy #$81			ldy #Wh_Flags		; make it NN
.cc01	b1 10		lda ($10),y			lda (dp),y
.cc03	29 df		and #$df			and #$ff-AN
.cc05	09 10		ora #$10			ora #NN
.cc07	91 10		sta ($10),y			sta (dp),y
.cc09	a0 ff		ldy #$ff			ldy #$ff		; set max length for header
.cc0b	98		tya		_short:		tya			; fill in length in header
.cc0c	a0 82		ldy #$82			ldy #Wh_CodeLength
.cc0e	91 10		sta ($10),y			sta (dp),y
.cc10	60		rts				rts
>cc11	3a				Name0:	.text ":"	;  name of word as a string, ending at wh_NameLastChar
=1					NameLength = *-Name0
=52114					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>cc12	41					.byte ((":"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=112					LinkDisplacement = Nt0-WordListLink
>cc13	10					.byte WordFlags	;wh_Flags
>cc14	03					.byte 3	;wh_CodeLength
>cc15	70					  .byte LinkDisplacement	; offset to previous nt
=$cc16					XtPtr1 ::= *
=52114					WordListLink ::= Nt0 ; remember the nt of this word for later
.cc16					Colon:
.cc16	20 3f c7	jsr $c73f			jsr Right_Bracket	; switch to compile state
.cc19	a5 0c		lda $0c				lda status
.cc1b	09 40		ora #$40			ora #%01000000	; tell ";" and RECURSE that WorkWord contains nt
.cc1d	09 80		ora #$80			ora #%10000000	; Tell Header_Build not to print warning for duplicate name.
.cc1f	85 0c		sta $0c				sta status
.cc21	4c 2e d1	jmp $d12e			jmp Header_Build	; compile word header (but don't link into wordlist)
=14					CodeLen	.var *-XtPtr1
=$cc24					Here1 = *	; remember here
>cc14	0e					.byte CodeLen	;patch wh_CodeLength
>cc24	3a 4e 6f 4e 61 6d 65		Name0:	.text ":NoName"	;  name of word as a string, ending at wh_NameLastChar
=7					NameLength = *-Name0
=52139					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>cc2b	a7					.byte ((":NoName"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=25					LinkDisplacement = Nt0-WordListLink
>cc2c	10					.byte WordFlags	;wh_Flags
>cc2d	03					.byte 3	;wh_CodeLength
>cc2e	19					  .byte LinkDisplacement	; offset to previous nt
=$cc2f					XtPtr1 ::= *
=52139					WordListLink ::= Nt0 ; remember the nt of this word for later
.cc2f					Colon_NoName:
.cc2f	20 3f c7	jsr $c73f			jsr Right_Bracket	; switch to compile state
.cc32	a9 bf		lda #$bf			lda #$ff-%01000000	; tell ";" and RECURSE that WorkWord contains xt
.cc34	25 0c		and $0c				and status
.cc36	85 0c		sta $0c				sta status
.cc38	a5 00		lda $00				lda cp+0
.cc3a	85 0e		sta $0e				sta WorkWord+0
.cc3c	a5 01		lda $01				lda cp+1
.cc3e	85 0f		sta $0f				sta WorkWord+1
=17					CodeLen	.var *-XtPtr1
=$cc40					Here1 = *	; remember here
>cc2d	11					.byte CodeLen	;patch wh_CodeLength
.cc40	60		rts				rts
>cc41	27				Name0:	.text "'"	;  name of word as a string, ending at wh_NameLastChar
=1					NameLength = *-Name0
=52162					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>cc42	e1					.byte (("'"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=23					LinkDisplacement = Nt0-WordListLink
>cc43	10					.byte WordFlags	;wh_Flags
>cc44	03					.byte 3	;wh_CodeLength
>cc45	17					  .byte LinkDisplacement	; offset to previous nt
=$cc46					XtPtr1 ::= *
=52162					WordListLink ::= Nt0 ; remember the nt of this word for later
.cc46	20 4c cc	jsr $cc4c	Tick:		jsr Tick_Nt
.cc49	4c ae cd	jmp $cdae			jmp Name_To_Int	; ( nt -- xt )
=6					CodeLen	.var *-XtPtr1
=$cc4c					Here1 = *	; remember here
>cc44	06					.byte CodeLen	;patch wh_CodeLength
.cc4c	20 b8 ca	jsr $cab8	Tick_Nt:	jsr parse_name_check	; ( -- addr u )
.cc4f	4c 9a cc	jmp $cc9a			jmp find_name_check	; ( addr u -- nt )
>cc52	5b 27 5d			Name0:	.text "[']"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=52181					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>cc55	a3					.byte (("[']"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=28					WordFlags ::= CO+IM+NN	; modifiable copy, remember for later
=19					LinkDisplacement = Nt0-WordListLink
>cc56	1c					.byte WordFlags	;wh_Flags
>cc57	03					.byte 3	;wh_CodeLength
>cc58	13					  .byte LinkDisplacement	; offset to previous nt
=$cc59					XtPtr1 ::= *
=52181					WordListLink ::= Nt0 ; remember the nt of this word for later
.cc59	20 46 cc	jsr $cc46	Bracket_Tick:	jsr Tick
.cc5c	4c 57 c7	jmp $c757			jmp Literal
=6					CodeLen	.var *-XtPtr1
=$cc5f					Here1 = *	; remember here
>cc57	06					.byte CodeLen	;patch wh_CodeLength
>cc5f	46 69 6e 64 2d 4e 61 6d		Name0:	.text "Find-Name"	;  name of word as a string, ending at wh_NameLastChar
>cc67	65
=9					NameLength = *-Name0
=52200					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>cc68	a9					.byte (("Find-Name"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=19					LinkDisplacement = Nt0-WordListLink
>cc69	10					.byte WordFlags	;wh_Flags
>cc6a	03					.byte 3	;wh_CodeLength
>cc6b	13					  .byte LinkDisplacement	; offset to previous nt
=$cc6c					XtPtr1 ::= *
=52200					WordListLink ::= Nt0 ; remember the nt of this word for later
.cc6c					Find_Name:
.cc6c	20 a7 cc	jsr $cca7			jsr swl_prepare 	; setup for search
.cc6f	ca		dex				dex
.cc70	ca		dex				dex			; ( ? )
.cc71	a9 ff		lda #$ff			lda #$ff		; for each entry in search order
.cc73	95 25		sta $25,x			sta DStack+1,x
.cc75	f6 25		inc $25,x	_wordlist_next:	inc DStack+1,x		; step to next search order entry
.cc77	b4 25		ldy $25,x			ldy DStack+1,x
.cc79	cc 2a 03	cpy $032a			cpy Num_OrderV		; at end of list?
.cc7c	90 06		bcc $cc84			bcc _nextS
.cc7e	d0 15		bne $cc95			bne _fail
.cc80	a9 03		lda #$03			lda #wid_Root		; also try root wordlist
.cc82	d0 03		bne $cc87			bne _nextA
.cc84	b9 2b 03	lda $032b,y	_nextS:		lda Search_OrderV,y	; A= search_order[Y]  get wordlist ID
.cc87	20 d0 cc	jsr $ccd0	_nextA:		jsr swl_search_wordlist
.cc8a	f0 e9		beq $cc75			beq _wordlist_next
.cc8c	a5 14		lda $14				lda tmp1+0		; return nt
.cc8e	a4 15		ldy $15				ldy tmp1+1
.cc90	95 24		sta $24,x	_exit:		sta DStack+0,x
.cc92	94 25		sty $25,x			sty DStack+1,x
.cc94	60		rts				rts			; ( ? )
.cc95	a9 00		lda #$00	_fail:		lda #0			; return 0
.cc97	a8		tay				tay
.cc98	f0 f6		beq $cc90			beq _exit
=46					CodeLen	.var *-XtPtr1
=$cc9a					Here1 = *	; remember here
>cc6a	2e					.byte CodeLen	;patch wh_CodeLength
.cc9a					find_name_check:
.cc9a	20 6c cc	jsr $cc6c			jsr Find_Name
.cc9d	b5 25		lda $25,x			lda DStack+1,x		; check that we found a word
.cc9f	f0 01		beq $cca2			beq _NotFound
.cca1	60		rts				rts
.cca2	a9 f3		lda #$f3	_NotFound:	lda #$100+err_UndefinedWord ; complain & quit
.cca4	4c 68 c4	jmp $c468			jmp ThrowA
.cca7					swl_prepare:
.cca7	20 20 c4	jsr $c420			jsr underflow_2
.ccaa	38		sec				sec			; A= 0 - name start offset
.ccab	b5 24		lda $24,x			lda DStack+0,x
.ccad	e9 80		sbc #$80			sbc #wh_NameLastChar+1
.ccaf	75 26		adc $26,x			adc DStack+2,x		; tmp2= pattern nt
.ccb1	85 16		sta $16				sta tmp2+0
.ccb3	a9 ff		lda #$ff			lda #$ff
.ccb5	75 27		adc $27,x			adc DStack+3,x
.ccb7	85 17		sta $17				sta tmp2+1
.ccb9	a9 7f		lda #$7f			lda #wh_NameLastChar	; tmp4+0= starting name char index -1
.ccbb	38		sec				sec
.ccbc	f5 24		sbc $24,x			sbc DStack+0,x
.ccbe	85 1a		sta $1a				sta tmp4+0
.ccc0	a0 7f		ldy #$7f			ldy #wh_NameLastChar	; tmp3+0= wh_HashNameLength
.ccc2	b1 16		lda ($16),y			lda (tmp2),y
.ccc4	0a		asl a				asl a
.ccc5	0a		asl a				asl a
.ccc6	0a		asl a				asl a
.ccc7	0a		asl a				asl a
.ccc8	0a		asl a				asl a
.ccc9	15 24		ora $24,x			ora DStack+0,x
.cccb	85 18		sta $18				sta tmp3+0
.cccd	4c 72 d5	jmp $d572			jmp Two_Drop		; Drop addr & u
.ccd0					swl_search_wordlist:
.ccd0	86 19		stx $19				stx tmp3+1		; save data stack index
.ccd2	0a		asl a				asl			; tmp1 = up->wordlists[A]
.ccd3	a8		tay				tay
.ccd4	be 12 03	ldx $0312,y			ldx WordlistsV+0,y
.ccd7	b9 13 03	lda $0313,y			lda WordlistsV+1,y
.ccda	d0 15		bne $ccf1			bne _word_3		;   not end-of-list?
.ccdc	08		php		_rts:		php
.ccdd	a6 19		ldx $19				ldx tmp3+1		; restore data stack index
.ccdf	28		plp				plp
.cce0	60		rts				rts			; Z= end_of_list
.cce1					_word_next:
.cce1	a0 81		ldy #$81			ldy #wh_Flags		; what kind of LinkNt?
.cce3	b1 14		lda ($14),y			lda (tmp1),y
.cce5	a0 83		ldy #$83			ldy #wh_LinkNt
.cce7	29 01		and #$01			and #FP
.cce9	f0 0e		beq $ccf9			beq _LinkShort
.cceb	b1 14		lda ($14),y	_LinkLong:	lda (tmp1),y		; tmp1= tmp1->Wh_LinkNt_word
.cced	aa		tax				tax
.ccee	c8		iny				iny
.ccef	b1 14		lda ($14),y			lda (tmp1),y
.ccf1	85 15		sta $15		_word_3:	sta tmp1+1
.ccf3	86 14		stx $14				stx tmp1+0
.ccf5	d0 0d		bne $cd04			bne _Test
.ccf7	f0 e3		beq $ccdc			beq _rts
.ccf9	a5 14		lda $14		_LinkShort:	lda tmp1+0		; tmp1 -= tmp1->wh_LinkNt offset byte
.ccfb	38		sec				sec
.ccfc	f1 14		sbc ($14),y			sbc (tmp1),y
.ccfe	85 14		sta $14				sta tmp1+0
.cd00	b0 02		bcs $cd04			bcs +
.cd02	c6 15		dec $15				dec tmp1+1
.cd04					+
.cd04	a0 80		ldy #$80	_Test:		ldy #Wh_HashNameLen	; Are hash & name length the same?
.cd06	b1 14		lda ($14),y			lda (tmp1),y
.cd08	c5 18		cmp $18				cmp tmp3+0
.cd0a	d0 d5		bne $cce1			bne _word_next
.cd0c	a4 1a		ldy $1a				ldy tmp4+0		; Y= index of 1st char -1
.cd0e	c8		iny		_char_next:	iny			; to next char
.cd0f	30 cb		bmi $ccdc			bmi _rts		; end of string?
.cd11	b1 16		lda ($16),y			lda (tmp2),y		; char of pattern name
.cd13	51 14		eor ($14),y			eor (tmp1),y		; char of this word name
.cd15	f0 f7		beq $cd0e			beq _char_next		;   exact match?
.cd17	c9 20		cmp #$20			cmp #$20		;   only a case mismatch?
.cd19	d0 c6		bne $cce1			bne _word_next
.cd1b	b1 16		lda ($16),y			lda (tmp2),y		;   verify it is alpha char
.cd1d	29 df		and #$df			and #$df
.cd1f	e9 41		sbc #$41			sbc #'A'
.cd21	c9 1a		cmp #$1a			cmp #'Z'-'A'+1
.cd23	90 e9		bcc $cd0e			bcc _char_next
.cd25	b0 ba		bcs $cce1			bcs _word_next
>cd27	46 69 6e 64			Name0:	.text "Find"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=52395					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>cd2b	84					.byte (("Find"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=195					LinkDisplacement = Nt0-WordListLink
>cd2c	10					.byte WordFlags	;wh_Flags
>cd2d	03					.byte 3	;wh_CodeLength
>cd2e	c3					  .byte LinkDisplacement	; offset to previous nt
=$cd2f					XtPtr1 ::= *
=52395					WordListLink ::= Nt0 ; remember the nt of this word for later
.cd2f					Find:
.cd2f	20 d2 df	jsr $dfd2			jsr Dup			; Save caddr in case conversion fails, check underflow
.cd32	20 dc c1	jsr $c1dc			jsr Count		; Convert counted string address to modern format
.cd35	20 6c cc	jsr $cc6c			jsr Find_Name		; ( caddr nt | 0 ) tmp1=nt
.cd38	b5 25		lda $25,x			lda DStack+1,x		; word found?
.cd3a	d0 01		bne $cd3d			bne _found_word
.cd3c	60		rts				rts			; ( caddr 0 )
.cd3d					_found_word:
.cd3d	20 cd d9	jsr $d9cd			jsr Nip			; ( nt )
.cd40	20 ae cd	jsr $cdae			jsr Name_To_Int		; ( xt ) tmp1=nt
.cd43	a0 81		ldy #$81			ldy #Wh_Flags		; immediate?
.cd45	b1 14		lda ($14),y			lda (tmp1),y
.cd47	29 08		and #$08			and #IM
.cd49	d0 03		bne $cd4e			bne _immediate
.cd4b	4c c9 c7	jmp $c7c9			jmp True		; not immediate, return ( xt -1 )
.cd4e	4c 00 c8	jmp $c800	_immediate:	jmp One			; immediate, return ( xt 1 )
=34					CodeLen	.var *-XtPtr1
=$cd51					Here1 = *	; remember here
>cd2d	22					.byte CodeLen	;patch wh_CodeLength
>cd51	49 6e 74 3e 4e 61 6d 65		Name0:	.text "Int>Name"	;  name of word as a string, ending at wh_NameLastChar
=8					NameLength = *-Name0
=52441					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>cd59	a8					.byte (("Int>Name"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=46					LinkDisplacement = Nt0-WordListLink
>cd5a	10					.byte WordFlags	;wh_Flags
>cd5b	03					.byte 3	;wh_CodeLength
>cd5c	2e					  .byte LinkDisplacement	; offset to previous nt
=$cd5d					XtPtr1 ::= *
=52441					WordListLink ::= Nt0 ; remember the nt of this word for later
.cd5d	20 0c c4	jsr $c40c	Int_To_Name:	jsr underflow_1
.cd60	a9 fe		lda #$fe			lda #$100-2		; for each wordlist
.cd62	85 19		sta $19				sta tmp3+1
.cd64					_wordlist_next:
.cd64	a4 19		ldy $19				ldy tmp3+1		; get next wordlist index
.cd66	c8		iny				iny
.cd67	c8		iny				iny
.cd68	84 19		sty $19				sty tmp3+1
.cd6a	c0 0c		cpy #$0c			cpy #(Num_OrderV-WordlistsV)/2
.cd6c	b0 2b		bcs $cd99			bcs _fail
.cd6e	b9 12 03	lda $0312,y			lda WordlistsV+0,y
.cd71	85 14		sta $14				sta tmp1+0
.cd73	b9 13 03	lda $0313,y			lda WordlistsV+1,y
.cd76	85 15		sta $15				sta tmp1+1
.cd78	d0 07		bne $cd81			bne _calc
.cd7a	f0 e8		beq $cd64			beq _wordlist_next
.cd7c	20 95 82	jsr $8295	_word_next:	jsr LinkNext		; step to next word
.cd7f	f0 e3		beq $cd64			beq _wordlist_next
.cd81	20 bb cd	jsr $cdbb	_calc:		jsr NameToIntTmp	; tmp2= xt
.cd84	a5 16		lda $16				lda tmp2+0
.cd86	d5 24		cmp $24,x			cmp DStack+0,x		;  match?
.cd88	d0 f2		bne $cd7c			bne _word_next
.cd8a	a5 17		lda $17				lda tmp2+1
.cd8c	d5 25		cmp $25,x			cmp DStack+1,x
.cd8e	d0 ec		bne $cd7c			bne _word_next
.cd90	a5 14		lda $14				lda tmp1+0
.cd92	95 24		sta $24,x			sta DStack+0,x
.cd94	a5 15		lda $15				lda tmp1+1
.cd96	95 25		sta $25,x			sta DStack+1,x
.cd98	60		rts				rts			; return P.Z=0
.cd99					_fail:
.cd99	a9 00		lda #$00			lda #0			; return a zero to indicate that we didn't find it.
.cd9b	95 24		sta $24,x			sta DStack+0,x
.cd9d	95 25		sta $25,x			sta DStack+1,x
.cd9f	85 15		sta $15				sta tmp1+1
.cda1	60		rts				rts			; return P.Z=1
=69					CodeLen	.var *-XtPtr1
=$cda2					Here1 = *	; remember here
>cd5b	45					.byte CodeLen	;patch wh_CodeLength
>cda2	4e 61 6d 65 3e 49 6e 74		Name0:	.text "Name>Int"	;  name of word as a string, ending at wh_NameLastChar
=8					NameLength = *-Name0
=52522					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>cdaa	88					.byte (("Name>Int"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=81					LinkDisplacement = Nt0-WordListLink
>cdab	10					.byte WordFlags	;wh_Flags
>cdac	03					.byte 3	;wh_CodeLength
>cdad	51					  .byte LinkDisplacement	; offset to previous nt
=$cdae					XtPtr1 ::= *
=52522					WordListLink ::= Nt0 ; remember the nt of this word for later
.cdae	20 ee c3	jsr $c3ee	Name_To_Int:	jsr PopTmp1
.cdb1	20 bb cd	jsr $cdbb	Name_To_Int_T:	jsr NameToIntTmp
.cdb4	a5 16		lda $16				lda tmp2+0
.cdb6	a4 17		ldy $17				ldy tmp2+1
.cdb8	4c ba c7	jmp $c7ba			jmp PushYA
=13					CodeLen	.var *-XtPtr1
=$cdbb					Here1 = *	; remember here
>cdac	0d					.byte CodeLen	;patch wh_CodeLength
.cdbb					NameToIntTmp:
.cdbb	a0 81		ldy #$81			ldy #wh_Flags
.cdbd	b1 14		lda ($14),y			lda (tmp1),y
.cdbf	29 02		and #$02			and #DB			; has XT ptr?
.cdc1	d0 12		bne $cdd5			bne _HasXtPtr
.cdc3	b1 14		lda ($14),y			lda (tmp1),y		; A= header length
.cdc5	29 03		and #$03			and #DB+FP
.cdc7	18		clc				clc
.cdc8	69 84		adc #$84			adc #wh_LinkNt+1
.cdca	65 14		adc $14				adc tmp1+0		; TOS=tmp1+A
.cdcc	85 16		sta $16				sta tmp2+0
.cdce	a9 00		lda #$00			lda #0
.cdd0	65 15		adc $15				adc tmp1+1
.cdd2	85 17		sta $17				sta tmp2+1
.cdd4	60		rts				rts
.cdd5	b1 14		lda ($14),y	_HasXtPtr:	lda (tmp1),y		; get wh_Flags again
.cdd7	a0 84		ldy #$84			ldy #wh_LinkNt+1
.cdd9	29 01		and #$01			and #FP			; has long LinkNt ?
.cddb	f0 01		beq $cdde			beq _short
.cddd	c8		iny				iny			;   skip extra byte
.cdde	b1 14		lda ($14),y	_short:		lda (tmp1),y		; tmp2= xt pointer
.cde0	85 16		sta $16				sta tmp2+0
.cde2	c8		iny				iny
.cde3	b1 14		lda ($14),y			lda (tmp1),y
.cde5	85 17		sta $17				sta tmp2+1
.cde7	60		rts				rts
>cde8	4e 61 6d 65 3e 53 74 72		Name0:	.text "Name>String"	;  name of word as a string, ending at wh_NameLastChar
>cdf0	69 6e 67
=11					NameLength = *-Name0
=52595					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>cdf3	eb					.byte (("Name>String"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=73					LinkDisplacement = Nt0-WordListLink
>cdf4	10					.byte WordFlags	;wh_Flags
>cdf5	03					.byte 3	;wh_CodeLength
>cdf6	49					  .byte LinkDisplacement	; offset to previous nt
=$cdf7					XtPtr1 ::= *
=52595					WordListLink ::= Nt0 ; remember the nt of this word for later
.cdf7	20 e3 c3	jsr $c3e3	Name_To_String:	jsr PopYA
.cdfa					Name_To_String_YA:
.cdfa	85 14		sta $14				sta tmp1+0		; tmp1= nt
.cdfc	84 15		sty $15				sty tmp1+1
.cdfe	20 ba c7	jsr $c7ba			jsr PushYA		; ( nt )
.ce01	a0 80		ldy #$80			ldy #Wh_HashNameLen	; A= name length
.ce03	b1 14		lda ($14),y			lda (tmp1),y
.ce05	29 1f		and #$1f			and #wh_NameLengthMask
.ce07	48		pha				pha			; save string length
.ce08	49 ff		eor #$ff			eor #$ff
.ce0a	38		sec				sec
.ce0b	69 80		adc #$80			adc #Wh_NameLastChar+1	; calc string start offset
.ce0d	20 48 da	jsr $da48			jsr Plus_A		; calc string start addr
.ce10	68		pla				pla			; push string length
.ce11	4c e9 c7	jmp $c7e9			jmp PushZA
=29					CodeLen	.var *-XtPtr1
=$ce14					Here1 = *	; remember here
>cdf5	1d					.byte CodeLen	;patch wh_CodeLength
>ce14	3e 42 6f 64 79			Name0:	.text ">Body"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=52633					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>ce19	25					.byte ((">Body"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=38					LinkDisplacement = Nt0-WordListLink
>ce1a	10					.byte WordFlags	;wh_Flags
>ce1b	03					.byte 3	;wh_CodeLength
>ce1c	26					  .byte LinkDisplacement	; offset to previous nt
=$ce1d					XtPtr1 ::= *
=52633					WordListLink ::= Nt0 ; remember the nt of this word for later
.ce1d	a9 03		lda #$03	To_Body:	lda #3		; PFA is after the beginning JSR abs
.ce1f	4c 48 da	jmp $da48			jmp Plus_A
=5					CodeLen	.var *-XtPtr1
=$ce22					Here1 = *	; remember here
>ce1b	05					.byte CodeLen	;patch wh_CodeLength
.ce22	4c 2f c4	jmp $c42f	Throw_Stack_07: jmp Throw_Stack
>ce25	45 72 61 73 65			Name0:	.text "Erase"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=52650					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>ce2a	a5					.byte (("Erase"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=17					LinkDisplacement = Nt0-WordListLink
>ce2b	10					.byte WordFlags	;wh_Flags
>ce2c	03					.byte 3	;wh_CodeLength
>ce2d	11					  .byte LinkDisplacement	; offset to previous nt
=$ce2e					XtPtr1 ::= *
=52650					WordListLink ::= Nt0 ; remember the nt of this word for later
.ce2e					Erase:
.ce2e	20 f7 c7	jsr $c7f7			jsr Zero
.ce31	4c 4b ce	jmp $ce4b			jmp Fill
=6					CodeLen	.var *-XtPtr1
=$ce34					Here1 = *	; remember here
>ce2c	06					.byte CodeLen	;patch wh_CodeLength
>ce34	42 6c 61 6e 6b			Name0:	.text "Blank"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=52665					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>ce39	65					.byte (("Blank"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=15					LinkDisplacement = Nt0-WordListLink
>ce3a	10					.byte WordFlags	;wh_Flags
>ce3b	03					.byte 3	;wh_CodeLength
>ce3c	0f					  .byte LinkDisplacement	; offset to previous nt
=$ce3d					XtPtr1 ::= *
=52665					WordListLink ::= Nt0 ; remember the nt of this word for later
.ce3d					Blank:
.ce3d	20 13 c8	jsr $c813			jsr Bl
.ce40	4c 4b ce	jmp $ce4b			jmp Fill
=6					CodeLen	.var *-XtPtr1
=$ce43					Here1 = *	; remember here
>ce3b	06					.byte CodeLen	;patch wh_CodeLength
>ce43	46 69 6c 6c			Name0:	.text "Fill"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=52679					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>ce47	84					.byte (("Fill"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=14					LinkDisplacement = Nt0-WordListLink
>ce48	10					.byte WordFlags	;wh_Flags
>ce49	03					.byte 3	;wh_CodeLength
>ce4a	0e					  .byte LinkDisplacement	; offset to previous nt
=$ce4b					XtPtr1 ::= *
=52679					WordListLink ::= Nt0 ; remember the nt of this word for later
.ce4b					Fill:
.ce4b	e0 2b		cpx #$2b		cpx #(DDim-3)*2+1	; far enough below end of data stack (& not negative)?
.ce4d	b0 d3		bcs $ce22		bcs Throw_Stack_07
.ce4f	b5 28		lda $28,x			lda DStack+4,x		; tmp1= address
.ce51	85 14		sta $14				sta tmp1+0
.ce53	b5 29		lda $29,x			lda DStack+5,x
.ce55	85 15		sta $15				sta tmp1+1
.ce57	b5 26		lda $26,x			lda DStack+2,x		; tmp2= counter.lo
.ce59	85 16		sta $16				sta tmp2+0
.ce5b	f6 27		inc $27,x			inc DStack+3,x		; so decrement & test for 0 works
.ce5d	b5 24		lda $24,x			lda DStack+0,x		; A= fill byte
.ce5f	a0 00		ldy #$00			ldy #0
.ce61	c4 16		cpy $16		_loop:		cpy tmp2+0		; done?
.ce63	f0 09		beq $ce6e			beq _test2
.ce65	91 14		sta ($14),y	_3:		sta (tmp1),y		; store a byte
.ce67	c8		iny				iny			; to next byte
.ce68	d0 f7		bne $ce61			bne _loop
.ce6a	e6 15		inc $15				inc tmp1+1		; increment addr page
.ce6c	d0 f3		bne $ce61			bne _loop
.ce6e	d6 27		dec $27,x	_test2:		dec DStack+3,x		; any more pages?
.ce70	d0 f3		bne $ce65			bne _3
.ce72	4c 72 bd	jmp $bd72			jmp ThreeDrop	; Drop three cells off the Data Stack.
=42					CodeLen	.var *-XtPtr1
=$ce75					Here1 = *	; remember here
>ce49	2a					.byte CodeLen	;patch wh_CodeLength
>ce75	56 61 72 69 61 62 6c 65		Name0:	.text "Variable"	;  name of word as a string, ending at wh_NameLastChar
=8					NameLength = *-Name0
=52733					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>ce7d	a8					.byte (("Variable"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=54					LinkDisplacement = Nt0-WordListLink
>ce7e	10					.byte WordFlags	;wh_Flags
>ce7f	03					.byte 3	;wh_CodeLength
>ce80	36					  .byte LinkDisplacement	; offset to previous nt
=$ce81					XtPtr1 ::= *
=52733					WordListLink ::= Nt0 ; remember the nt of this word for later
.ce81	20 cd d1	jsr $d1cd	Variable:	jsr Create		; compile word header & push PFA
.ce84	a9 00		lda #$00	Z_Comma:	lda #0			; allot & initialize the variable's data
.ce86	a8		tay				tay
.ce87	4c 55 dd	jmp $dd55			jmp Comma_YA
=9					CodeLen	.var *-XtPtr1
=$ce8a					Here1 = *	; remember here
>ce7f	09					.byte CodeLen	;patch wh_CodeLength
>ce8a	32 56 61 72 69 61 62 6c		Name0:	.text "2Variable"	;  name of word as a string, ending at wh_NameLastChar
>ce92	65
=9					NameLength = *-Name0
=52755					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>ce93	a9					.byte (("2Variable"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=22					LinkDisplacement = Nt0-WordListLink
>ce94	10					.byte WordFlags	;wh_Flags
>ce95	03					.byte 3	;wh_CodeLength
>ce96	16					  .byte LinkDisplacement	; offset to previous nt
=$ce97					XtPtr1 ::= *
=52755					WordListLink ::= Nt0 ; remember the nt of this word for later
.ce97	20 81 ce	jsr $ce81	Two_variable:	jsr Variable		; compile word header & push PFA & 1st cell of data
.ce9a	4c 84 ce	jmp $ce84			jmp Z_Comma		; alloc & init 2nd cell of data
=6					CodeLen	.var *-XtPtr1
=$ce9d					Here1 = *	; remember here
>ce95	06					.byte CodeLen	;patch wh_CodeLength
>ce9d	43 6f 6e 73 74 61 6e 74		Name0:	.text "Constant"	;  name of word as a string, ending at wh_NameLastChar
=8					NameLength = *-Name0
=52773					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>cea5	88					.byte (("Constant"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=80					WordFlags ::= UF+NN	; modifiable copy, remember for later
=18					LinkDisplacement = Nt0-WordListLink
>cea6	50					.byte WordFlags	;wh_Flags
>cea7	03					.byte 3	;wh_CodeLength
>cea8	12					  .byte LinkDisplacement	; offset to previous nt
=$cea9					XtPtr1 ::= *
=52773					WordListLink ::= Nt0 ; remember the nt of this word for later
.cea9	20 0c c4	jsr $c40c	Constant:	jsr underflow_1
.ceac	20 20 d1	jsr $d120			jsr Header_Comma	; compile word header
.ceaf	20 60 c7	jsr $c760			jsr LitCompile		; compile code to load registers, & pick a subroutine
.ceb2	20 95 dd	jsr $dd95			jsr Jmp_Comma_NT_YA	; compile code to JMP to the subroutine
.ceb5	4c e0 cb	jmp $cbe0			jmp adjust_z		; fix word length
=15					CodeLen	.var *-XtPtr1
=$ceb8					Here1 = *	; remember here
>cea7	0f					.byte CodeLen	;patch wh_CodeLength
>ceb8	32 43 6f 6e 73 74 61 6e		Name0:	.text "2Constant"	;  name of word as a string, ending at wh_NameLastChar
>cec0	74
=9					NameLength = *-Name0
=52801					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>cec1	89					.byte (("2Constant"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=28					LinkDisplacement = Nt0-WordListLink
>cec2	10					.byte WordFlags	;wh_Flags
>cec3	03					.byte 3	;wh_CodeLength
>cec4	1c					  .byte LinkDisplacement	; offset to previous nt
=$cec5					XtPtr1 ::= *
=52801					WordListLink ::= Nt0 ; remember the nt of this word for later
.cec5					Two_constant:
.cec5	4c ee ce	jmp $ceee			jmp TwoValue
=3					CodeLen	.var *-XtPtr1
=$cec8					Here1 = *	; remember here
>cec3	03					.byte CodeLen	;patch wh_CodeLength
>cec8	56 61 6c 75 65			Name0:	.text "Value"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=52813					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>cecd	a5					.byte (("Value"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=12					LinkDisplacement = Nt0-WordListLink
>cece	10					.byte WordFlags	;wh_Flags
>cecf	03					.byte 3	;wh_CodeLength
>ced0	0c					  .byte LinkDisplacement	; offset to previous nt
=$ced1					XtPtr1 ::= *
=52813					WordListLink ::= Nt0 ; remember the nt of this word for later
.ced1	20 0c c4	jsr $c40c	Value:		jsr underflow_1
.ced4	20 20 d1	jsr $d120			jsr Header_Comma	; compile word header
.ced7	20 a1 c7	jsr $c7a1			jsr ldya_immed_comma	; compile lda # & ldy #
.ceda	a9 ba		lda #$ba			lda #<PushYA		; compile jmp PushYA
.cedc	a0 c7		ldy #$c7			ldy #>PushYA
.cede	20 8e dd	jsr $dd8e			jsr Jmp_Comma_YA
.cee1	4c e0 cb	jmp $cbe0			jmp adjust_z		; fix word length
=19					CodeLen	.var *-XtPtr1
=$cee4					Here1 = *	; remember here
>cecf	13					.byte CodeLen	;patch wh_CodeLength
>cee4	32 56 61 6c 75 65		Name0:	.text "2Value"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=52842					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>ceea	a6					.byte (("2Value"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=29					LinkDisplacement = Nt0-WordListLink
>ceeb	10					.byte WordFlags	;wh_Flags
>ceec	03					.byte 3	;wh_CodeLength
>ceed	1d					  .byte LinkDisplacement	; offset to previous nt
=$ceee					XtPtr1 ::= *
=52842					WordListLink ::= Nt0 ; remember the nt of this word for later
.ceee	20 20 d1	jsr $d120	TwoValue:	jsr Header_Comma	; compile word header
.cef1	a9 fe		lda #$fe			lda #<TwoValue_Runtime	; compile JSR TValue_Runtime
.cef3	a0 ce		ldy #$ce			ldy #>TwoValue_Runtime
.cef5	20 78 dd	jsr $dd78			jsr Jsr_Comma_YA
.cef8	20 e0 cb	jsr $cbe0			jsr adjust_z		; fix word length
.cefb	4c 62 dd	jmp $dd62			jmp Two_Comma		; compile the value, return
=16					CodeLen	.var *-XtPtr1
=$cefe					Here1 = *	; remember here
>ceec	10					.byte CodeLen	;patch wh_CodeLength
.cefe					TwoValue_Runtime:
.cefe	68		pla				pla			; pop RTS addr
.ceff	85 14		sta $14				sta tmp1+0
.cf01	68		pla				pla
.cf02	85 15		sta $15				sta tmp1+1
.cf04	a0 01		ldy #$01			ldy #1			; start at offset 1 (for RTS addr behavior)
.cf06	4c ee d5	jmp $d5ee			jmp Two_Fetch_Tmp1Y	; fetch the data, return
>cf09	54 6f				Name0:	.text "To"	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=52875					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>cf0b	e2					.byte (("To"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=24					WordFlags ::= NN+IM	; modifiable copy, remember for later
=33					LinkDisplacement = Nt0-WordListLink
>cf0c	18					.byte WordFlags	;wh_Flags
>cf0d	03					.byte 3	;wh_CodeLength
>cf0e	21					  .byte LinkDisplacement	; offset to previous nt
=$cf0f					XtPtr1 ::= *
=52875					WordListLink ::= Nt0 ; remember the nt of this word for later
.cf0f					To:
.cf0f	20 46 cc	jsr $cc46			jsr Tick		; We always need the xt of the target word
.cf12	b5 24		lda $24,x			lda DStack+0,x		; tmp1= xt
.cf14	b4 25		ldy $25,x			ldy DStack+1,x
.cf16	85 14		sta $14				sta tmp1+0
.cf18	84 15		sty $15				sty tmp1+1
.cf1a	a0 00		ldy #$00			ldy #0			; determine what type xt points at
.cf1c	b1 14		lda ($14),y			lda (tmp1),y
.cf1e	c9 a0		cmp #$a0			cmp #$a0		;   LDY #
.cf20	d0 38		bne $cf5a			bne _Test2
.cf22	a5 0a		lda $0a				lda state		; check compile state
.cf24	f0 20		beq $cf46			beq _Value_interpret
.cf26	a9 e3		lda #$e3			lda #<PopYA		; compile jsr PopYA
.cf28	a0 c3		ldy #$c3			ldy #>PopYA
.cf2a	20 78 dd	jsr $dd78			jsr Jsr_Comma_YA
.cf2d	a9 8c		lda #$8c			lda #$8C		; compile STY xt+1
.cf2f	20 3e dd	jsr $dd3e			jsr C_Comma_A
.cf32	20 9a da	jsr $da9a			jsr One_plus
.cf35	20 d2 df	jsr $dfd2			jsr Dup
.cf38	20 52 dd	jsr $dd52			jsr Comma
.cf3b	a9 8d		lda #$8d			lda #$8D		; compile STA xt+3
.cf3d	20 3e dd	jsr $dd3e			jsr C_Comma_A
.cf40	20 46 da	jsr $da46			jsr Cell_Plus
.cf43	4c 52 dd	jmp $dd52			jmp Comma
.cf46					_Value_interpret:
.cf46	20 20 c4	jsr $c420			jsr underflow_2		; ( n xt )
.cf49	e8		inx				inx			; Drop xt
.cf4a	e8		inx				inx
.cf4b	b5 24		lda $24,x			lda DStack+0,x		; LSB
.cf4d	a0 03		ldy #$03			ldy #3			;   modify LDA # data
.cf4f	91 14		sta ($14),y			sta (tmp1),y
.cf51	b5 25		lda $25,x			lda DStack+1,x		; MSB
.cf53	a0 01		ldy #$01			ldy #1			;   modify LDY # data
.cf55	91 14		sta ($14),y			sta (tmp1),y
.cf57	e8		inx				inx			; Drop n
.cf58	e8		inx				inx
.cf59	60		rts				rts
.cf5a	c9 20		cmp #$20	_Test2:		cmp #$20		;   JSR abs ?
.cf5c	d0 48		bne $cfa6			bne _Err
.cf5e	a9 03		lda #$03			lda #3			; advance xt over the JSR abs to the data
.cf60	20 48 da	jsr $da48			jsr Plus_A
.cf63	a0 01		ldy #$01			ldy #1			; get JSR abs addr lo byte
.cf65	b1 14		lda ($14),y			lda (tmp1),y
.cf67	c9 fe		cmp #$fe			cmp #<TwoValue_Runtime
.cf69	d0 11		bne $cf7c			bne _Test3
.cf6b	a5 0a		lda $0a				lda state		; check compile state
.cf6d	f0 0a		beq $cf79			beq _2Value_runtime
.cf6f	20 a1 c7	jsr $c7a1			jsr ldya_immed_comma	; compile LDY #; LDA #  of xt+3
.cf72	a9 bd		lda #$bd			lda #<Two_Store_YA
.cf74	a0 d5		ldy #$d5			ldy #>Two_Store_YA
.cf76	4c 78 dd	jmp $dd78			jmp Jsr_Comma_YA	; compile JSR Two_Store_YA; return
.cf79	4c ba d5	jmp $d5ba	_2Value_runtime: jmp Two_Store
.cf7c					_Test3:
.cf7c	c9 5e		cmp #$5e			cmp #<FValue_runtime
.cf7e	d0 11		bne $cf91			bne _Test4
.cf80	a5 0a		lda $0a				lda state		; check compile state
.cf82	f0 0a		beq $cf8e			beq _FValue_interpret
.cf84	20 a1 c7	jsr $c7a1			jsr ldya_immed_comma	; compile LDY #; LDA #  of xt+3
.cf87	a9 7f		lda #$7f			lda #<FStore_YA
.cf89	a0 86		ldy #$86			ldy #>FStore_YA
.cf8b	4c 78 dd	jmp $dd78			jmp Jsr_Comma_YA	; compile JSR FStore_YA; return
.cf8e	4c 7c 86	jmp $867c	_FValue_interpret: jmp FStore
.cf91					_Test4:
.cf91	c9 d7		cmp #$d7			cmp #<EValue_runtime
.cf93	d0 11		bne $cfa6			bne _Err
.cf95	a5 0a		lda $0a				lda state		; check compile state
.cf97	f0 0a		beq $cfa3			beq _EValue_interpret
.cf99	20 a1 c7	jsr $c7a1			jsr ldya_immed_comma	; compile LDY #; LDA #  of xt+3
.cf9c	a9 0e		lda #$0e			lda #<EStore_YA
.cf9e	a0 9c		ldy #$9c			ldy #>EStore_YA
.cfa0	4c 78 dd	jmp $dd78			jmp Jsr_Comma_YA	; compile JSR EStore_YA; return
.cfa3	4c 0b 9c	jmp $9c0b	_EValue_interpret: jmp EStore
.cfa6	a9 e0		lda #$e0	_Err:		lda #$100+err_InvalidName ; unrecognized type.
.cfa8	20 68 c4	jsr $c468			jsr ThrowA
=156					CodeLen	.var *-XtPtr1
=$cfab					Here1 = *	; remember here
>cf0d	9c					.byte CodeLen	;patch wh_CodeLength
>cfab	44 4d 61 78			Name0:	.text "DMax"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=53039					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>cfaf	04					.byte (("DMax"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=164					LinkDisplacement = Nt0-WordListLink
>cfb0	10					.byte WordFlags	;wh_Flags
>cfb1	03					.byte 3	;wh_CodeLength
>cfb2	a4					  .byte LinkDisplacement	; offset to previous nt
=$cfb3					XtPtr1 ::= *
=53039					WordListLink ::= Nt0 ; remember the nt of this word for later
.cfb3	a9 80		lda #$80	DMax:		lda #$80
.cfb5	d0 0d		bne $cfc4			bne DMin3
=4					CodeLen	.var *-XtPtr1
=$cfb7					Here1 = *	; remember here
>cfb1	04					.byte CodeLen	;patch wh_CodeLength
.cfb7	4c 2f c4	jmp $c42f	Throw_Stack_23: jmp Throw_Stack
>cfba	44 4d 69 6e			Name0:	.text "DMin"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=53054					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>cfbe	c4					.byte (("DMin"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=15					LinkDisplacement = Nt0-WordListLink
>cfbf	10					.byte WordFlags	;wh_Flags
>cfc0	03					.byte 3	;wh_CodeLength
>cfc1	0f					  .byte LinkDisplacement	; offset to previous nt
=$cfc2					XtPtr1 ::= *
=53054					WordListLink ::= Nt0 ; remember the nt of this word for later
.cfc2	a9 00		lda #$00	DMin:		lda #0
.cfc4	85 16		sta $16		DMin3:		sta tmp2	; save sign correction
.cfc6	e0 29		cpx #$29		cpx #(DDim-4)*2+1	; far enough below end of data stack (& not negative)?
.cfc8	b0 ed		bcs $cfb7		bcs Throw_Stack_23
.cfca	b5 26		lda $26,x			lda DStack+2,x	; compare
.cfcc	d5 2a		cmp $2a,x			cmp DStack+6,x
.cfce	b5 27		lda $27,x			lda DStack+3,x
.cfd0	f5 2b		sbc $2b,x			sbc DStack+7,x
.cfd2	b5 24		lda $24,x			lda DStack+0,x
.cfd4	f5 28		sbc $28,x			sbc DStack+4,x
.cfd6	b5 25		lda $25,x			lda DStack+1,x
.cfd8	f5 29		sbc $29,x			sbc DStack+5,x
.cfda	50 02		bvc $cfde			bvc +
.cfdc	49 80		eor #$80			eor #$80	; fix sign
.cfde	45 16		eor $16		+		eor tmp2
.cfe0	30 0f		bmi $cff1			bmi TwoNip_nouf	; if negative, NOS is larger and needs to be kept
.cfe2	4c 72 d5	jmp $d572			jmp Two_Drop
=35					CodeLen	.var *-XtPtr1
=$cfe5					Here1 = *	; remember here
>cfc0	23					.byte CodeLen	;patch wh_CodeLength
>cfe5	32 4e 69 70			Name0:	.text "2Nip"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=53097					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>cfe9	04					.byte (("2Nip"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=43					LinkDisplacement = Nt0-WordListLink
>cfea	10					.byte WordFlags	;wh_Flags
>cfeb	03					.byte 3	;wh_CodeLength
>cfec	2b					  .byte LinkDisplacement	; offset to previous nt
=$cfed					XtPtr1 ::= *
=53097					WordListLink ::= Nt0 ; remember the nt of this word for later
.cfed					TwoNip:
.cfed	e0 29		cpx #$29		cpx #(DDim-4)*2+1	; far enough below end of data stack (& not negative)?
.cfef	b0 62		bcs $d053		bcs Throw_Stack_25
.cff1	b5 24		lda $24,x	TwoNip_NoUf:	lda DStack+0,x	; copy dTOS to dNOS
.cff3	95 28		sta $28,x			sta DStack+4,x
.cff5	b5 25		lda $25,x			lda DStack+1,x
.cff7	95 29		sta $29,x			sta DStack+5,x
.cff9	b5 26		lda $26,x			lda DStack+2,x
.cffb	95 2a		sta $2a,x			sta DStack+6,x
.cffd	b5 27		lda $27,x			lda DStack+3,x
.cfff	95 2b		sta $2b,x			sta DStack+7,x
.d001	4c 72 d5	jmp $d572			jmp Two_Drop
=23					CodeLen	.var *-XtPtr1
=$d004					Here1 = *	; remember here
>cfeb	17					.byte CodeLen	;patch wh_CodeLength
>d004	53 3e 44			Name0:	.text "S>D"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=53127					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>d007	83					.byte (("S>D"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=30					LinkDisplacement = Nt0-WordListLink
>d008	10					.byte WordFlags	;wh_Flags
>d009	03					.byte 3	;wh_CodeLength
>d00a	1e					  .byte LinkDisplacement	; offset to previous nt
=$d00b					XtPtr1 ::= *
=53127					WordListLink ::= Nt0 ; remember the nt of this word for later
.d00b					S_To_D:
.d00b	e0 2f		cpx #$2f		cpx #(DDim-1)*2+1	; far enough below end of data stack (& not negative)?
.d00d	b0 44		bcs $d053		bcs Throw_Stack_25
.d00f	a0 00		ldy #$00			ldy #0			; assume positive
.d011	b5 25		lda $25,x			lda DStack+1,x		; test n
.d013	10 01		bpl $d016			bpl +
.d015	88		dey				dey			; make negative
.d016					+
.d016	ca		dex				dex			; push new hi cell
.d017	ca		dex				dex
.d018	94 24		sty $24,x			sty DStack+0,x
.d01a	94 25		sty $25,x			sty DStack+1,x
=17					CodeLen	.var *-XtPtr1
=$d01c					Here1 = *	; remember here
>d009	11					.byte CodeLen	;patch wh_CodeLength
.d01c	60		rts				rts
>d01d	44 3e 53			Name0:	.text "D>S"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=53152					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>d020	63					.byte (("D>S"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=25					LinkDisplacement = Nt0-WordListLink
>d021	10					.byte WordFlags	;wh_Flags
>d022	03					.byte 3	;wh_CodeLength
>d023	19					  .byte LinkDisplacement	; offset to previous nt
=$d024					XtPtr1 ::= *
=53152					WordListLink ::= Nt0 ; remember the nt of this word for later
.d024					D_To_S:
.d024	e0 2d		cpx #$2d		cpx #(DDim-2)*2+1	; far enough below end of data stack (& not negative)?
.d026	b0 2b		bcs $d053		bcs Throw_Stack_25
.d028	e8		inx				inx		; Drop hi cell
.d029	e8		inx				inx
=6					CodeLen	.var *-XtPtr1
=$d02a					Here1 = *	; remember here
>d022	06					.byte CodeLen	;patch wh_CodeLength
.d02a	60		rts				rts
>d02b	44 2d				Name0:	.text "D-"	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=53165					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>d02d	a2					.byte (("D-"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>d02e	10					.byte WordFlags	;wh_Flags
>d02f	03					.byte 3	;wh_CodeLength
>d030	0d					  .byte LinkDisplacement	; offset to previous nt
=$d031					XtPtr1 ::= *
=53165					WordListLink ::= Nt0 ; remember the nt of this word for later
.d031					D_Minus:
.d031	e0 29		cpx #$29		cpx #(DDim-4)*2+1	; far enough below end of data stack (& not negative)?
.d033	b0 1e		bcs $d053		bcs Throw_Stack_25
.d035	38		sec				sec
.d036	b5 2a		lda $2a,x			lda DStack+6,x	; LSB of lower word
.d038	f5 26		sbc $26,x			sbc DStack+2,x
.d03a	95 2a		sta $2a,x			sta DStack+6,x
.d03c	b5 2b		lda $2b,x			lda DStack+7,x	; MSB of lower word
.d03e	f5 27		sbc $27,x			sbc DStack+3,x
.d040	95 2b		sta $2b,x			sta DStack+7,x
.d042	b5 28		lda $28,x			lda DStack+4,x	; LSB of upper word
.d044	f5 24		sbc $24,x			sbc DStack+0,x
.d046	95 28		sta $28,x			sta DStack+4,x
.d048	b5 29		lda $29,x			lda DStack+5,x	; MSB of upper word
.d04a	f5 25		sbc $25,x			sbc DStack+1,x
.d04c	95 29		sta $29,x			sta DStack+5,x
.d04e	e8		inx				inx
.d04f	e8		inx				inx
.d050	e8		inx				inx
.d051	e8		inx				inx
=33					CodeLen	.var *-XtPtr1
=$d052					Here1 = *	; remember here
>d02f	21					.byte CodeLen	;patch wh_CodeLength
.d052	60		rts				rts
.d053	4c 2f c4	jmp $c42f	Throw_Stack_25: jmp Throw_Stack
>d056	44 2b				Name0:	.text "D+"	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=53208					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>d058	62					.byte (("D+"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=43					LinkDisplacement = Nt0-WordListLink
>d059	10					.byte WordFlags	;wh_Flags
>d05a	03					.byte 3	;wh_CodeLength
>d05b	2b					  .byte LinkDisplacement	; offset to previous nt
=$d05c					XtPtr1 ::= *
=53208					WordListLink ::= Nt0 ; remember the nt of this word for later
.d05c					D_Plus:
.d05c	e0 29		cpx #$29		cpx #(DDim-4)*2+1	; far enough below end of data stack (& not negative)?
.d05e	b0 f3		bcs $d053		bcs Throw_Stack_25
.d060	b5 26		lda $26,x			lda DStack+2,x	; LSB of lower word
.d062	75 2a		adc $2a,x			adc DStack+6,x
.d064	95 2a		sta $2a,x			sta DStack+6,x
.d066	b5 27		lda $27,x			lda DStack+3,x	; MSB of lower word
.d068	75 2b		adc $2b,x			adc DStack+7,x
.d06a	95 2b		sta $2b,x			sta DStack+7,x
.d06c	b5 24		lda $24,x			lda DStack+0,x	; LSB of upper word
.d06e	75 28		adc $28,x			adc DStack+4,x
.d070	95 28		sta $28,x			sta DStack+4,x
.d072	b5 25		lda $25,x			lda DStack+1,x	; MSB of upper word
.d074	75 29		adc $29,x			adc DStack+5,x
.d076	95 29		sta $29,x			sta DStack+5,x
.d078	e8		inx				inx
.d079	e8		inx				inx
.d07a	e8		inx				inx
.d07b	e8		inx				inx
=32					CodeLen	.var *-XtPtr1
=$d07c					Here1 = *	; remember here
>d05a	20					.byte CodeLen	;patch wh_CodeLength
.d07c	60		rts				rts
>d07d	44 31 2b			Name0:	.text "D1+"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=53248					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>d080	63					.byte (("D1+"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=40					LinkDisplacement = Nt0-WordListLink
>d081	10					.byte WordFlags	;wh_Flags
>d082	03					.byte 3	;wh_CodeLength
>d083	28					  .byte LinkDisplacement	; offset to previous nt
=$d084					XtPtr1 ::= *
=53248					WordListLink ::= Nt0 ; remember the nt of this word for later
.d084					D1Plus:
.d084	e0 29		cpx #$29		cpx #(DDim-4)*2+1	; far enough below end of data stack (& not negative)?
.d086	b0 cb		bcs $d053		bcs Throw_Stack_25
.d088	f6 26		inc $26,x			inc DStack+2,x
.d08a	d0 0a		bne $d096			bne +
.d08c	f6 27		inc $27,x			inc DStack+3,x
.d08e	d0 06		bne $d096			bne +
.d090	f6 24		inc $24,x			inc DStack+0,x
.d092	d0 02		bne $d096			bne +
.d094	f6 25		inc $25,x			inc DStack+1,x
.d096					+
=18					CodeLen	.var *-XtPtr1
=$d096					Here1 = *	; remember here
>d082	12					.byte CodeLen	;patch wh_CodeLength
.d096	60		rts				rts
>d097	44 31 2d			Name0:	.text "D1-"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=53274					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>d09a	a3					.byte (("D1-"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=26					LinkDisplacement = Nt0-WordListLink
>d09b	10					.byte WordFlags	;wh_Flags
>d09c	03					.byte 3	;wh_CodeLength
>d09d	1a					  .byte LinkDisplacement	; offset to previous nt
=$d09e					XtPtr1 ::= *
=53274					WordListLink ::= Nt0 ; remember the nt of this word for later
.d09e					D1Minus:
.d09e	e0 29		cpx #$29		cpx #(DDim-4)*2+1	; far enough below end of data stack (& not negative)?
.d0a0	b0 b1		bcs $d053		bcs Throw_Stack_25
.d0a2	b5 26		lda $26,x			lda DStack+2,x
.d0a4	d0 0e		bne $d0b4			bne _1
.d0a6	b5 27		lda $27,x			lda DStack+3,x
.d0a8	d0 08		bne $d0b2			bne _2
.d0aa	b5 24		lda $24,x			lda DStack+0,x
.d0ac	d0 02		bne $d0b0			bne _3
.d0ae	d6 25		dec $25,x			dec DStack+1,x
.d0b0	d6 24		dec $24,x	_3:		dec DStack+0,x
.d0b2	d6 27		dec $27,x	_2:		dec DStack+3,x
.d0b4	d6 26		dec $26,x	_1:		dec DStack+2,x
=24					CodeLen	.var *-XtPtr1
=$d0b6					Here1 = *	; remember here
>d09c	18					.byte CodeLen	;patch wh_CodeLength
.d0b6	60		rts				rts
.d0b7	20 e9 c7	jsr $c7e9	Allot_ZA:	jsr PushZA
.d0ba	4c c6 d0	jmp $d0c6			jmp Allot
>d0bd	41 6c 6c 6f 74			Name0:	.text "Allot"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=53314					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>d0c2	85					.byte (("Allot"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=40					LinkDisplacement = Nt0-WordListLink
>d0c3	10					.byte WordFlags	;wh_Flags
>d0c4	03					.byte 3	;wh_CodeLength
>d0c5	28					  .byte LinkDisplacement	; offset to previous nt
=$d0c6					XtPtr1 ::= *
=53314					WordListLink ::= Nt0 ; remember the nt of this word for later
.d0c6					Allot:
.d0c6	e0 2f		cpx #$2f		cpx #(DDim-1)*2+1	; far enough below end of data stack (& not negative)?
.d0c8	b0 89		bcs $d053		bcs Throw_Stack_25
.d0ca	18		clc				clc			; adjust cp
.d0cb	b5 24		lda $24,x			lda DStack+0,x
.d0cd	65 00		adc $00				adc cp+0
.d0cf	85 00		sta $00				sta cp+0
.d0d1	a8		tay				tay			;   save lo byte
.d0d2	b5 25		lda $25,x			lda DStack+1,x
.d0d4	85 14		sta $14				sta tmp1
.d0d6	65 01		adc $01				adc cp+1
.d0d8	85 01		sta $01				sta cp+1
.d0da	24 14		bit $14				bit tmp1
.d0dc	30 15		bmi $d0f3			bmi _release
.d0de	b0 06		bcs $d0e6			bcs _pos_err		; carry from the add is bad
=32600					_last = cp_end-2*PadOffset
.d0e0	c0 58		cpy #$58			cpy #<_last		; cp < cp_end ?
.d0e2	e9 7f		sbc #$7f			sbc #>_last
.d0e4	90 2c		bcc $d112			bcc _done		; we're fine.
.d0e6					_pos_err:
.d0e6	a9 58		lda #$58			lda #<_last
.d0e8	85 00		sta $00				sta cp+0
.d0ea	a9 7f		lda #$7f			lda #>_last
.d0ec	85 01		sta $01				sta cp+1
.d0ee	a9 c5		lda #$c5			lda #$100+err_Allocate
.d0f0	4c 68 c4	jmp $c468			jmp ThrowA
.d0f3					_release:
.d0f3	90 06		bcc $d0fb			bcc _neg_err		; borrow indicates we've gone below 0
.d0f5	c0 66		cpy #$66			cpy #<cp0
.d0f7	e9 0b		sbc #$0b			sbc #>cp0
.d0f9	b0 17		bcs $d112			bcs _done
.d0fb					_neg_err:
.d0fb	a9 66		lda #$66			lda #<cp0		; Set CP to CP0
.d0fd	85 00		sta $00				sta cp+0
.d0ff	a9 0b		lda #$0b			lda #>cp0
.d101	85 01		sta $01				sta cp+1
.d103	a9 8c		lda #$8c			lda #<forth_dictionary_start	; set WordLists[Forth] to the first
.d105	8d 12 03	sta $0312			sta WordlistsV+0		; word in ROM
.d108	a9 df		lda #$df			lda #>forth_dictionary_start
.d10a	8d 13 03	sta $0313			sta WordlistsV+1
.d10d	a9 c4		lda #$c4			lda #$100+err_Free		; abort with an error
.d10f	4c 68 c4	jmp $c468			jmp ThrowA
.d112					_done:
.d112	e8		inx				inx			; Drop n
.d113	e8		inx				inx
=78					CodeLen	.var *-XtPtr1
=$d114					Here1 = *	; remember here
>d0c4	4e					.byte CodeLen	;patch wh_CodeLength
.d114	60		rts				rts
>d115	48 65 61 64 65 72 2c		Name0:	.text "Header,"	;  name of word as a string, ending at wh_NameLastChar
=7					NameLength = *-Name0
=53404					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>d11c	87					.byte (("Header,"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=90					LinkDisplacement = Nt0-WordListLink
>d11d	10					.byte WordFlags	;wh_Flags
>d11e	03					.byte 3	;wh_CodeLength
>d11f	5a					  .byte LinkDisplacement	; offset to previous nt
=$d120					XtPtr1 ::= *
=53404					WordListLink ::= Nt0 ; remember the nt of this word for later
.d120					Header_Comma:
.d120	20 2e d1	jsr $d12e			jsr Header_Build
.d123					Header_Link:
.d123	a5 0e		lda $0e				lda WorkWord+0		; dp= WorkWord
.d125	85 10		sta $10				sta dp+0
.d127	a5 0f		lda $0f				lda WorkWord+1
.d129	85 11		sta $11				sta dp+1
.d12b	4c 69 ca	jmp $ca69			jmp dp_to_current	; Update the CURRENT wordlist with the new DP.
.d12e					Header_Build:
.d12e	20 b8 ca	jsr $cab8			jsr parse_name_check	; get name string, throw error if empty string
.d131	20 f6 dc	jsr $dcf6			jsr Two_dup		; ( addr u addr u )
.d134	20 a3 b0	jsr $b0a3			jsr Get_Current
.d137	20 bd b1	jsr $b1bd			jsr Search_WordList	; ( addr u xt f ) or ( addr u 0 )
.d13a	e8		inx				inx			; pop flag.
.d13b	e8		inx				inx
.d13c	b5 22		lda $22,x			lda DStack-2,x		; not found?
.d13e	f0 21		beq $d161			beq _new_name		; We haven't seen this one before.
.d140	e8		inx				inx			; Drop xt
.d141	e8		inx				inx
.d142	24 0c		bit $0c				bit status		; Check bit 7
.d144	10 08		bpl $d14e			bpl _redefined_name	; Bit 7 is zero, so print the message.
.d146	a9 80		lda #$80			lda #$80		; Set bit 7 to indicate dup
.d148	05 0c		ora $0c				ora status
.d14a	85 0c		sta $0c				sta status
.d14c	d0 19		bne $d167			bne _process_name
.d14e					_redefined_name:
.d14e	a9 c1		lda #$c1			lda #<str_redefined
.d150	a0 ea		ldy #$ea			ldy #>str_redefined
.d152	20 55 de	jsr $de55			jsr Print_ASCIIZ_YA_no_lf
.d155	20 f6 dc	jsr $dcf6			jsr Two_dup		 ; ( addr u addr u )
.d158	20 39 de	jsr $de39			jsr Type
.d15b	20 2d de	jsr $de2d			jsr Space
.d15e	4c 67 d1	jmp $d167			jmp _process_name
.d161					_new_name:
.d161	a9 7f		lda #$7f			lda #$7F		; Clear bit 0 of status to indicate new word.
.d163	25 0c		and $0c				and status
.d165	85 0c		sta $0c				sta status
.d167					_process_name:
.d167	20 f6 dc	jsr $dcf6			jsr Two_dup		; compile name string ending at wh_NameLastChar
.d16a	20 67 da	jsr $da67			jsr Here
.d16d	20 f3 df	jsr $dff3			jsr Swap
.d170	20 c9 bd	jsr $bdc9			jsr CMove
.d173	b5 24		lda $24,x			lda DStack+0,x		;   save length
.d175	20 b7 d0	jsr $d0b7			jsr Allot_ZA
.d178	38		sec				sec
.d179	a5 00		lda $00				lda cp+0		; WorkWord= nt
.d17b	e9 80		sbc #$80			sbc #wh_NameLastChar+1
.d17d	85 0e		sta $0e				sta WorkWord+0
.d17f	a5 01		lda $01				lda cp+1
.d181	e9 00		sbc #$00			sbc #0
.d183	85 0f		sta $0f				sta WorkWord+1
.d185	a0 7f		ldy #$7f			ldy #wh_NameLastChar
.d187	b1 0e		lda ($0e),y			lda (WorkWord),y
.d189	0a		asl a				asl a
.d18a	0a		asl a				asl a
.d18b	0a		asl a				asl a
.d18c	0a		asl a				asl a
.d18d	0a		asl a				asl a
.d18e	15 24		ora $24,x			ora DStack+0,x
.d190	95 24		sta $24,x			sta DStack+0,x
.d192	20 3b dd	jsr $dd3b			jsr C_Comma		; compile wh_HashNameLen
.d195	e8		inx				inx			; drop name string addr
.d196	e8		inx				inx
.d197	a9 10		lda #$10			lda #NN			; compile wh_Flags
.d199	20 3e dd	jsr $dd3e			jsr C_Comma_A
.d19c	a9 03		lda #$03			lda #3			; compile wh_CodeLength (temporary value, see adjust_z)
.d19e	20 3e dd	jsr $dd3e			jsr C_Comma_A
.d1a1	20 59 ca	jsr $ca59			jsr current_to_dp	; Get the CURRENT dictionary pointer.
.d1a4	38		sec				sec
.d1a5	a5 0e		lda $0e				lda WorkWord+0
.d1a7	e5 10		sbc $10				sbc dp+0
.d1a9	a8		tay				tay
.d1aa	a5 0f		lda $0f				lda WorkWord+1
.d1ac	e5 11		sbc $11				sbc dp+1
.d1ae	f0 0f		beq $d1bf			beq _LinkShort
.d1b0	a0 81		ldy #$81			ldy #wh_Flags		; set FP flag
.d1b2	b1 0e		lda ($0e),y			lda (WorkWord),y
.d1b4	09 01		ora #$01			ora #FP
.d1b6	91 0e		sta ($0e),y			sta (WorkWord),y
.d1b8	a5 10		lda $10				lda dp+0		; compile wh_LinkNt ptr word
.d1ba	a4 11		ldy $11				ldy dp+1
.d1bc	4c 55 dd	jmp $dd55			jmp Comma_YA
.d1bf	98		tya		_LinkShort:	tya			; compile wh_LinkNt offset byte
.d1c0	4c 3e dd	jmp $dd3e			jmp C_Comma_A
=163					CodeLen	.var *-XtPtr1
=$d1c3					Here1 = *	; remember here
>d11e	a3					.byte CodeLen	;patch wh_CodeLength
>d1c3	43 72 65 61 74 65		Name0:	.text "Create"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=53577					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>d1c9	a6					.byte (("Create"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=173					LinkDisplacement = Nt0-WordListLink
>d1ca	10					.byte WordFlags	;wh_Flags
>d1cb	03					.byte 3	;wh_CodeLength
>d1cc	ad					  .byte LinkDisplacement	; offset to previous nt
=$d1cd					XtPtr1 ::= *
=53577					WordListLink ::= Nt0 ; remember the nt of this word for later
.d1cd					Create:
.d1cd	20 20 d1	jsr $d120			jsr Header_Comma	; compile word header
.d1d0	a9 da		lda #$da			lda #<DoVar		; compile JSR DoVar
.d1d2	a0 d1		ldy #$d1			ldy #>DoVar
.d1d4	20 78 dd	jsr $dd78			jsr Jsr_Comma_YA
.d1d7	4c e0 cb	jmp $cbe0			jmp adjust_z
=13					CodeLen	.var *-XtPtr1
=$d1da					Here1 = *	; remember here
>d1cb	0d					.byte CodeLen	;patch wh_CodeLength
.d1da					DoVar:
.d1da	68		pla				pla		; Pull the return address off the machine's stack
.d1db	18		clc				clc		;   +1 because of the way the JSR works
.d1dc	69 01		adc #$01			adc #1
.d1de	ca		dex				dex		; push on data stack
.d1df	ca		dex				dex
.d1e0	95 24		sta $24,x			sta DStack+0,x
.d1e2	68		pla				pla
.d1e3	69 00		adc #$00			adc #0
.d1e5	95 25		sta $25,x			sta DStack+1,x
.d1e7	60		rts				rts		; takes us to the original caller of the
>d1e8	44 6f 65 73 3e			Name0:	.text "Does>"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=53613					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>d1ed	c5					.byte (("Does>"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=28					WordFlags ::= CO+IM+NN	; modifiable copy, remember for later
=36					LinkDisplacement = Nt0-WordListLink
>d1ee	1c					.byte WordFlags	;wh_Flags
>d1ef	03					.byte 3	;wh_CodeLength
>d1f0	24					  .byte LinkDisplacement	; offset to previous nt
=$d1f1					XtPtr1 ::= *
=53613					WordListLink ::= Nt0 ; remember the nt of this word for later
.d1f1					Does:
.d1f1	a0 d2		ldy #$d2			ldy #>_runtime		; compile JSR _runtime
.d1f3	a9 0b		lda #$0b			lda #<_runtime
.d1f5	20 78 dd	jsr $dd78			jsr Jsr_Comma_YA
.d1f8	a9 68		lda #$68			lda #$68		; compile PLA  to pop RTS addr (PFA-1) to AY
.d1fa	a0 a8		ldy #$a8			ldy #$a8		;    & TAY
.d1fc	20 55 dd	jsr $dd55			jsr Comma_YA
.d1ff	a9 68		lda #$68			lda #$68		; compile PLA
.d201	20 3e dd	jsr $dd3e			jsr C_Comma_A
.d204	a0 d2		ldy #$d2			ldy #>_DoDoes		; compile JSR _DoDoes
.d206	a9 28		lda #$28			lda #<_DoDoes
.d208	4c 78 dd	jmp $dd78			jmp Jsr_Comma_YA
=26					CodeLen	.var *-XtPtr1
=$d20b					Here1 = *	; remember here
>d1ef	1a					.byte CodeLen	;patch wh_CodeLength
.d20b					_runtime:
.d20b	20 59 ca	jsr $ca59			jsr current_to_dp	; Grab the DP from the CURRENT wordlist.
.d20e	a5 10		lda $10				lda dp+0		; tmp1= dp
.d210	a4 11		ldy $11				ldy dp+1
.d212	85 14		sta $14				sta tmp1+0
.d214	84 15		sty $15				sty tmp1+1
.d216	20 bb cd	jsr $cdbb			jsr NameToIntTmp	; tmp2= xt
.d219	18		clc				clc
.d21a	68		pla				pla		; RTS addr LSB
.d21b	69 01		adc #$01			adc #1		;   +1 for JSR bahavior
.d21d	a0 01		ldy #$01			ldy #1
.d21f	91 16		sta ($16),y			sta (tmp2),y
.d221	68		pla				pla		; RTS addr MSB
.d222	69 00		adc #$00			adc #0
.d224	c8		iny				iny
.d225	91 16		sta ($16),y			sta (tmp2),y
.d227	60		rts				rts
.d228					_DoDoes:
.d228	c8		iny				iny		; +1 for JSR behavior
.d229	d0 03		bne $d22e			bne +
.d22b	18		clc				clc
.d22c	69 01		adc #$01			adc #1
.d22e					+
.d22e	4c e4 df	jmp $dfe4			jmp PushAY
>d231	43 70 45 6e 64			Name0:	.text "CpEnd"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=53686					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>d236	85					.byte (("CpEnd"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=73					LinkDisplacement = Nt0-WordListLink
>d237	10					.byte WordFlags	;wh_Flags
>d238	03					.byte 3	;wh_CodeLength
>d239	49					  .byte LinkDisplacement	; offset to previous nt
=$d23a					XtPtr1 ::= *
=53686					WordListLink ::= Nt0 ; remember the nt of this word for later
.d23a	a9 00		lda #$00			lda #<cp_end
.d23c	a0 80		ldy #$80			ldy #>cp_end
.d23e	4c ba c7	jmp $c7ba			jmp PushYA
>d241	55 6e 75 73 65 64		Name0:	.text "Unused"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=53703					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>d247	86					.byte (("Unused"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=17					LinkDisplacement = Nt0-WordListLink
>d248	10					.byte WordFlags	;wh_Flags
>d249	03					.byte 3	;wh_CodeLength
>d24a	11					  .byte LinkDisplacement	; offset to previous nt
=$d24b					XtPtr1 ::= *
=53703					WordListLink ::= Nt0 ; remember the nt of this word for later
.d24b					Unused:
=32600					_last = cp_end-2*padoffset
.d24b	38		sec				sec
.d24c	a9 58		lda #$58			lda #<_last
.d24e	e5 00		sbc $00				sbc cp+0
.d250	a8		tay				tay
.d251	a9 7f		lda #$7f			lda #>_last
.d253	e5 01		sbc $01				sbc cp+1
.d255	4c e4 df	jmp $dfe4			jmp PushAY
=13					CodeLen	.var *-XtPtr1
=$d258					Here1 = *	; remember here
>d249	0d					.byte CodeLen	;patch wh_CodeLength
>d258	44 65 70 74 68			Name0:	.text "Depth"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=53725					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>d25d	05					.byte (("Depth"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=22					LinkDisplacement = Nt0-WordListLink
>d25e	10					.byte WordFlags	;wh_Flags
>d25f	03					.byte 3	;wh_CodeLength
>d260	16					  .byte LinkDisplacement	; offset to previous nt
=$d261					XtPtr1 ::= *
=53725					WordListLink ::= Nt0 ; remember the nt of this word for later
.d261					Depth:
.d261	a9 30		lda #$30			lda #DDim*2	; A= DDim*2 - X
.d263	86 1a		stx $1a				stx tmp4
.d265	38		sec				sec
.d266	e5 1a		sbc $1a				sbc tmp4
.d268	4a		lsr a				lsr		; divide by two because each cell is two bytes
.d269	4c e9 c7	jmp $c7e9			jmp PushZA
=11					CodeLen	.var *-XtPtr1
=$d26c					Here1 = *	; remember here
>d25f	0b					.byte CodeLen	;patch wh_CodeLength
>d26c	4b 65 79			Name0:	.text "Key"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=53743					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>d26f	23					.byte (("Key"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=18					LinkDisplacement = Nt0-WordListLink
>d270	10					.byte WordFlags	;wh_Flags
>d271	03					.byte 3	;wh_CodeLength
>d272	12					  .byte LinkDisplacement	; offset to previous nt
=$d273					XtPtr1 ::= *
=53743					WordListLink ::= Nt0 ; remember the nt of this word for later
.d273	20 79 d2	jsr $d279	Key:		jsr key_a		; returns char in A
.d276	4c e9 c7	jmp $c7e9			jmp PushZA
=6					CodeLen	.var *-XtPtr1
=$d279					Here1 = *	; remember here
>d271	06					.byte CodeLen	;patch wh_CodeLength
.d279					Key_A:
.d279	6c 08 03	jmp ($0308)			jmp (input)		; JSR/RTS
>d27c	4b 65 79 3f			Name0:	.text "Key?"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=53760					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>d280	e4					.byte (("Key?"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=17					LinkDisplacement = Nt0-WordListLink
>d281	10					.byte WordFlags	;wh_Flags
>d282	03					.byte 3	;wh_CodeLength
>d283	11					  .byte LinkDisplacement	; offset to previous nt
=$d284					XtPtr1 ::= *
=53760					WordListLink ::= Nt0 ; remember the nt of this word for later
.d284	20 8a d2	jsr $d28a	KeyQ:		jsr KeyQ_A
.d287	4c e9 c7	jmp $c7e9			jmp PushZA
.d28a	6c 0a 03	jmp ($030a)	KeyQ_A:		jmp (HaveKey)
>d28d	52 65 66 69 6c 6c		Name0:	.text "Refill"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=53779					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>d293	86					.byte (("Refill"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=19					LinkDisplacement = Nt0-WordListLink
>d294	10					.byte WordFlags	;wh_Flags
>d295	03					.byte 3	;wh_CodeLength
>d296	13					  .byte LinkDisplacement	; offset to previous nt
=$d297					XtPtr1 ::= *
=53779					WordListLink ::= Nt0 ; remember the nt of this word for later
.d297					Refill:
.d297	a9 00		lda #$00			lda #0			; show empty in case of error
.d299	85 06		sta $06				sta ciblen+0
.d29b	85 07		sta $07				sta ciblen+1
.d29d	a5 02		lda $02				lda insrc		; cheat: We only check LSB
.d29f	d0 24		bne $d2c5			bne _src_not_kbd
.d2a1	a5 04		lda $04				lda cib+0		; address of CIB is NOS
.d2a3	a4 05		ldy $05				ldy cib+1
.d2a5	20 ba c7	jsr $c7ba			jsr PushYA
.d2a8	a9 ff		lda #$ff			lda #bsize		; max number of chars is TOS
.d2aa	20 e9 c7	jsr $c7e9			jsr PushZA		;  cheat: We only accept max 255
.d2ad	20 de d2	jsr $d2de			jsr Accept		; ( addr n1 -- n2)
.d2b0	b5 24		lda $24,x			lda DStack+0,x
.d2b2	85 06		sta $06				sta ciblen+0
.d2b4	b5 25		lda $25,x			lda DStack+1,x
.d2b6	85 07		sta $07				sta ciblen+1		; though we only accept 255 chars
.d2b8	a9 00		lda #$00			lda #0
.d2ba	85 08		sta $08				sta toin+0
.d2bc	85 09		sta $09				sta toin+1
.d2be	a9 ff		lda #$ff			lda #$FF		; overwrite with TRUE flag
.d2c0	95 24		sta $24,x			sta DStack+0,x
.d2c2	95 25		sta $25,x			sta DStack+1,x
.d2c4	60		rts				rts
.d2c5					_src_not_kbd:
.d2c5	c9 ff		cmp #$ff			cmp #$ff
.d2c7	d0 03		bne $d2cc			bne _src_not_string
.d2c9	4c db c7	jmp $c7db			jmp False
.d2cc					_src_not_string:
.d2cc	a9 eb		lda #$eb			lda #$100+err_Unsupported
.d2ce	20 68 c4	jsr $c468			jsr ThrowA
=58					CodeLen	.var *-XtPtr1
=$d2d1					Here1 = *	; remember here
>d295	3a					.byte CodeLen	;patch wh_CodeLength
.d2d1	4c 2f c4	jmp $c42f	Throw_Stack_06: jmp Throw_Stack
>d2d4	41 63 63 65 70 74		Name0:	.text "Accept"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=53850					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>d2da	86					.byte (("Accept"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=71					LinkDisplacement = Nt0-WordListLink
>d2db	10					.byte WordFlags	;wh_Flags
>d2dc	03					.byte 3	;wh_CodeLength
>d2dd	47					  .byte LinkDisplacement	; offset to previous nt
=$d2de					XtPtr1 ::= *
=53850					WordListLink ::= Nt0 ; remember the nt of this word for later
.d2de					Accept:
.d2de	e0 2d		cpx #$2d		cpx #(DDim-2)*2+1	; far enough below end of data stack (& not negative)?
.d2e0	b0 ef		bcs $d2d1		bcs Throw_Stack_06
.d2e2	b5 24		lda $24,x			lda DStack+0,x		; Abort if we were asked to receive 0 chars
.d2e4	15 25		ora $25,x			ora DStack+1,x
.d2e6	d0 09		bne $d2f1			bne _not_zero
.d2e8	e8		inx				inx			; drop n
.d2e9	e8		inx				inx
.d2ea	95 24		sta $24,x			sta DStack+0,x		; replace addr with 0
.d2ec	95 25		sta $25,x			sta DStack+1,x
.d2ee	4c c6 d3	jmp $d3c6			jmp accept_done
.d2f1					_not_zero:
.d2f1	b5 24		lda $24,x			lda DStack+0,x	; number of chars to get in tmp2 ...
.d2f3	85 16		sta $16				sta tmp2
.d2f5	a9 00		lda #$00			lda #0
.d2f7	85 17		sta $17				sta tmp2+1	; ... but we only accept max 255 chars
.d2f9	b5 26		lda $26,x			lda DStack+2,x	; address of buffer is NOS, to tmp1
.d2fb	85 14		sta $14				sta tmp1
.d2fd	b5 27		lda $27,x			lda DStack+3,x
.d2ff	85 15		sta $15				sta tmp1+1
.d301	e8		inx				inx
.d302	e8		inx				inx
.d303	a0 00		ldy #$00			ldy #0
.d305	a5 0c		lda $0c				lda status
.d307	29 f7		and #$f7			and #$f7
.d309	18		clc				clc
.d30a	69 01		adc #$01			adc #1
.d30c	09 08		ora #$08			ora #$08
.d30e	85 0c		sta $0c				sta status
.d310					accept_loop:
.d310	20 79 d2	jsr $d279			jsr key_a
.d313	c9 0a		cmp #$0a			cmp #AscLF
.d315	f0 20		beq $d337			beq _eol
.d317	c9 0d		cmp #$0d			cmp #AscCR
.d319	f0 1c		beq $d337			beq _eol
.d31b	c9 08		cmp #$08			cmp #AscBS
.d31d	f0 24		beq $d343			beq _backspace
.d31f	c9 7f		cmp #$7f			cmp #AscDEL	; (CTRL-h)
.d321	f0 20		beq $d343			beq _backspace
.d323	c9 10		cmp #$10			cmp #AscCP
.d325	f0 37		beq $d35e			beq _ctrl_p
.d327	c9 0e		cmp #$0e			cmp #AscCN
.d329	f0 46		beq $d371			beq _ctrl_n
.d32b	91 14		sta ($14),y			sta (tmp1),y
.d32d	c8		iny				iny
.d32e	20 21 de	jsr $de21			jsr Emit_A
.d331	c4 16		cpy $16				cpy tmp2	; reached character limit?
.d333	d0 db		bne $d310			bne accept_loop	      ; fall through if buffer limit reached
.d335	f0 03		beq $d33a			beq _buffer_full
.d337					_eol:
.d337	20 2d de	jsr $de2d			jsr Space	; print final space
.d33a					_buffer_full:
.d33a	94 24		sty $24,x			sty DStack+0,x	; Y contains number of chars accepted already
.d33c	a9 00		lda #$00			lda #0
.d33e	95 25		sta $25,x			sta DStack+1,x		; we only accept 256 chars
.d340	4c c6 d3	jmp $d3c6			jmp accept_done
.d343					_backspace:
.d343	c0 00		cpy #$00			cpy #0		; buffer empty?
.d345	d0 06		bne $d34d			bne +
.d347	a9 07		lda #$07			lda #AscBELL	; complain and don't delete beyond the start of line
.d349	20 21 de	jsr $de21			jsr Emit_A
.d34c	c8		iny				iny
.d34d					+
.d34d	88		dey				dey
.d34e	a9 08		lda #$08			lda #AscBS	; move back one
.d350	20 21 de	jsr $de21			jsr Emit_A
.d353	20 2d de	jsr $de2d			jsr Space	; print a space (rubout)
.d356	a9 08		lda #$08			lda #AscBS	; move back over space
.d358	20 21 de	jsr $de21			jsr Emit_A
.d35b	4c 10 d3	jmp $d310			jmp accept_loop
.d35e					_ctrl_p:
.d35e	a5 0c		lda $0c				lda status
.d360	29 07		and #$07			and #7
.d362	d0 08		bne $d36c			bne _ctrl_p_dec
.d364	a5 0c		lda $0c				lda status
.d366	09 07		ora #$07			ora #7
.d368	85 0c		sta $0c				sta status
.d36a	d0 14		bne $d380			bne _recall_history
.d36c					_ctrl_p_dec:
.d36c	c6 0c		dec $0c				dec status
.d36e	4c 80 d3	jmp $d380			jmp _recall_history
.d371					_ctrl_n:
.d371	a9 08		lda #$08			lda #$8
.d373	24 0c		bit $0c				bit status
.d375	d0 09		bne $d380			bne _recall_history
.d377	a5 0c		lda $0c				lda status
.d379	29 f7		and #$f7			and #$f7
.d37b	18		clc				clc
.d37c	69 01		adc #$01			adc #1
.d37e	85 0c		sta $0c				sta status
.d380					_recall_history:
.d380	a9 f7		lda #$f7			lda #$ff-%00001000
.d382	25 0c		and $0c				and status
.d384	85 0c		sta $0c				sta status
.d386	20 e1 d3	jsr $d3e1			jsr accept_total_recall
.d389	a9 0d		lda #$0d			lda #AscCR
.d38b	20 21 de	jsr $de21			jsr Emit_A
.d38e					input_clear:
.d38e	c0 00		cpy #$00			cpy #0
.d390	f0 07		beq $d399			beq input_cleared
.d392	20 2d de	jsr $de2d			jsr Space
.d395	88		dey				dey
.d396	4c 8e d3	jmp $d38e			jmp input_clear
.d399					input_cleared:
.d399	a9 0d		lda #$0d			lda #AscCR
.d39b	20 21 de	jsr $de21			jsr Emit_A
.d39e	b1 18		lda ($18),y			lda (tmp3),y
.d3a0	85 0d		sta $0d				sta status+1
.d3a2	e6 18		inc $18				inc tmp3
.d3a4	d0 02		bne $d3a8			bne +		; Increment the upper byte on carry.
.d3a6	e6 19		inc $19				inc tmp3+1
.d3a8					+
.d3a8	a9 0d		lda #$0d			lda #AscCR
.d3aa	20 21 de	jsr $de21			jsr Emit_A
.d3ad					_history_loop:
.d3ad	c4 0d		cpy $0d				cpy status+1
.d3af	d0 03		bne $d3b4			bne +
.d3b1	4c 10 d3	jmp $d310			jmp accept_loop	      ; Needs a long jump
.d3b4					+
.d3b4	c4 16		cpy $16				cpy tmp2
.d3b6	f0 0a		beq $d3c2			beq _hist_filled_buffer
.d3b8	b1 18		lda ($18),y			lda (tmp3),y
.d3ba	91 14		sta ($14),y			sta (tmp1),y
.d3bc	20 21 de	jsr $de21			jsr Emit_A
.d3bf	c8		iny				iny
.d3c0	d0 eb		bne $d3ad			bne _history_loop
.d3c2					_hist_filled_buffer:
.d3c2	88		dey				dey
.d3c3	4c 10 d3	jmp $d310			jmp accept_loop
.d3c6					accept_done:
.d3c6	20 e1 d3	jsr $d3e1			jsr accept_total_recall
.d3c9	85 0d		sta $0d				sta status+1
.d3cb	a0 00		ldy #$00			ldy #0
.d3cd	91 18		sta ($18),y			sta (tmp3),y
.d3cf	e6 18		inc $18				inc tmp3
.d3d1	d0 02		bne $d3d5			bne +		; Increment the upper byte on carry.
.d3d3	e6 19		inc $19				inc tmp3+1
.d3d5					+
.d3d5					_save_history_loop:
.d3d5	c4 0d		cpy $0d				cpy status+1
.d3d7	f0 07		beq $d3e0			beq _save_history_done
.d3d9	b1 14		lda ($14),y			lda (tmp1),y
.d3db	91 18		sta ($18),y			sta (tmp3),y
.d3dd	c8		iny				iny
.d3de	d0 f5		bne $d3d5			bne _save_history_loop
.d3e0					_save_history_done:
=258					CodeLen	.var *-XtPtr1
=$ff					CodeLen	 .var $ff
=$d3e0					Here1 = *	; remember here
>d2dc	ff					.byte CodeLen	;patch wh_CodeLength
.d3e0	60		rts				rts
.d3e1					accept_total_recall:
.d3e1	a9 66		lda #$66			lda #<hist_buff
.d3e3	85 18		sta $18				sta tmp3
.d3e5	a9 07		lda #$07			lda #>hist_buff
.d3e7	85 19		sta $19				sta tmp3+1
.d3e9	a5 0c		lda $0c				lda status
.d3eb	6a		ror a				ror
.d3ec	29 03		and #$03			and #3
.d3ee	18		clc				clc
.d3ef	65 19		adc $19				adc tmp3+1
.d3f1	85 19		sta $19				sta tmp3+1
.d3f3	a5 0c		lda $0c				lda status
.d3f5	6a		ror a				ror		; Rotate through carry into msb.
.d3f6	6a		ror a				ror
.d3f7	29 80		and #$80			and #$80
.d3f9	18		clc				clc
.d3fa	65 18		adc $18				adc tmp3
.d3fc	85 18		sta $18				sta tmp3
.d3fe	90 02		bcc $d402			bcc +		; Increment the upper byte on carry.
.d400	e6 19		inc $19				inc tmp3+1
.d402					+
.d402	98		tya				tya
.d403	c9 80		cmp #$80			cmp #$80
.d405	90 02		bcc $d409			bcc +
.d407	a9 7f		lda #$7f			lda #$7F
.d409					+
.d409	60		rts				rts
>d40a	49 6e 70 75 74 3e 52		Name0:	.text "Input>R"	;  name of word as a string, ending at wh_NameLastChar
=7					NameLength = *-Name0
=54161					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>d411	47					.byte (("Input>R"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$30					WordFlags ::= NN|ST	; modifiable copy, remember for later
=311					LinkDisplacement = Nt0-WordListLink
=$31						  WordFlags ::= WordFlags | FP
>d412	31					.byte WordFlags	;wh_Flags
>d413	03					.byte 3	;wh_CodeLength
>d414	5a d2					  .word WordListLink
=$d416					XtPtr1 ::= *
=54161					WordListLink ::= Nt0 ; remember the nt of this word for later
.d416					Input_To_R:
.d416	68		pla				pla			; move it out of the way
.d417	85 14		sta $14				sta tmp1+0
.d419	68		pla				pla
.d41a	85 15		sta $15				sta tmp1+1
.d41c	a0 07		ldy #$07			ldy #7
.d41e	b9 02 00	lda $0002,y	_loop:		lda InSrc,y	; insrc+7 is toin+1
.d421	48		pha				pha
.d422	88		dey				dey
.d423	10 f9		bpl $d41e			bpl _loop
.d425	a5 15		lda $15				lda tmp1+1		; Restore address for return jump
.d427	48		pha				pha
.d428	a5 14		lda $14				lda tmp1+0
.d42a	48		pha				pha
=21					CodeLen	.var *-XtPtr1
=$d42b					Here1 = *	; remember here
>d413	15					.byte CodeLen	;patch wh_CodeLength
.d42b	60		rts				rts
>d42c	52 3e 49 6e 70 75 74		Name0:	.text "R>Input"	;  name of word as a string, ending at wh_NameLastChar
=7					NameLength = *-Name0
=54195					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>d433	87					.byte (("R>Input"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$30					WordFlags ::= ST	; modifiable copy, remember for later
=34					LinkDisplacement = Nt0-WordListLink
>d434	30					.byte WordFlags	;wh_Flags
>d435	03					.byte 3	;wh_CodeLength
>d436	22					  .byte LinkDisplacement	; offset to previous nt
=$d437					XtPtr1 ::= *
=54195					WordListLink ::= Nt0 ; remember the nt of this word for later
.d437					R_To_Input:
.d437	68		pla				pla		 ; move RTS addr out of the way
.d438	85 14		sta $14				sta tmp1+0
.d43a	68		pla				pla
.d43b	85 15		sta $15				sta tmp1+1
.d43d	a0 00		ldy #$00			ldy #0
.d43f	68		pla		_loop:		pla
.d440	99 02 00	sta $0002,y			sta InSrc,y ; also cib ciblen toin
.d443	c8		iny				iny
.d444	c0 08		cpy #$08			cpy #8
.d446	d0 f7		bne $d43f			bne _loop
.d448	a5 15		lda $15				lda tmp1+1	; Restore RTS address
.d44a	48		pha				pha
.d44b	a5 14		lda $14				lda tmp1+0
.d44d	48		pha				pha
=23					CodeLen	.var *-XtPtr1
=$d44e					Here1 = *	; remember here
>d435	17					.byte CodeLen	;patch wh_CodeLength
.d44e	60		rts				rts
>d44f	49 4b 65 79			Name0:	.text "IKey"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=54227					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>d453	24					.byte (("IKey"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=32					LinkDisplacement = Nt0-WordListLink
>d454	10					.byte WordFlags	;wh_Flags
>d455	03					.byte 3	;wh_CodeLength
>d456	20					  .byte LinkDisplacement	; offset to previous nt
=$d457					XtPtr1 ::= *
=54227					WordListLink ::= Nt0 ; remember the nt of this word for later
.d457					IKey:
.d457	20 f7 c7	jsr $c7f7	_again:		jsr Zero
.d45a	20 f7 c7	jsr $c7f7			jsr Zero	; ( ud )
.d45d	20 67 da	jsr $da67			jsr Here
.d460	20 d2 df	jsr $dfd2			jsr Dup		; get text
.d463	a9 10		lda #$10			lda #16
.d465	20 e9 c7	jsr $c7e9			jsr PushZA
.d468	20 de d2	jsr $d2de			jsr Accept	; ( ud addr len )
.d46b	a1 26		lda ($26,x)			lda (DStack+2,x) ; negative?
.d46d	c9 2d		cmp #$2d			cmp #'-'
.d46f	08		php				php		;  save sign
.d470	d0 06		bne $d478			bne +
.d472	20 a5 da	jsr $daa5			jsr NOS_One_Plus ;   eat the '-'
.d475	20 74 da	jsr $da74			jsr One_Minus
.d478					+
.d478	20 39 c0	jsr $c039			jsr To_Number ; ( ud addr u -- ud addr u )  Continue convert a string to an integer
.d47b	e8		inx				inx		; Drop len
.d47c	e8		inx				inx
.d47d	e8		inx				inx		; Drop addr
.d47e	e8		inx				inx
.d47f	e8		inx				inx		; UD>S
.d480	e8		inx				inx
.d481	b5 1e		lda $1e,x			lda DStack-6,x	; string all consumed?
.d483	f0 11		beq $d496			beq _ok
.d485	e8		inx		_err:		inx		; Drop u
.d486	e8		inx				inx
.d487	28		plp				plp		; RDrop saved sign
.d488	20 2d de	jsr $de2d			jsr Space	; prompt again
.d48b	a9 3f		lda #$3f			lda #'?'
.d48d	20 21 de	jsr $de21			jsr Emit_A
.d490	20 2d de	jsr $de2d			jsr Space
.d493	4c 57 d4	jmp $d457			jmp _again	; try it again
.d496	28		plp		_ok:		plp		; apply sign
.d497	d0 03		bne $d49c			bne +
.d499	20 e9 d6	jsr $d6e9			jsr Negate
.d49c					+
.d49c	60		rts				rts
=70					CodeLen	.var *-XtPtr1
=$d49d					Here1 = *	; remember here
>d455	46					.byte CodeLen	;patch wh_CodeLength
>d49d	42 6f 75 6e 64 73		Name0:	.text "Bounds"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=54307					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>d4a3	66					.byte (("Bounds"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=80					LinkDisplacement = Nt0-WordListLink
>d4a4	10					.byte WordFlags	;wh_Flags
>d4a5	03					.byte 3	;wh_CodeLength
>d4a6	50					  .byte LinkDisplacement	; offset to previous nt
=$d4a7					XtPtr1 ::= *
=54307					WordListLink ::= Nt0 ; remember the nt of this word for later
.d4a7					Bounds:
.d4a7	e0 2d		cpx #$2d		cpx #(DDim-2)*2+1	; far enough below end of data stack (& not negative)?
.d4a9	b0 14		bcs $d4bf		bcs Throw_Stack_22
.d4ab	18		clc				clc
.d4ac	b5 26		lda $26,x			lda DStack+2,x		; LSB addr
.d4ae	a8		tay				tay
.d4af	75 24		adc $24,x			adc DStack+0,x		; LSB u
.d4b1	95 26		sta $26,x			sta DStack+2,x		; LSB addr+u
.d4b3	94 24		sty $24,x			sty DStack+0,x
.d4b5	b5 27		lda $27,x			lda DStack+3,x		; MSB addr
.d4b7	a8		tay				tay
.d4b8	75 25		adc $25,x			adc DStack+1,x		; MSB u
.d4ba	95 27		sta $27,x			sta DStack+3,x		; MSB addr+u
.d4bc	94 25		sty $25,x			sty DStack+1,x
=23					CodeLen	.var *-XtPtr1
=$d4be					Here1 = *	; remember here
>d4a5	17					.byte CodeLen	;patch wh_CodeLength
.d4be	60		rts				rts
.d4bf	4c 2f c4	jmp $c42f	Throw_Stack_22: jmp Throw_Stack
>d4c2	53 70 61 63 65 73		Name0:	.text "Spaces"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=54344					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>d4c8	66					.byte (("Spaces"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=37					LinkDisplacement = Nt0-WordListLink
>d4c9	10					.byte WordFlags	;wh_Flags
>d4ca	03					.byte 3	;wh_CodeLength
>d4cb	25					  .byte LinkDisplacement	; offset to previous nt
=$d4cc					XtPtr1 ::= *
=54344					WordListLink ::= Nt0 ; remember the nt of this word for later
.d4cc					Spaces:
.d4cc	e0 2f		cpx #$2f		cpx #(DDim-1)*2+1	; far enough below end of data stack (& not negative)?
.d4ce	b0 ef		bcs $d4bf		bcs Throw_Stack_22
.d4d0	4c d6 d4	jmp $d4d6			jmp _test
.d4d3					_loop:
.d4d3	20 2d de	jsr $de2d			jsr Space		; print a space
.d4d6	d6 24		dec $24,x	_test:		dec DStack+0,x		; decrement & test
.d4d8	10 f9		bpl $d4d3			bpl _loop
.d4da	e8		inx				inx			; Drop
.d4db	e8		inx				inx
=16					CodeLen	.var *-XtPtr1
=$d4dc					Here1 = *	; remember here
>d4ca	10					.byte CodeLen	;patch wh_CodeLength
.d4dc	60		rts				rts
>d4dd	2d 54 72 61 69 6c 69 6e		Name0:	.text "-Trailing"	;  name of word as a string, ending at wh_NameLastChar
>d4e5	67
=9					NameLength = *-Name0
=54374					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>d4e6	e9					.byte (("-Trailing"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=30					LinkDisplacement = Nt0-WordListLink
>d4e7	10					.byte WordFlags	;wh_Flags
>d4e8	03					.byte 3	;wh_CodeLength
>d4e9	1e					  .byte LinkDisplacement	; offset to previous nt
=$d4ea					XtPtr1 ::= *
=54374					WordListLink ::= Nt0 ; remember the nt of this word for later
.d4ea					Minus_trailing:
.d4ea	e0 2d		cpx #$2d		cpx #(DDim-2)*2+1	; far enough below end of data stack (& not negative)?
.d4ec	b0 78		bcs $d566		bcs Throw_Stack_20
.d4ee	b5 26		lda $26,x			lda DStack+2,x		; tmp1= addr + (u1 & $ff00)
.d4f0	85 14		sta $14				sta tmp1+0
.d4f2	b5 27		lda $27,x			lda DStack+3,x
.d4f4	18		clc				clc
.d4f5	75 25		adc $25,x			adc DStack+1,x
.d4f7	85 15		sta $15				sta tmp1+1
.d4f9	b4 24		ldy $24,x			ldy DStack+0,x
.d4fb	88		dey		_loop:		dey			; back 1 char
.d4fc	c0 ff		cpy #$ff			cpy #$ff
.d4fe	d0 06		bne $d506			bne +
.d500	c6 15		dec $15				dec tmp1+1		;   back 1 page
.d502	d6 25		dec $25,x			dec DStack+1,x
.d504	30 06		bmi $d50c			bmi _done
.d506					+
.d506	b1 14		lda ($14),y			lda (tmp1),y		; if blank, keep going
.d508	c9 20		cmp #$20			cmp #AscSP
.d50a	f0 ef		beq $d4fb			beq _loop
.d50c	c8		iny		_done:		iny			; forward 1 char
.d50d	d0 02		bne $d511			bne +
.d50f	f6 25		inc $25,x			inc DStack+1,x
.d511	94 24		sty $24,x	+		sty DStack+0,x
=41					CodeLen	.var *-XtPtr1
=$d513					Here1 = *	; remember here
>d4e8	29					.byte CodeLen	;patch wh_CodeLength
.d513	60		rts				rts
>d514	2d 4c 65 61 64 69 6e 67		Name0:	.text "-Leading"	;  name of word as a string, ending at wh_NameLastChar
=8					NameLength = *-Name0
=54428					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>d51c	e8					.byte (("-Leading"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=54					LinkDisplacement = Nt0-WordListLink
>d51d	10					.byte WordFlags	;wh_Flags
>d51e	03					.byte 3	;wh_CodeLength
>d51f	36					  .byte LinkDisplacement	; offset to previous nt
=$d520					XtPtr1 ::= *
=54428					WordListLink ::= Nt0 ; remember the nt of this word for later
.d520					Minus_leading:
.d520	e0 2d		cpx #$2d		cpx #(DDim-2)*2+1	; far enough below end of data stack (& not negative)?
.d522	b0 42		bcs $d566		bcs Throw_Stack_20
.d524					_loop:
.d524	b5 24		lda $24,x			lda DStack+0,x		; chars left?
.d526	15 25		ora $25,x			ora DStack+1,x
.d528	f0 0f		beq $d539			beq _done
.d52a	a1 26		lda ($26,x)			lda (DStack+2,x)	; get first character
.d52c	c9 21		cmp #$21			cmp #AscSP+1		;   is_whitespace
.d52e	b0 09		bcs $d539			bcs _done
.d530	20 a5 da	jsr $daa5			jsr NOS_One_Plus
.d533	20 78 da	jsr $da78			jsr One_Minus_NoUF
.d536	4c 24 d5	jmp $d524			jmp _loop
.d539					_done:
=25					CodeLen	.var *-XtPtr1
=$d539					Here1 = *	; remember here
>d51e	19					.byte CodeLen	;patch wh_CodeLength
.d539	60		rts				rts
>d53a	2f 53 74 72 69 6e 67		Name0:	.text "/String"	;  name of word as a string, ending at wh_NameLastChar
=7					NameLength = *-Name0
=54465					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>d541	e7					.byte (("/String"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=37					LinkDisplacement = Nt0-WordListLink
>d542	10					.byte WordFlags	;wh_Flags
>d543	03					.byte 3	;wh_CodeLength
>d544	25					  .byte LinkDisplacement	; offset to previous nt
=$d545					XtPtr1 ::= *
=54465					WordListLink ::= Nt0 ; remember the nt of this word for later
.d545					Slash_String:
.d545	e0 2b		cpx #$2b		cpx #(DDim-3)*2+1	; far enough below end of data stack (& not negative)?
.d547	b0 1d		bcs $d566		bcs Throw_Stack_20
.d549	18		clc				clc		; addr += n
.d54a	b5 24		lda $24,x			lda DStack+0,x
.d54c	75 28		adc $28,x			adc DStack+4,x
.d54e	95 28		sta $28,x			sta DStack+4,x
.d550	b5 25		lda $25,x			lda DStack+1,x
.d552	75 29		adc $29,x			adc DStack+5,x
.d554	95 29		sta $29,x			sta DStack+5,x
.d556	38		sec				sec		; u -= n
.d557	b5 26		lda $26,x			lda DStack+2,x
.d559	f5 24		sbc $24,x			sbc DStack+0,x
.d55b	95 26		sta $26,x			sta DStack+2,x
.d55d	b5 27		lda $27,x			lda DStack+3,x
.d55f	f5 25		sbc $25,x			sbc DStack+1,x
.d561	95 27		sta $27,x			sta DStack+3,x
.d563	e8		inx				inx		; Drop n
.d564	e8		inx				inx
=32					CodeLen	.var *-XtPtr1
=$d565					Here1 = *	; remember here
>d543	20					.byte CodeLen	;patch wh_CodeLength
.d565	60		rts				rts
.d566	4c 2f c4	jmp $c42f	Throw_Stack_20: jmp Throw_Stack
>d569	32 44 72 6f 70			Name0:	.text "2Drop"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=54510					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>d56e	05					.byte (("2Drop"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=45					LinkDisplacement = Nt0-WordListLink
>d56f	10					.byte WordFlags	;wh_Flags
>d570	03					.byte 3	;wh_CodeLength
>d571	2d					  .byte LinkDisplacement	; offset to previous nt
=$d572					XtPtr1 ::= *
=54510					WordListLink ::= Nt0 ; remember the nt of this word for later
.d572					Two_drop:
.d572	e0 2d		cpx #$2d		cpx #(DDim-2)*2+1	; far enough below end of data stack (& not negative)?
.d574	b0 f0		bcs $d566		bcs Throw_Stack_20
.d576	e8		inx				inx
.d577	e8		inx				inx
.d578	e8		inx				inx
.d579	e8		inx				inx
=8					CodeLen	.var *-XtPtr1
=$d57a					Here1 = *	; remember here
>d570	08					.byte CodeLen	;patch wh_CodeLength
.d57a	60		rts				rts
>d57b	32 53 77 61 70			Name0:	.text "2Swap"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=54528					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>d580	05					.byte (("2Swap"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=18					LinkDisplacement = Nt0-WordListLink
>d581	10					.byte WordFlags	;wh_Flags
>d582	03					.byte 3	;wh_CodeLength
>d583	12					  .byte LinkDisplacement	; offset to previous nt
=$d584					XtPtr1 ::= *
=54528					WordListLink ::= Nt0 ; remember the nt of this word for later
.d584					Two_Swap:
.d584	e0 29		cpx #$29		cpx #(DDim-4)*2+1	; far enough below end of data stack (& not negative)?
.d586	b0 de		bcs $d566		bcs Throw_Stack_20
.d588	86 14		stx $14				stx tmp1
.d58a	ca		dex				dex
.d58b	ca		dex				dex
.d58c	ca		dex				dex
.d58d	ca		dex				dex
.d58e	e8		inx		_loop:		inx
.d58f	b5 27		lda $27,x			lda DStack+3,x	; 3 <-> 7
.d591	b4 2b		ldy $2b,x			ldy DStack+7,x
.d593	95 2b		sta $2b,x			sta DStack+7,x
.d595	94 27		sty $27,x			sty DStack+3,x
.d597	e4 14		cpx $14				cpx tmp1
.d599	90 f3		bcc $d58e			bcc _loop
=23					CodeLen	.var *-XtPtr1
=$d59b					Here1 = *	; remember here
>d582	17					.byte CodeLen	;patch wh_CodeLength
.d59b	60		rts				rts
>d59c	32 4f 76 65 72			Name0:	.text "2Over"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=54561					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>d5a1	45					.byte (("2Over"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=33					LinkDisplacement = Nt0-WordListLink
>d5a2	10					.byte WordFlags	;wh_Flags
>d5a3	03					.byte 3	;wh_CodeLength
>d5a4	21					  .byte LinkDisplacement	; offset to previous nt
=$d5a5					XtPtr1 ::= *
=54561					WordListLink ::= Nt0 ; remember the nt of this word for later
.d5a5					Two_over:
.d5a5	e0 29		cpx #$29		cpx #(DDim-4)*2+1	; far enough below end of data stack (& not negative)?
.d5a7	b0 bd		bcs $d566		bcs Throw_Stack_20
.d5a9	a0 04		ldy #$04			ldy #4
.d5ab	ca		dex		_loop:		dex
.d5ac	b5 2c		lda $2c,x			lda DStack+8,x
.d5ae	95 24		sta $24,x			sta DStack+0,x
.d5b0	88		dey				dey
.d5b1	d0 f8		bne $d5ab			bne _loop
=14					CodeLen	.var *-XtPtr1
=$d5b3					Here1 = *	; remember here
>d5a3	0e					.byte CodeLen	;patch wh_CodeLength
.d5b3	60		rts				rts
>d5b4	32 21				Name0:	.text "2!"	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=54582					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>d5b6	22					.byte (("2!"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=21					LinkDisplacement = Nt0-WordListLink
>d5b7	10					.byte WordFlags	;wh_Flags
>d5b8	03					.byte 3	;wh_CodeLength
>d5b9	15					  .byte LinkDisplacement	; offset to previous nt
=$d5ba					XtPtr1 ::= *
=54582					WordListLink ::= Nt0 ; remember the nt of this word for later
.d5ba	20 e3 c3	jsr $c3e3	Two_Store:	jsr PopYA
.d5bd	85 14		sta $14		Two_Store_YA:	sta tmp1+0	; save addr
.d5bf	84 15		sty $15				sty tmp1+1
.d5c1	e0 2d		cpx #$2d		cpx #(DDim-2)*2+1	; far enough below end of data stack (& not negative)?
.d5c3	b0 a1		bcs $d566		bcs Throw_Stack_20
.d5c5	b5 24		lda $24,x			lda DStack+0,x	; copy MSB
.d5c7	a0 00		ldy #$00			ldy #0
.d5c9	91 14		sta ($14),y			sta (tmp1),y
.d5cb	b5 25		lda $25,x			lda DStack+1,x	; copy next
.d5cd	c8		iny				iny
.d5ce	91 14		sta ($14),y			sta (tmp1),y
.d5d0	b5 26		lda $26,x			lda DStack+2,x	; copy next
.d5d2	c8		iny				iny
.d5d3	91 14		sta ($14),y			sta (tmp1),y
.d5d5	b5 27		lda $27,x			lda DStack+3,x	; copy MSB
.d5d7	c8		iny				iny
.d5d8	91 14		sta ($14),y			sta (tmp1),y
.d5da	e8		inx				inx		; 2Drop
.d5db	e8		inx				inx
.d5dc	e8		inx				inx
.d5dd	e8		inx				inx
=36					CodeLen	.var *-XtPtr1
=$d5de					Here1 = *	; remember here
>d5b8	24					.byte CodeLen	;patch wh_CodeLength
.d5de	60		rts				rts
>d5df	32 40				Name0:	.text "2@"	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=54625					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>d5e1	02					.byte (("2@"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=0					WordFlags ::= 0	; modifiable copy, remember for later
=43					LinkDisplacement = Nt0-WordListLink
>d5e2	00					.byte WordFlags	;wh_Flags
>d5e3	03					.byte 3	;wh_CodeLength
>d5e4	2b					  .byte LinkDisplacement	; offset to previous nt
=$d5e5					XtPtr1 ::= *
=54625					WordListLink ::= Nt0 ; remember the nt of this word for later
.d5e5	20 e3 c3	jsr $c3e3	Two_fetch:	jsr PopYA
.d5e8	85 14		sta $14		Two_Fetch_YA:	sta tmp1+0	; save addr
.d5ea	84 15		sty $15				sty tmp1+1
.d5ec	a0 00		ldy #$00			ldy #0
.d5ee					Two_Fetch_Tmp1Y:
.d5ee	ca		dex				dex
.d5ef	ca		dex				dex
.d5f0	ca		dex				dex
.d5f1	ca		dex				dex
.d5f2	b1 14		lda ($14),y			lda (tmp1),y	; copy LSB
.d5f4	95 24		sta $24,x			sta DStack+0,x
.d5f6	c8		iny				iny		; copy next
.d5f7	b1 14		lda ($14),y			lda (tmp1),y
.d5f9	95 25		sta $25,x			sta DStack+1,x
.d5fb	c8		iny				iny		; copy next
.d5fc	b1 14		lda ($14),y			lda (tmp1),y
.d5fe	95 26		sta $26,x			sta DStack+2,x
.d600	c8		iny				iny		; copy next
.d601	b1 14		lda ($14),y			lda (tmp1),y
.d603	95 27		sta $27,x			sta DStack+3,x
=32					CodeLen	.var *-XtPtr1
=$d605					Here1 = *	; remember here
>d5e3	20					.byte CodeLen	;patch wh_CodeLength
.d605	60		rts				rts
>d606	44 40				Name0:	.text "D@"	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=54664					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>d608	02					.byte (("D@"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=39					LinkDisplacement = Nt0-WordListLink
>d609	10					.byte WordFlags	;wh_Flags
>d60a	03					.byte 3	;wh_CodeLength
>d60b	27					  .byte LinkDisplacement	; offset to previous nt
=$d60c					XtPtr1 ::= *
=54664					WordListLink ::= Nt0 ; remember the nt of this word for later
.d60c	20 e3 c3	jsr $c3e3	DFetch:		jsr PopYA
.d60f	85 14		sta $14		DFetchYA:	sta tmp1+0	; save addr
.d611	84 15		sty $15				sty tmp1+1
.d613	ca		dex				dex
.d614	ca		dex				dex
.d615	ca		dex				dex
.d616	ca		dex				dex
.d617	a0 00		ldy #$00			ldy #0
.d619	b1 14		lda ($14),y			lda (tmp1),y
.d61b	95 26		sta $26,x			sta DStack+2,x
.d61d	c8		iny				iny
.d61e	b1 14		lda ($14),y			lda (tmp1),y
.d620	95 27		sta $27,x			sta DStack+3,x
.d622	c8		iny				iny
.d623	b1 14		lda ($14),y			lda (tmp1),y
.d625	95 24		sta $24,x			sta DStack+0,x
.d627	c8		iny				iny
.d628	b1 14		lda ($14),y			lda (tmp1),y
.d62a	95 25		sta $25,x			sta DStack+1,x
=32					CodeLen	.var *-XtPtr1
=$d62c					Here1 = *	; remember here
>d60a	20					.byte CodeLen	;patch wh_CodeLength
.d62c	60		rts				rts
>d62d	44 21				Name0:	.text "D!"	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=54703					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>d62f	22					.byte (("D!"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=39					LinkDisplacement = Nt0-WordListLink
>d630	10					.byte WordFlags	;wh_Flags
>d631	03					.byte 3	;wh_CodeLength
>d632	27					  .byte LinkDisplacement	; offset to previous nt
=$d633					XtPtr1 ::= *
=54703					WordListLink ::= Nt0 ; remember the nt of this word for later
.d633	20 e3 c3	jsr $c3e3	DStore:		jsr PopYA
.d636	85 14		sta $14		DStoreYA:	sta tmp1+0	; save addr
.d638	84 15		sty $15				sty tmp1+1
.d63a	b5 26		lda $26,x			lda DStack+2,x	; LSB
.d63c	a0 00		ldy #$00			ldy #0
.d63e	91 14		sta ($14),y			sta (tmp1),y
.d640	b5 27		lda $27,x			lda DStack+3,x
.d642	c8		iny				iny
.d643	91 14		sta ($14),y			sta (tmp1),y
.d645	b5 24		lda $24,x			lda DStack+0,x
.d647	c8		iny				iny
.d648	91 14		sta ($14),y			sta (tmp1),y
.d64a	b5 25		lda $25,x			lda DStack+1,x	; MSB
.d64c	c8		iny				iny
.d64d	91 14		sta ($14),y			sta (tmp1),y
.d64f	4c 72 d5	jmp $d572			jmp Two_Drop	; also check underflow, return
=31					CodeLen	.var *-XtPtr1
=$d652					Here1 = *	; remember here
>d631	1f					.byte CodeLen	;patch wh_CodeLength
>d652	32 52 40			Name0:	.text "2R@"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=54741					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>d655	03					.byte (("2R@"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=20					WordFlags ::= CO+NN	; modifiable copy, remember for later
=38					LinkDisplacement = Nt0-WordListLink
>d656	14					.byte WordFlags	;wh_Flags
>d657	03					.byte 3	;wh_CodeLength
>d658	26					  .byte LinkDisplacement	; offset to previous nt
=$d659					XtPtr1 ::= *
=54741					WordListLink ::= Nt0 ; remember the nt of this word for later
.d659					Two_r_fetch:
.d659	8a		txa				txa		; Y= return stack index
.d65a	ba		tsx				tsx
.d65b	86 14		stx $14				stx tmp1
.d65d	a4 14		ldy $14				ldy tmp1
.d65f	aa		tax				tax
.d660	ca		dex				dex		; make room on the Data Stack
.d661	ca		dex				dex
.d662	ca		dex				dex
.d663	ca		dex				dex
.d664	b9 03 01	lda $0103,y			lda RStack+3,y	; LSB of top entry
.d667	95 24		sta $24,x			sta DStack+0,x
.d669	b9 04 01	lda $0104,y			lda RStack+4,y	; MSB of top entry
.d66c	95 25		sta $25,x			sta DStack+1,x
.d66e	b9 05 01	lda $0105,y			lda RStack+5,y	; LSB of bottom entry
.d671	95 26		sta $26,x			sta DStack+2,x
.d673	b9 06 01	lda $0106,y			lda RStack+6,y	; MSB of bottom entry
.d676	95 27		sta $27,x			sta DStack+3,x
=31					CodeLen	.var *-XtPtr1
=$d678					Here1 = *	; remember here
>d657	1f					.byte CodeLen	;patch wh_CodeLength
.d678	60		rts				rts
>d679	32 52 3e			Name0:	.text "2R>"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=54780					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>d67c	c3					.byte (("2R>"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=52					WordFlags ::= CO+ST	; modifiable copy, remember for later
=39					LinkDisplacement = Nt0-WordListLink
>d67d	34					.byte WordFlags	;wh_Flags
>d67e	03					.byte 3	;wh_CodeLength
>d67f	27					  .byte LinkDisplacement	; offset to previous nt
=$d680					XtPtr1 ::= *
=54780					WordListLink ::= Nt0 ; remember the nt of this word for later
.d680					Two_r_from:
.d680	68		pla				pla			; save the return address
.d681	85 14		sta $14				sta tmp1+0
.d683	68		pla				pla
.d684	85 15		sta $15				sta tmp1+1
.d686	ca		dex				dex			; make room on stack
.d687	ca		dex				dex
.d688	ca		dex				dex
.d689	ca		dex				dex
.d68a	68		pla				pla			; LSB
.d68b	95 24		sta $24,x			sta DStack+0,x
.d68d	68		pla				pla			; MSB
.d68e	95 25		sta $25,x			sta DStack+1,x
.d690	68		pla				pla			; LSB
.d691	95 26		sta $26,x			sta DStack+2,x
.d693	68		pla				pla			; MSB
.d694	95 27		sta $27,x			sta DStack+3,x
.d696	a5 15		lda $15				lda tmp1+1		; restore return address
.d698	48		pha				pha
.d699	a5 14		lda $14				lda tmp1+0
.d69b	48		pha				pha
=28					CodeLen	.var *-XtPtr1
=$d69c					Here1 = *	; remember here
>d67e	1c					.byte CodeLen	;patch wh_CodeLength
.d69c	60		rts				rts
>d69d	32 3e 52			Name0:	.text "2>R"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=54816					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>d6a0	43					.byte (("2>R"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=116					WordFlags ::= CO+UF+ST	; modifiable copy, remember for later
=36					LinkDisplacement = Nt0-WordListLink
>d6a1	74					.byte WordFlags	;wh_Flags
>d6a2	03					.byte 3	;wh_CodeLength
>d6a3	24					  .byte LinkDisplacement	; offset to previous nt
=$d6a4					XtPtr1 ::= *
=54816					WordListLink ::= Nt0 ; remember the nt of this word for later
.d6a4					Two_to_r:
.d6a4	68		pla				pla		; save the return address
.d6a5	85 14		sta $14				sta tmp1+0
.d6a7	68		pla				pla
.d6a8	85 15		sta $15				sta tmp1+1
.d6aa	20 20 c4	jsr $c420			jsr underflow_2
.d6ad	b5 27		lda $27,x			lda DStack+3,x	; MSB
.d6af	48		pha				pha
.d6b0	b5 26		lda $26,x			lda DStack+2,x	; LSB
.d6b2	48		pha				pha
.d6b3	b5 25		lda $25,x			lda DStack+1,x	; MSB
.d6b5	48		pha				pha
.d6b6	b5 24		lda $24,x			lda DStack+0,x	; LSB
.d6b8	48		pha				pha
.d6b9	e8		inx				inx
.d6ba	e8		inx				inx
.d6bb	e8		inx				inx
.d6bc	e8		inx				inx
.d6bd	a5 15		lda $15				lda tmp1+1	; restore return address
.d6bf	48		pha				pha
.d6c0	a5 14		lda $14				lda tmp1+0
.d6c2	48		pha				pha
=31					CodeLen	.var *-XtPtr1
=$d6c3					Here1 = *	; remember here
>d6a2	1f					.byte CodeLen	;patch wh_CodeLength
.d6c3	60		rts				rts
>d6c4	49 6e 76 65 72 74		Name0:	.text "Invert"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=54858					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>d6ca	86					.byte (("Invert"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$40					WordFlags ::= UF	; modifiable copy, remember for later
=42					LinkDisplacement = Nt0-WordListLink
>d6cb	40					.byte WordFlags	;wh_Flags
>d6cc	03					.byte 3	;wh_CodeLength
>d6cd	2a					  .byte LinkDisplacement	; offset to previous nt
=$d6ce					XtPtr1 ::= *
=54858					WordListLink ::= Nt0 ; remember the nt of this word for later
.d6ce					Invert:
.d6ce	e0 2f		cpx #$2f		cpx #(DDim-1)*2+1	; far enough below end of data stack (& not negative)?
.d6d0	b0 39		bcs $d70b		bcs Throw_Stack_17
.d6d2	a9 ff		lda #$ff			lda #$FF
.d6d4	55 24		eor $24,x			eor DStack+0,x	; LSB
.d6d6	95 24		sta $24,x			sta DStack+0,x
.d6d8	a9 ff		lda #$ff			lda #$FF
.d6da	55 25		eor $25,x			eor DStack+1,x	; MSB
.d6dc	95 25		sta $25,x			sta DStack+1,x
=16					CodeLen	.var *-XtPtr1
=$d6de					Here1 = *	; remember here
>d6cc	10					.byte CodeLen	;patch wh_CodeLength
.d6de	60		rts				rts
>d6df	4e 65 67 61 74 65		Name0:	.text "Negate"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=54885					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>d6e5	a6					.byte (("Negate"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=27					LinkDisplacement = Nt0-WordListLink
>d6e6	10					.byte WordFlags	;wh_Flags
>d6e7	03					.byte 3	;wh_CodeLength
>d6e8	1b					  .byte LinkDisplacement	; offset to previous nt
=$d6e9					XtPtr1 ::= *
=54885					WordListLink ::= Nt0 ; remember the nt of this word for later
.d6e9					Negate:
.d6e9	e0 2f		cpx #$2f		cpx #(DDim-1)*2+1	; far enough below end of data stack (& not negative)?
.d6eb	b0 1e		bcs $d70b		bcs Throw_Stack_17
.d6ed	38		sec		Negate3:	sec
.d6ee	a9 00		lda #$00	Negate4:	lda #0
.d6f0	f5 24		sbc $24,x			sbc DStack+0,x	; LSB
.d6f2	95 24		sta $24,x			sta DStack+0,x
.d6f4	a9 00		lda #$00			lda #0
.d6f6	f5 25		sbc $25,x			sbc DStack+1,x	; MSB
.d6f8	95 25		sta $25,x			sta DStack+1,x
=17					CodeLen	.var *-XtPtr1
=$d6fa					Here1 = *	; remember here
>d6e7	11					.byte CodeLen	;patch wh_CodeLength
.d6fa	60		rts				rts
>d6fb	41 62 73			Name0:	.text "Abs"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=54910					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>d6fe	63					.byte (("Abs"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=25					LinkDisplacement = Nt0-WordListLink
>d6ff	10					.byte WordFlags	;wh_Flags
>d700	03					.byte 3	;wh_CodeLength
>d701	19					  .byte LinkDisplacement	; offset to previous nt
=$d702					XtPtr1 ::= *
=54910					WordListLink ::= Nt0 ; remember the nt of this word for later
.d702					Abs:
.d702	e0 2f		cpx #$2f		cpx #(DDim-1)*2+1	; far enough below end of data stack (& not negative)?
.d704	b0 05		bcs $d70b		bcs Throw_Stack_17
.d706	b5 25		lda $25,x			lda DStack+1,x	; n negative?
.d708	30 e3		bmi $d6ed			bmi Negate3
=8					CodeLen	.var *-XtPtr1
=$d70a					Here1 = *	; remember here
>d700	08					.byte CodeLen	;patch wh_CodeLength
.d70a	60		rts				rts
.d70b	4c 2f c4	jmp $c42f	Throw_Stack_17: jmp Throw_Stack
>d70e	44 4e 65 67 61 74 65		Name0:	.text "DNegate"	;  name of word as a string, ending at wh_NameLastChar
=7					NameLength = *-Name0
=54933					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>d715	a7					.byte (("DNegate"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=23					LinkDisplacement = Nt0-WordListLink
>d716	10					.byte WordFlags	;wh_Flags
>d717	03					.byte 3	;wh_CodeLength
>d718	17					  .byte LinkDisplacement	; offset to previous nt
=$d719					XtPtr1 ::= *
=54933					WordListLink ::= Nt0 ; remember the nt of this word for later
.d719					DNegate:
.d719	e0 2d		cpx #$2d		cpx #(DDim-2)*2+1	; far enough below end of data stack (& not negative)?
.d71b	b0 ee		bcs $d70b		bcs Throw_Stack_17
.d71d	38		sec		DNegate3:	sec
.d71e	a9 00		lda #$00			lda #0
.d720	f5 26		sbc $26,x			sbc DStack+2,x	; LSB of low cell
.d722	95 26		sta $26,x			sta DStack+2,x
.d724	a9 00		lda #$00			lda #0
.d726	f5 27		sbc $27,x			sbc DStack+3,x	; MSB of low cell
.d728	95 27		sta $27,x			sta DStack+3,x
.d72a	4c ee d6	jmp $d6ee			jmp Negate4
=20					CodeLen	.var *-XtPtr1
=$d72d					Here1 = *	; remember here
>d717	14					.byte CodeLen	;patch wh_CodeLength
>d72d	44 41 62 73			Name0:	.text "DAbs"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=54961					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>d731	64					.byte (("DAbs"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=28					LinkDisplacement = Nt0-WordListLink
>d732	10					.byte WordFlags	;wh_Flags
>d733	03					.byte 3	;wh_CodeLength
>d734	1c					  .byte LinkDisplacement	; offset to previous nt
=$d735					XtPtr1 ::= *
=54961					WordListLink ::= Nt0 ; remember the nt of this word for later
.d735					DAbs:
.d735	e0 2d		cpx #$2d		cpx #(DDim-2)*2+1	; far enough below end of data stack (& not negative)?
.d737	b0 d2		bcs $d70b		bcs Throw_Stack_17
.d739	b5 25		lda $25,x			lda DStack+1,x	; d negative?
.d73b	30 e0		bmi $d71d			bmi DNegate3
=8					CodeLen	.var *-XtPtr1
=$d73d					Here1 = *	; remember here
>d733	08					.byte CodeLen	;patch wh_CodeLength
.d73d	60		rts				rts
>d73e	44 3c 3e			Name0:	.text "D<>"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=54977					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>d741	c3					.byte (("D<>"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=16					LinkDisplacement = Nt0-WordListLink
>d742	10					.byte WordFlags	;wh_Flags
>d743	03					.byte 3	;wh_CodeLength
>d744	10					  .byte LinkDisplacement	; offset to previous nt
=$d745					XtPtr1 ::= *
=54977					WordListLink ::= Nt0 ; remember the nt of this word for later
.d745	20 51 d7	jsr $d751	DNEq:		jsr DEqual
.d748	4c 3c d9	jmp $d93c			jmp ZEqA
=6					CodeLen	.var *-XtPtr1
=$d74b					Here1 = *	; remember here
>d743	06					.byte CodeLen	;patch wh_CodeLength
>d74b	44 3d				Name0:	.text "D="	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=54989					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>d74d	a2					.byte (("D="[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=12					LinkDisplacement = Nt0-WordListLink
>d74e	10					.byte WordFlags	;wh_Flags
>d74f	03					.byte 3	;wh_CodeLength
>d750	0c					  .byte LinkDisplacement	; offset to previous nt
=$d751					XtPtr1 ::= *
=54989					WordListLink ::= Nt0 ; remember the nt of this word for later
.d751	b5 2a		lda $2a,x	DEqual:		lda DStack+6,x
.d753	d5 26		cmp $26,x			cmp DStack+2,x
.d755	d0 4c		bne $d7a3			bne False3
.d757	b5 2b		lda $2b,x			lda DStack+7,x
.d759	d5 27		cmp $27,x			cmp DStack+3,x
.d75b	d0 46		bne $d7a3			bne False3
.d75d	b5 24		lda $24,x			lda DStack+0,x
.d75f	d5 28		cmp $28,x			cmp DStack+4,x
.d761	d0 40		bne $d7a3			bne False3
.d763	b5 25		lda $25,x			lda DStack+1,x
.d765	d5 29		cmp $29,x			cmp DStack+5,x
.d767	d0 3a		bne $d7a3			bne False3
.d769	f0 5c		beq $d7c7			beq True3
=26					CodeLen	.var *-XtPtr1
=$d76b					Here1 = *	; remember here
>d74f	1a					.byte CodeLen	;patch wh_CodeLength
>d76b	44 55 3e			Name0:	.text "DU>"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=55022					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>d76e	c3					.byte (("DU>"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=33					LinkDisplacement = Nt0-WordListLink
>d76f	10					.byte WordFlags	;wh_Flags
>d770	03					.byte 3	;wh_CodeLength
>d771	21					  .byte LinkDisplacement	; offset to previous nt
=$d772					XtPtr1 ::= *
=55022					WordListLink ::= Nt0 ; remember the nt of this word for later
.d772	20 08 d8	jsr $d808	DUGt:		jsr DGtSub
.d775	90 50		bcc $d7c7			bcc True3
.d777	b0 2a		bcs $d7a3			bcs False3
=7					CodeLen	.var *-XtPtr1
=$d779					Here1 = *	; remember here
>d770	07					.byte CodeLen	;patch wh_CodeLength
>d779	44 55 3c 3d			Name0:	.text "DU<="	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=55037					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>d77d	a4					.byte (("DU<="[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=15					LinkDisplacement = Nt0-WordListLink
>d77e	10					.byte WordFlags	;wh_Flags
>d77f	03					.byte 3	;wh_CodeLength
>d780	0f					  .byte LinkDisplacement	; offset to previous nt
=$d781					XtPtr1 ::= *
=55037					WordListLink ::= Nt0 ; remember the nt of this word for later
.d781	20 08 d8	jsr $d808	DULe:		jsr DGtSub
.d784	b0 41		bcs $d7c7			bcs True3
.d786	90 1b		bcc $d7a3			bcc False3
=7					CodeLen	.var *-XtPtr1
=$d788					Here1 = *	; remember here
>d77f	07					.byte CodeLen	;patch wh_CodeLength
>d788	44 55 3e 3d			Name0:	.text "DU>="	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=55052					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>d78c	a4					.byte (("DU>="[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=15					LinkDisplacement = Nt0-WordListLink
>d78d	10					.byte WordFlags	;wh_Flags
>d78e	03					.byte 3	;wh_CodeLength
>d78f	0f					  .byte LinkDisplacement	; offset to previous nt
=$d790					XtPtr1 ::= *
=55052					WordListLink ::= Nt0 ; remember the nt of this word for later
.d790	20 d8 d7	jsr $d7d8	DUGe:		jsr DLessSub
.d793	b0 32		bcs $d7c7			bcs True3
.d795	90 0c		bcc $d7a3			bcc False3
=7					CodeLen	.var *-XtPtr1
=$d797					Here1 = *	; remember here
>d78e	07					.byte CodeLen	;patch wh_CodeLength
>d797	44 55 3c			Name0:	.text "DU<"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=55066					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>d79a	83					.byte (("DU<"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=14					LinkDisplacement = Nt0-WordListLink
>d79b	10					.byte WordFlags	;wh_Flags
>d79c	03					.byte 3	;wh_CodeLength
>d79d	0e					  .byte LinkDisplacement	; offset to previous nt
=$d79e					XtPtr1 ::= *
=55066					WordListLink ::= Nt0 ; remember the nt of this word for later
.d79e	20 d8 d7	jsr $d7d8	DULess:		jsr DLessSub
.d7a1	90 24		bcc $d7c7			bcc True3
.d7a3	a9 00		lda #$00	False3:		lda #0
.d7a5	f0 22		beq $d7c9			beq DReturn3
=9					CodeLen	.var *-XtPtr1
=$d7a7					Here1 = *	; remember here
>d79c	09					.byte CodeLen	;patch wh_CodeLength
.d7a7	4c 2f c4	jmp $c42f	Throw_Stack_09: jmp Throw_Stack
>d7aa	44 3e 3d			Name0:	.text "D>="	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=55085					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>d7ad	a3					.byte (("D>="[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=19					LinkDisplacement = Nt0-WordListLink
>d7ae	10					.byte WordFlags	;wh_Flags
>d7af	03					.byte 3	;wh_CodeLength
>d7b0	13					  .byte LinkDisplacement	; offset to previous nt
=$d7b1					XtPtr1 ::= *
=55085					WordListLink ::= Nt0 ; remember the nt of this word for later
.d7b1	20 d8 d7	jsr $d7d8	DGEq:		jsr DLessSub
.d7b4	70 0f		bvs $d7c5			bvs DLess3
.d7b6	10 0f		bpl $d7c7	DGEq3:		bpl True3
.d7b8	30 e9		bmi $d7a3			bmi False3
=9					CodeLen	.var *-XtPtr1
=$d7ba					Here1 = *	; remember here
>d7af	09					.byte CodeLen	;patch wh_CodeLength
>d7ba	44 3c				Name0:	.text "D<"	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=55100					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>d7bc	82					.byte (("D<"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=15					LinkDisplacement = Nt0-WordListLink
>d7bd	10					.byte WordFlags	;wh_Flags
>d7be	03					.byte 3	;wh_CodeLength
>d7bf	0f					  .byte LinkDisplacement	; offset to previous nt
=$d7c0					XtPtr1 ::= *
=55100					WordListLink ::= Nt0 ; remember the nt of this word for later
.d7c0	20 d8 d7	jsr $d7d8	DLess:		jsr DLessSub
.d7c3	70 f1		bvs $d7b6			bvs DGEq3
.d7c5	10 dc		bpl $d7a3	DLess3:		bpl False3
.d7c7	a9 ff		lda #$ff	True3:		lda #$ff
.d7c9					DReturn3:
.d7c9	e0 29		cpx #$29		cpx #(DDim-4)*2+1	; far enough below end of data stack (& not negative)?
.d7cb	b0 da		bcs $d7a7		bcs Throw_Stack_09
.d7cd	95 2a		sta $2a,x			sta DStack+6,x
.d7cf	95 2b		sta $2b,x			sta DStack+7,x
.d7d1	e8		inx				inx			; preserve A, don't use ThreeDrop
.d7d2	e8		inx				inx
.d7d3	e8		inx				inx
.d7d4	e8		inx				inx
.d7d5	e8		inx				inx
.d7d6	e8		inx				inx
.d7d7	60		rts				rts
=24					CodeLen	.var *-XtPtr1
=$d7d8					Here1 = *	; remember here
>d7be	18					.byte CodeLen	;patch wh_CodeLength
.d7d8	b5 2a		lda $2a,x	DLessSub:	lda DStack+6,x
.d7da	d5 26		cmp $26,x			cmp DStack+2,x
.d7dc	b5 2b		lda $2b,x			lda DStack+7,x
.d7de	f5 27		sbc $27,x			sbc DStack+3,x
.d7e0	b5 28		lda $28,x			lda DStack+4,x
.d7e2	f5 24		sbc $24,x			sbc DStack+0,x
.d7e4	b5 29		lda $29,x			lda DStack+5,x
.d7e6	f5 25		sbc $25,x			sbc DStack+1,x
.d7e8	60		rts				rts
>d7e9	44 3c 3d			Name0:	.text "D<="	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=55148					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>d7ec	a3					.byte (("D<="[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=48					LinkDisplacement = Nt0-WordListLink
>d7ed	10					.byte WordFlags	;wh_Flags
>d7ee	03					.byte 3	;wh_CodeLength
>d7ef	30					  .byte LinkDisplacement	; offset to previous nt
=$d7f0					XtPtr1 ::= *
=55148					WordListLink ::= Nt0 ; remember the nt of this word for later
.d7f0	20 08 d8	jsr $d808	DLe:		jsr DGtSub
.d7f3	70 0f		bvs $d804			bvs DGt3
.d7f5	10 d0		bpl $d7c7	DLe3:		bpl True3
.d7f7	30 aa		bmi $d7a3			bmi False3
=9					CodeLen	.var *-XtPtr1
=$d7f9					Here1 = *	; remember here
>d7ee	09					.byte CodeLen	;patch wh_CodeLength
>d7f9	44 3e				Name0:	.text "D>"	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=55163					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>d7fb	c2					.byte (("D>"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=15					LinkDisplacement = Nt0-WordListLink
>d7fc	10					.byte WordFlags	;wh_Flags
>d7fd	03					.byte 3	;wh_CodeLength
>d7fe	0f					  .byte LinkDisplacement	; offset to previous nt
=$d7ff					XtPtr1 ::= *
=55163					WordListLink ::= Nt0 ; remember the nt of this word for later
.d7ff	20 08 d8	jsr $d808	DGt:		jsr DGtSub
.d802	70 f1		bvs $d7f5			bvs DLe3
.d804	30 c1		bmi $d7c7	DGt3:		bmi True3
.d806	10 9b		bpl $d7a3			bpl False3
=9					CodeLen	.var *-XtPtr1
=$d808					Here1 = *	; remember here
>d7fd	09					.byte CodeLen	;patch wh_CodeLength
.d808	b5 26		lda $26,x	DGtSub:		lda DStack+2,x
.d80a	d5 2a		cmp $2a,x			cmp DStack+6,x
.d80c	b5 27		lda $27,x			lda DStack+3,x
.d80e	f5 2b		sbc $2b,x			sbc DStack+7,x
.d810	b5 24		lda $24,x			lda DStack+0,x
.d812	f5 28		sbc $28,x			sbc DStack+4,x
.d814	b5 25		lda $25,x			lda DStack+1,x
.d816	f5 29		sbc $29,x			sbc DStack+5,x
.d818	60		rts				rts
>d819	44 30 3c 3d			Name0:	.text "D0<="	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=55197					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>d81d	a4					.byte (("D0<="[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=34					LinkDisplacement = Nt0-WordListLink
>d81e	10					.byte WordFlags	;wh_Flags
>d81f	03					.byte 3	;wh_CodeLength
>d820	22					  .byte LinkDisplacement	; offset to previous nt
=$d821					XtPtr1 ::= *
=55197					WordListLink ::= Nt0 ; remember the nt of this word for later
.d821	b5 25		lda $25,x	D0Le:		lda DStack+1,x	; test sign
.d823	30 65		bmi $d88a			bmi True1
.d825	10 24		bpl $d84b			bpl D0Equal
=6					CodeLen	.var *-XtPtr1
=$d827					Here1 = *	; remember here
>d81f	06					.byte CodeLen	;patch wh_CodeLength
>d827	44 30 3e			Name0:	.text "D0>"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=55210					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>d82a	c3					.byte (("D0>"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>d82b	10					.byte WordFlags	;wh_Flags
>d82c	03					.byte 3	;wh_CodeLength
>d82d	0d					  .byte LinkDisplacement	; offset to previous nt
=$d82e					XtPtr1 ::= *
=55210					WordListLink ::= Nt0 ; remember the nt of this word for later
.d82e	b5 25		lda $25,x	D0Gt:		lda DStack+1,x	; test sign
.d830	10 0b		bpl $d83d			bpl D0Ne
.d832	4c a9 d8	jmp $d8a9			jmp False1
>d835	44 30 3c 3e			Name0:	.text "D0<>"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=55225					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>d839	c4					.byte (("D0<>"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=15					LinkDisplacement = Nt0-WordListLink
>d83a	10					.byte WordFlags	;wh_Flags
>d83b	03					.byte 3	;wh_CodeLength
>d83c	0f					  .byte LinkDisplacement	; offset to previous nt
=$d83d					XtPtr1 ::= *
=55225					WordListLink ::= Nt0 ; remember the nt of this word for later
.d83d	20 52 d8	jsr $d852	D0Ne:		jsr D0EqSub
.d840	d0 48		bne $d88a			bne True1
.d842	f0 65		beq $d8a9			beq False1
=7					CodeLen	.var *-XtPtr1
=$d844					Here1 = *	; remember here
>d83b	07					.byte CodeLen	;patch wh_CodeLength
>d844	44 30 3d			Name0:	.text "D0="	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=55239					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>d847	a3					.byte (("D0="[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=14					LinkDisplacement = Nt0-WordListLink
>d848	10					.byte WordFlags	;wh_Flags
>d849	03					.byte 3	;wh_CodeLength
>d84a	0e					  .byte LinkDisplacement	; offset to previous nt
=$d84b					XtPtr1 ::= *
=55239					WordListLink ::= Nt0 ; remember the nt of this word for later
.d84b	20 52 d8	jsr $d852	D0Equal:	jsr D0EqSub
.d84e	d0 59		bne $d8a9			bne False1
.d850	f0 38		beq $d88a			beq True1
=7					CodeLen	.var *-XtPtr1
=$d852					Here1 = *	; remember here
>d849	07					.byte CodeLen	;patch wh_CodeLength
.d852	b5 26		lda $26,x	D0EqSub:	lda DStack+2,x
.d854	15 27		ora $27,x			ora DStack+3,x
.d856	15 24		ora $24,x			ora DStack+0,x
.d858	15 25		ora $25,x			ora DStack+1,x
.d85a	60		rts				rts
>d85b	44 30 3c			Name0:	.text "D0<"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=55262					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>d85e	83					.byte (("D0<"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=23					LinkDisplacement = Nt0-WordListLink
>d85f	10					.byte WordFlags	;wh_Flags
>d860	03					.byte 3	;wh_CodeLength
>d861	17					  .byte LinkDisplacement	; offset to previous nt
=$d862					XtPtr1 ::= *
=55262					WordListLink ::= Nt0 ; remember the nt of this word for later
.d862	b5 25		lda $25,x	D0Less:		lda DStack+1,x	; test sign
.d864	30 24		bmi $d88a			bmi True1
.d866	10 41		bpl $d8a9			bpl False1
=6					CodeLen	.var *-XtPtr1
=$d868					Here1 = *	; remember here
>d860	06					.byte CodeLen	;patch wh_CodeLength
>d868	44 30 3e 3d			Name0:	.text "D0>="	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=55276					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>d86c	a4					.byte (("D0>="[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=14					LinkDisplacement = Nt0-WordListLink
>d86d	10					.byte WordFlags	;wh_Flags
>d86e	03					.byte 3	;wh_CodeLength
>d86f	0e					  .byte LinkDisplacement	; offset to previous nt
=$d870					XtPtr1 ::= *
=55276					WordListLink ::= Nt0 ; remember the nt of this word for later
.d870	b5 25		lda $25,x	D0Ge:		lda DStack+1,x	; test sign
.d872	10 16		bpl $d88a			bpl True1
.d874	30 33		bmi $d8a9			bmi False1
=6					CodeLen	.var *-XtPtr1
=$d876					Here1 = *	; remember here
>d86e	06					.byte CodeLen	;patch wh_CodeLength
.d876	4c 2f c4	jmp $c42f	Throw_Stack_08: jmp Throw_Stack
>d879	3d				Name0:	.text "="	;  name of word as a string, ending at wh_NameLastChar
=1					NameLength = *-Name0
=55290					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>d87a	a1					.byte (("="[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=14					LinkDisplacement = Nt0-WordListLink
>d87b	10					.byte WordFlags	;wh_Flags
>d87c	03					.byte 3	;wh_CodeLength
>d87d	0e					  .byte LinkDisplacement	; offset to previous nt
=$d87e					XtPtr1 ::= *
=55290					WordListLink ::= Nt0 ; remember the nt of this word for later
.d87e	b5 24		lda $24,x	Equal:		lda DStack+0,x		; LSB
.d880	d5 26		cmp $26,x			cmp DStack+2,x
.d882	d0 25		bne $d8a9			bne False1
.d884	b5 25		lda $25,x			lda DStack+1,x		; MSB
.d886	d5 27		cmp $27,x			cmp DStack+3,x
.d888	d0 1f		bne $d8a9			bne False1
.d88a	a9 ff		lda #$ff	True1:		lda #$ff	; return TRUE
.d88c					Return1:
.d88c	e0 2d		cpx #$2d		cpx #(DDim-2)*2+1	; far enough below end of data stack (& not negative)?
.d88e	b0 e6		bcs $d876		bcs Throw_Stack_08
.d890	e8		inx				inx		; Drop
.d891	e8		inx				inx
.d892	95 24		sta $24,x			sta DStack+0,x	; store f
.d894	95 25		sta $25,x			sta DStack+1,x
.d896	60		rts				rts
=25					CodeLen	.var *-XtPtr1
=$d897					Here1 = *	; remember here
>d87c	19					.byte CodeLen	;patch wh_CodeLength
>d897	3c 3e				Name0:	.text "<>"	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=55321					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>d899	c2					.byte (("<>"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=31					LinkDisplacement = Nt0-WordListLink
>d89a	10					.byte WordFlags	;wh_Flags
>d89b	03					.byte 3	;wh_CodeLength
>d89c	1f					  .byte LinkDisplacement	; offset to previous nt
=$d89d					XtPtr1 ::= *
=55321					WordListLink ::= Nt0 ; remember the nt of this word for later
.d89d	b5 24		lda $24,x	Not_Equals:	lda DStack+0,x		; LSB
.d89f	d5 26		cmp $26,x			cmp DStack+2,x
.d8a1	d0 e7		bne $d88a			bne True1
.d8a3	b5 25		lda $25,x			lda DStack+1,x		; MSB
.d8a5	d5 27		cmp $27,x			cmp DStack+3,x
.d8a7	d0 e1		bne $d88a			bne True1
.d8a9	a9 00		lda #$00	False1:		lda #0		; return FALSE
.d8ab	f0 df		beq $d88c			beq Return1
=16					CodeLen	.var *-XtPtr1
=$d8ad					Here1 = *	; remember here
>d89b	10					.byte CodeLen	;patch wh_CodeLength
>d8ad	3c				Name0:	.text "<"	;  name of word as a string, ending at wh_NameLastChar
=1					NameLength = *-Name0
=55342					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>d8ae	81					.byte (("<"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=21					LinkDisplacement = Nt0-WordListLink
>d8af	10					.byte WordFlags	;wh_Flags
>d8b0	03					.byte 3	;wh_CodeLength
>d8b1	15					  .byte LinkDisplacement	; offset to previous nt
=$d8b2					XtPtr1 ::= *
=55342					WordListLink ::= Nt0 ; remember the nt of this word for later
.d8b2	b5 26		lda $26,x	Less_Than:	lda DStack+2,x	; compare
.d8b4	d5 24		cmp $24,x			cmp DStack+0,x
.d8b6	b5 27		lda $27,x			lda DStack+3,x
.d8b8	f5 25		sbc $25,x			sbc DStack+1,x
.d8ba	50 02		bvc $d8be			bvc _c
.d8bc	49 80		eor #$80			eor #$80	; fix sign
.d8be	10 e9		bpl $d8a9	_c:		bpl False1
.d8c0	30 c8		bmi $d88a			bmi True1
=16					CodeLen	.var *-XtPtr1
=$d8c2					Here1 = *	; remember here
>d8b0	10					.byte CodeLen	;patch wh_CodeLength
>d8c2	3e 3d				Name0:	.text ">="	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=55364					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>d8c4	a2					.byte ((">="[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=22					LinkDisplacement = Nt0-WordListLink
>d8c5	10					.byte WordFlags	;wh_Flags
>d8c6	03					.byte 3	;wh_CodeLength
>d8c7	16					  .byte LinkDisplacement	; offset to previous nt
=$d8c8					XtPtr1 ::= *
=55364					WordListLink ::= Nt0 ; remember the nt of this word for later
.d8c8	20 b2 d8	jsr $d8b2	Ge:		jsr Less_Than
.d8cb	4c 3c d9	jmp $d93c			jmp ZEqA
=6					CodeLen	.var *-XtPtr1
=$d8ce					Here1 = *	; remember here
>d8c6	06					.byte CodeLen	;patch wh_CodeLength
>d8ce	55 3c				Name0:	.text "U<"	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=55376					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>d8d0	82					.byte (("U<"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=12					LinkDisplacement = Nt0-WordListLink
>d8d1	10					.byte WordFlags	;wh_Flags
>d8d2	03					.byte 3	;wh_CodeLength
>d8d3	0c					  .byte LinkDisplacement	; offset to previous nt
=$d8d4					XtPtr1 ::= *
=55376					WordListLink ::= Nt0 ; remember the nt of this word for later
.d8d4	b5 26		lda $26,x	U_Less_Than:	lda DStack+2,x
.d8d6	d5 24		cmp $24,x			cmp DStack+0,x
.d8d8	b5 27		lda $27,x			lda DStack+3,x
.d8da	f5 25		sbc $25,x			sbc DStack+1,x
.d8dc	b0 cb		bcs $d8a9			bcs False1
.d8de	90 aa		bcc $d88a			bcc True1
=12					CodeLen	.var *-XtPtr1
=$d8e0					Here1 = *	; remember here
>d8d2	0c					.byte CodeLen	;patch wh_CodeLength
>d8e0	55 3e				Name0:	.text "U>"	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=55394					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>d8e2	c2					.byte (("U>"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=18					LinkDisplacement = Nt0-WordListLink
>d8e3	10					.byte WordFlags	;wh_Flags
>d8e4	03					.byte 3	;wh_CodeLength
>d8e5	12					  .byte LinkDisplacement	; offset to previous nt
=$d8e6					XtPtr1 ::= *
=55394					WordListLink ::= Nt0 ; remember the nt of this word for later
.d8e6	b5 24		lda $24,x	U_Greater_Than:	lda DStack+0,x
.d8e8	d5 26		cmp $26,x			cmp DStack+2,x
.d8ea	b5 25		lda $25,x			lda DStack+1,x
.d8ec	f5 27		sbc $27,x			sbc DStack+3,x
.d8ee	b0 b9		bcs $d8a9			bcs False1
.d8f0	90 98		bcc $d88a			bcc True1
=12					CodeLen	.var *-XtPtr1
=$d8f2					Here1 = *	; remember here
>d8e4	0c					.byte CodeLen	;patch wh_CodeLength
>d8f2	3e				Name0:	.text ">"	;  name of word as a string, ending at wh_NameLastChar
=1					NameLength = *-Name0
=55411					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>d8f3	c1					.byte ((">"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=17					LinkDisplacement = Nt0-WordListLink
>d8f4	10					.byte WordFlags	;wh_Flags
>d8f5	03					.byte 3	;wh_CodeLength
>d8f6	11					  .byte LinkDisplacement	; offset to previous nt
=$d8f7					XtPtr1 ::= *
=55411					WordListLink ::= Nt0 ; remember the nt of this word for later
.d8f7	b5 24		lda $24,x	Greater_Than:	lda DStack+0,x	; compare
.d8f9	d5 26		cmp $26,x			cmp DStack+2,x
.d8fb	b5 25		lda $25,x			lda DStack+1,x
.d8fd	f5 27		sbc $27,x			sbc DStack+3,x
.d8ff	50 02		bvc $d903			bvc _c
.d901	49 80		eor #$80			eor #$80	; fix sign
.d903	10 a4		bpl $d8a9	_c:		bpl False1
.d905	4c 8a d8	jmp $d88a			jmp True1
=17					CodeLen	.var *-XtPtr1
=$d908					Here1 = *	; remember here
>d8f5	11					.byte CodeLen	;patch wh_CodeLength
>d908	3c 3d				Name0:	.text "<="	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=55434					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>d90a	a2					.byte (("<="[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=23					LinkDisplacement = Nt0-WordListLink
>d90b	10					.byte WordFlags	;wh_Flags
>d90c	03					.byte 3	;wh_CodeLength
>d90d	17					  .byte LinkDisplacement	; offset to previous nt
=$d90e					XtPtr1 ::= *
=55434					WordListLink ::= Nt0 ; remember the nt of this word for later
.d90e	20 f7 d8	jsr $d8f7	Le:		jsr Greater_Than
.d911	4c 3c d9	jmp $d93c			jmp ZEqA
=6					CodeLen	.var *-XtPtr1
=$d914					Here1 = *	; remember here
>d90c	06					.byte CodeLen	;patch wh_CodeLength
>d914	55 3e 3d			Name0:	.text "U>="	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=55447					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>d917	a3					.byte (("U>="[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>d918	10					.byte WordFlags	;wh_Flags
>d919	03					.byte 3	;wh_CodeLength
>d91a	0d					  .byte LinkDisplacement	; offset to previous nt
=$d91b					XtPtr1 ::= *
=55447					WordListLink ::= Nt0 ; remember the nt of this word for later
.d91b	20 d4 d8	jsr $d8d4	UGe:		jsr U_Less_Than
.d91e	4c 3c d9	jmp $d93c			jmp ZEqA
=6					CodeLen	.var *-XtPtr1
=$d921					Here1 = *	; remember here
>d919	06					.byte CodeLen	;patch wh_CodeLength
>d921	55 3c 3d			Name0:	.text "U<="	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=55460					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>d924	a3					.byte (("U<="[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>d925	10					.byte WordFlags	;wh_Flags
>d926	03					.byte 3	;wh_CodeLength
>d927	0d					  .byte LinkDisplacement	; offset to previous nt
=$d928					XtPtr1 ::= *
=55460					WordListLink ::= Nt0 ; remember the nt of this word for later
.d928	20 e6 d8	jsr $d8e6	ULe:		jsr U_Greater_Than
.d92b	4c 3c d9	jmp $d93c			jmp ZEqA
=6					CodeLen	.var *-XtPtr1
=$d92e					Here1 = *	; remember here
>d926	06					.byte CodeLen	;patch wh_CodeLength
>d92e	30 3d				Name0:	.text "0="	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=55472					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>d930	a2					.byte (("0="[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=12					LinkDisplacement = Nt0-WordListLink
>d931	10					.byte WordFlags	;wh_Flags
>d932	03					.byte 3	;wh_CodeLength
>d933	0c					  .byte LinkDisplacement	; offset to previous nt
=$d934					XtPtr1 ::= *
=55472					WordListLink ::= Nt0 ; remember the nt of this word for later
.d934	b5 25		lda $25,x	Zero_Equal:	lda DStack+1,x
.d936	15 24		ora $24,x	ZEq3:		ora DStack+0,x
.d938	d0 2b		bne $d965			bne False0
.d93a	f0 14		beq $d950			beq True0
=8					CodeLen	.var *-XtPtr1
=$d93c					Here1 = *	; remember here
>d932	08					.byte CodeLen	;patch wh_CodeLength
.d93c					ZEqA:
.d93c	49 ff		eor #$ff			eor #$ff
.d93e	95 24		sta $24,x			sta DStack+0,x
.d940	95 25		sta $25,x			sta DStack+1,x
.d942	60		rts				rts
>d943	30 3c 3e			Name0:	.text "0<>"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=55494					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>d946	c3					.byte (("0<>"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=22					LinkDisplacement = Nt0-WordListLink
>d947	10					.byte WordFlags	;wh_Flags
>d948	03					.byte 3	;wh_CodeLength
>d949	16					  .byte LinkDisplacement	; offset to previous nt
=$d94a					XtPtr1 ::= *
=55494					WordListLink ::= Nt0 ; remember the nt of this word for later
.d94a	b5 25		lda $25,x	Zero_Unequal:	lda DStack+1,x
.d94c	15 24		ora $24,x	ZNe3:		ora DStack+0,x
.d94e	f0 15		beq $d965			beq False0
.d950	a9 ff		lda #$ff	True0:		lda #$ff	; return TRUE
.d952	95 24		sta $24,x	Return0:	sta DStack+0,x
.d954	95 25		sta $25,x			sta DStack+1,x
.d956	e0 2f		cpx #$2f		cpx #(DDim-1)*2+1	; far enough below end of data stack (& not negative)?
.d958	b0 35		bcs $d98f		bcs Throw_Stack_05
.d95a	60		rts				rts
=17					CodeLen	.var *-XtPtr1
=$d95b					Here1 = *	; remember here
>d948	11					.byte CodeLen	;patch wh_CodeLength
>d95b	30 3e				Name0:	.text "0>"	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=55517					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>d95d	c2					.byte (("0>"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=23					LinkDisplacement = Nt0-WordListLink
>d95e	10					.byte WordFlags	;wh_Flags
>d95f	03					.byte 3	;wh_CodeLength
>d960	17					  .byte LinkDisplacement	; offset to previous nt
=$d961					XtPtr1 ::= *
=55517					WordListLink ::= Nt0 ; remember the nt of this word for later
.d961	b5 25		lda $25,x	Zero_Greater:	lda DStack+1,x	; MSB
.d963	10 e7		bpl $d94c			bpl ZNe3	; >= 0 ?
.d965	a9 00		lda #$00	False0:		lda #0		; return FALSE
.d967	f0 e9		beq $d952			beq Return0
=8					CodeLen	.var *-XtPtr1
=$d969					Here1 = *	; remember here
>d95f	08					.byte CodeLen	;patch wh_CodeLength
>d969	30 3c 3d			Name0:	.text "0<="	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=55532					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>d96c	a3					.byte (("0<="[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=15					LinkDisplacement = Nt0-WordListLink
>d96d	10					.byte WordFlags	;wh_Flags
>d96e	03					.byte 3	;wh_CodeLength
>d96f	0f					  .byte LinkDisplacement	; offset to previous nt
=$d970					XtPtr1 ::= *
=55532					WordListLink ::= Nt0 ; remember the nt of this word for later
.d970	b5 25		lda $25,x	ZLe:		lda DStack+1,x	; < 0 ?
.d972	30 dc		bmi $d950			bmi True0
.d974	10 c0		bpl $d936			bpl ZEq3
=6					CodeLen	.var *-XtPtr1
=$d976					Here1 = *	; remember here
>d96e	06					.byte CodeLen	;patch wh_CodeLength
>d976	30 3e 3d			Name0:	.text "0>="	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=55545					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>d979	a3					.byte (("0>="[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>d97a	10					.byte WordFlags	;wh_Flags
>d97b	03					.byte 3	;wh_CodeLength
>d97c	0d					  .byte LinkDisplacement	; offset to previous nt
=$d97d					XtPtr1 ::= *
=55545					WordListLink ::= Nt0 ; remember the nt of this word for later
.d97d	b5 25		lda $25,x	ZGe:		lda DStack+1,x
.d97f	10 cf		bpl $d950			bpl True0
.d981	30 e2		bmi $d965			bmi False0
=6					CodeLen	.var *-XtPtr1
=$d983					Here1 = *	; remember here
>d97b	06					.byte CodeLen	;patch wh_CodeLength
>d983	30 3c				Name0:	.text "0<"	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=55557					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>d985	82					.byte (("0<"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=12					LinkDisplacement = Nt0-WordListLink
>d986	10					.byte WordFlags	;wh_Flags
>d987	03					.byte 3	;wh_CodeLength
>d988	0c					  .byte LinkDisplacement	; offset to previous nt
=$d989					XtPtr1 ::= *
=55557					WordListLink ::= Nt0 ; remember the nt of this word for later
.d989	b5 25		lda $25,x	Zero_Less:	lda DStack+1,x	; MSB
.d98b	10 d8		bpl $d965			bpl False0
.d98d	30 c1		bmi $d950			bmi True0
=6					CodeLen	.var *-XtPtr1
=$d98f					Here1 = *	; remember here
>d987	06					.byte CodeLen	;patch wh_CodeLength
.d98f	4c 2f c4	jmp $c42f	Throw_Stack_05: jmp Throw_Stack
>d992	4d 69 6e			Name0:	.text "Min"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=55573					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>d995	c3					.byte (("Min"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=16					LinkDisplacement = Nt0-WordListLink
>d996	10					.byte WordFlags	;wh_Flags
>d997	03					.byte 3	;wh_CodeLength
>d998	10					  .byte LinkDisplacement	; offset to previous nt
=$d999					XtPtr1 ::= *
=55573					WordListLink ::= Nt0 ; remember the nt of this word for later
.d999					Min:
.d999	e0 2d		cpx #$2d		cpx #(DDim-2)*2+1	; far enough below end of data stack (& not negative)?
.d99b	b0 f2		bcs $d98f		bcs Throw_Stack_05
.d99d	b5 24		lda $24,x			lda DStack+0,x	; compare n1 & n2; sets V & N but not Z
.d99f	d5 26		cmp $26,x			cmp DStack+2,x
.d9a1	b5 25		lda $25,x			lda DStack+1,x
.d9a3	f5 27		sbc $27,x			sbc DStack+3,x
.d9a5	70 1a		bvs $d9c1			bvs Max_3	; if overflow, the sign is backwards
.d9a7	30 28		bmi $d9d1	Min_3:		bmi Nip_NoUf	; if negative, NOS is larger and needs to be dumped
.d9a9	e8		inx				inx		; Drop n2
.d9aa	e8		inx				inx
=18					CodeLen	.var *-XtPtr1
=$d9ab					Here1 = *	; remember here
>d997	12					.byte CodeLen	;patch wh_CodeLength
.d9ab	60		rts				rts
>d9ac	4d 61 78			Name0:	.text "Max"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=55599					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>d9af	03					.byte (("Max"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=26					LinkDisplacement = Nt0-WordListLink
>d9b0	10					.byte WordFlags	;wh_Flags
>d9b1	03					.byte 3	;wh_CodeLength
>d9b2	1a					  .byte LinkDisplacement	; offset to previous nt
=$d9b3					XtPtr1 ::= *
=55599					WordListLink ::= Nt0 ; remember the nt of this word for later
.d9b3					Max:
.d9b3	e0 2d		cpx #$2d		cpx #(DDim-2)*2+1	; far enough below end of data stack (& not negative)?
.d9b5	b0 d8		bcs $d98f		bcs Throw_Stack_05
.d9b7	b5 24		lda $24,x			lda DStack+0,x	; Compare n1 & n2; sets V & N but not Z
.d9b9	d5 26		cmp $26,x			cmp DStack+2,x
.d9bb	b5 25		lda $25,x			lda DStack+1,x
.d9bd	f5 27		sbc $27,x			sbc DStack+3,x
.d9bf	70 e6		bvs $d9a7			bvs Min_3	; if overflow, the sign is backwards
.d9c1	10 0e		bpl $d9d1	Max_3:		bpl Nip_NoUf	; if negative, NOS is larger and needs to be kept
.d9c3	e8		inx				inx		; Drop n2
.d9c4	e8		inx				inx
=18					CodeLen	.var *-XtPtr1
=$d9c5					Here1 = *	; remember here
>d9b1	12					.byte CodeLen	;patch wh_CodeLength
.d9c5	60		rts				rts
>d9c6	4e 69 70			Name0:	.text "Nip"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=55625					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>d9c9	03					.byte (("Nip"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=26					LinkDisplacement = Nt0-WordListLink
>d9ca	10					.byte WordFlags	;wh_Flags
>d9cb	03					.byte 3	;wh_CodeLength
>d9cc	1a					  .byte LinkDisplacement	; offset to previous nt
=$d9cd					XtPtr1 ::= *
=55625					WordListLink ::= Nt0 ; remember the nt of this word for later
.d9cd					Nip:
.d9cd	e0 2d		cpx #$2d		cpx #(DDim-2)*2+1	; far enough below end of data stack (& not negative)?
.d9cf	b0 be		bcs $d98f		bcs Throw_Stack_05
.d9d1	b5 24		lda $24,x	Nip_NoUf:	lda DStack+0,x	; PopYA
.d9d3	b4 25		ldy $25,x			ldy DStack+1,x
.d9d5	e8		inx				inx
.d9d6	e8		inx				inx
.d9d7	95 24		sta $24,x			sta DStack+0,x	; store over n1
.d9d9	94 25		sty $25,x			sty DStack+1,x
=14					CodeLen	.var *-XtPtr1
=$d9db					Here1 = *	; remember here
>d9cb	0e					.byte CodeLen	;patch wh_CodeLength
.d9db	60		rts				rts
>d9dc	50 69 63 6b			Name0:	.text "Pick"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=55648					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>d9e0	64					.byte (("Pick"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=0					WordFlags ::= 0	; modifiable copy, remember for later
=23					LinkDisplacement = Nt0-WordListLink
>d9e1	00					.byte WordFlags	;wh_Flags
>d9e2	03					.byte 3	;wh_CodeLength
>d9e3	17					  .byte LinkDisplacement	; offset to previous nt
=$d9e4					XtPtr1 ::= *
=55648					WordListLink ::= Nt0 ; remember the nt of this word for later
.d9e4					Pick:
.d9e4	16 24		asl $24,x			asl DStack+0,x	; we assume u < 128 (stack is small)
.d9e6	8a		txa				txa
.d9e7	75 24		adc $24,x			adc DStack+0,x
.d9e9	a8		tay				tay
.d9ea	b9 26 00	lda $0026,y			lda DStack+2,y
.d9ed	95 24		sta $24,x			sta DStack+0,x
.d9ef	b9 27 00	lda $0027,y			lda DStack+3,y
.d9f2	95 25		sta $25,x			sta DStack+1,x
=16					CodeLen	.var *-XtPtr1
=$d9f4					Here1 = *	; remember here
>d9e2	10					.byte CodeLen	;patch wh_CodeLength
.d9f4	60		rts				rts
>d9f5	43 68 61 72			Name0:	.text "Char"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=55673					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>d9f9	44					.byte (("Char"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=25					LinkDisplacement = Nt0-WordListLink
>d9fa	10					.byte WordFlags	;wh_Flags
>d9fb	03					.byte 3	;wh_CodeLength
>d9fc	19					  .byte LinkDisplacement	; offset to previous nt
=$d9fd					XtPtr1 ::= *
=55673					WordListLink ::= Nt0 ; remember the nt of this word for later
.d9fd					Char:
.d9fd	20 b8 ca	jsr $cab8			jsr parse_name_check
.da00	e8		inx				inx		; Drop number of characters, leave addr
.da01	e8		inx				inx
.da02	4c a4 dd	jmp $dda4			jmp C_Fetch	; get character ( C@ )
=8					CodeLen	.var *-XtPtr1
=$da05					Here1 = *	; remember here
>d9fb	08					.byte CodeLen	;patch wh_CodeLength
>da05	5b 43 68 61 72 5d		Name0:	.text "[Char]"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=55691					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>da0b	a6					.byte (("[Char]"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=28					WordFlags ::= CO+IM+NN	; modifiable copy, remember for later
=18					LinkDisplacement = Nt0-WordListLink
>da0c	1c					.byte WordFlags	;wh_Flags
>da0d	03					.byte 3	;wh_CodeLength
>da0e	12					  .byte LinkDisplacement	; offset to previous nt
=$da0f					XtPtr1 ::= *
=55691					WordListLink ::= Nt0 ; remember the nt of this word for later
.da0f	20 fd d9	jsr $d9fd	Bracket_Char:	jsr Char
.da12	4c 57 c7	jmp $c757			jmp Literal
=6					CodeLen	.var *-XtPtr1
=$da15					Here1 = *	; remember here
>da0d	06					.byte CodeLen	;patch wh_CodeLength
>da15	43 68 61 72 2b			Name0:	.text "Char+"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=55706					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>da1a	65					.byte (("Char+"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=15					LinkDisplacement = Nt0-WordListLink
>da1b	10					.byte WordFlags	;wh_Flags
>da1c	03					.byte 3	;wh_CodeLength
>da1d	0f					  .byte LinkDisplacement	; offset to previous nt
=$da1e					XtPtr1 ::= *
=55706					WordListLink ::= Nt0 ; remember the nt of this word for later
.da1e	4c 9a da	jmp $da9a	Char_Plus:	jmp One_Plus
=3					CodeLen	.var *-XtPtr1
=$da21					Here1 = *	; remember here
>da1c	03					.byte CodeLen	;patch wh_CodeLength
>da21	43 68 61 72 73			Name0:	.text "Chars"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=55718					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>da26	65					.byte (("Chars"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$20					WordFlags ::= AN	; modifiable copy, remember for later
=12					LinkDisplacement = Nt0-WordListLink
>da27	20					.byte WordFlags	;wh_Flags
>da28	03					.byte 3	;wh_CodeLength
>da29	0c					  .byte LinkDisplacement	; offset to previous nt
=$da2a					XtPtr1 ::= *
=55718					WordListLink ::= Nt0 ; remember the nt of this word for later
.da2a					Chars:
=0					CodeLen	.var *-XtPtr1
=$da2a					Here1 = *	; remember here
>da28	00					.byte CodeLen	;patch wh_CodeLength
.da2a	60		rts				rts
>da2b	43 65 6c 6c 73			Name0:	.text "Cells"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=55728					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>da30	65					.byte (("Cells"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=10					LinkDisplacement = Nt0-WordListLink
>da31	10					.byte WordFlags	;wh_Flags
>da32	03					.byte 3	;wh_CodeLength
>da33	0a					  .byte LinkDisplacement	; offset to previous nt
=$da34					XtPtr1 ::= *
=55728					WordListLink ::= Nt0 ; remember the nt of this word for later
.da34					Cells:
.da34	e0 2f		cpx #$2f		cpx #(DDim-1)*2+1	; far enough below end of data stack (& not negative)?
.da36	b0 74		bcs $daac		bcs Throw_Stack_19
.da38	16 24		asl $24,x			asl DStack+0,x		; 2*
.da3a	36 25		rol $25,x			rol DStack+1,x
=8					CodeLen	.var *-XtPtr1
=$da3c					Here1 = *	; remember here
>da32	08					.byte CodeLen	;patch wh_CodeLength
.da3c	60		rts				rts
>da3d	43 65 6c 6c 2b			Name0:	.text "Cell+"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=55746					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>da42	65					.byte (("Cell+"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$40					WordFlags ::= UF	; modifiable copy, remember for later
=18					LinkDisplacement = Nt0-WordListLink
>da43	40					.byte WordFlags	;wh_Flags
>da44	03					.byte 3	;wh_CodeLength
>da45	12					  .byte LinkDisplacement	; offset to previous nt
=$da46					XtPtr1 ::= *
=55746					WordListLink ::= Nt0 ; remember the nt of this word for later
.da46	a9 02		lda #$02	Cell_Plus:	lda #2		; our cells are 2 bytes
.da48					Plus_A:
.da48	e0 2f		cpx #$2f		cpx #(DDim-1)*2+1	; far enough below end of data stack (& not negative)?
.da4a	b0 60		bcs $daac		bcs Throw_Stack_19
.da4c	75 24		adc $24,x			adc DStack+0,x
.da4e	95 24		sta $24,x			sta DStack+0,x
.da50	90 02		bcc $da54			bcc +
.da52	f6 25		inc $25,x			inc DStack+1,x
.da54					+
=14					CodeLen	.var *-XtPtr1
=$da54					Here1 = *	; remember here
>da44	0e					.byte CodeLen	;patch wh_CodeLength
.da54	60		rts				rts
.da55					Nos_Plus_A:
.da55	18		clc				clc
.da56	75 26		adc $26,x			adc DStack+2,x
.da58	95 26		sta $26,x			sta DStack+2,x
.da5a	90 02		bcc $da5e			bcc +
.da5c	f6 27		inc $27,x			inc DStack+3,x
.da5e	60		rts		+		rts
>da5f	48 65 72 65			Name0:	.text "Here"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=55779					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>da63	a4					.byte (("Here"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=33					LinkDisplacement = Nt0-WordListLink
>da64	10					.byte WordFlags	;wh_Flags
>da65	03					.byte 3	;wh_CodeLength
>da66	21					  .byte LinkDisplacement	; offset to previous nt
=$da67					XtPtr1 ::= *
=55779					WordListLink ::= Nt0 ; remember the nt of this word for later
.da67	a5 00		lda $00		Here:		lda cp+0
.da69	a4 01		ldy $01				ldy cp+1
.da6b	4c ba c7	jmp $c7ba			jmp PushYA
=7					CodeLen	.var *-XtPtr1
=$da6e					Here1 = *	; remember here
>da65	07					.byte CodeLen	;patch wh_CodeLength
>da6e	31 2d				Name0:	.text "1-"	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=55792					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>da70	a2					.byte (("1-"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>da71	10					.byte WordFlags	;wh_Flags
>da72	03					.byte 3	;wh_CodeLength
>da73	0d					  .byte LinkDisplacement	; offset to previous nt
=$da74					XtPtr1 ::= *
=55792					WordListLink ::= Nt0 ; remember the nt of this word for later
.da74					One_Minus:
.da74	e0 2f		cpx #$2f		cpx #(DDim-1)*2+1	; far enough below end of data stack (& not negative)?
.da76	b0 34		bcs $daac		bcs Throw_Stack_19
.da78					One_Minus_NoUf:
.da78	b5 24		lda $24,x			lda DStack+0,x
.da7a	d0 02		bne $da7e			bne +
.da7c	d6 25		dec $25,x			dec DStack+1,x
.da7e	d6 24		dec $24,x	+		dec DStack+0,x
=12					CodeLen	.var *-XtPtr1
=$da80					Here1 = *	; remember here
>da72	0c					.byte CodeLen	;patch wh_CodeLength
.da80	60		rts				rts
.da81					NOS_One_Minus:
.da81	b5 26		lda $26,x			lda DStack+2,x
.da83	d0 02		bne $da87			bne +
.da85	d6 27		dec $27,x			dec DStack+3,x
.da87	d6 26		dec $26,x	+		dec DStack+2,x
.da89	60		rts				rts
.da8a					Minus_A:
.da8a	18		clc				clc
.da8b	75 24		adc $24,x			adc DStack+0,x
.da8d	95 24		sta $24,x			sta DStack+0,x
.da8f	b0 02		bcs $da93			bcs +
.da91	d6 25		dec $25,x			dec DStack+1,x
.da93	60		rts		+		rts
>da94	31 2b				Name0:	.text "1+"	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=55830					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>da96	62					.byte (("1+"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=38					LinkDisplacement = Nt0-WordListLink
>da97	10					.byte WordFlags	;wh_Flags
>da98	03					.byte 3	;wh_CodeLength
>da99	26					  .byte LinkDisplacement	; offset to previous nt
=$da9a					XtPtr1 ::= *
=55830					WordListLink ::= Nt0 ; remember the nt of this word for later
.da9a					One_Plus:
.da9a	e0 2f		cpx #$2f		cpx #(DDim-1)*2+1	; far enough below end of data stack (& not negative)?
.da9c	b0 0e		bcs $daac		bcs Throw_Stack_19
.da9e	f6 24		inc $24,x			inc DStack+0,x
.daa0	d0 02		bne $daa4			bne +
.daa2	f6 25		inc $25,x			inc DStack+1,x
.daa4					+
=10					CodeLen	.var *-XtPtr1
=$daa4					Here1 = *	; remember here
>da98	0a					.byte CodeLen	;patch wh_CodeLength
.daa4	60		rts				rts
.daa5					NOS_One_Plus:
.daa5	f6 26		inc $26,x			inc DStack+2,x
.daa7	d0 02		bne $daab			bne +
.daa9	f6 27		inc $27,x			inc DStack+3,x
.daab	60		rts		+		rts
.daac	4c 2f c4	jmp $c42f	Throw_Stack_19: jmp Throw_Stack
>daaf	55 4d 2b			Name0:	.text "UM+"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=55858					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>dab2	63					.byte (("UM+"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=0					WordFlags ::= 0	; modifiable copy, remember for later
=28					LinkDisplacement = Nt0-WordListLink
>dab3	00					.byte WordFlags	;wh_Flags
>dab4	03					.byte 3	;wh_CodeLength
>dab5	1c					  .byte LinkDisplacement	; offset to previous nt
=$dab6					XtPtr1 ::= *
=55858					WordListLink ::= Nt0 ; remember the nt of this word for later
.dab6	20 e3 c3	jsr $c3e3	UMPlus:		jsr PopYA
.dab9	18		clc				clc		; add n to d1.lo
.daba	75 26		adc $26,x			adc DStack+2,x
.dabc	95 26		sta $26,x			sta DStack+2,x
.dabe	98		tya				tya
.dabf	75 27		adc $27,x			adc DStack+3,x
.dac1	95 27		sta $27,x			sta DStack+3,x
.dac3	90 06		bcc $dacb			bcc +		; propagate carry thru d1.hi
.dac5	f6 24		inc $24,x			inc DStack+0,x
.dac7	d0 02		bne $dacb			bne +
.dac9	f6 25		inc $25,x			inc DStack+1,x
.dacb					+
=21					CodeLen	.var *-XtPtr1
=$dacb					Here1 = *	; remember here
>dab4	15					.byte CodeLen	;patch wh_CodeLength
.dacb	60		rts				rts
>dacc	4d 2b				Name0:	.text "M+"	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=55886					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>dace	62					.byte (("M+"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=28					LinkDisplacement = Nt0-WordListLink
>dacf	10					.byte WordFlags	;wh_Flags
>dad0	03					.byte 3	;wh_CodeLength
>dad1	1c					  .byte LinkDisplacement	; offset to previous nt
=$dad2					XtPtr1 ::= *
=55886					WordListLink ::= Nt0 ; remember the nt of this word for later
.dad2	20 b6 da	jsr $dab6	MPlus:		jsr UMPlus
.dad5	98		tya				tya		; if n negative
.dad6	30 a0		bmi $da78			bmi One_Minus_NoUf ;   decrement d1.hi
=6					CodeLen	.var *-XtPtr1
=$dad8					Here1 = *	; remember here
>dad0	06					.byte CodeLen	;patch wh_CodeLength
.dad8	60		rts				rts
>dad9	44 32 2a			Name0:	.text "D2*"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=55900					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>dadc	43					.byte (("D2*"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=14					LinkDisplacement = Nt0-WordListLink
>dadd	10					.byte WordFlags	;wh_Flags
>dade	03					.byte 3	;wh_CodeLength
>dadf	0e					  .byte LinkDisplacement	; offset to previous nt
=$dae0					XtPtr1 ::= *
=55900					WordListLink ::= Nt0 ; remember the nt of this word for later
.dae0					D2Star:
.dae0	e0 2d		cpx #$2d		cpx #(DDim-2)*2+1	; far enough below end of data stack (& not negative)?
.dae2	b0 c8		bcs $daac		bcs Throw_Stack_19
.dae4	16 26		asl $26,x			asl DStack+2,x
.dae6	36 27		rol $27,x			rol DStack+3,x
.dae8	36 24		rol $24,x			rol DStack+0,x
.daea	36 25		rol $25,x			rol DStack+1,x
=12					CodeLen	.var *-XtPtr1
=$daec					Here1 = *	; remember here
>dade	0c					.byte CodeLen	;patch wh_CodeLength
.daec	60		rts				rts
>daed	44 32 2f			Name0:	.text "D2/"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=55920					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>daf0	e3					.byte (("D2/"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=20					LinkDisplacement = Nt0-WordListLink
>daf1	10					.byte WordFlags	;wh_Flags
>daf2	03					.byte 3	;wh_CodeLength
>daf3	14					  .byte LinkDisplacement	; offset to previous nt
=$daf4					XtPtr1 ::= *
=55920					WordListLink ::= Nt0 ; remember the nt of this word for later
.daf4					D2Slash:
.daf4	e0 2d		cpx #$2d		cpx #(DDim-2)*2+1	; far enough below end of data stack (& not negative)?
.daf6	b0 b4		bcs $daac		bcs Throw_Stack_19
.daf8	b5 25		lda $25,x			lda DStack+1,x		; setup for sign-extended shift right
.dafa	0a		asl a				asl a
.dafb	76 25		ror $25,x	D2SlashU:	ror DStack+1,x
.dafd	76 24		ror $24,x			ror DStack+0,x
.daff	76 27		ror $27,x			ror DStack+3,x
.db01	76 26		ror $26,x			ror DStack+2,x
=15					CodeLen	.var *-XtPtr1
=$db03					Here1 = *	; remember here
>daf2	0f					.byte CodeLen	;patch wh_CodeLength
.db03	60		rts				rts
>db04	55 44 32 2f			Name0:	.text "UD2/"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=55944					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>db08	e4					.byte (("UD2/"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=24					LinkDisplacement = Nt0-WordListLink
>db09	10					.byte WordFlags	;wh_Flags
>db0a	03					.byte 3	;wh_CodeLength
>db0b	18					  .byte LinkDisplacement	; offset to previous nt
=$db0c					XtPtr1 ::= *
=55944					WordListLink ::= Nt0 ; remember the nt of this word for later
.db0c					DU2Slash:
.db0c	e0 2d		cpx #$2d		cpx #(DDim-2)*2+1	; far enough below end of data stack (& not negative)?
.db0e	b0 9c		bcs $daac		bcs Throw_Stack_19
.db10	18		clc				clc
.db11	90 e8		bcc $dafb			bcc D2SlashU
=7					CodeLen	.var *-XtPtr1
=$db13					Here1 = *	; remember here
>db0a	07					.byte CodeLen	;patch wh_CodeLength
>db13	32 2a				Name0:	.text "2*"	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=55957					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>db15	42					.byte (("2*"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>db16	10					.byte WordFlags	;wh_Flags
>db17	03					.byte 3	;wh_CodeLength
>db18	0d					  .byte LinkDisplacement	; offset to previous nt
=$db19					XtPtr1 ::= *
=55957					WordListLink ::= Nt0 ; remember the nt of this word for later
.db19					Two_Star:
.db19	e0 2f		cpx #$2f		cpx #(DDim-1)*2+1	; far enough below end of data stack (& not negative)?
.db1b	b0 8f		bcs $daac		bcs Throw_Stack_19
.db1d	16 24		asl $24,x			asl DStack+0,x
.db1f	36 25		rol $25,x			rol DStack+1,x
=8					CodeLen	.var *-XtPtr1
=$db21					Here1 = *	; remember here
>db17	08					.byte CodeLen	;patch wh_CodeLength
.db21	60		rts				rts
>db22	32 2f				Name0:	.text "2/"	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=55972					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>db24	e2					.byte (("2/"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=15					LinkDisplacement = Nt0-WordListLink
>db25	10					.byte WordFlags	;wh_Flags
>db26	03					.byte 3	;wh_CodeLength
>db27	0f					  .byte LinkDisplacement	; offset to previous nt
=$db28					XtPtr1 ::= *
=55972					WordListLink ::= Nt0 ; remember the nt of this word for later
.db28					Two_Slash:
.db28	e0 2f		cpx #$2f		cpx #(DDim-1)*2+1	; far enough below end of data stack (& not negative)?
.db2a	b0 80		bcs $daac		bcs Throw_Stack_19
.db2c	b5 25		lda $25,x			lda DStack+1,x		; load sign into carry, for signed shift
.db2e	0a		asl a				asl
.db2f	76 25		ror $25,x			ror DStack+1,x
.db31	76 24		ror $24,x			ror DStack+0,x
=11					CodeLen	.var *-XtPtr1
=$db33					Here1 = *	; remember here
>db26	0b					.byte CodeLen	;patch wh_CodeLength
.db33	60		rts				rts
>db34	55 32 2f			Name0:	.text "U2/"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=55991					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>db37	e3					.byte (("U2/"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$40					WordFlags ::= UF	; modifiable copy, remember for later
=19					LinkDisplacement = Nt0-WordListLink
>db38	40					.byte WordFlags	;wh_Flags
>db39	03					.byte 3	;wh_CodeLength
>db3a	13					  .byte LinkDisplacement	; offset to previous nt
=$db3b					XtPtr1 ::= *
=55991					WordListLink ::= Nt0 ; remember the nt of this word for later
.db3b					UTwo_Slash:
.db3b	e0 2f		cpx #$2f		cpx #(DDim-1)*2+1	; far enough below end of data stack (& not negative)?
.db3d	b0 75		bcs $dbb4		bcs Throw_Stack_18
.db3f	56 25		lsr $25,x			lsr DStack+1,x
.db41	76 24		ror $24,x			ror DStack+0,x
=8					CodeLen	.var *-XtPtr1
=$db43					Here1 = *	; remember here
>db39	08					.byte CodeLen	;patch wh_CodeLength
.db43	60		rts				rts
>db44	44 52 53 68 69 66 74		Name0:	.text "DRShift"	;  name of word as a string, ending at wh_NameLastChar
=7					NameLength = *-Name0
=56011					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>db4b	87					.byte (("DRShift"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=0					WordFlags ::= 0	; modifiable copy, remember for later
=20					LinkDisplacement = Nt0-WordListLink
>db4c	00					.byte WordFlags	;wh_Flags
>db4d	03					.byte 3	;wh_CodeLength
>db4e	14					  .byte LinkDisplacement	; offset to previous nt
=$db4f					XtPtr1 ::= *
=56011					WordListLink ::= Nt0 ; remember the nt of this word for later
.db4f	20 c8 c3	jsr $c3c8	DRShift:	jsr PopA	; pop u
.db52	a8		tay		DRShiftA:	tay
.db53	f0 0e		beq $db63			beq _9
.db55	b5 25		lda $25,x			lda DStack+1,x
.db57	4a		lsr a		_2:		lsr a
.db58	76 24		ror $24,x			ror DStack+0,x
.db5a	76 27		ror $27,x			ror DStack+3,x
.db5c	76 26		ror $26,x			ror DStack+2,x
.db5e	88		dey				dey
.db5f	d0 f6		bne $db57			bne _2
.db61	95 25		sta $25,x			sta DStack+1,x
.db63					_9:
=20					CodeLen	.var *-XtPtr1
=$db63					Here1 = *	; remember here
>db4d	14					.byte CodeLen	;patch wh_CodeLength
.db63	60		rts				rts
>db64	52 53 68 69 66 74		Name0:	.text "RShift"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=56042					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>db6a	86					.byte (("RShift"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=0					WordFlags ::= 0	; modifiable copy, remember for later
=31					LinkDisplacement = Nt0-WordListLink
>db6b	00					.byte WordFlags	;wh_Flags
>db6c	03					.byte 3	;wh_CodeLength
>db6d	1f					  .byte LinkDisplacement	; offset to previous nt
=$db6e					XtPtr1 ::= *
=56042					WordListLink ::= Nt0 ; remember the nt of this word for later
.db6e	20 d1 c3	jsr $c3d1	RShift:		jsr PopA2	; pop u, check for 2 params
.db71	a8		tay		RShift_A:	tay		; get shift count
.db72	f0 0a		beq $db7e			beq _done
.db74	b5 25		lda $25,x			lda DStack+1,x
.db76	4a		lsr a		_loop:		lsr a
.db77	76 24		ror $24,x			ror DStack+0,x
.db79	88		dey				dey
.db7a	d0 fa		bne $db76			bne _loop
.db7c	95 25		sta $25,x			sta DStack+1,x
.db7e					_done:
=16					CodeLen	.var *-XtPtr1
=$db7e					Here1 = *	; remember here
>db6c	10					.byte CodeLen	;patch wh_CodeLength
.db7e	60		rts				rts
>db7f	4c 53 68 69 66 74		Name0:	.text "LShift"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=56069					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>db85	86					.byte (("LShift"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=0					WordFlags ::= 0	; modifiable copy, remember for later
=27					LinkDisplacement = Nt0-WordListLink
>db86	00					.byte WordFlags	;wh_Flags
>db87	03					.byte 3	;wh_CodeLength
>db88	1b					  .byte LinkDisplacement	; offset to previous nt
=$db89					XtPtr1 ::= *
=56069					WordListLink ::= Nt0 ; remember the nt of this word for later
.db89	20 d1 c3	jsr $c3d1	LShift:		jsr PopA2	; pop u, check for 2 params
.db8c	a8		tay		LShift_A:	tay		; get shift count
.db8d	f0 0a		beq $db99			beq _done
.db8f	b5 25		lda $25,x			lda DStack+1,x
.db91	16 24		asl $24,x	_loop:		asl DStack+0,x
.db93	2a		rol a				rol a
.db94	88		dey				dey
.db95	d0 fa		bne $db91			bne _loop
.db97	95 25		sta $25,x			sta DStack+1,x
.db99					_done:
=16					CodeLen	.var *-XtPtr1
=$db99					Here1 = *	; remember here
>db87	10					.byte CodeLen	;patch wh_CodeLength
.db99	60		rts				rts
>db9a	41 6e 64			Name0:	.text "And"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=56093					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>db9d	83					.byte (("And"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=24					LinkDisplacement = Nt0-WordListLink
>db9e	10					.byte WordFlags	;wh_Flags
>db9f	03					.byte 3	;wh_CodeLength
>dba0	18					  .byte LinkDisplacement	; offset to previous nt
=$dba1					XtPtr1 ::= *
=56093					WordListLink ::= Nt0 ; remember the nt of this word for later
.dba1					And2:
.dba1	e0 2d		cpx #$2d		cpx #(DDim-2)*2+1	; far enough below end of data stack (& not negative)?
.dba3	b0 0f		bcs $dbb4		bcs Throw_Stack_18
.dba5	b5 24		lda $24,x			lda DStack+0,x
.dba7	35 26		and $26,x			and DStack+2,x
.dba9	95 26		sta $26,x			sta DStack+2,x
.dbab	b5 25		lda $25,x			lda DStack+1,x
.dbad	35 27		and $27,x			and DStack+3,x
.dbaf	95 27		sta $27,x			sta DStack+3,x
.dbb1	e8		inx				inx		; Drop n2
.dbb2	e8		inx				inx
=18					CodeLen	.var *-XtPtr1
=$dbb3					Here1 = *	; remember here
>db9f	12					.byte CodeLen	;patch wh_CodeLength
.dbb3	60		rts				rts
.dbb4	4c 2f c4	jmp $c42f	Throw_Stack_18: jmp Throw_Stack
>dbb7	4f 72				Name0:	.text "Or"	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=56121					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>dbb9	42					.byte (("Or"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=28					LinkDisplacement = Nt0-WordListLink
>dbba	10					.byte WordFlags	;wh_Flags
>dbbb	03					.byte 3	;wh_CodeLength
>dbbc	1c					  .byte LinkDisplacement	; offset to previous nt
=$dbbd					XtPtr1 ::= *
=56121					WordListLink ::= Nt0 ; remember the nt of this word for later
.dbbd					Or:
.dbbd	e0 2d		cpx #$2d		cpx #(DDim-2)*2+1	; far enough below end of data stack (& not negative)?
.dbbf	b0 f3		bcs $dbb4		bcs Throw_Stack_18
.dbc1	b5 24		lda $24,x			lda DStack+0,x
.dbc3	15 26		ora $26,x			ora DStack+2,x
.dbc5	95 26		sta $26,x			sta DStack+2,x
.dbc7	b5 25		lda $25,x			lda DStack+1,x
.dbc9	15 27		ora $27,x			ora DStack+3,x
.dbcb	95 27		sta $27,x			sta DStack+3,x
.dbcd	e8		inx				inx		; Drop n2
.dbce	e8		inx				inx
=18					CodeLen	.var *-XtPtr1
=$dbcf					Here1 = *	; remember here
>dbbb	12					.byte CodeLen	;patch wh_CodeLength
.dbcf	60		rts				rts
>dbd0	58 6f 72			Name0:	.text "Xor"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=56147					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>dbd3	43					.byte (("Xor"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=26					LinkDisplacement = Nt0-WordListLink
>dbd4	10					.byte WordFlags	;wh_Flags
>dbd5	03					.byte 3	;wh_CodeLength
>dbd6	1a					  .byte LinkDisplacement	; offset to previous nt
=$dbd7					XtPtr1 ::= *
=56147					WordListLink ::= Nt0 ; remember the nt of this word for later
.dbd7					Xor:
.dbd7	e0 2d		cpx #$2d		cpx #(DDim-2)*2+1	; far enough below end of data stack (& not negative)?
.dbd9	b0 d9		bcs $dbb4		bcs Throw_Stack_18
.dbdb	b5 24		lda $24,x			lda DStack+0,x
.dbdd	55 26		eor $26,x			eor DStack+2,x
.dbdf	95 26		sta $26,x			sta DStack+2,x
.dbe1	b5 25		lda $25,x			lda DStack+1,x
.dbe3	55 27		eor $27,x			eor DStack+3,x
.dbe5	95 27		sta $27,x			sta DStack+3,x
.dbe7	e8		inx				inx		; Drop n2
.dbe8	e8		inx				inx
=18					CodeLen	.var *-XtPtr1
=$dbe9					Here1 = *	; remember here
>dbd5	12					.byte CodeLen	;patch wh_CodeLength
.dbe9	60		rts				rts
>dbea	2b				Name0:	.text "+"	;  name of word as a string, ending at wh_NameLastChar
=1					NameLength = *-Name0
=56171					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>dbeb	61					.byte (("+"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=24					LinkDisplacement = Nt0-WordListLink
>dbec	10					.byte WordFlags	;wh_Flags
>dbed	03					.byte 3	;wh_CodeLength
>dbee	18					  .byte LinkDisplacement	; offset to previous nt
=$dbef					XtPtr1 ::= *
=56171					WordListLink ::= Nt0 ; remember the nt of this word for later
.dbef					Plus:
.dbef	e0 2d		cpx #$2d		cpx #(DDim-2)*2+1	; far enough below end of data stack (& not negative)?
.dbf1	b0 c1		bcs $dbb4		bcs Throw_Stack_18
.dbf3	18		clc				clc
.dbf4	b5 24		lda $24,x			lda DStack+0,x		; LSB
.dbf6	75 26		adc $26,x			adc DStack+2,x
.dbf8	95 26		sta $26,x			sta DStack+2,x
.dbfa	b5 25		lda $25,x			lda DStack+1,x		; MSB. No CLC, conserve carry bit
.dbfc	75 27		adc $27,x			adc DStack+3,x
.dbfe	95 27		sta $27,x			sta DStack+3,x
.dc00	e8		inx				inx
.dc01	e8		inx				inx
=19					CodeLen	.var *-XtPtr1
=$dc02					Here1 = *	; remember here
>dbed	13					.byte CodeLen	;patch wh_CodeLength
.dc02	60		rts				rts
>dc03	2d				Name0:	.text "-"	;  name of word as a string, ending at wh_NameLastChar
=1					NameLength = *-Name0
=56196					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>dc04	a1					.byte (("-"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=25					LinkDisplacement = Nt0-WordListLink
>dc05	10					.byte WordFlags	;wh_Flags
>dc06	03					.byte 3	;wh_CodeLength
>dc07	19					  .byte LinkDisplacement	; offset to previous nt
=$dc08					XtPtr1 ::= *
=56196					WordListLink ::= Nt0 ; remember the nt of this word for later
.dc08					Minus:
.dc08	e0 2d		cpx #$2d		cpx #(DDim-2)*2+1	; far enough below end of data stack (& not negative)?
.dc0a	b0 a8		bcs $dbb4		bcs Throw_Stack_18
.dc0c	38		sec				sec
.dc0d	b5 26		lda $26,x			lda DStack+2,x	; LSB
.dc0f	f5 24		sbc $24,x			sbc DStack+0,x
.dc11	95 26		sta $26,x			sta DStack+2,x
.dc13	b5 27		lda $27,x			lda DStack+3,x	; MSB
.dc15	f5 25		sbc $25,x			sbc DStack+1,x
.dc17	95 27		sta $27,x			sta DStack+3,x
.dc19	e8		inx				inx		; Drop n2
.dc1a	e8		inx				inx
=19					CodeLen	.var *-XtPtr1
=$dc1b					Here1 = *	; remember here
>dc06	13					.byte CodeLen	;patch wh_CodeLength
.dc1b	60		rts				rts
>dc1c	2e				Name0:	.text "."	;  name of word as a string, ending at wh_NameLastChar
=1					NameLength = *-Name0
=56221					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>dc1d	c1					.byte (("."[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=25					LinkDisplacement = Nt0-WordListLink
>dc1e	10					.byte WordFlags	;wh_Flags
>dc1f	03					.byte 3	;wh_CodeLength
>dc20	19					  .byte LinkDisplacement	; offset to previous nt
=$dc21					XtPtr1 ::= *
=56221					WordListLink ::= Nt0 ; remember the nt of this word for later
.dc21	b5 25		lda $25,x	Dot:		lda DStack+1,x		; ( n )	save sign
.dc23	08		php				php
.dc24	20 02 d7	jsr $d702			jsr Abs			; ( u )
.dc27	20 f7 c7	jsr $c7f7			jsr Zero		; ( ud )	u>d  cvt u to ud
.dc2a	4c 39 dc	jmp $dc39			jmp fmt_d3
=12					CodeLen	.var *-XtPtr1
=$dc2d					Here1 = *	; remember here
>dc1f	0c					.byte CodeLen	;patch wh_CodeLength
>dc2d	44 2e				Name0:	.text "D."	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=56239					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>dc2f	c2					.byte (("D."[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=18					LinkDisplacement = Nt0-WordListLink
>dc30	10					.byte WordFlags	;wh_Flags
>dc31	03					.byte 3	;wh_CodeLength
>dc32	12					  .byte LinkDisplacement	; offset to previous nt
=$dc33					XtPtr1 ::= *
=56239					WordListLink ::= Nt0 ; remember the nt of this word for later
.dc33	b5 25		lda $25,x	D_Dot:		lda DStack+1,x		; save sign
.dc35	08		php				php
.dc36	20 35 d7	jsr $d735			jsr DAbs
.dc39	20 c5 bb	jsr $bbc5	fmt_d3:		jsr Less_Number_Sign	; ( ud )	start formatting
.dc3c	20 34 bc	jsr $bc34			jsr Number_sign_s	; ( ud )	do all digits
.dc3f	28		plp				plp			; ( ud )	do sign
.dc40	20 4e bc	jsr $bc4e			jsr Sign_P		; ( ud )
.dc43	20 d1 bb	jsr $bbd1			jsr Number_sign_greater	; ( addr u )	end formatting
.dc46	20 39 de	jsr $de39			jsr Type
.dc49	4c 2d de	jmp $de2d			jmp Space
=25					CodeLen	.var *-XtPtr1
=$dc4c					Here1 = *	; remember here
>dc31	19					.byte CodeLen	;patch wh_CodeLength
>dc4c	55 2e				Name0:	.text "U."	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=56270					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>dc4e	c2					.byte (("U."[-1]&7)<<5)+NameLength	;wh_HashNameLen
=80					WordFlags ::= UF+NN	; modifiable copy, remember for later
=31					LinkDisplacement = Nt0-WordListLink
>dc4f	50					.byte WordFlags	;wh_Flags
>dc50	03					.byte 3	;wh_CodeLength
>dc51	1f					  .byte LinkDisplacement	; offset to previous nt
=$dc52					XtPtr1 ::= *
=56270					WordListLink ::= Nt0 ; remember the nt of this word for later
.dc52	20 0c c4	jsr $c40c	U_Dot:		jsr underflow_1
.dc55	20 6b dc	jsr $dc6b			jsr print_u
.dc58	4c 2d de	jmp $de2d			jmp Space
=9					CodeLen	.var *-XtPtr1
=$dc5b					Here1 = *	; remember here
>dc50	09					.byte CodeLen	;patch wh_CodeLength
>dc5b	55 44 2e			Name0:	.text "UD."	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=56286					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>dc5e	c3					.byte (("UD."[-1]&7)<<5)+NameLength	;wh_HashNameLen
=80					WordFlags ::= UF+NN	; modifiable copy, remember for later
=16					LinkDisplacement = Nt0-WordListLink
>dc5f	50					.byte WordFlags	;wh_Flags
>dc60	03					.byte 3	;wh_CodeLength
>dc61	10					  .byte LinkDisplacement	; offset to previous nt
=$dc62					XtPtr1 ::= *
=56286					WordListLink ::= Nt0 ; remember the nt of this word for later
.dc62	20 20 c4	jsr $c420	UD_Dot:		jsr underflow_2 ; double number
.dc65	20 6e dc	jsr $dc6e			jsr print_ud
.dc68	4c 2d de	jmp $de2d			jmp Space
=9					CodeLen	.var *-XtPtr1
=$dc6b					Here1 = *	; remember here
>dc60	09					.byte CodeLen	;patch wh_CodeLength
.dc6b					print_u:
.dc6b	20 f7 c7	jsr $c7f7			jsr Zero			; convert to ud
.dc6e					print_ud:
.dc6e	20 c5 bb	jsr $bbc5			jsr Less_Number_Sign		; <#	start formatting
.dc71	20 34 bc	jsr $bc34			jsr Number_sign_s		; #S	do all digits
.dc74	20 d1 bb	jsr $bbd1			jsr Number_sign_greater		; #>	end formatting
.dc77	4c 39 de	jmp $de39			jmp Type
>dc7a	55 2e 52			Name0:	.text "U.R"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=56317					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>dc7d	43					.byte (("U.R"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=31					LinkDisplacement = Nt0-WordListLink
>dc7e	10					.byte WordFlags	;wh_Flags
>dc7f	03					.byte 3	;wh_CodeLength
>dc80	1f					  .byte LinkDisplacement	; offset to previous nt
=$dc81					XtPtr1 ::= *
=56317					WordListLink ::= Nt0 ; remember the nt of this word for later
.dc81	20 c8 c3	jsr $c3c8	U_Dot_R:	jsr PopA		; save field width
.dc84	48		pha		U_Dot_R_A:	pha
.dc85	20 f7 c7	jsr $c7f7			jsr Zero		; u>d  cvt u to ud
.dc88	4c 97 dc	jmp $dc97			jmp fmt_udr3
=10					CodeLen	.var *-XtPtr1
=$dc8b					Here1 = *	; remember here
>dc7f	0a					.byte CodeLen	;patch wh_CodeLength
>dc8b	55 44 2e 52			Name0:	.text "UD.R"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=56335					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>dc8f	44					.byte (("UD.R"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=18					LinkDisplacement = Nt0-WordListLink
>dc90	10					.byte WordFlags	;wh_Flags
>dc91	03					.byte 3	;wh_CodeLength
>dc92	12					  .byte LinkDisplacement	; offset to previous nt
=$dc93					XtPtr1 ::= *
=56335					WordListLink ::= Nt0 ; remember the nt of this word for later
.dc93	20 c8 c3	jsr $c3c8	UD_Dot_R:	jsr PopA			; save field width
.dc96	48		pha		UD_Dot_R_A:	pha
.dc97	20 c5 bb	jsr $bbc5	fmt_udr3:	jsr Less_Number_Sign		; start formatted
.dc9a	20 34 bc	jsr $bc34			jsr Number_sign_s		; do all digits
.dc9d	20 d1 bb	jsr $bbd1	fmt_r:		jsr Number_sign_greater		; finish formatted
.dca0	68		pla				pla				; recover field width
.dca1	38		sec				sec				; do leading spaces
.dca2	f5 24		sbc $24,x			sbc DStack+0,x
.dca4	90 06		bcc $dcac			bcc +
.dca6	20 e9 c7	jsr $c7e9			jsr PushZA
.dca9	20 cc d4	jsr $d4cc			jsr Spaces
.dcac	4c 39 de	jmp $de39	+		jmp Type			; type formatted
=28					CodeLen	.var *-XtPtr1
=$dcaf					Here1 = *	; remember here
>dc91	1c					.byte CodeLen	;patch wh_CodeLength
>dcaf	2e 52				Name0:	.text ".R"	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=56369					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>dcb1	42					.byte ((".R"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=34					LinkDisplacement = Nt0-WordListLink
>dcb2	10					.byte WordFlags	;wh_Flags
>dcb3	03					.byte 3	;wh_CodeLength
>dcb4	22					  .byte LinkDisplacement	; offset to previous nt
=$dcb5					XtPtr1 ::= *
=56369					WordListLink ::= Nt0 ; remember the nt of this word for later
.dcb5	20 c8 c3	jsr $c3c8	Dot_R:		jsr PopA		; save field width
.dcb8	48		pha		Dot_R_A:	pha
.dcb9	b5 25		lda $25,x			lda DStack+1,x		; save sign
.dcbb	08		php				php
.dcbc	20 02 d7	jsr $d702			jsr Abs
.dcbf	20 f7 c7	jsr $c7f7			jsr Zero		; u>d  cvt u to ud
.dcc2	4c d6 dc	jmp $dcd6			jmp fmt_dr3
=16					CodeLen	.var *-XtPtr1
=$dcc5					Here1 = *	; remember here
>dcb3	10					.byte CodeLen	;patch wh_CodeLength
>dcc5	44 2e 52			Name0:	.text "D.R"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=56392					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>dcc8	43					.byte (("D.R"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=23					LinkDisplacement = Nt0-WordListLink
>dcc9	10					.byte WordFlags	;wh_Flags
>dcca	03					.byte 3	;wh_CodeLength
>dccb	17					  .byte LinkDisplacement	; offset to previous nt
=$dccc					XtPtr1 ::= *
=56392					WordListLink ::= Nt0 ; remember the nt of this word for later
.dccc	20 c8 c3	jsr $c3c8	D_Dot_R:	jsr PopA		; save field width
.dccf	48		pha		D_Dot_R_A:	pha
.dcd0	b5 25		lda $25,x			lda DStack+1,x		; save sign
.dcd2	08		php				php
.dcd3	20 35 d7	jsr $d735			jsr DAbs
.dcd6	20 c5 bb	jsr $bbc5	fmt_dr3:	jsr Less_Number_Sign	; start formatted output
.dcd9	20 34 bc	jsr $bc34			jsr Number_sign_s	; do all digits
.dcdc	28		plp				plp			; do the sign
.dcdd	20 4e bc	jsr $bc4e			jsr Sign_P
.dce0	4c 9d dc	jmp $dc9d			jmp fmt_r
=23					CodeLen	.var *-XtPtr1
=$dce3					Here1 = *	; remember here
>dcca	17					.byte CodeLen	;patch wh_CodeLength
>dce3	3f				Name0:	.text "?"	;  name of word as a string, ending at wh_NameLastChar
=1					NameLength = *-Name0
=56420					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>dce4	e1					.byte (("?"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=28					LinkDisplacement = Nt0-WordListLink
>dce5	10					.byte WordFlags	;wh_Flags
>dce6	03					.byte 3	;wh_CodeLength
>dce7	1c					  .byte LinkDisplacement	; offset to previous nt
=$dce8					XtPtr1 ::= *
=56420					WordListLink ::= Nt0 ; remember the nt of this word for later
.dce8					Question:
.dce8	20 fa de	jsr $defa			jsr Fetch
.dceb	4c 21 dc	jmp $dc21			jmp Dot
=6					CodeLen	.var *-XtPtr1
=$dcee					Here1 = *	; remember here
>dce6	06					.byte CodeLen	;patch wh_CodeLength
>dcee	32 44 75 70			Name0:	.text "2Dup"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=56434					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>dcf2	04					.byte (("2Dup"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=14					LinkDisplacement = Nt0-WordListLink
>dcf3	10					.byte WordFlags	;wh_Flags
>dcf4	03					.byte 3	;wh_CodeLength
>dcf5	0e					  .byte LinkDisplacement	; offset to previous nt
=$dcf6					XtPtr1 ::= *
=56434					WordListLink ::= Nt0 ; remember the nt of this word for later
.dcf6					Two_Dup:
.dcf6	e0 2d		cpx #$2d		cpx #(DDim-2)*2+1	; far enough below end of data stack (& not negative)?
.dcf8	b0 15		bcs $dd0f		bcs Throw_Stack_13
.dcfa	ca		dex				dex
.dcfb	ca		dex				dex
.dcfc	ca		dex				dex
.dcfd	ca		dex				dex
.dcfe	b5 28		lda $28,x			lda DStack+4,x	; TOS
.dd00	95 24		sta $24,x			sta DStack+0,x
.dd02	b5 29		lda $29,x			lda DStack+5,x
.dd04	95 25		sta $25,x			sta DStack+1,x
.dd06	b5 2a		lda $2a,x			lda DStack+6,x	; NOS
.dd08	95 26		sta $26,x			sta DStack+2,x
.dd0a	b5 2b		lda $2b,x			lda DStack+7,x
.dd0c	95 27		sta $27,x			sta DStack+3,x
=24					CodeLen	.var *-XtPtr1
=$dd0e					Here1 = *	; remember here
>dcf4	18					.byte CodeLen	;patch wh_CodeLength
.dd0e	60		rts				rts
.dd0f	4c 2f c4	jmp $c42f	Throw_Stack_13: jmp Throw_Stack
>dd12	54 75 63 6b			Name0:	.text "Tuck"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=56470					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>dd16	64					.byte (("Tuck"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=36					LinkDisplacement = Nt0-WordListLink
>dd17	10					.byte WordFlags	;wh_Flags
>dd18	03					.byte 3	;wh_CodeLength
>dd19	24					  .byte LinkDisplacement	; offset to previous nt
=$dd1a					XtPtr1 ::= *
=56470					WordListLink ::= Nt0 ; remember the nt of this word for later
.dd1a					Tuck:
.dd1a	e0 2d		cpx #$2d		cpx #(DDim-2)*2+1	; far enough below end of data stack (& not negative)?
.dd1c	b0 f1		bcs $dd0f		bcs Throw_Stack_13
.dd1e	ca		dex				dex
.dd1f	ca		dex				dex
.dd20	b4 28		ldy $28,x			ldy DStack+4,x	; LSB
.dd22	b5 26		lda $26,x			lda DStack+2,x
.dd24	95 28		sta $28,x			sta DStack+4,x
.dd26	94 26		sty $26,x			sty DStack+2,x
.dd28	95 24		sta $24,x			sta DStack+0,x
.dd2a	b4 29		ldy $29,x			ldy DStack+5,x	; MSB
.dd2c	b5 27		lda $27,x			lda DStack+3,x
.dd2e	95 29		sta $29,x			sta DStack+5,x
.dd30	94 27		sty $27,x			sty DStack+3,x
.dd32	95 25		sta $25,x			sta DStack+1,x
=26					CodeLen	.var *-XtPtr1
=$dd34					Here1 = *	; remember here
>dd18	1a					.byte CodeLen	;patch wh_CodeLength
.dd34	60		rts				rts
>dd35	43 2c				Name0:	.text "C,"	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=56503					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>dd37	82					.byte (("C,"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=33					LinkDisplacement = Nt0-WordListLink
>dd38	10					.byte WordFlags	;wh_Flags
>dd39	03					.byte 3	;wh_CodeLength
>dd3a	21					  .byte LinkDisplacement	; offset to previous nt
=$dd3b					XtPtr1 ::= *
=56503					WordListLink ::= Nt0 ; remember the nt of this word for later
.dd3b	20 c8 c3	jsr $c3c8	C_Comma:	jsr PopA	; pop c, with underflow check
.dd3e					C_Comma_A:
.dd3e	94 23		sty $23,x			sty DStack-1,x	; save Y
.dd40	a0 00		ldy #$00			ldy #0		; store A
.dd42	91 00		sta ($00),y			sta (cp),y
.dd44	e6 00		inc $00				inc cp+0	; increment cp
.dd46	d0 02		bne $dd4a			bne +
.dd48	e6 01		inc $01				inc cp+1
.dd4a					+
.dd4a	b4 23		ldy $23,x			ldy DStack-1,x	; restore Y
=17					CodeLen	.var *-XtPtr1
=$dd4c					Here1 = *	; remember here
>dd39	11					.byte CodeLen	;patch wh_CodeLength
.dd4c	60		rts				rts
>dd4d	2c				Name0:	.text ","	;  name of word as a string, ending at wh_NameLastChar
=1					NameLength = *-Name0
=56526					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>dd4e	81					.byte ((","[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=23					LinkDisplacement = Nt0-WordListLink
>dd4f	10					.byte WordFlags	;wh_Flags
>dd50	03					.byte 3	;wh_CodeLength
>dd51	17					  .byte LinkDisplacement	; offset to previous nt
=$dd52					XtPtr1 ::= *
=56526					WordListLink ::= Nt0 ; remember the nt of this word for later
.dd52	20 e3 c3	jsr $c3e3	Comma:		jsr PopYA	; pop n, with underflow check
.dd55					Comma_YA:
.dd55	20 3e dd	jsr $dd3e			jsr C_Comma_A	; compile LSB
.dd58	98		tya				tya		; compile MSB
.dd59	4c 3e dd	jmp $dd3e			jmp C_Comma_A
=10					CodeLen	.var *-XtPtr1
=$dd5c					Here1 = *	; remember here
>dd50	0a					.byte CodeLen	;patch wh_CodeLength
>dd5c	32 2c				Name0:	.text "2,"	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=56542					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>dd5e	82					.byte (("2,"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=16					LinkDisplacement = Nt0-WordListLink
>dd5f	10					.byte WordFlags	;wh_Flags
>dd60	03					.byte 3	;wh_CodeLength
>dd61	10					  .byte LinkDisplacement	; offset to previous nt
=$dd62					XtPtr1 ::= *
=56542					WordListLink ::= Nt0 ; remember the nt of this word for later
.dd62	20 52 dd	jsr $dd52	Two_Comma:	jsr Comma
.dd65	4c 52 dd	jmp $dd52			jmp Comma
=6					CodeLen	.var *-XtPtr1
=$dd68					Here1 = *	; remember here
>dd60	06					.byte CodeLen	;patch wh_CodeLength
.dd68	a9 e8		lda #$e8	Drop_Comma:	lda #$e8	;inx
.dd6a	a8		tay				tay
.dd6b	d0 e8		bne $dd55			bne Comma_YA
>dd6d	4a 73 72 2c			Name0:	.text "Jsr,"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=56561					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>dd71	84					.byte (("Jsr,"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=19					LinkDisplacement = Nt0-WordListLink
>dd72	10					.byte WordFlags	;wh_Flags
>dd73	03					.byte 3	;wh_CodeLength
>dd74	13					  .byte LinkDisplacement	; offset to previous nt
=$dd75					XtPtr1 ::= *
=56561					WordListLink ::= Nt0 ; remember the nt of this word for later
.dd75	20 e3 c3	jsr $c3e3	Jsr_Comma:	jsr PopYA	; pop addr (optimize can skip)
.dd78	20 ba c7	jsr $c7ba	Jsr_Comma_YA:	jsr PushYA	; push addr
.dd7b	a9 20		lda #$20			lda #$20	; JSR abs opcode
.dd7d	20 3e dd	jsr $dd3e	Jsr_Comma_3:	jsr C_Comma_A
.dd80	4c 52 dd	jmp $dd52			jmp Comma	; compile addr
=14					CodeLen	.var *-XtPtr1
=$dd83					Here1 = *	; remember here
>dd73	0e					.byte CodeLen	;patch wh_CodeLength
>dd83	4a 6d 70 2c			Name0:	.text "Jmp,"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=56583					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>dd87	84					.byte (("Jmp,"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=22					LinkDisplacement = Nt0-WordListLink
>dd88	10					.byte WordFlags	;wh_Flags
>dd89	03					.byte 3	;wh_CodeLength
>dd8a	16					  .byte LinkDisplacement	; offset to previous nt
=$dd8b					XtPtr1 ::= *
=56583					WordListLink ::= Nt0 ; remember the nt of this word for later
.dd8b	20 e3 c3	jsr $c3e3	Jmp_Comma:	jsr PopYA	; pop addr (optimize can skip)
.dd8e	20 ba c7	jsr $c7ba	Jmp_Comma_YA:	jsr PushYA	; push addr
.dd91	a9 4c		lda #$4c			lda #$4c	; JMP abs opcode
.dd93	d0 e8		bne $dd7d			bne Jsr_Comma_3
.dd95					Jmp_Comma_NT_YA:
.dd95	20 ba c7	jsr $c7ba			jsr PushYA
.dd98	20 ae cd	jsr $cdae			jsr Name_To_Int	; convert nt to xt
.dd9b	4c 8b dd	jmp $dd8b			jmp Jmp_Comma
=19					CodeLen	.var *-XtPtr1
=$dd9e					Here1 = *	; remember here
>dd89	13					.byte CodeLen	;patch wh_CodeLength
>dd9e	43 40				Name0:	.text "C@"	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=56608					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>dda0	02					.byte (("C@"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=25					LinkDisplacement = Nt0-WordListLink
>dda1	10					.byte WordFlags	;wh_Flags
>dda2	03					.byte 3	;wh_CodeLength
>dda3	19					  .byte LinkDisplacement	; offset to previous nt
=$dda4					XtPtr1 ::= *
=56608					WordListLink ::= Nt0 ; remember the nt of this word for later
.dda4					C_Fetch:
.dda4	e0 2f		cpx #$2f		cpx #(DDim-1)*2+1	; far enough below end of data stack (& not negative)?
.dda6	b0 1c		bcs $ddc4		bcs Throw_Stack_16
.dda8	a1 24		lda ($24,x)			lda (DStack+0,x)
.ddaa	95 24		sta $24,x			sta DStack+0,x
.ddac	a9 00		lda #$00			lda #0
.ddae	95 25		sta $25,x			sta DStack+1,x	; zero MSB
=12					CodeLen	.var *-XtPtr1
=$ddb0					Here1 = *	; remember here
>dda2	0c					.byte CodeLen	;patch wh_CodeLength
.ddb0	60		rts				rts
>ddb1	43 21				Name0:	.text "C!"	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=56627					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>ddb3	22					.byte (("C!"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=19					LinkDisplacement = Nt0-WordListLink
>ddb4	10					.byte WordFlags	;wh_Flags
>ddb5	03					.byte 3	;wh_CodeLength
>ddb6	13					  .byte LinkDisplacement	; offset to previous nt
=$ddb7					XtPtr1 ::= *
=56627					WordListLink ::= Nt0 ; remember the nt of this word for later
.ddb7					C_Store:
.ddb7	e0 2d		cpx #$2d		cpx #(DDim-2)*2+1	; far enough below end of data stack (& not negative)?
.ddb9	b0 09		bcs $ddc4		bcs Throw_Stack_16
.ddbb	b5 26		lda $26,x			lda DStack+2,x
.ddbd	81 24		sta ($24,x)			sta (DStack+0,x)
.ddbf	e8		inx				inx
.ddc0	e8		inx				inx
.ddc1	e8		inx				inx
.ddc2	e8		inx				inx
=12					CodeLen	.var *-XtPtr1
=$ddc3					Here1 = *	; remember here
>ddb5	0c					.byte CodeLen	;patch wh_CodeLength
.ddc3	60		rts				rts
.ddc4	4c 2f c4	jmp $c42f	Throw_Stack_16: jmp Throw_Stack
>ddc7	31 2b 21			Name0:	.text "1+!"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=56650					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>ddca	23					.byte (("1+!"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=0					WordFlags ::= 0	; modifiable copy, remember for later
=23					LinkDisplacement = Nt0-WordListLink
>ddcb	00					.byte WordFlags	;wh_Flags
>ddcc	03					.byte 3	;wh_CodeLength
>ddcd	17					  .byte LinkDisplacement	; offset to previous nt
=$ddce					XtPtr1 ::= *
=56650					WordListLink ::= Nt0 ; remember the nt of this word for later
.ddce	a9 01		lda #$01	OnePlusStore:	lda #1
.ddd0	e0 2f		cpx #$2f		cpx #(DDim-1)*2+1	; far enough below end of data stack (& not negative)?
.ddd2	b0 f0		bcs $ddc4		bcs Throw_Stack_16
.ddd4	18		clc				clc
.ddd5	61 24		adc ($24,x)			adc (DStack+0,x)	; increment lo byte
.ddd7	81 24		sta ($24,x)			sta (DStack+0,x)
.ddd9	90 0c		bcc $dde7			bcc _7			; if carry
.dddb	f6 24		inc $24,x			inc DStack+0,x		;   point at hi byte
.dddd	d0 02		bne $dde1			bne +
.dddf	f6 25		inc $25,x			inc DStack+1,x
.dde1					+
.dde1	a1 24		lda ($24,x)			lda (DStack+0,x)	;   increment hi byte
.dde3	69 00		adc #$00			adc #0
.dde5	81 24		sta ($24,x)			sta (Dstack+0,x)
.dde7					_7:
.dde7	e8		inx				inx			; Drop addr
.dde8	e8		inx				inx
=27					CodeLen	.var *-XtPtr1
=$dde9					Here1 = *	; remember here
>ddcc	1b					.byte CodeLen	;patch wh_CodeLength
.dde9	60		rts				rts
>ddea	2b 21				Name0:	.text "+!"	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=56684					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>ddec	22					.byte (("+!"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=34					LinkDisplacement = Nt0-WordListLink
>dded	10					.byte WordFlags	;wh_Flags
>ddee	03					.byte 3	;wh_CodeLength
>ddef	22					  .byte LinkDisplacement	; offset to previous nt
=$ddf0					XtPtr1 ::= *
=56684					WordListLink ::= Nt0 ; remember the nt of this word for later
.ddf0					Plus_store:
.ddf0	e0 2d		cpx #$2d		cpx #(DDim-2)*2+1	; far enough below end of data stack (& not negative)?
.ddf2	b0 d0		bcs $ddc4		bcs Throw_Stack_16
.ddf4	18		clc				clc
.ddf5	b5 26		lda $26,x			lda DStack+2,x
.ddf7	61 24		adc ($24,x)			adc (DStack+0,x)
.ddf9	81 24		sta ($24,x)			sta (DStack+0,x)
.ddfb	f6 24		inc $24,x			inc DStack+0,x
.ddfd	d0 02		bne $de01			bne +
.ddff	f6 25		inc $25,x			inc DStack+1,x
.de01					+
.de01	b5 27		lda $27,x			lda DStack+3,x
.de03	61 24		adc ($24,x)			adc (DStack+0,x)
.de05	81 24		sta ($24,x)			sta (DStack+0,x)
.de07	4c 72 d5	jmp $d572			jmp Two_Drop
=26					CodeLen	.var *-XtPtr1
=$de0a					Here1 = *	; remember here
>ddee	1a					.byte CodeLen	;patch wh_CodeLength
>de0a	42 65 6c 6c			Name0:	.text "Bell"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=56718					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>de0e	84					.byte (("Bell"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=34					LinkDisplacement = Nt0-WordListLink
>de0f	10					.byte WordFlags	;wh_Flags
>de10	03					.byte 3	;wh_CodeLength
>de11	22					  .byte LinkDisplacement	; offset to previous nt
=$de12					XtPtr1 ::= *
=56718					WordListLink ::= Nt0 ; remember the nt of this word for later
.de12	a9 07		lda #$07	Bell:		lda #7		; ASCII value for BELL
.de14	d0 0b		bne $de21			bne Emit_A
=4					CodeLen	.var *-XtPtr1
=$de16					Here1 = *	; remember here
>de10	04					.byte CodeLen	;patch wh_CodeLength
>de16	45 6d 69 74			Name0:	.text "Emit"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=56730					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>de1a	84					.byte (("Emit"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=12					LinkDisplacement = Nt0-WordListLink
>de1b	10					.byte WordFlags	;wh_Flags
>de1c	03					.byte 3	;wh_CodeLength
>de1d	0c					  .byte LinkDisplacement	; offset to previous nt
=$de1e					XtPtr1 ::= *
=56730					WordListLink ::= Nt0 ; remember the nt of this word for later
.de1e	20 c8 c3	jsr $c3c8	Emit:		jsr PopA		; pop char, with underflow check
.de21					Emit_A:
.de21	6c 06 03	jmp ($0306)			jmp (output)		; JSR/RTS
=6					CodeLen	.var *-XtPtr1
=$de24					Here1 = *	; remember here
>de1c	06					.byte CodeLen	;patch wh_CodeLength
>de24	53 70 61 63 65			Name0:	.text "Space"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=56745					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>de29	a5					.byte (("Space"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=15					LinkDisplacement = Nt0-WordListLink
>de2a	10					.byte WordFlags	;wh_Flags
>de2b	03					.byte 3	;wh_CodeLength
>de2c	0f					  .byte LinkDisplacement	; offset to previous nt
=$de2d					XtPtr1 ::= *
=56745					WordListLink ::= Nt0 ; remember the nt of this word for later
.de2d	a9 20		lda #$20	Space:		lda #AscSP
.de2f	d0 f0		bne $de21			bne Emit_A
=4					CodeLen	.var *-XtPtr1
=$de31					Here1 = *	; remember here
>de2b	04					.byte CodeLen	;patch wh_CodeLength
>de31	54 79 70 65			Name0:	.text "Type"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=56757					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>de35	a4					.byte (("Type"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=80					WordFlags ::= UF+NN	; modifiable copy, remember for later
=12					LinkDisplacement = Nt0-WordListLink
>de36	50					.byte WordFlags	;wh_Flags
>de37	03					.byte 3	;wh_CodeLength
>de38	0c					  .byte LinkDisplacement	; offset to previous nt
=$de39					XtPtr1 ::= *
=56757					WordListLink ::= Nt0 ; remember the nt of this word for later
.de39					Type:
.de39	e0 2d		cpx #$2d		cpx #(DDim-2)*2+1	; far enough below end of data stack (& not negative)?
.de3b	b0 6c		bcs $dea9		bcs Throw_Stack_03
.de3d	4c 4a de	jmp $de4a			jmp _test
.de40					_loop:
.de40	d6 24		dec $24,x			dec DStack+0,x		; finish length decrement
.de42	a1 26		lda ($26,x)			lda (DStack+2,x)	; Send the current character
.de44	20 21 de	jsr $de21			jsr Emit_A
.de47	20 a5 da	jsr $daa5			jsr NOS_One_Plus	; increment address
.de4a	b5 24		lda $24,x	_test:		lda DStack+0,x		; decrement length & test for <0
.de4c	d0 f2		bne $de40			bne _loop
.de4e	d6 25		dec $25,x			dec DStack+1,x
.de50	10 ee		bpl $de40			bpl _loop
.de52	4c 72 d5	jmp $d572			jmp Two_drop
=28					CodeLen	.var *-XtPtr1
=$de55					Here1 = *	; remember here
>de37	1c					.byte CodeLen	;patch wh_CodeLength
.de55					Print_ASCIIZ_YA_no_lf:
.de55	85 18		sta $18				sta tmp3+0		; save string address
.de57	84 19		sty $19				sty tmp3+1
.de59	a0 00		ldy #$00			ldy #0
.de5b					Print_ASCIIZ_tmp3_no_lf:
.de5b	b1 18		lda ($18),y			lda (tmp3),y
.de5d	f0 06		beq $de65			beq _done		; end of string?
.de5f	20 21 de	jsr $de21			jsr emit_a
.de62	c8		iny				iny
.de63	d0 f6		bne $de5b			bne Print_ASCIIZ_tmp3_no_lf
.de65					_done:
.de65	60		rts				rts
.de66					Print_ASCIIZ_YA:
.de66	20 55 de	jsr $de55			jsr Print_ASCIIZ_YA_no_lf
.de69	4c 4c bb	jmp $bb4c	                jmp CR
>de6c	45 78 65 63 75 74 65		Name0:	.text "Execute"	;  name of word as a string, ending at wh_NameLastChar
=7					NameLength = *-Name0
=56819					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>de73	a7					.byte (("Execute"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=62					LinkDisplacement = Nt0-WordListLink
>de74	10					.byte WordFlags	;wh_Flags
>de75	03					.byte 3	;wh_CodeLength
>de76	3e					  .byte LinkDisplacement	; offset to previous nt
=$de77					XtPtr1 ::= *
=56819					WordListLink ::= Nt0 ; remember the nt of this word for later
.de77					Execute:
.de77	e0 2f		cpx #$2f		cpx #(DDim-1)*2+1	; far enough below end of data stack (& not negative)?
.de79	b0 2e		bcs $dea9		bcs Throw_Stack_03
.de7b	b5 25		lda $25,x			lda DStack+1,x	; addr for RTI
.de7d	48		pha				pha
.de7e	b5 24		lda $24,x			lda DStack+0,x
.de80	48		pha				pha
.de81	e8		inx				inx		; drop addr
.de82	e8		inx				inx
.de83	08		php				php		; flags for RTI
.de84	40		rti				rti
=14					CodeLen	.var *-XtPtr1
=$de85					Here1 = *	; remember here
>de75	0e					.byte CodeLen	;patch wh_CodeLength
>de85	32 52 6f 74			Name0:	.text "2Rot"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=56841					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>de89	84					.byte (("2Rot"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=22					LinkDisplacement = Nt0-WordListLink
>de8a	10					.byte WordFlags	;wh_Flags
>de8b	03					.byte 3	;wh_CodeLength
>de8c	16					  .byte LinkDisplacement	; offset to previous nt
=$de8d					XtPtr1 ::= *
=56841					WordListLink ::= Nt0 ; remember the nt of this word for later
.de8d					TwoRot:
.de8d	e0 25		cpx #$25		cpx #(DDim-6)*2+1	; far enough below end of data stack (& not negative)?
.de8f	b0 18		bcs $dea9		bcs Throw_Stack_03
.de91	86 14		stx $14				stx tmp1+0
.de93	e8		inx				inx		; do 4 times
.de94	e8		inx				inx
.de95	e8		inx				inx
.de96	e8		inx				inx
.de97	ca		dex		-		dex
.de98	b4 2c		ldy $2c,x			ldy DStack+8,x	; do a byte
.de9a	b5 28		lda $28,x			lda DStack+4,x
.de9c	95 2c		sta $2c,x			sta DStack+8,x
.de9e	b5 24		lda $24,x			lda DStack+0,x
.dea0	95 28		sta $28,x			sta DStack+4,x
.dea2	94 24		sty $24,x			sty DStack+0,x
.dea4	e4 14		cpx $14				cpx tmp1+0
.dea6	d0 ef		bne $de97			bne -
=27					CodeLen	.var *-XtPtr1
=$dea8					Here1 = *	; remember here
>de8b	1b					.byte CodeLen	;patch wh_CodeLength
.dea8	60		rts				rts
.dea9	4c 2f c4	jmp $c42f	Throw_Stack_03: jmp Throw_Stack
>deac	52 6f 74			Name0:	.text "Rot"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=56879					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>deaf	83					.byte (("Rot"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=38					LinkDisplacement = Nt0-WordListLink
>deb0	10					.byte WordFlags	;wh_Flags
>deb1	03					.byte 3	;wh_CodeLength
>deb2	26					  .byte LinkDisplacement	; offset to previous nt
=$deb3					XtPtr1 ::= *
=56879					WordListLink ::= Nt0 ; remember the nt of this word for later
.deb3					Rot:
.deb3	e0 2b		cpx #$2b		cpx #(DDim-3)*2+1	; far enough below end of data stack (& not negative)?
.deb5	b0 f2		bcs $dea9		bcs Throw_Stack_03
.deb7	b4 29		ldy $29,x			ldy DStack+5,x	; do MSB
.deb9	b5 27		lda $27,x			lda DStack+3,x
.debb	95 29		sta $29,x			sta DStack+5,x
.debd	b5 25		lda $25,x			lda DStack+1,x
.debf	95 27		sta $27,x			sta DStack+3,x
.dec1	94 25		sty $25,x			sty DStack+1,x
.dec3	b4 28		ldy $28,x			ldy DStack+4,x	; do LSB
.dec5	b5 26		lda $26,x			lda DStack+2,x
.dec7	95 28		sta $28,x			sta DStack+4,x
.dec9	b5 24		lda $24,x			lda DStack+0,x
.decb	95 26		sta $26,x			sta DStack+2,x
.decd	94 24		sty $24,x			sty DStack+0,x
=28					CodeLen	.var *-XtPtr1
=$decf					Here1 = *	; remember here
>deb1	1c					.byte CodeLen	;patch wh_CodeLength
.decf	60		rts				rts
>ded0	2d 52 6f 74			Name0:	.text "-Rot"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=56916					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>ded4	84					.byte (("-Rot"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=37					LinkDisplacement = Nt0-WordListLink
>ded5	10					.byte WordFlags	;wh_Flags
>ded6	03					.byte 3	;wh_CodeLength
>ded7	25					  .byte LinkDisplacement	; offset to previous nt
=$ded8					XtPtr1 ::= *
=56916					WordListLink ::= Nt0 ; remember the nt of this word for later
.ded8					Not_Rot:
.ded8	e0 2b		cpx #$2b		cpx #(DDim-3)*2+1	; far enough below end of data stack (& not negative)?
.deda	b0 cd		bcs $dea9		bcs Throw_Stack_03
.dedc	b4 25		ldy $25,x			ldy DStack+1,x	; do MSB
.dede	b5 27		lda $27,x			lda DStack+3,x
.dee0	95 25		sta $25,x			sta DStack+1,x
.dee2	b5 29		lda $29,x			lda DStack+5,x
.dee4	95 27		sta $27,x			sta DStack+3,x
.dee6	94 29		sty $29,x			sty DStack+5,x
.dee8	b4 24		ldy $24,x			ldy DStack+0,x	; do LSB
.deea	b5 26		lda $26,x			lda DStack+2,x
.deec	95 24		sta $24,x			sta DStack+0,x
.deee	b5 28		lda $28,x			lda DStack+4,x
.def0	95 26		sta $26,x			sta DStack+2,x
.def2	94 28		sty $28,x			sty DStack+4,x
=28					CodeLen	.var *-XtPtr1
=$def4					Here1 = *	; remember here
>ded6	1c					.byte CodeLen	;patch wh_CodeLength
.def4	60		rts				rts
>def5	40				Name0:	.text "@"	;  name of word as a string, ending at wh_NameLastChar
=1					NameLength = *-Name0
=56950					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>def6	01					.byte (("@"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=34					LinkDisplacement = Nt0-WordListLink
>def7	10					.byte WordFlags	;wh_Flags
>def8	03					.byte 3	;wh_CodeLength
>def9	22					  .byte LinkDisplacement	; offset to previous nt
=$defa					XtPtr1 ::= *
=56950					WordListLink ::= Nt0 ; remember the nt of this word for later
.defa					Fetch:
.defa	e0 2f		cpx #$2f		cpx #(DDim-1)*2+1	; far enough below end of data stack (& not negative)?
.defc	b0 ab		bcs $dea9		bcs Throw_Stack_03
.defe	a1 24		lda ($24,x)			lda (DStack+0,x)		; LSB
.df00	a8		tay				tay
.df01	f6 24		inc $24,x			inc DStack+0,x
.df03	d0 02		bne $df07			bne +
.df05	f6 25		inc $25,x			inc DStack+1,x
.df07					+
.df07	a1 24		lda ($24,x)			lda (DStack+0,x)		; MSB
.df09	95 25		sta $25,x			sta DStack+1,x
.df0b	94 24		sty $24,x			sty DStack+0,x
=19					CodeLen	.var *-XtPtr1
=$df0d					Here1 = *	; remember here
>def8	13					.byte CodeLen	;patch wh_CodeLength
.df0d	60		rts				rts
>df0e	21				Name0:	.text "!"	;  name of word as a string, ending at wh_NameLastChar
=1					NameLength = *-Name0
=56975					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>df0f	21					.byte (("!"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=25					LinkDisplacement = Nt0-WordListLink
>df10	10					.byte WordFlags	;wh_Flags
>df11	03					.byte 3	;wh_CodeLength
>df12	19					  .byte LinkDisplacement	; offset to previous nt
=$df13					XtPtr1 ::= *
=56975					WordListLink ::= Nt0 ; remember the nt of this word for later
.df13					Store:
.df13	e0 2d		cpx #$2d		cpx #(DDim-2)*2+1	; far enough below end of data stack (& not negative)?
.df15	b0 92		bcs $dea9		bcs Throw_Stack_03
.df17	b5 26		lda $26,x			lda DStack+2,x	; LSB
.df19	81 24		sta ($24,x)			sta (DStack+0,x)
.df1b	f6 24		inc $24,x			inc DStack+0,x
.df1d	d0 02		bne $df21			bne +
.df1f	f6 25		inc $25,x			inc DStack+1,x
.df21					+
.df21	b5 27		lda $27,x			lda DStack+3,x	; MSB
.df23	81 24		sta ($24,x)			sta (DStack+0,x)
.df25	e8		inx				inx		; 2Drop
.df26	e8		inx				inx
.df27	e8		inx				inx
.df28	e8		inx				inx
=22					CodeLen	.var *-XtPtr1
=$df29					Here1 = *	; remember here
>df11	16					.byte CodeLen	;patch wh_CodeLength
.df29	60		rts				rts
>df2a	30 21				Name0:	.text "0!"	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=57004					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>df2c	22					.byte (("0!"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=0					WordFlags ::= 0	; modifiable copy, remember for later
=29					LinkDisplacement = Nt0-WordListLink
>df2d	00					.byte WordFlags	;wh_Flags
>df2e	03					.byte 3	;wh_CodeLength
>df2f	1d					  .byte LinkDisplacement	; offset to previous nt
=$df30					XtPtr1 ::= *
=57004					WordListLink ::= Nt0 ; remember the nt of this word for later
.df30	20 ee c3	jsr $c3ee	ZStore:		jsr PopTmp1	; pop addr, check underflow
.df33	a9 00		lda #$00			lda #0
.df35	a8		tay				tay		; clear LSB
.df36	91 14		sta ($14),y			sta (tmp1),y
.df38	c8		iny				iny		; clear MSB
.df39	91 14		sta ($14),y			sta (tmp1),y
=11					CodeLen	.var *-XtPtr1
=$df3b					Here1 = *	; remember here
>df2e	0b					.byte CodeLen	;patch wh_CodeLength
.df3b	60		rts				rts
>df3c	3e 52				Name0:	.text ">R"	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=57022					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>df3e	42					.byte ((">R"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=52					WordFlags ::= CO+ST	; modifiable copy, remember for later
=18					LinkDisplacement = Nt0-WordListLink
>df3f	34					.byte WordFlags	;wh_Flags
>df40	03					.byte 3	;wh_CodeLength
>df41	12					  .byte LinkDisplacement	; offset to previous nt
=$df42					XtPtr1 ::= *
=57022					WordListLink ::= Nt0 ; remember the nt of this word for later
.df42					To_R:
.df42	68		pla				pla		; move the RTS address out of the way
.df43	85 1c		sta $1c				sta tmp5+0
.df45	68		pla				pla
.df46	85 1d		sta $1d				sta tmp5+1
.df48	20 0c c4	jsr $c40c			jsr underflow_1
.df4b	b5 25		lda $25,x			lda DStack+1,x	; MSB
.df4d	48		pha				pha
.df4e	b5 24		lda $24,x			lda DStack+0,x	; LSB
.df50	48		pha				pha
.df51	e8		inx				inx
.df52	e8		inx				inx
.df53	a5 1d		lda $1d				lda tmp5+1	; move the RTS address back in
.df55	48		pha				pha
.df56	a5 1c		lda $1c				lda tmp5+0
.df58	48		pha				pha
=23					CodeLen	.var *-XtPtr1
=$df59					Here1 = *	; remember here
>df40	17					.byte CodeLen	;patch wh_CodeLength
.df59	60		rts				rts
>df5a	52 3e				Name0:	.text "R>"	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=57052					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>df5c	c2					.byte (("R>"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=52					WordFlags ::= CO+ST	; modifiable copy, remember for later
=30					LinkDisplacement = Nt0-WordListLink
>df5d	34					.byte WordFlags	;wh_Flags
>df5e	03					.byte 3	;wh_CodeLength
>df5f	1e					  .byte LinkDisplacement	; offset to previous nt
=$df60					XtPtr1 ::= *
=57052					WordListLink ::= Nt0 ; remember the nt of this word for later
.df60					R_From:
.df60	68		pla				pla		; Move the RTS addr out of the way
.df61	85 1c		sta $1c				sta tmp5+0
.df63	68		pla				pla
.df64	85 1d		sta $1d				sta tmp5+1
.df66	ca		dex				dex
.df67	ca		dex				dex
.df68	68		pla				pla		; LSB
.df69	95 24		sta $24,x			sta DStack+0,x
.df6b	68		pla				pla		; MSB
.df6c	95 25		sta $25,x			sta DStack+1,x
.df6e	a5 1d		lda $1d				lda tmp5+1	; Restore the RTS addr
.df70	48		pha				pha
.df71	a5 1c		lda $1c				lda tmp5+0
.df73	48		pha				pha
=20					CodeLen	.var *-XtPtr1
=$df74					Here1 = *	; remember here
>df5e	14					.byte CodeLen	;patch wh_CodeLength
.df74	60		rts				rts
>df75	52 40				Name0:	.text "R@"	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=57079					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>df77	02					.byte (("R@"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=20					WordFlags ::= NN+CO	; modifiable copy, remember for later
=27					LinkDisplacement = Nt0-WordListLink
>df78	14					.byte WordFlags	;wh_Flags
>df79	03					.byte 3	;wh_CodeLength
>df7a	1b					  .byte LinkDisplacement	; offset to previous nt
=$df7b					XtPtr1 ::= *
=57079					WordListLink ::= Nt0 ; remember the nt of this word for later
.df7b					R_Fetch:
.df7b	86 14		stx $14				stx tmp1	; save data stack index
.df7d	ba		tsx				tsx		; X= return stack index
.df7e	bd 03 01	lda $0103,x			lda RStack+3,x
.df81	bc 04 01	ldy $0104,x			ldy RStack+4,x
.df84	a6 14		ldx $14				ldx tmp1	; restore data stack index
.df86	4c ba c7	jmp $c7ba			jmp PushYA
=14					CodeLen	.var *-XtPtr1
=$df89					Here1 = *	; remember here
>df79	0e					.byte CodeLen	;patch wh_CodeLength
>df89	52 44 72 6f 70			Name0:	.text "RDrop"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=57102					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>df8e	05					.byte (("RDrop"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=52					WordFlags ::= CO+ST	; modifiable copy, remember for later
=23					LinkDisplacement = Nt0-WordListLink
>df8f	34					.byte WordFlags	;wh_Flags
>df90	03					.byte 3	;wh_CodeLength
>df91	17					  .byte LinkDisplacement	; offset to previous nt
=$df92					XtPtr1 ::= *
=57102					WordListLink ::= Nt0 ; remember the nt of this word for later
.df92					RDrop:
.df92	68		pla				pla		; Move the RTS addr out of the way
.df93	85 1c		sta $1c				sta tmp5+0
.df95	68		pla				pla
.df96	85 1d		sta $1d				sta tmp5+1
.df98	68		pla				pla		; LSB
.df99	68		pla				pla		; MSB
.df9a	a5 1d		lda $1d				lda tmp5+1	; Restore the RTS addr
.df9c	48		pha				pha
.df9d	a5 1c		lda $1c				lda tmp5+0
.df9f	48		pha				pha
=14					CodeLen	.var *-XtPtr1
=$dfa0					Here1 = *	; remember here
>df90	0e					.byte CodeLen	;patch wh_CodeLength
.dfa0	60		rts				rts
>dfa1	4f 76 65 72			Name0:	.text "Over"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=57125					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>dfa5	44					.byte (("Over"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=23					LinkDisplacement = Nt0-WordListLink
>dfa6	10					.byte WordFlags	;wh_Flags
>dfa7	03					.byte 3	;wh_CodeLength
>dfa8	17					  .byte LinkDisplacement	; offset to previous nt
=$dfa9					XtPtr1 ::= *
=57125					WordListLink ::= Nt0 ; remember the nt of this word for later
.dfa9					Over:
.dfa9	e0 2d		cpx #$2d		cpx #(DDim-2)*2+1	; far enough below end of data stack (& not negative)?
.dfab	b0 34		bcs $dfe1		bcs Throw_Stack_04
.dfad	b5 26		lda $26,x			lda DStack+2,x	; LSB
.dfaf	b4 27		ldy $27,x			ldy DStack+3,x	; MSB
.dfb1	ca		dex				dex		; PushYA
.dfb2	ca		dex				dex
.dfb3	95 24		sta $24,x			sta DStack+0,x
.dfb5	94 25		sty $25,x			sty DStack+1,x
=14					CodeLen	.var *-XtPtr1
=$dfb7					Here1 = *	; remember here
>dfa7	0e					.byte CodeLen	;patch wh_CodeLength
.dfb7	60		rts				rts
>dfb8	3f 44 75 70			Name0:	.text "?Dup"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=57148					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>dfbc	04					.byte (("?Dup"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=23					LinkDisplacement = Nt0-WordListLink
>dfbd	10					.byte WordFlags	;wh_Flags
>dfbe	03					.byte 3	;wh_CodeLength
>dfbf	17					  .byte LinkDisplacement	; offset to previous nt
=$dfc0					XtPtr1 ::= *
=57148					WordListLink ::= Nt0 ; remember the nt of this word for later
.dfc0					Question_Dup:
.dfc0	e0 2f		cpx #$2f		cpx #(DDim-1)*2+1	; far enough below end of data stack (& not negative)?
.dfc2	b0 1d		bcs $dfe1		bcs Throw_Stack_04
.dfc4	b5 24		lda $24,x			lda DStack+0,x	; Check if TOS is zero
.dfc6	15 25		ora $25,x			ora DStack+1,x
.dfc8	d0 0c		bne $dfd6			bne Dup_NoUf
=10					CodeLen	.var *-XtPtr1
=$dfca					Here1 = *	; remember here
>dfbe	0a					.byte CodeLen	;patch wh_CodeLength
.dfca	60		rts				rts
>dfcb	44 75 70			Name0:	.text "Dup"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=57166					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>dfce	03					.byte (("Dup"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=18					LinkDisplacement = Nt0-WordListLink
>dfcf	10					.byte WordFlags	;wh_Flags
>dfd0	03					.byte 3	;wh_CodeLength
>dfd1	12					  .byte LinkDisplacement	; offset to previous nt
=$dfd2					XtPtr1 ::= *
=57166					WordListLink ::= Nt0 ; remember the nt of this word for later
.dfd2					Dup:
.dfd2	e0 2f		cpx #$2f		cpx #(DDim-1)*2+1	; far enough below end of data stack (& not negative)?
.dfd4	b0 0b		bcs $dfe1		bcs Throw_Stack_04
.dfd6	b5 24		lda $24,x	Dup_NoUf:	lda DStack+0,x	; LSB
.dfd8	b4 25		ldy $25,x			ldy DStack+1,x	; MSB
.dfda	ca		dex				dex
.dfdb	ca		dex				dex
.dfdc	95 24		sta $24,x			sta DStack+0,x
.dfde	94 25		sty $25,x			sty DStack+1,x
=14					CodeLen	.var *-XtPtr1
=$dfe0					Here1 = *	; remember here
>dfd0	0e					.byte CodeLen	;patch wh_CodeLength
.dfe0	60		rts				rts
.dfe1	4c 2f c4	jmp $c42f	Throw_Stack_04: jmp Throw_Stack
.dfe4					PushAY:
.dfe4	ca		dex				dex
.dfe5	ca		dex				dex
.dfe6	94 24		sty $24,x			sty DStack+0,x
.dfe8	95 25		sta $25,x			sta DStack+1,x
.dfea	60		rts				rts
>dfeb	53 77 61 70			Name0:	.text "Swap"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=57199					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>dfef	04					.byte (("Swap"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=33					LinkDisplacement = Nt0-WordListLink
>dff0	10					.byte WordFlags	;wh_Flags
>dff1	03					.byte 3	;wh_CodeLength
>dff2	21					  .byte LinkDisplacement	; offset to previous nt
=$dff3					XtPtr1 ::= *
=57199					WordListLink ::= Nt0 ; remember the nt of this word for later
.dff3					Swap:
.dff3	e0 2d		cpx #$2d		cpx #(DDim-2)*2+1	; far enough below end of data stack (& not negative)?
.dff5	b0 ea		bcs $dfe1		bcs Throw_Stack_04
.dff7	b5 24		lda $24,x			lda DStack+0,x	; do LSB
.dff9	b4 26		ldy $26,x			ldy DStack+2,x
.dffb	95 26		sta $26,x			sta DStack+2,x
.dffd	94 24		sty $24,x			sty DStack+0,x
.dfff	b5 25		lda $25,x			lda DStack+1,x	; do MSB
.e001	b4 27		ldy $27,x			ldy DStack+3,x
.e003	95 27		sta $27,x			sta DStack+3,x
.e005	94 25		sty $25,x			sty DStack+1,x
=20					CodeLen	.var *-XtPtr1
=$e007					Here1 = *	; remember here
>dff1	14					.byte CodeLen	;patch wh_CodeLength
.e007	60		rts				rts
>e008	44 72 6f 70			Name0:	.text "Drop"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=57228					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e00c	04					.byte (("Drop"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=29					LinkDisplacement = Nt0-WordListLink
>e00d	10					.byte WordFlags	;wh_Flags
>e00e	03					.byte 3	;wh_CodeLength
>e00f	1d					  .byte LinkDisplacement	; offset to previous nt
=$e010					XtPtr1 ::= *
=57228					WordListLink ::= Nt0 ; remember the nt of this word for later
.e010					Drop:
.e010	e0 2f		cpx #$2f		cpx #(DDim-1)*2+1	; far enough below end of data stack (& not negative)?
.e012	b0 cd		bcs $dfe1		bcs Throw_Stack_04
.e014	e8		inx				inx
.e015	e8		inx				inx
=6					CodeLen	.var *-XtPtr1
=$e016					Here1 = *	; remember here
>e00e	06					.byte CodeLen	;patch wh_CodeLength
.e016	60		rts				rts
=57228					forth_dictionary_start = WordListLink ; END of FORTH-WORDLIST
=0					WordListLink .var 0
>e017	57 6f 72 64 73			Name0:	.text "Words"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=57244					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e01c	65					.byte (("Words"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=57244					LinkDisplacement = Nt0-WordListLink
=$11						  WordFlags ::= WordFlags | FP
=$13						  WordFlags ::= WordFlags | DB
>e01d	13					.byte WordFlags	;wh_Flags
>e01e	08					.byte 8	;wh_CodeLength
>e01f	00 00					  .word WordListLink
>e021	9f ba					  .word Words		; pointer to xt
=0					XtPtr1 ::= 0
=57244					WordListLink ::= Nt0 ; remember the nt of this word for later
>e023	46 6f 72 74 68 2d 57 6f		Name0:	.text "Forth-Wordlist"	;  name of word as a string, ending at wh_NameLastChar
>e02b	72 64 6c 69 73 74
=14					NameLength = *-Name0
=57265					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e031	8e					.byte (("Forth-Wordlist"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=21					LinkDisplacement = Nt0-WordListLink
=$12						  WordFlags ::= WordFlags | DB
>e032	12					.byte WordFlags	;wh_Flags
>e033	08					.byte 8	;wh_CodeLength
>e034	15					  .byte LinkDisplacement	; offset to previous nt
>e035	02 b0					  .word Forth_WordList		; pointer to xt
=0					XtPtr1 ::= 0
=57265					WordListLink ::= Nt0 ; remember the nt of this word for later
>e037	46 6f 72 74 68			Name0:	.text "Forth"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=57276					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e03c	05					.byte (("Forth"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=11					LinkDisplacement = Nt0-WordListLink
=$12						  WordFlags ::= WordFlags | DB
>e03d	12					.byte WordFlags	;wh_Flags
>e03e	08					.byte 8	;wh_CodeLength
>e03f	0b					  .byte LinkDisplacement	; offset to previous nt
>e040	06 b1					  .word Forth		; pointer to xt
=0					XtPtr1 ::= 0
=57276					WordListLink ::= Nt0 ; remember the nt of this word for later
>e042	53 65 74 2d 4f 72 64 65		Name0:	.text "Set-Order"	;  name of word as a string, ending at wh_NameLastChar
>e04a	72
=9					NameLength = *-Name0
=57291					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e04b	49					.byte (("Set-Order"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=15					LinkDisplacement = Nt0-WordListLink
=$12						  WordFlags ::= WordFlags | DB
>e04c	12					.byte WordFlags	;wh_Flags
>e04d	08					.byte 8	;wh_CodeLength
>e04e	0f					  .byte LinkDisplacement	; offset to previous nt
>e04f	6f b1					  .word Set_Order		; pointer to xt
=0					XtPtr1 ::= 0
=57291					WordListLink ::= Nt0 ; remember the nt of this word for later
=57291					root_dictionary_start = WordListLink ; END of ROOT-WORDLIST
=0					WordListLink .var 0
>e051	61 64 63			Name0:	.text "adc"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=57300					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e054	63					.byte (("adc"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=57300					LinkDisplacement = Nt0-WordListLink
=$11						  WordFlags ::= WordFlags | FP
>e055	11					.byte WordFlags	;wh_Flags
>e056	03					.byte 3	;wh_CodeLength
>e057	00 00					  .word WordListLink
=$e059					XtPtr1 ::= *
=57300					WordListLink ::= Nt0 ; remember the nt of this word for later
.e059	20 0c e8	jsr $e80c		jsr asm_2
=3					CodeLen	.var *-XtPtr1
=$e05c					Here1 = *	; remember here
>e056	03					.byte CodeLen	;patch wh_CodeLength
>e05c	6d					.byte $6d
>e05d	61 64 63 2e 23			Name0:	.text "adc.#"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=57314					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e062	65					.byte (("adc.#"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=14					LinkDisplacement = Nt0-WordListLink
>e063	10					.byte WordFlags	;wh_Flags
>e064	03					.byte 3	;wh_CodeLength
>e065	0e					  .byte LinkDisplacement	; offset to previous nt
=$e066					XtPtr1 ::= *
=57314					WordListLink ::= Nt0 ; remember the nt of this word for later
.e066	20 fa e7	jsr $e7fa		jsr asm_1
=3					CodeLen	.var *-XtPtr1
=$e069					Here1 = *	; remember here
>e064	03					.byte CodeLen	;patch wh_CodeLength
>e069	69					.byte $69
>e06a	61 64 63 2e 78			Name0:	.text "adc.x"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=57327					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e06f	05					.byte (("adc.x"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>e070	10					.byte WordFlags	;wh_Flags
>e071	03					.byte 3	;wh_CodeLength
>e072	0d					  .byte LinkDisplacement	; offset to previous nt
=$e073					XtPtr1 ::= *
=57327					WordListLink ::= Nt0 ; remember the nt of this word for later
.e073	20 0c e8	jsr $e80c		jsr asm_2
=3					CodeLen	.var *-XtPtr1
=$e076					Here1 = *	; remember here
>e071	03					.byte CodeLen	;patch wh_CodeLength
>e076	7d					.byte $7d
>e077	61 64 63 2e 79			Name0:	.text "adc.y"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=57340					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e07c	25					.byte (("adc.y"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>e07d	10					.byte WordFlags	;wh_Flags
>e07e	03					.byte 3	;wh_CodeLength
>e07f	0d					  .byte LinkDisplacement	; offset to previous nt
=$e080					XtPtr1 ::= *
=57340					WordListLink ::= Nt0 ; remember the nt of this word for later
.e080	20 0c e8	jsr $e80c		jsr asm_2
=3					CodeLen	.var *-XtPtr1
=$e083					Here1 = *	; remember here
>e07e	03					.byte CodeLen	;patch wh_CodeLength
>e083	79					.byte $79
>e084	61 64 63 2e 7a			Name0:	.text "adc.z"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=57353					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e089	45					.byte (("adc.z"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>e08a	10					.byte WordFlags	;wh_Flags
>e08b	03					.byte 3	;wh_CodeLength
>e08c	0d					  .byte LinkDisplacement	; offset to previous nt
=$e08d					XtPtr1 ::= *
=57353					WordListLink ::= Nt0 ; remember the nt of this word for later
.e08d	20 fa e7	jsr $e7fa		jsr asm_1
=3					CodeLen	.var *-XtPtr1
=$e090					Here1 = *	; remember here
>e08b	03					.byte CodeLen	;patch wh_CodeLength
>e090	65					.byte $65
>e091	61 64 63 2e 7a 69 79		Name0:	.text "adc.ziy"	;  name of word as a string, ending at wh_NameLastChar
=7					NameLength = *-Name0
=57368					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e098	27					.byte (("adc.ziy"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=15					LinkDisplacement = Nt0-WordListLink
>e099	10					.byte WordFlags	;wh_Flags
>e09a	03					.byte 3	;wh_CodeLength
>e09b	0f					  .byte LinkDisplacement	; offset to previous nt
=$e09c					XtPtr1 ::= *
=57368					WordListLink ::= Nt0 ; remember the nt of this word for later
.e09c	20 fa e7	jsr $e7fa		jsr asm_1
=3					CodeLen	.var *-XtPtr1
=$e09f					Here1 = *	; remember here
>e09a	03					.byte CodeLen	;patch wh_CodeLength
>e09f	71					.byte $71
>e0a0	61 64 63 2e 7a 78		Name0:	.text "adc.zx"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=57382					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e0a6	06					.byte (("adc.zx"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=14					LinkDisplacement = Nt0-WordListLink
>e0a7	10					.byte WordFlags	;wh_Flags
>e0a8	03					.byte 3	;wh_CodeLength
>e0a9	0e					  .byte LinkDisplacement	; offset to previous nt
=$e0aa					XtPtr1 ::= *
=57382					WordListLink ::= Nt0 ; remember the nt of this word for later
.e0aa	20 fa e7	jsr $e7fa		jsr asm_1
=3					CodeLen	.var *-XtPtr1
=$e0ad					Here1 = *	; remember here
>e0a8	03					.byte CodeLen	;patch wh_CodeLength
>e0ad	75					.byte $75
>e0ae	61 64 63 2e 7a 78 69		Name0:	.text "adc.zxi"	;  name of word as a string, ending at wh_NameLastChar
=7					NameLength = *-Name0
=57397					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e0b5	27					.byte (("adc.zxi"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=15					LinkDisplacement = Nt0-WordListLink
>e0b6	10					.byte WordFlags	;wh_Flags
>e0b7	03					.byte 3	;wh_CodeLength
>e0b8	0f					  .byte LinkDisplacement	; offset to previous nt
=$e0b9					XtPtr1 ::= *
=57397					WordListLink ::= Nt0 ; remember the nt of this word for later
.e0b9	20 fa e7	jsr $e7fa		jsr asm_1
=3					CodeLen	.var *-XtPtr1
=$e0bc					Here1 = *	; remember here
>e0b7	03					.byte CodeLen	;patch wh_CodeLength
>e0bc	61					.byte $61
>e0bd	61 6e 64 2e			Name0:	.text "and."	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=57409					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e0c1	c4					.byte (("and."[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=12					LinkDisplacement = Nt0-WordListLink
>e0c2	10					.byte WordFlags	;wh_Flags
>e0c3	03					.byte 3	;wh_CodeLength
>e0c4	0c					  .byte LinkDisplacement	; offset to previous nt
=$e0c5					XtPtr1 ::= *
=57409					WordListLink ::= Nt0 ; remember the nt of this word for later
.e0c5	20 0c e8	jsr $e80c		jsr asm_2
=3					CodeLen	.var *-XtPtr1
=$e0c8					Here1 = *	; remember here
>e0c3	03					.byte CodeLen	;patch wh_CodeLength
>e0c8	2d					.byte $2d
>e0c9	61 6e 64 2e 23			Name0:	.text "and.#"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=57422					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e0ce	65					.byte (("and.#"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>e0cf	10					.byte WordFlags	;wh_Flags
>e0d0	03					.byte 3	;wh_CodeLength
>e0d1	0d					  .byte LinkDisplacement	; offset to previous nt
=$e0d2					XtPtr1 ::= *
=57422					WordListLink ::= Nt0 ; remember the nt of this word for later
.e0d2	20 fa e7	jsr $e7fa		jsr asm_1
=3					CodeLen	.var *-XtPtr1
=$e0d5					Here1 = *	; remember here
>e0d0	03					.byte CodeLen	;patch wh_CodeLength
>e0d5	29					.byte $29
>e0d6	61 6e 64 2e 78			Name0:	.text "and.x"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=57435					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e0db	05					.byte (("and.x"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>e0dc	10					.byte WordFlags	;wh_Flags
>e0dd	03					.byte 3	;wh_CodeLength
>e0de	0d					  .byte LinkDisplacement	; offset to previous nt
=$e0df					XtPtr1 ::= *
=57435					WordListLink ::= Nt0 ; remember the nt of this word for later
.e0df	20 0c e8	jsr $e80c		jsr asm_2
=3					CodeLen	.var *-XtPtr1
=$e0e2					Here1 = *	; remember here
>e0dd	03					.byte CodeLen	;patch wh_CodeLength
>e0e2	3d					.byte $3d
>e0e3	61 6e 64 2e 79			Name0:	.text "and.y"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=57448					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e0e8	25					.byte (("and.y"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>e0e9	10					.byte WordFlags	;wh_Flags
>e0ea	03					.byte 3	;wh_CodeLength
>e0eb	0d					  .byte LinkDisplacement	; offset to previous nt
=$e0ec					XtPtr1 ::= *
=57448					WordListLink ::= Nt0 ; remember the nt of this word for later
.e0ec	20 0c e8	jsr $e80c		jsr asm_2
=3					CodeLen	.var *-XtPtr1
=$e0ef					Here1 = *	; remember here
>e0ea	03					.byte CodeLen	;patch wh_CodeLength
>e0ef	39					.byte $39
>e0f0	61 6e 64 2e 7a			Name0:	.text "and.z"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=57461					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e0f5	45					.byte (("and.z"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>e0f6	10					.byte WordFlags	;wh_Flags
>e0f7	03					.byte 3	;wh_CodeLength
>e0f8	0d					  .byte LinkDisplacement	; offset to previous nt
=$e0f9					XtPtr1 ::= *
=57461					WordListLink ::= Nt0 ; remember the nt of this word for later
.e0f9	20 fa e7	jsr $e7fa		jsr asm_1
=3					CodeLen	.var *-XtPtr1
=$e0fc					Here1 = *	; remember here
>e0f7	03					.byte CodeLen	;patch wh_CodeLength
>e0fc	25					.byte $25
>e0fd	61 6e 64 2e 7a 69 79		Name0:	.text "and.ziy"	;  name of word as a string, ending at wh_NameLastChar
=7					NameLength = *-Name0
=57476					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e104	27					.byte (("and.ziy"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=15					LinkDisplacement = Nt0-WordListLink
>e105	10					.byte WordFlags	;wh_Flags
>e106	03					.byte 3	;wh_CodeLength
>e107	0f					  .byte LinkDisplacement	; offset to previous nt
=$e108					XtPtr1 ::= *
=57476					WordListLink ::= Nt0 ; remember the nt of this word for later
.e108	20 fa e7	jsr $e7fa		jsr asm_1
=3					CodeLen	.var *-XtPtr1
=$e10b					Here1 = *	; remember here
>e106	03					.byte CodeLen	;patch wh_CodeLength
>e10b	31					.byte $31
>e10c	61 6e 64 2e 7a 78		Name0:	.text "and.zx"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=57490					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e112	06					.byte (("and.zx"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=14					LinkDisplacement = Nt0-WordListLink
>e113	10					.byte WordFlags	;wh_Flags
>e114	03					.byte 3	;wh_CodeLength
>e115	0e					  .byte LinkDisplacement	; offset to previous nt
=$e116					XtPtr1 ::= *
=57490					WordListLink ::= Nt0 ; remember the nt of this word for later
.e116	20 fa e7	jsr $e7fa		jsr asm_1
=3					CodeLen	.var *-XtPtr1
=$e119					Here1 = *	; remember here
>e114	03					.byte CodeLen	;patch wh_CodeLength
>e119	35					.byte $35
>e11a	61 6e 64 2e 7a 78 69		Name0:	.text "and.zxi"	;  name of word as a string, ending at wh_NameLastChar
=7					NameLength = *-Name0
=57505					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e121	27					.byte (("and.zxi"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=15					LinkDisplacement = Nt0-WordListLink
>e122	10					.byte WordFlags	;wh_Flags
>e123	03					.byte 3	;wh_CodeLength
>e124	0f					  .byte LinkDisplacement	; offset to previous nt
=$e125					XtPtr1 ::= *
=57505					WordListLink ::= Nt0 ; remember the nt of this word for later
.e125	20 fa e7	jsr $e7fa		jsr asm_1
=3					CodeLen	.var *-XtPtr1
=$e128					Here1 = *	; remember here
>e123	03					.byte CodeLen	;patch wh_CodeLength
>e128	21					.byte $21
>e129	61 73 6c			Name0:	.text "asl"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=57516					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e12c	83					.byte (("asl"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=11					LinkDisplacement = Nt0-WordListLink
>e12d	10					.byte WordFlags	;wh_Flags
>e12e	03					.byte 3	;wh_CodeLength
>e12f	0b					  .byte LinkDisplacement	; offset to previous nt
=$e130					XtPtr1 ::= *
=57516					WordListLink ::= Nt0 ; remember the nt of this word for later
.e130	20 0c e8	jsr $e80c		jsr asm_2
=3					CodeLen	.var *-XtPtr1
=$e133					Here1 = *	; remember here
>e12e	03					.byte CodeLen	;patch wh_CodeLength
>e133	0e					.byte $0e
>e134	61 73 6c 2e 61			Name0:	.text "asl.a"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=57529					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e139	25					.byte (("asl.a"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>e13a	10					.byte WordFlags	;wh_Flags
>e13b	03					.byte 3	;wh_CodeLength
>e13c	0d					  .byte LinkDisplacement	; offset to previous nt
=$e13d					XtPtr1 ::= *
=57529					WordListLink ::= Nt0 ; remember the nt of this word for later
.e13d	20 15 e8	jsr $e815		jsr asm_0
=3					CodeLen	.var *-XtPtr1
=$e140					Here1 = *	; remember here
>e13b	03					.byte CodeLen	;patch wh_CodeLength
>e140	0a					.byte $0a
>e141	61 73 6c 2e 78			Name0:	.text "asl.x"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=57542					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e146	05					.byte (("asl.x"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>e147	10					.byte WordFlags	;wh_Flags
>e148	03					.byte 3	;wh_CodeLength
>e149	0d					  .byte LinkDisplacement	; offset to previous nt
=$e14a					XtPtr1 ::= *
=57542					WordListLink ::= Nt0 ; remember the nt of this word for later
.e14a	20 0c e8	jsr $e80c		jsr asm_2
=3					CodeLen	.var *-XtPtr1
=$e14d					Here1 = *	; remember here
>e148	03					.byte CodeLen	;patch wh_CodeLength
>e14d	1e					.byte $1e
>e14e	61 73 6c 2e 7a			Name0:	.text "asl.z"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=57555					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e153	45					.byte (("asl.z"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>e154	10					.byte WordFlags	;wh_Flags
>e155	03					.byte 3	;wh_CodeLength
>e156	0d					  .byte LinkDisplacement	; offset to previous nt
=$e157					XtPtr1 ::= *
=57555					WordListLink ::= Nt0 ; remember the nt of this word for later
.e157	20 fa e7	jsr $e7fa		jsr asm_1
=3					CodeLen	.var *-XtPtr1
=$e15a					Here1 = *	; remember here
>e155	03					.byte CodeLen	;patch wh_CodeLength
>e15a	06					.byte $06
>e15b	61 73 6c 2e 7a 78		Name0:	.text "asl.zx"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=57569					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e161	06					.byte (("asl.zx"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=14					LinkDisplacement = Nt0-WordListLink
>e162	10					.byte WordFlags	;wh_Flags
>e163	03					.byte 3	;wh_CodeLength
>e164	0e					  .byte LinkDisplacement	; offset to previous nt
=$e165					XtPtr1 ::= *
=57569					WordListLink ::= Nt0 ; remember the nt of this word for later
.e165	20 fa e7	jsr $e7fa		jsr asm_1
=3					CodeLen	.var *-XtPtr1
=$e168					Here1 = *	; remember here
>e163	03					.byte CodeLen	;patch wh_CodeLength
>e168	16					.byte $16
>e169	62 63 63			Name0:	.text "bcc"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=57580					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e16c	63					.byte (("bcc"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=11					LinkDisplacement = Nt0-WordListLink
>e16d	10					.byte WordFlags	;wh_Flags
>e16e	03					.byte 3	;wh_CodeLength
>e16f	0b					  .byte LinkDisplacement	; offset to previous nt
=$e170					XtPtr1 ::= *
=57580					WordListLink ::= Nt0 ; remember the nt of this word for later
.e170	20 da e7	jsr $e7da		jsr asm_r
=3					CodeLen	.var *-XtPtr1
=$e173					Here1 = *	; remember here
>e16e	03					.byte CodeLen	;patch wh_CodeLength
>e173	90					.byte $90
>e174	62 63 73			Name0:	.text "bcs"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=57591					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e177	63					.byte (("bcs"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=11					LinkDisplacement = Nt0-WordListLink
>e178	10					.byte WordFlags	;wh_Flags
>e179	03					.byte 3	;wh_CodeLength
>e17a	0b					  .byte LinkDisplacement	; offset to previous nt
=$e17b					XtPtr1 ::= *
=57591					WordListLink ::= Nt0 ; remember the nt of this word for later
.e17b	20 da e7	jsr $e7da		jsr asm_r
=3					CodeLen	.var *-XtPtr1
=$e17e					Here1 = *	; remember here
>e179	03					.byte CodeLen	;patch wh_CodeLength
>e17e	b0					.byte $b0
>e17f	62 65 71			Name0:	.text "beq"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=57602					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e182	23					.byte (("beq"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=11					LinkDisplacement = Nt0-WordListLink
>e183	10					.byte WordFlags	;wh_Flags
>e184	03					.byte 3	;wh_CodeLength
>e185	0b					  .byte LinkDisplacement	; offset to previous nt
=$e186					XtPtr1 ::= *
=57602					WordListLink ::= Nt0 ; remember the nt of this word for later
.e186	20 da e7	jsr $e7da		jsr asm_r
=3					CodeLen	.var *-XtPtr1
=$e189					Here1 = *	; remember here
>e184	03					.byte CodeLen	;patch wh_CodeLength
>e189	f0					.byte $f0
>e18a	62 69 74			Name0:	.text "bit"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=57613					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e18d	83					.byte (("bit"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=11					LinkDisplacement = Nt0-WordListLink
>e18e	10					.byte WordFlags	;wh_Flags
>e18f	03					.byte 3	;wh_CodeLength
>e190	0b					  .byte LinkDisplacement	; offset to previous nt
=$e191					XtPtr1 ::= *
=57613					WordListLink ::= Nt0 ; remember the nt of this word for later
.e191	20 0c e8	jsr $e80c		jsr asm_2
=3					CodeLen	.var *-XtPtr1
=$e194					Here1 = *	; remember here
>e18f	03					.byte CodeLen	;patch wh_CodeLength
>e194	2c					.byte $2c
>e195	62 69 74 2e 7a			Name0:	.text "bit.z"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=57626					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e19a	45					.byte (("bit.z"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>e19b	10					.byte WordFlags	;wh_Flags
>e19c	03					.byte 3	;wh_CodeLength
>e19d	0d					  .byte LinkDisplacement	; offset to previous nt
=$e19e					XtPtr1 ::= *
=57626					WordListLink ::= Nt0 ; remember the nt of this word for later
.e19e	20 fa e7	jsr $e7fa		jsr asm_1
=3					CodeLen	.var *-XtPtr1
=$e1a1					Here1 = *	; remember here
>e19c	03					.byte CodeLen	;patch wh_CodeLength
>e1a1	24					.byte $24
>e1a2	62 6d 69			Name0:	.text "bmi"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=57637					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e1a5	23					.byte (("bmi"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=11					LinkDisplacement = Nt0-WordListLink
>e1a6	10					.byte WordFlags	;wh_Flags
>e1a7	03					.byte 3	;wh_CodeLength
>e1a8	0b					  .byte LinkDisplacement	; offset to previous nt
=$e1a9					XtPtr1 ::= *
=57637					WordListLink ::= Nt0 ; remember the nt of this word for later
.e1a9	20 da e7	jsr $e7da		jsr asm_r
=3					CodeLen	.var *-XtPtr1
=$e1ac					Here1 = *	; remember here
>e1a7	03					.byte CodeLen	;patch wh_CodeLength
>e1ac	30					.byte $30
>e1ad	62 6e 65			Name0:	.text "bne"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=57648					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e1b0	a3					.byte (("bne"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=11					LinkDisplacement = Nt0-WordListLink
>e1b1	10					.byte WordFlags	;wh_Flags
>e1b2	03					.byte 3	;wh_CodeLength
>e1b3	0b					  .byte LinkDisplacement	; offset to previous nt
=$e1b4					XtPtr1 ::= *
=57648					WordListLink ::= Nt0 ; remember the nt of this word for later
.e1b4	20 da e7	jsr $e7da		jsr asm_r
=3					CodeLen	.var *-XtPtr1
=$e1b7					Here1 = *	; remember here
>e1b2	03					.byte CodeLen	;patch wh_CodeLength
>e1b7	d0					.byte $d0
>e1b8	62 70 6c			Name0:	.text "bpl"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=57659					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e1bb	83					.byte (("bpl"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=11					LinkDisplacement = Nt0-WordListLink
>e1bc	10					.byte WordFlags	;wh_Flags
>e1bd	03					.byte 3	;wh_CodeLength
>e1be	0b					  .byte LinkDisplacement	; offset to previous nt
=$e1bf					XtPtr1 ::= *
=57659					WordListLink ::= Nt0 ; remember the nt of this word for later
.e1bf	20 da e7	jsr $e7da		jsr asm_r
=3					CodeLen	.var *-XtPtr1
=$e1c2					Here1 = *	; remember here
>e1bd	03					.byte CodeLen	;patch wh_CodeLength
>e1c2	10					.byte $10
>e1c3	62 72 6b			Name0:	.text "brk"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=57670					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e1c6	63					.byte (("brk"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=11					LinkDisplacement = Nt0-WordListLink
>e1c7	10					.byte WordFlags	;wh_Flags
>e1c8	03					.byte 3	;wh_CodeLength
>e1c9	0b					  .byte LinkDisplacement	; offset to previous nt
=$e1ca					XtPtr1 ::= *
=57670					WordListLink ::= Nt0 ; remember the nt of this word for later
.e1ca	20 fa e7	jsr $e7fa		jsr asm_1
=3					CodeLen	.var *-XtPtr1
=$e1cd					Here1 = *	; remember here
>e1c8	03					.byte CodeLen	;patch wh_CodeLength
>e1cd	00					.byte $00
>e1ce	62 76 63			Name0:	.text "bvc"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=57681					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e1d1	63					.byte (("bvc"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=11					LinkDisplacement = Nt0-WordListLink
>e1d2	10					.byte WordFlags	;wh_Flags
>e1d3	03					.byte 3	;wh_CodeLength
>e1d4	0b					  .byte LinkDisplacement	; offset to previous nt
=$e1d5					XtPtr1 ::= *
=57681					WordListLink ::= Nt0 ; remember the nt of this word for later
.e1d5	20 da e7	jsr $e7da		jsr asm_r
=3					CodeLen	.var *-XtPtr1
=$e1d8					Here1 = *	; remember here
>e1d3	03					.byte CodeLen	;patch wh_CodeLength
>e1d8	50					.byte $50
>e1d9	62 76 73			Name0:	.text "bvs"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=57692					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e1dc	63					.byte (("bvs"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=11					LinkDisplacement = Nt0-WordListLink
>e1dd	10					.byte WordFlags	;wh_Flags
>e1de	03					.byte 3	;wh_CodeLength
>e1df	0b					  .byte LinkDisplacement	; offset to previous nt
=$e1e0					XtPtr1 ::= *
=57692					WordListLink ::= Nt0 ; remember the nt of this word for later
.e1e0	20 da e7	jsr $e7da		jsr asm_r
=3					CodeLen	.var *-XtPtr1
=$e1e3					Here1 = *	; remember here
>e1de	03					.byte CodeLen	;patch wh_CodeLength
>e1e3	70					.byte $70
>e1e4	63 6c 63			Name0:	.text "clc"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=57703					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e1e7	63					.byte (("clc"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=11					LinkDisplacement = Nt0-WordListLink
>e1e8	10					.byte WordFlags	;wh_Flags
>e1e9	03					.byte 3	;wh_CodeLength
>e1ea	0b					  .byte LinkDisplacement	; offset to previous nt
=$e1eb					XtPtr1 ::= *
=57703					WordListLink ::= Nt0 ; remember the nt of this word for later
.e1eb	20 15 e8	jsr $e815		jsr asm_0
=3					CodeLen	.var *-XtPtr1
=$e1ee					Here1 = *	; remember here
>e1e9	03					.byte CodeLen	;patch wh_CodeLength
>e1ee	18					.byte $18
>e1ef	63 6c 64			Name0:	.text "cld"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=57714					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e1f2	83					.byte (("cld"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=11					LinkDisplacement = Nt0-WordListLink
>e1f3	10					.byte WordFlags	;wh_Flags
>e1f4	03					.byte 3	;wh_CodeLength
>e1f5	0b					  .byte LinkDisplacement	; offset to previous nt
=$e1f6					XtPtr1 ::= *
=57714					WordListLink ::= Nt0 ; remember the nt of this word for later
.e1f6	20 15 e8	jsr $e815		jsr asm_0
=3					CodeLen	.var *-XtPtr1
=$e1f9					Here1 = *	; remember here
>e1f4	03					.byte CodeLen	;patch wh_CodeLength
>e1f9	d8					.byte $d8
>e1fa	63 6c 69			Name0:	.text "cli"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=57725					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e1fd	23					.byte (("cli"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=11					LinkDisplacement = Nt0-WordListLink
>e1fe	10					.byte WordFlags	;wh_Flags
>e1ff	03					.byte 3	;wh_CodeLength
>e200	0b					  .byte LinkDisplacement	; offset to previous nt
=$e201					XtPtr1 ::= *
=57725					WordListLink ::= Nt0 ; remember the nt of this word for later
.e201	20 15 e8	jsr $e815		jsr asm_0
=3					CodeLen	.var *-XtPtr1
=$e204					Here1 = *	; remember here
>e1ff	03					.byte CodeLen	;patch wh_CodeLength
>e204	58					.byte $58
>e205	63 6c 76			Name0:	.text "clv"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=57736					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e208	c3					.byte (("clv"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=11					LinkDisplacement = Nt0-WordListLink
>e209	10					.byte WordFlags	;wh_Flags
>e20a	03					.byte 3	;wh_CodeLength
>e20b	0b					  .byte LinkDisplacement	; offset to previous nt
=$e20c					XtPtr1 ::= *
=57736					WordListLink ::= Nt0 ; remember the nt of this word for later
.e20c	20 15 e8	jsr $e815		jsr asm_0
=3					CodeLen	.var *-XtPtr1
=$e20f					Here1 = *	; remember here
>e20a	03					.byte CodeLen	;patch wh_CodeLength
>e20f	b8					.byte $b8
>e210	63 6d 70			Name0:	.text "cmp"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=57747					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e213	03					.byte (("cmp"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=11					LinkDisplacement = Nt0-WordListLink
>e214	10					.byte WordFlags	;wh_Flags
>e215	03					.byte 3	;wh_CodeLength
>e216	0b					  .byte LinkDisplacement	; offset to previous nt
=$e217					XtPtr1 ::= *
=57747					WordListLink ::= Nt0 ; remember the nt of this word for later
.e217	20 0c e8	jsr $e80c		jsr asm_2
=3					CodeLen	.var *-XtPtr1
=$e21a					Here1 = *	; remember here
>e215	03					.byte CodeLen	;patch wh_CodeLength
>e21a	cd					.byte $cd
>e21b	63 6d 70 2e 23			Name0:	.text "cmp.#"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=57760					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e220	65					.byte (("cmp.#"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>e221	10					.byte WordFlags	;wh_Flags
>e222	03					.byte 3	;wh_CodeLength
>e223	0d					  .byte LinkDisplacement	; offset to previous nt
=$e224					XtPtr1 ::= *
=57760					WordListLink ::= Nt0 ; remember the nt of this word for later
.e224	20 fa e7	jsr $e7fa		jsr asm_1
=3					CodeLen	.var *-XtPtr1
=$e227					Here1 = *	; remember here
>e222	03					.byte CodeLen	;patch wh_CodeLength
>e227	c9					.byte $c9
>e228	63 6d 70 2e 78			Name0:	.text "cmp.x"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=57773					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e22d	05					.byte (("cmp.x"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>e22e	10					.byte WordFlags	;wh_Flags
>e22f	03					.byte 3	;wh_CodeLength
>e230	0d					  .byte LinkDisplacement	; offset to previous nt
=$e231					XtPtr1 ::= *
=57773					WordListLink ::= Nt0 ; remember the nt of this word for later
.e231	20 0c e8	jsr $e80c		jsr asm_2
=3					CodeLen	.var *-XtPtr1
=$e234					Here1 = *	; remember here
>e22f	03					.byte CodeLen	;patch wh_CodeLength
>e234	dd					.byte $dd
>e235	63 6d 70 2e 79			Name0:	.text "cmp.y"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=57786					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e23a	25					.byte (("cmp.y"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>e23b	10					.byte WordFlags	;wh_Flags
>e23c	03					.byte 3	;wh_CodeLength
>e23d	0d					  .byte LinkDisplacement	; offset to previous nt
=$e23e					XtPtr1 ::= *
=57786					WordListLink ::= Nt0 ; remember the nt of this word for later
.e23e	20 0c e8	jsr $e80c		jsr asm_2
=3					CodeLen	.var *-XtPtr1
=$e241					Here1 = *	; remember here
>e23c	03					.byte CodeLen	;patch wh_CodeLength
>e241	d9					.byte $d9
>e242	63 6d 70 2e 7a			Name0:	.text "cmp.z"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=57799					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e247	45					.byte (("cmp.z"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>e248	10					.byte WordFlags	;wh_Flags
>e249	03					.byte 3	;wh_CodeLength
>e24a	0d					  .byte LinkDisplacement	; offset to previous nt
=$e24b					XtPtr1 ::= *
=57799					WordListLink ::= Nt0 ; remember the nt of this word for later
.e24b	20 fa e7	jsr $e7fa		jsr asm_1
=3					CodeLen	.var *-XtPtr1
=$e24e					Here1 = *	; remember here
>e249	03					.byte CodeLen	;patch wh_CodeLength
>e24e	c5					.byte $c5
>e24f	63 6d 70 2e 7a 69 79		Name0:	.text "cmp.ziy"	;  name of word as a string, ending at wh_NameLastChar
=7					NameLength = *-Name0
=57814					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e256	27					.byte (("cmp.ziy"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=15					LinkDisplacement = Nt0-WordListLink
>e257	10					.byte WordFlags	;wh_Flags
>e258	03					.byte 3	;wh_CodeLength
>e259	0f					  .byte LinkDisplacement	; offset to previous nt
=$e25a					XtPtr1 ::= *
=57814					WordListLink ::= Nt0 ; remember the nt of this word for later
.e25a	20 fa e7	jsr $e7fa		jsr asm_1
=3					CodeLen	.var *-XtPtr1
=$e25d					Here1 = *	; remember here
>e258	03					.byte CodeLen	;patch wh_CodeLength
>e25d	d1					.byte $d1
>e25e	63 6d 70 2e 7a 78		Name0:	.text "cmp.zx"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=57828					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e264	06					.byte (("cmp.zx"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=14					LinkDisplacement = Nt0-WordListLink
>e265	10					.byte WordFlags	;wh_Flags
>e266	03					.byte 3	;wh_CodeLength
>e267	0e					  .byte LinkDisplacement	; offset to previous nt
=$e268					XtPtr1 ::= *
=57828					WordListLink ::= Nt0 ; remember the nt of this word for later
.e268	20 fa e7	jsr $e7fa		jsr asm_1
=3					CodeLen	.var *-XtPtr1
=$e26b					Here1 = *	; remember here
>e266	03					.byte CodeLen	;patch wh_CodeLength
>e26b	d5					.byte $d5
>e26c	63 6d 70 2e 7a 78 69		Name0:	.text "cmp.zxi"	;  name of word as a string, ending at wh_NameLastChar
=7					NameLength = *-Name0
=57843					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e273	27					.byte (("cmp.zxi"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=15					LinkDisplacement = Nt0-WordListLink
>e274	10					.byte WordFlags	;wh_Flags
>e275	03					.byte 3	;wh_CodeLength
>e276	0f					  .byte LinkDisplacement	; offset to previous nt
=$e277					XtPtr1 ::= *
=57843					WordListLink ::= Nt0 ; remember the nt of this word for later
.e277	20 fa e7	jsr $e7fa		jsr asm_1
=3					CodeLen	.var *-XtPtr1
=$e27a					Here1 = *	; remember here
>e275	03					.byte CodeLen	;patch wh_CodeLength
>e27a	c1					.byte $c1
>e27b	63 70 78			Name0:	.text "cpx"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=57854					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e27e	03					.byte (("cpx"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=11					LinkDisplacement = Nt0-WordListLink
>e27f	10					.byte WordFlags	;wh_Flags
>e280	03					.byte 3	;wh_CodeLength
>e281	0b					  .byte LinkDisplacement	; offset to previous nt
=$e282					XtPtr1 ::= *
=57854					WordListLink ::= Nt0 ; remember the nt of this word for later
.e282	20 0c e8	jsr $e80c		jsr asm_2
=3					CodeLen	.var *-XtPtr1
=$e285					Here1 = *	; remember here
>e280	03					.byte CodeLen	;patch wh_CodeLength
>e285	ec					.byte $ec
>e286	63 70 78 2e 23			Name0:	.text "cpx.#"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=57867					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e28b	65					.byte (("cpx.#"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>e28c	10					.byte WordFlags	;wh_Flags
>e28d	03					.byte 3	;wh_CodeLength
>e28e	0d					  .byte LinkDisplacement	; offset to previous nt
=$e28f					XtPtr1 ::= *
=57867					WordListLink ::= Nt0 ; remember the nt of this word for later
.e28f	20 fa e7	jsr $e7fa		jsr asm_1
=3					CodeLen	.var *-XtPtr1
=$e292					Here1 = *	; remember here
>e28d	03					.byte CodeLen	;patch wh_CodeLength
>e292	e0					.byte $e0
>e293	63 70 78 2e 7a			Name0:	.text "cpx.z"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=57880					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e298	45					.byte (("cpx.z"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>e299	10					.byte WordFlags	;wh_Flags
>e29a	03					.byte 3	;wh_CodeLength
>e29b	0d					  .byte LinkDisplacement	; offset to previous nt
=$e29c					XtPtr1 ::= *
=57880					WordListLink ::= Nt0 ; remember the nt of this word for later
.e29c	20 fa e7	jsr $e7fa		jsr asm_1
=3					CodeLen	.var *-XtPtr1
=$e29f					Here1 = *	; remember here
>e29a	03					.byte CodeLen	;patch wh_CodeLength
>e29f	e4					.byte $e4
>e2a0	63 70 79			Name0:	.text "cpy"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=57891					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e2a3	23					.byte (("cpy"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=11					LinkDisplacement = Nt0-WordListLink
>e2a4	10					.byte WordFlags	;wh_Flags
>e2a5	03					.byte 3	;wh_CodeLength
>e2a6	0b					  .byte LinkDisplacement	; offset to previous nt
=$e2a7					XtPtr1 ::= *
=57891					WordListLink ::= Nt0 ; remember the nt of this word for later
.e2a7	20 0c e8	jsr $e80c		jsr asm_2
=3					CodeLen	.var *-XtPtr1
=$e2aa					Here1 = *	; remember here
>e2a5	03					.byte CodeLen	;patch wh_CodeLength
>e2aa	cc					.byte $cc
>e2ab	63 70 79 2e 23			Name0:	.text "cpy.#"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=57904					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e2b0	65					.byte (("cpy.#"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>e2b1	10					.byte WordFlags	;wh_Flags
>e2b2	03					.byte 3	;wh_CodeLength
>e2b3	0d					  .byte LinkDisplacement	; offset to previous nt
=$e2b4					XtPtr1 ::= *
=57904					WordListLink ::= Nt0 ; remember the nt of this word for later
.e2b4	20 fa e7	jsr $e7fa		jsr asm_1
=3					CodeLen	.var *-XtPtr1
=$e2b7					Here1 = *	; remember here
>e2b2	03					.byte CodeLen	;patch wh_CodeLength
>e2b7	c0					.byte $c0
>e2b8	63 70 79 2e 7a			Name0:	.text "cpy.z"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=57917					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e2bd	45					.byte (("cpy.z"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>e2be	10					.byte WordFlags	;wh_Flags
>e2bf	03					.byte 3	;wh_CodeLength
>e2c0	0d					  .byte LinkDisplacement	; offset to previous nt
=$e2c1					XtPtr1 ::= *
=57917					WordListLink ::= Nt0 ; remember the nt of this word for later
.e2c1	20 fa e7	jsr $e7fa		jsr asm_1
=3					CodeLen	.var *-XtPtr1
=$e2c4					Here1 = *	; remember here
>e2bf	03					.byte CodeLen	;patch wh_CodeLength
>e2c4	c4					.byte $c4
>e2c5	64 65 63			Name0:	.text "dec"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=57928					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e2c8	63					.byte (("dec"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=11					LinkDisplacement = Nt0-WordListLink
>e2c9	10					.byte WordFlags	;wh_Flags
>e2ca	03					.byte 3	;wh_CodeLength
>e2cb	0b					  .byte LinkDisplacement	; offset to previous nt
=$e2cc					XtPtr1 ::= *
=57928					WordListLink ::= Nt0 ; remember the nt of this word for later
.e2cc	20 0c e8	jsr $e80c		jsr asm_2
=3					CodeLen	.var *-XtPtr1
=$e2cf					Here1 = *	; remember here
>e2ca	03					.byte CodeLen	;patch wh_CodeLength
>e2cf	ce					.byte $ce
>e2d0	64 65 63 2e 61			Name0:	.text "dec.a"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=57941					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e2d5	25					.byte (("dec.a"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>e2d6	10					.byte WordFlags	;wh_Flags
>e2d7	03					.byte 3	;wh_CodeLength
>e2d8	0d					  .byte LinkDisplacement	; offset to previous nt
=$e2d9					XtPtr1 ::= *
=57941					WordListLink ::= Nt0 ; remember the nt of this word for later
.e2d9	20 15 e8	jsr $e815		jsr asm_0
=3					CodeLen	.var *-XtPtr1
=$e2dc					Here1 = *	; remember here
>e2d7	03					.byte CodeLen	;patch wh_CodeLength
>e2dc	3a					.byte $3a
>e2dd	64 65 63 2e 78			Name0:	.text "dec.x"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=57954					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e2e2	05					.byte (("dec.x"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>e2e3	10					.byte WordFlags	;wh_Flags
>e2e4	03					.byte 3	;wh_CodeLength
>e2e5	0d					  .byte LinkDisplacement	; offset to previous nt
=$e2e6					XtPtr1 ::= *
=57954					WordListLink ::= Nt0 ; remember the nt of this word for later
.e2e6	20 0c e8	jsr $e80c		jsr asm_2
=3					CodeLen	.var *-XtPtr1
=$e2e9					Here1 = *	; remember here
>e2e4	03					.byte CodeLen	;patch wh_CodeLength
>e2e9	de					.byte $de
>e2ea	64 65 63 2e 7a			Name0:	.text "dec.z"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=57967					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e2ef	45					.byte (("dec.z"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>e2f0	10					.byte WordFlags	;wh_Flags
>e2f1	03					.byte 3	;wh_CodeLength
>e2f2	0d					  .byte LinkDisplacement	; offset to previous nt
=$e2f3					XtPtr1 ::= *
=57967					WordListLink ::= Nt0 ; remember the nt of this word for later
.e2f3	20 fa e7	jsr $e7fa		jsr asm_1
=3					CodeLen	.var *-XtPtr1
=$e2f6					Here1 = *	; remember here
>e2f1	03					.byte CodeLen	;patch wh_CodeLength
>e2f6	c6					.byte $c6
>e2f7	64 65 63 2e 7a 78		Name0:	.text "dec.zx"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=57981					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e2fd	06					.byte (("dec.zx"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=14					LinkDisplacement = Nt0-WordListLink
>e2fe	10					.byte WordFlags	;wh_Flags
>e2ff	03					.byte 3	;wh_CodeLength
>e300	0e					  .byte LinkDisplacement	; offset to previous nt
=$e301					XtPtr1 ::= *
=57981					WordListLink ::= Nt0 ; remember the nt of this word for later
.e301	20 fa e7	jsr $e7fa		jsr asm_1
=3					CodeLen	.var *-XtPtr1
=$e304					Here1 = *	; remember here
>e2ff	03					.byte CodeLen	;patch wh_CodeLength
>e304	d6					.byte $d6
>e305	64 65 78			Name0:	.text "dex"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=57992					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e308	03					.byte (("dex"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=11					LinkDisplacement = Nt0-WordListLink
>e309	10					.byte WordFlags	;wh_Flags
>e30a	03					.byte 3	;wh_CodeLength
>e30b	0b					  .byte LinkDisplacement	; offset to previous nt
=$e30c					XtPtr1 ::= *
=57992					WordListLink ::= Nt0 ; remember the nt of this word for later
.e30c	20 15 e8	jsr $e815		jsr asm_0
=3					CodeLen	.var *-XtPtr1
=$e30f					Here1 = *	; remember here
>e30a	03					.byte CodeLen	;patch wh_CodeLength
>e30f	ca					.byte $ca
>e310	64 65 79			Name0:	.text "dey"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=58003					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e313	23					.byte (("dey"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=11					LinkDisplacement = Nt0-WordListLink
>e314	10					.byte WordFlags	;wh_Flags
>e315	03					.byte 3	;wh_CodeLength
>e316	0b					  .byte LinkDisplacement	; offset to previous nt
=$e317					XtPtr1 ::= *
=58003					WordListLink ::= Nt0 ; remember the nt of this word for later
.e317	20 15 e8	jsr $e815		jsr asm_0
=3					CodeLen	.var *-XtPtr1
=$e31a					Here1 = *	; remember here
>e315	03					.byte CodeLen	;patch wh_CodeLength
>e31a	88					.byte $88
>e31b	65 6f 72			Name0:	.text "eor"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=58014					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e31e	43					.byte (("eor"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=11					LinkDisplacement = Nt0-WordListLink
>e31f	10					.byte WordFlags	;wh_Flags
>e320	03					.byte 3	;wh_CodeLength
>e321	0b					  .byte LinkDisplacement	; offset to previous nt
=$e322					XtPtr1 ::= *
=58014					WordListLink ::= Nt0 ; remember the nt of this word for later
.e322	20 0c e8	jsr $e80c		jsr asm_2
=3					CodeLen	.var *-XtPtr1
=$e325					Here1 = *	; remember here
>e320	03					.byte CodeLen	;patch wh_CodeLength
>e325	4d					.byte $4d
>e326	65 6f 72 2e 23			Name0:	.text "eor.#"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=58027					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e32b	65					.byte (("eor.#"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>e32c	10					.byte WordFlags	;wh_Flags
>e32d	03					.byte 3	;wh_CodeLength
>e32e	0d					  .byte LinkDisplacement	; offset to previous nt
=$e32f					XtPtr1 ::= *
=58027					WordListLink ::= Nt0 ; remember the nt of this word for later
.e32f	20 fa e7	jsr $e7fa		jsr asm_1
=3					CodeLen	.var *-XtPtr1
=$e332					Here1 = *	; remember here
>e32d	03					.byte CodeLen	;patch wh_CodeLength
>e332	49					.byte $49
>e333	65 6f 72 2e 78			Name0:	.text "eor.x"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=58040					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e338	05					.byte (("eor.x"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>e339	10					.byte WordFlags	;wh_Flags
>e33a	03					.byte 3	;wh_CodeLength
>e33b	0d					  .byte LinkDisplacement	; offset to previous nt
=$e33c					XtPtr1 ::= *
=58040					WordListLink ::= Nt0 ; remember the nt of this word for later
.e33c	20 0c e8	jsr $e80c		jsr asm_2
=3					CodeLen	.var *-XtPtr1
=$e33f					Here1 = *	; remember here
>e33a	03					.byte CodeLen	;patch wh_CodeLength
>e33f	5d					.byte $5d
>e340	65 6f 72 2e 79			Name0:	.text "eor.y"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=58053					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e345	25					.byte (("eor.y"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>e346	10					.byte WordFlags	;wh_Flags
>e347	03					.byte 3	;wh_CodeLength
>e348	0d					  .byte LinkDisplacement	; offset to previous nt
=$e349					XtPtr1 ::= *
=58053					WordListLink ::= Nt0 ; remember the nt of this word for later
.e349	20 0c e8	jsr $e80c		jsr asm_2
=3					CodeLen	.var *-XtPtr1
=$e34c					Here1 = *	; remember here
>e347	03					.byte CodeLen	;patch wh_CodeLength
>e34c	59					.byte $59
>e34d	65 6f 72 2e 7a			Name0:	.text "eor.z"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=58066					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e352	45					.byte (("eor.z"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>e353	10					.byte WordFlags	;wh_Flags
>e354	03					.byte 3	;wh_CodeLength
>e355	0d					  .byte LinkDisplacement	; offset to previous nt
=$e356					XtPtr1 ::= *
=58066					WordListLink ::= Nt0 ; remember the nt of this word for later
.e356	20 fa e7	jsr $e7fa		jsr asm_1
=3					CodeLen	.var *-XtPtr1
=$e359					Here1 = *	; remember here
>e354	03					.byte CodeLen	;patch wh_CodeLength
>e359	45					.byte $45
>e35a	65 6f 72 2e 7a 69 79		Name0:	.text "eor.ziy"	;  name of word as a string, ending at wh_NameLastChar
=7					NameLength = *-Name0
=58081					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e361	27					.byte (("eor.ziy"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=15					LinkDisplacement = Nt0-WordListLink
>e362	10					.byte WordFlags	;wh_Flags
>e363	03					.byte 3	;wh_CodeLength
>e364	0f					  .byte LinkDisplacement	; offset to previous nt
=$e365					XtPtr1 ::= *
=58081					WordListLink ::= Nt0 ; remember the nt of this word for later
.e365	20 fa e7	jsr $e7fa		jsr asm_1
=3					CodeLen	.var *-XtPtr1
=$e368					Here1 = *	; remember here
>e363	03					.byte CodeLen	;patch wh_CodeLength
>e368	51					.byte $51
>e369	65 6f 72 2e 7a 78		Name0:	.text "eor.zx"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=58095					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e36f	06					.byte (("eor.zx"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=14					LinkDisplacement = Nt0-WordListLink
>e370	10					.byte WordFlags	;wh_Flags
>e371	03					.byte 3	;wh_CodeLength
>e372	0e					  .byte LinkDisplacement	; offset to previous nt
=$e373					XtPtr1 ::= *
=58095					WordListLink ::= Nt0 ; remember the nt of this word for later
.e373	20 fa e7	jsr $e7fa		jsr asm_1
=3					CodeLen	.var *-XtPtr1
=$e376					Here1 = *	; remember here
>e371	03					.byte CodeLen	;patch wh_CodeLength
>e376	55					.byte $55
>e377	65 6f 72 2e 7a 78 69		Name0:	.text "eor.zxi"	;  name of word as a string, ending at wh_NameLastChar
=7					NameLength = *-Name0
=58110					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e37e	27					.byte (("eor.zxi"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=15					LinkDisplacement = Nt0-WordListLink
>e37f	10					.byte WordFlags	;wh_Flags
>e380	03					.byte 3	;wh_CodeLength
>e381	0f					  .byte LinkDisplacement	; offset to previous nt
=$e382					XtPtr1 ::= *
=58110					WordListLink ::= Nt0 ; remember the nt of this word for later
.e382	20 fa e7	jsr $e7fa		jsr asm_1
=3					CodeLen	.var *-XtPtr1
=$e385					Here1 = *	; remember here
>e380	03					.byte CodeLen	;patch wh_CodeLength
>e385	41					.byte $41
>e386	69 6e 63			Name0:	.text "inc"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=58121					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e389	63					.byte (("inc"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=11					LinkDisplacement = Nt0-WordListLink
>e38a	10					.byte WordFlags	;wh_Flags
>e38b	03					.byte 3	;wh_CodeLength
>e38c	0b					  .byte LinkDisplacement	; offset to previous nt
=$e38d					XtPtr1 ::= *
=58121					WordListLink ::= Nt0 ; remember the nt of this word for later
.e38d	20 0c e8	jsr $e80c		jsr asm_2
=3					CodeLen	.var *-XtPtr1
=$e390					Here1 = *	; remember here
>e38b	03					.byte CodeLen	;patch wh_CodeLength
>e390	ee					.byte $ee
>e391	69 6e 63 2e 61			Name0:	.text "inc.a"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=58134					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e396	25					.byte (("inc.a"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>e397	10					.byte WordFlags	;wh_Flags
>e398	03					.byte 3	;wh_CodeLength
>e399	0d					  .byte LinkDisplacement	; offset to previous nt
=$e39a					XtPtr1 ::= *
=58134					WordListLink ::= Nt0 ; remember the nt of this word for later
.e39a	20 15 e8	jsr $e815		jsr asm_0
=3					CodeLen	.var *-XtPtr1
=$e39d					Here1 = *	; remember here
>e398	03					.byte CodeLen	;patch wh_CodeLength
>e39d	1a					.byte $1a
>e39e	69 6e 63 2e 78			Name0:	.text "inc.x"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=58147					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e3a3	05					.byte (("inc.x"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>e3a4	10					.byte WordFlags	;wh_Flags
>e3a5	03					.byte 3	;wh_CodeLength
>e3a6	0d					  .byte LinkDisplacement	; offset to previous nt
=$e3a7					XtPtr1 ::= *
=58147					WordListLink ::= Nt0 ; remember the nt of this word for later
.e3a7	20 0c e8	jsr $e80c		jsr asm_2
=3					CodeLen	.var *-XtPtr1
=$e3aa					Here1 = *	; remember here
>e3a5	03					.byte CodeLen	;patch wh_CodeLength
>e3aa	fe					.byte $fe
>e3ab	69 6e 63 2e 7a			Name0:	.text "inc.z"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=58160					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e3b0	45					.byte (("inc.z"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>e3b1	10					.byte WordFlags	;wh_Flags
>e3b2	03					.byte 3	;wh_CodeLength
>e3b3	0d					  .byte LinkDisplacement	; offset to previous nt
=$e3b4					XtPtr1 ::= *
=58160					WordListLink ::= Nt0 ; remember the nt of this word for later
.e3b4	20 fa e7	jsr $e7fa		jsr asm_1
=3					CodeLen	.var *-XtPtr1
=$e3b7					Here1 = *	; remember here
>e3b2	03					.byte CodeLen	;patch wh_CodeLength
>e3b7	e6					.byte $e6
>e3b8	69 6e 63 2e 7a 78		Name0:	.text "inc.zx"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=58174					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e3be	06					.byte (("inc.zx"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=14					LinkDisplacement = Nt0-WordListLink
>e3bf	10					.byte WordFlags	;wh_Flags
>e3c0	03					.byte 3	;wh_CodeLength
>e3c1	0e					  .byte LinkDisplacement	; offset to previous nt
=$e3c2					XtPtr1 ::= *
=58174					WordListLink ::= Nt0 ; remember the nt of this word for later
.e3c2	20 fa e7	jsr $e7fa		jsr asm_1
=3					CodeLen	.var *-XtPtr1
=$e3c5					Here1 = *	; remember here
>e3c0	03					.byte CodeLen	;patch wh_CodeLength
>e3c5	f6					.byte $f6
>e3c6	69 6e 78			Name0:	.text "inx"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=58185					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e3c9	03					.byte (("inx"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=11					LinkDisplacement = Nt0-WordListLink
>e3ca	10					.byte WordFlags	;wh_Flags
>e3cb	03					.byte 3	;wh_CodeLength
>e3cc	0b					  .byte LinkDisplacement	; offset to previous nt
=$e3cd					XtPtr1 ::= *
=58185					WordListLink ::= Nt0 ; remember the nt of this word for later
.e3cd	20 15 e8	jsr $e815		jsr asm_0
=3					CodeLen	.var *-XtPtr1
=$e3d0					Here1 = *	; remember here
>e3cb	03					.byte CodeLen	;patch wh_CodeLength
>e3d0	e8					.byte $e8
>e3d1	69 6e 79			Name0:	.text "iny"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=58196					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e3d4	23					.byte (("iny"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=11					LinkDisplacement = Nt0-WordListLink
>e3d5	10					.byte WordFlags	;wh_Flags
>e3d6	03					.byte 3	;wh_CodeLength
>e3d7	0b					  .byte LinkDisplacement	; offset to previous nt
=$e3d8					XtPtr1 ::= *
=58196					WordListLink ::= Nt0 ; remember the nt of this word for later
.e3d8	20 15 e8	jsr $e815		jsr asm_0
=3					CodeLen	.var *-XtPtr1
=$e3db					Here1 = *	; remember here
>e3d6	03					.byte CodeLen	;patch wh_CodeLength
>e3db	c8					.byte $c8
>e3dc	6a 6d 70			Name0:	.text "jmp"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=58207					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e3df	03					.byte (("jmp"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=11					LinkDisplacement = Nt0-WordListLink
>e3e0	10					.byte WordFlags	;wh_Flags
>e3e1	03					.byte 3	;wh_CodeLength
>e3e2	0b					  .byte LinkDisplacement	; offset to previous nt
=$e3e3					XtPtr1 ::= *
=58207					WordListLink ::= Nt0 ; remember the nt of this word for later
.e3e3	20 0c e8	jsr $e80c		jsr asm_2
=3					CodeLen	.var *-XtPtr1
=$e3e6					Here1 = *	; remember here
>e3e1	03					.byte CodeLen	;patch wh_CodeLength
>e3e6	4c					.byte $4c
>e3e7	6a 6d 70 2e 69			Name0:	.text "jmp.i"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=58220					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e3ec	25					.byte (("jmp.i"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>e3ed	10					.byte WordFlags	;wh_Flags
>e3ee	03					.byte 3	;wh_CodeLength
>e3ef	0d					  .byte LinkDisplacement	; offset to previous nt
=$e3f0					XtPtr1 ::= *
=58220					WordListLink ::= Nt0 ; remember the nt of this word for later
.e3f0	20 0c e8	jsr $e80c		jsr asm_2
=3					CodeLen	.var *-XtPtr1
=$e3f3					Here1 = *	; remember here
>e3ee	03					.byte CodeLen	;patch wh_CodeLength
>e3f3	6c					.byte $6c
>e3f4	6a 73 72			Name0:	.text "jsr"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=58231					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e3f7	43					.byte (("jsr"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=11					LinkDisplacement = Nt0-WordListLink
>e3f8	10					.byte WordFlags	;wh_Flags
>e3f9	03					.byte 3	;wh_CodeLength
>e3fa	0b					  .byte LinkDisplacement	; offset to previous nt
=$e3fb					XtPtr1 ::= *
=58231					WordListLink ::= Nt0 ; remember the nt of this word for later
.e3fb	20 0c e8	jsr $e80c		jsr asm_2
=3					CodeLen	.var *-XtPtr1
=$e3fe					Here1 = *	; remember here
>e3f9	03					.byte CodeLen	;patch wh_CodeLength
>e3fe	20					.byte $20
>e3ff	6c 64 61			Name0:	.text "lda"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=58242					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e402	23					.byte (("lda"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=11					LinkDisplacement = Nt0-WordListLink
>e403	10					.byte WordFlags	;wh_Flags
>e404	03					.byte 3	;wh_CodeLength
>e405	0b					  .byte LinkDisplacement	; offset to previous nt
=$e406					XtPtr1 ::= *
=58242					WordListLink ::= Nt0 ; remember the nt of this word for later
.e406	20 0c e8	jsr $e80c		jsr asm_2
=3					CodeLen	.var *-XtPtr1
=$e409					Here1 = *	; remember here
>e404	03					.byte CodeLen	;patch wh_CodeLength
>e409	ad					.byte $ad
>e40a	6c 64 61 2e 23			Name0:	.text "lda.#"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=58255					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e40f	65					.byte (("lda.#"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>e410	10					.byte WordFlags	;wh_Flags
>e411	03					.byte 3	;wh_CodeLength
>e412	0d					  .byte LinkDisplacement	; offset to previous nt
=$e413					XtPtr1 ::= *
=58255					WordListLink ::= Nt0 ; remember the nt of this word for later
.e413	20 fa e7	jsr $e7fa		jsr asm_1
=3					CodeLen	.var *-XtPtr1
=$e416					Here1 = *	; remember here
>e411	03					.byte CodeLen	;patch wh_CodeLength
>e416	a9					.byte $a9
>e417	6c 64 61 2e 78			Name0:	.text "lda.x"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=58268					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e41c	05					.byte (("lda.x"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>e41d	10					.byte WordFlags	;wh_Flags
>e41e	03					.byte 3	;wh_CodeLength
>e41f	0d					  .byte LinkDisplacement	; offset to previous nt
=$e420					XtPtr1 ::= *
=58268					WordListLink ::= Nt0 ; remember the nt of this word for later
.e420	20 0c e8	jsr $e80c		jsr asm_2
=3					CodeLen	.var *-XtPtr1
=$e423					Here1 = *	; remember here
>e41e	03					.byte CodeLen	;patch wh_CodeLength
>e423	bd					.byte $bd
>e424	6c 64 61 2e 79			Name0:	.text "lda.y"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=58281					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e429	25					.byte (("lda.y"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>e42a	10					.byte WordFlags	;wh_Flags
>e42b	03					.byte 3	;wh_CodeLength
>e42c	0d					  .byte LinkDisplacement	; offset to previous nt
=$e42d					XtPtr1 ::= *
=58281					WordListLink ::= Nt0 ; remember the nt of this word for later
.e42d	20 0c e8	jsr $e80c		jsr asm_2
=3					CodeLen	.var *-XtPtr1
=$e430					Here1 = *	; remember here
>e42b	03					.byte CodeLen	;patch wh_CodeLength
>e430	b9					.byte $b9
>e431	6c 64 61 2e 7a			Name0:	.text "lda.z"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=58294					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e436	45					.byte (("lda.z"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>e437	10					.byte WordFlags	;wh_Flags
>e438	03					.byte 3	;wh_CodeLength
>e439	0d					  .byte LinkDisplacement	; offset to previous nt
=$e43a					XtPtr1 ::= *
=58294					WordListLink ::= Nt0 ; remember the nt of this word for later
.e43a	20 fa e7	jsr $e7fa		jsr asm_1
=3					CodeLen	.var *-XtPtr1
=$e43d					Here1 = *	; remember here
>e438	03					.byte CodeLen	;patch wh_CodeLength
>e43d	a5					.byte $a5
>e43e	6c 64 61 2e 7a 69 79		Name0:	.text "lda.ziy"	;  name of word as a string, ending at wh_NameLastChar
=7					NameLength = *-Name0
=58309					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e445	27					.byte (("lda.ziy"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=15					LinkDisplacement = Nt0-WordListLink
>e446	10					.byte WordFlags	;wh_Flags
>e447	03					.byte 3	;wh_CodeLength
>e448	0f					  .byte LinkDisplacement	; offset to previous nt
=$e449					XtPtr1 ::= *
=58309					WordListLink ::= Nt0 ; remember the nt of this word for later
.e449	20 fa e7	jsr $e7fa		jsr asm_1
=3					CodeLen	.var *-XtPtr1
=$e44c					Here1 = *	; remember here
>e447	03					.byte CodeLen	;patch wh_CodeLength
>e44c	b1					.byte $b1
>e44d	6c 64 61 2e 7a 78		Name0:	.text "lda.zx"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=58323					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e453	06					.byte (("lda.zx"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=14					LinkDisplacement = Nt0-WordListLink
>e454	10					.byte WordFlags	;wh_Flags
>e455	03					.byte 3	;wh_CodeLength
>e456	0e					  .byte LinkDisplacement	; offset to previous nt
=$e457					XtPtr1 ::= *
=58323					WordListLink ::= Nt0 ; remember the nt of this word for later
.e457	20 fa e7	jsr $e7fa		jsr asm_1
=3					CodeLen	.var *-XtPtr1
=$e45a					Here1 = *	; remember here
>e455	03					.byte CodeLen	;patch wh_CodeLength
>e45a	b5					.byte $b5
>e45b	6c 64 61 2e 7a 78 69		Name0:	.text "lda.zxi"	;  name of word as a string, ending at wh_NameLastChar
=7					NameLength = *-Name0
=58338					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e462	27					.byte (("lda.zxi"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=15					LinkDisplacement = Nt0-WordListLink
>e463	10					.byte WordFlags	;wh_Flags
>e464	03					.byte 3	;wh_CodeLength
>e465	0f					  .byte LinkDisplacement	; offset to previous nt
=$e466					XtPtr1 ::= *
=58338					WordListLink ::= Nt0 ; remember the nt of this word for later
.e466	20 fa e7	jsr $e7fa		jsr asm_1
=3					CodeLen	.var *-XtPtr1
=$e469					Here1 = *	; remember here
>e464	03					.byte CodeLen	;patch wh_CodeLength
>e469	a1					.byte $a1
>e46a	6c 64 78			Name0:	.text "ldx"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=58349					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e46d	03					.byte (("ldx"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=11					LinkDisplacement = Nt0-WordListLink
>e46e	10					.byte WordFlags	;wh_Flags
>e46f	03					.byte 3	;wh_CodeLength
>e470	0b					  .byte LinkDisplacement	; offset to previous nt
=$e471					XtPtr1 ::= *
=58349					WordListLink ::= Nt0 ; remember the nt of this word for later
.e471	20 0c e8	jsr $e80c		jsr asm_2
=3					CodeLen	.var *-XtPtr1
=$e474					Here1 = *	; remember here
>e46f	03					.byte CodeLen	;patch wh_CodeLength
>e474	ae					.byte $ae
>e475	6c 64 78 2e 23			Name0:	.text "ldx.#"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=58362					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e47a	65					.byte (("ldx.#"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>e47b	10					.byte WordFlags	;wh_Flags
>e47c	03					.byte 3	;wh_CodeLength
>e47d	0d					  .byte LinkDisplacement	; offset to previous nt
=$e47e					XtPtr1 ::= *
=58362					WordListLink ::= Nt0 ; remember the nt of this word for later
.e47e	20 fa e7	jsr $e7fa		jsr asm_1
=3					CodeLen	.var *-XtPtr1
=$e481					Here1 = *	; remember here
>e47c	03					.byte CodeLen	;patch wh_CodeLength
>e481	a2					.byte $a2
>e482	6c 64 78 2e 79			Name0:	.text "ldx.y"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=58375					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e487	25					.byte (("ldx.y"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>e488	10					.byte WordFlags	;wh_Flags
>e489	03					.byte 3	;wh_CodeLength
>e48a	0d					  .byte LinkDisplacement	; offset to previous nt
=$e48b					XtPtr1 ::= *
=58375					WordListLink ::= Nt0 ; remember the nt of this word for later
.e48b	20 0c e8	jsr $e80c		jsr asm_2
=3					CodeLen	.var *-XtPtr1
=$e48e					Here1 = *	; remember here
>e489	03					.byte CodeLen	;patch wh_CodeLength
>e48e	be					.byte $be
>e48f	6c 64 78 2e 7a			Name0:	.text "ldx.z"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=58388					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e494	45					.byte (("ldx.z"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>e495	10					.byte WordFlags	;wh_Flags
>e496	03					.byte 3	;wh_CodeLength
>e497	0d					  .byte LinkDisplacement	; offset to previous nt
=$e498					XtPtr1 ::= *
=58388					WordListLink ::= Nt0 ; remember the nt of this word for later
.e498	20 fa e7	jsr $e7fa		jsr asm_1
=3					CodeLen	.var *-XtPtr1
=$e49b					Here1 = *	; remember here
>e496	03					.byte CodeLen	;patch wh_CodeLength
>e49b	a6					.byte $a6
>e49c	6c 64 78 2e 7a 79		Name0:	.text "ldx.zy"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=58402					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e4a2	26					.byte (("ldx.zy"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=14					LinkDisplacement = Nt0-WordListLink
>e4a3	10					.byte WordFlags	;wh_Flags
>e4a4	03					.byte 3	;wh_CodeLength
>e4a5	0e					  .byte LinkDisplacement	; offset to previous nt
=$e4a6					XtPtr1 ::= *
=58402					WordListLink ::= Nt0 ; remember the nt of this word for later
.e4a6	20 fa e7	jsr $e7fa		jsr asm_1
=3					CodeLen	.var *-XtPtr1
=$e4a9					Here1 = *	; remember here
>e4a4	03					.byte CodeLen	;patch wh_CodeLength
>e4a9	b6					.byte $b6
>e4aa	6c 64 79			Name0:	.text "ldy"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=58413					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e4ad	23					.byte (("ldy"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=11					LinkDisplacement = Nt0-WordListLink
>e4ae	10					.byte WordFlags	;wh_Flags
>e4af	03					.byte 3	;wh_CodeLength
>e4b0	0b					  .byte LinkDisplacement	; offset to previous nt
=$e4b1					XtPtr1 ::= *
=58413					WordListLink ::= Nt0 ; remember the nt of this word for later
.e4b1	20 0c e8	jsr $e80c		jsr asm_2
=3					CodeLen	.var *-XtPtr1
=$e4b4					Here1 = *	; remember here
>e4af	03					.byte CodeLen	;patch wh_CodeLength
>e4b4	ac					.byte $ac
>e4b5	6c 64 79 2e 23			Name0:	.text "ldy.#"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=58426					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e4ba	65					.byte (("ldy.#"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>e4bb	10					.byte WordFlags	;wh_Flags
>e4bc	03					.byte 3	;wh_CodeLength
>e4bd	0d					  .byte LinkDisplacement	; offset to previous nt
=$e4be					XtPtr1 ::= *
=58426					WordListLink ::= Nt0 ; remember the nt of this word for later
.e4be	20 fa e7	jsr $e7fa		jsr asm_1
=3					CodeLen	.var *-XtPtr1
=$e4c1					Here1 = *	; remember here
>e4bc	03					.byte CodeLen	;patch wh_CodeLength
>e4c1	a0					.byte $a0
>e4c2	6c 64 79 2e 78			Name0:	.text "ldy.x"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=58439					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e4c7	05					.byte (("ldy.x"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>e4c8	10					.byte WordFlags	;wh_Flags
>e4c9	03					.byte 3	;wh_CodeLength
>e4ca	0d					  .byte LinkDisplacement	; offset to previous nt
=$e4cb					XtPtr1 ::= *
=58439					WordListLink ::= Nt0 ; remember the nt of this word for later
.e4cb	20 0c e8	jsr $e80c		jsr asm_2
=3					CodeLen	.var *-XtPtr1
=$e4ce					Here1 = *	; remember here
>e4c9	03					.byte CodeLen	;patch wh_CodeLength
>e4ce	bc					.byte $bc
>e4cf	6c 64 79 2e 7a			Name0:	.text "ldy.z"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=58452					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e4d4	45					.byte (("ldy.z"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>e4d5	10					.byte WordFlags	;wh_Flags
>e4d6	03					.byte 3	;wh_CodeLength
>e4d7	0d					  .byte LinkDisplacement	; offset to previous nt
=$e4d8					XtPtr1 ::= *
=58452					WordListLink ::= Nt0 ; remember the nt of this word for later
.e4d8	20 fa e7	jsr $e7fa		jsr asm_1
=3					CodeLen	.var *-XtPtr1
=$e4db					Here1 = *	; remember here
>e4d6	03					.byte CodeLen	;patch wh_CodeLength
>e4db	a4					.byte $a4
>e4dc	6c 64 79 2e 7a 78		Name0:	.text "ldy.zx"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=58466					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e4e2	06					.byte (("ldy.zx"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=14					LinkDisplacement = Nt0-WordListLink
>e4e3	10					.byte WordFlags	;wh_Flags
>e4e4	03					.byte 3	;wh_CodeLength
>e4e5	0e					  .byte LinkDisplacement	; offset to previous nt
=$e4e6					XtPtr1 ::= *
=58466					WordListLink ::= Nt0 ; remember the nt of this word for later
.e4e6	20 fa e7	jsr $e7fa		jsr asm_1
=3					CodeLen	.var *-XtPtr1
=$e4e9					Here1 = *	; remember here
>e4e4	03					.byte CodeLen	;patch wh_CodeLength
>e4e9	b4					.byte $b4
>e4ea	6c 73 72			Name0:	.text "lsr"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=58477					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e4ed	43					.byte (("lsr"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=11					LinkDisplacement = Nt0-WordListLink
>e4ee	10					.byte WordFlags	;wh_Flags
>e4ef	03					.byte 3	;wh_CodeLength
>e4f0	0b					  .byte LinkDisplacement	; offset to previous nt
=$e4f1					XtPtr1 ::= *
=58477					WordListLink ::= Nt0 ; remember the nt of this word for later
.e4f1	20 0c e8	jsr $e80c		jsr asm_2
=3					CodeLen	.var *-XtPtr1
=$e4f4					Here1 = *	; remember here
>e4ef	03					.byte CodeLen	;patch wh_CodeLength
>e4f4	4e					.byte $4e
>e4f5	6c 73 72 2e 61			Name0:	.text "lsr.a"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=58490					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e4fa	25					.byte (("lsr.a"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>e4fb	10					.byte WordFlags	;wh_Flags
>e4fc	03					.byte 3	;wh_CodeLength
>e4fd	0d					  .byte LinkDisplacement	; offset to previous nt
=$e4fe					XtPtr1 ::= *
=58490					WordListLink ::= Nt0 ; remember the nt of this word for later
.e4fe	20 15 e8	jsr $e815		jsr asm_0
=3					CodeLen	.var *-XtPtr1
=$e501					Here1 = *	; remember here
>e4fc	03					.byte CodeLen	;patch wh_CodeLength
>e501	4a					.byte $4a
>e502	6c 73 72 2e 78			Name0:	.text "lsr.x"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=58503					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e507	05					.byte (("lsr.x"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>e508	10					.byte WordFlags	;wh_Flags
>e509	03					.byte 3	;wh_CodeLength
>e50a	0d					  .byte LinkDisplacement	; offset to previous nt
=$e50b					XtPtr1 ::= *
=58503					WordListLink ::= Nt0 ; remember the nt of this word for later
.e50b	20 0c e8	jsr $e80c		jsr asm_2
=3					CodeLen	.var *-XtPtr1
=$e50e					Here1 = *	; remember here
>e509	03					.byte CodeLen	;patch wh_CodeLength
>e50e	5e					.byte $5e
>e50f	6c 73 72 2e 7a			Name0:	.text "lsr.z"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=58516					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e514	45					.byte (("lsr.z"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>e515	10					.byte WordFlags	;wh_Flags
>e516	03					.byte 3	;wh_CodeLength
>e517	0d					  .byte LinkDisplacement	; offset to previous nt
=$e518					XtPtr1 ::= *
=58516					WordListLink ::= Nt0 ; remember the nt of this word for later
.e518	20 fa e7	jsr $e7fa		jsr asm_1
=3					CodeLen	.var *-XtPtr1
=$e51b					Here1 = *	; remember here
>e516	03					.byte CodeLen	;patch wh_CodeLength
>e51b	46					.byte $46
>e51c	6c 73 72 2e 7a 78		Name0:	.text "lsr.zx"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=58530					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e522	06					.byte (("lsr.zx"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=14					LinkDisplacement = Nt0-WordListLink
>e523	10					.byte WordFlags	;wh_Flags
>e524	03					.byte 3	;wh_CodeLength
>e525	0e					  .byte LinkDisplacement	; offset to previous nt
=$e526					XtPtr1 ::= *
=58530					WordListLink ::= Nt0 ; remember the nt of this word for later
.e526	20 fa e7	jsr $e7fa		jsr asm_1
=3					CodeLen	.var *-XtPtr1
=$e529					Here1 = *	; remember here
>e524	03					.byte CodeLen	;patch wh_CodeLength
>e529	56					.byte $56
>e52a	6e 6f 70			Name0:	.text "nop"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=58541					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e52d	03					.byte (("nop"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=11					LinkDisplacement = Nt0-WordListLink
>e52e	10					.byte WordFlags	;wh_Flags
>e52f	03					.byte 3	;wh_CodeLength
>e530	0b					  .byte LinkDisplacement	; offset to previous nt
=$e531					XtPtr1 ::= *
=58541					WordListLink ::= Nt0 ; remember the nt of this word for later
.e531	20 15 e8	jsr $e815		jsr asm_0
=3					CodeLen	.var *-XtPtr1
=$e534					Here1 = *	; remember here
>e52f	03					.byte CodeLen	;patch wh_CodeLength
>e534	ea					.byte $ea
>e535	6f 72 61			Name0:	.text "ora"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=58552					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e538	23					.byte (("ora"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=11					LinkDisplacement = Nt0-WordListLink
>e539	10					.byte WordFlags	;wh_Flags
>e53a	03					.byte 3	;wh_CodeLength
>e53b	0b					  .byte LinkDisplacement	; offset to previous nt
=$e53c					XtPtr1 ::= *
=58552					WordListLink ::= Nt0 ; remember the nt of this word for later
.e53c	20 0c e8	jsr $e80c		jsr asm_2
=3					CodeLen	.var *-XtPtr1
=$e53f					Here1 = *	; remember here
>e53a	03					.byte CodeLen	;patch wh_CodeLength
>e53f	0d					.byte $0d
>e540	6f 72 61 2e 23			Name0:	.text "ora.#"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=58565					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e545	65					.byte (("ora.#"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>e546	10					.byte WordFlags	;wh_Flags
>e547	03					.byte 3	;wh_CodeLength
>e548	0d					  .byte LinkDisplacement	; offset to previous nt
=$e549					XtPtr1 ::= *
=58565					WordListLink ::= Nt0 ; remember the nt of this word for later
.e549	20 fa e7	jsr $e7fa		jsr asm_1
=3					CodeLen	.var *-XtPtr1
=$e54c					Here1 = *	; remember here
>e547	03					.byte CodeLen	;patch wh_CodeLength
>e54c	09					.byte $09
>e54d	6f 72 61 2e 78			Name0:	.text "ora.x"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=58578					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e552	05					.byte (("ora.x"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>e553	10					.byte WordFlags	;wh_Flags
>e554	03					.byte 3	;wh_CodeLength
>e555	0d					  .byte LinkDisplacement	; offset to previous nt
=$e556					XtPtr1 ::= *
=58578					WordListLink ::= Nt0 ; remember the nt of this word for later
.e556	20 0c e8	jsr $e80c		jsr asm_2
=3					CodeLen	.var *-XtPtr1
=$e559					Here1 = *	; remember here
>e554	03					.byte CodeLen	;patch wh_CodeLength
>e559	1d					.byte $1d
>e55a	6f 72 61 2e 79			Name0:	.text "ora.y"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=58591					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e55f	25					.byte (("ora.y"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>e560	10					.byte WordFlags	;wh_Flags
>e561	03					.byte 3	;wh_CodeLength
>e562	0d					  .byte LinkDisplacement	; offset to previous nt
=$e563					XtPtr1 ::= *
=58591					WordListLink ::= Nt0 ; remember the nt of this word for later
.e563	20 0c e8	jsr $e80c		jsr asm_2
=3					CodeLen	.var *-XtPtr1
=$e566					Here1 = *	; remember here
>e561	03					.byte CodeLen	;patch wh_CodeLength
>e566	19					.byte $19
>e567	6f 72 61 2e 7a			Name0:	.text "ora.z"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=58604					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e56c	45					.byte (("ora.z"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>e56d	10					.byte WordFlags	;wh_Flags
>e56e	03					.byte 3	;wh_CodeLength
>e56f	0d					  .byte LinkDisplacement	; offset to previous nt
=$e570					XtPtr1 ::= *
=58604					WordListLink ::= Nt0 ; remember the nt of this word for later
.e570	20 fa e7	jsr $e7fa		jsr asm_1
=3					CodeLen	.var *-XtPtr1
=$e573					Here1 = *	; remember here
>e56e	03					.byte CodeLen	;patch wh_CodeLength
>e573	05					.byte $05
>e574	6f 72 61 2e 7a 69 79		Name0:	.text "ora.ziy"	;  name of word as a string, ending at wh_NameLastChar
=7					NameLength = *-Name0
=58619					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e57b	27					.byte (("ora.ziy"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=15					LinkDisplacement = Nt0-WordListLink
>e57c	10					.byte WordFlags	;wh_Flags
>e57d	03					.byte 3	;wh_CodeLength
>e57e	0f					  .byte LinkDisplacement	; offset to previous nt
=$e57f					XtPtr1 ::= *
=58619					WordListLink ::= Nt0 ; remember the nt of this word for later
.e57f	20 fa e7	jsr $e7fa		jsr asm_1
=3					CodeLen	.var *-XtPtr1
=$e582					Here1 = *	; remember here
>e57d	03					.byte CodeLen	;patch wh_CodeLength
>e582	11					.byte $11
>e583	6f 72 61 2e 7a 78		Name0:	.text "ora.zx"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=58633					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e589	06					.byte (("ora.zx"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=14					LinkDisplacement = Nt0-WordListLink
>e58a	10					.byte WordFlags	;wh_Flags
>e58b	03					.byte 3	;wh_CodeLength
>e58c	0e					  .byte LinkDisplacement	; offset to previous nt
=$e58d					XtPtr1 ::= *
=58633					WordListLink ::= Nt0 ; remember the nt of this word for later
.e58d	20 fa e7	jsr $e7fa		jsr asm_1
=3					CodeLen	.var *-XtPtr1
=$e590					Here1 = *	; remember here
>e58b	03					.byte CodeLen	;patch wh_CodeLength
>e590	15					.byte $15
>e591	6f 72 61 2e 7a 78 69		Name0:	.text "ora.zxi"	;  name of word as a string, ending at wh_NameLastChar
=7					NameLength = *-Name0
=58648					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e598	27					.byte (("ora.zxi"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=15					LinkDisplacement = Nt0-WordListLink
>e599	10					.byte WordFlags	;wh_Flags
>e59a	03					.byte 3	;wh_CodeLength
>e59b	0f					  .byte LinkDisplacement	; offset to previous nt
=$e59c					XtPtr1 ::= *
=58648					WordListLink ::= Nt0 ; remember the nt of this word for later
.e59c	20 fa e7	jsr $e7fa		jsr asm_1
=3					CodeLen	.var *-XtPtr1
=$e59f					Here1 = *	; remember here
>e59a	03					.byte CodeLen	;patch wh_CodeLength
>e59f	01					.byte $01
>e5a0	70 68 61			Name0:	.text "pha"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=58659					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e5a3	23					.byte (("pha"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=11					LinkDisplacement = Nt0-WordListLink
>e5a4	10					.byte WordFlags	;wh_Flags
>e5a5	03					.byte 3	;wh_CodeLength
>e5a6	0b					  .byte LinkDisplacement	; offset to previous nt
=$e5a7					XtPtr1 ::= *
=58659					WordListLink ::= Nt0 ; remember the nt of this word for later
.e5a7	20 15 e8	jsr $e815		jsr asm_0
=3					CodeLen	.var *-XtPtr1
=$e5aa					Here1 = *	; remember here
>e5a5	03					.byte CodeLen	;patch wh_CodeLength
>e5aa	48					.byte $48
>e5ab	70 68 70			Name0:	.text "php"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=58670					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e5ae	03					.byte (("php"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=11					LinkDisplacement = Nt0-WordListLink
>e5af	10					.byte WordFlags	;wh_Flags
>e5b0	03					.byte 3	;wh_CodeLength
>e5b1	0b					  .byte LinkDisplacement	; offset to previous nt
=$e5b2					XtPtr1 ::= *
=58670					WordListLink ::= Nt0 ; remember the nt of this word for later
.e5b2	20 15 e8	jsr $e815		jsr asm_0
=3					CodeLen	.var *-XtPtr1
=$e5b5					Here1 = *	; remember here
>e5b0	03					.byte CodeLen	;patch wh_CodeLength
>e5b5	08					.byte $08
>e5b6	70 6c 61			Name0:	.text "pla"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=58681					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e5b9	23					.byte (("pla"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=11					LinkDisplacement = Nt0-WordListLink
>e5ba	10					.byte WordFlags	;wh_Flags
>e5bb	03					.byte 3	;wh_CodeLength
>e5bc	0b					  .byte LinkDisplacement	; offset to previous nt
=$e5bd					XtPtr1 ::= *
=58681					WordListLink ::= Nt0 ; remember the nt of this word for later
.e5bd	20 15 e8	jsr $e815		jsr asm_0
=3					CodeLen	.var *-XtPtr1
=$e5c0					Here1 = *	; remember here
>e5bb	03					.byte CodeLen	;patch wh_CodeLength
>e5c0	68					.byte $68
>e5c1	70 6c 70			Name0:	.text "plp"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=58692					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e5c4	03					.byte (("plp"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=11					LinkDisplacement = Nt0-WordListLink
>e5c5	10					.byte WordFlags	;wh_Flags
>e5c6	03					.byte 3	;wh_CodeLength
>e5c7	0b					  .byte LinkDisplacement	; offset to previous nt
=$e5c8					XtPtr1 ::= *
=58692					WordListLink ::= Nt0 ; remember the nt of this word for later
.e5c8	20 15 e8	jsr $e815		jsr asm_0
=3					CodeLen	.var *-XtPtr1
=$e5cb					Here1 = *	; remember here
>e5c6	03					.byte CodeLen	;patch wh_CodeLength
>e5cb	28					.byte $28
>e5cc	72 6f 6c			Name0:	.text "rol"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=58703					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e5cf	83					.byte (("rol"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=11					LinkDisplacement = Nt0-WordListLink
>e5d0	10					.byte WordFlags	;wh_Flags
>e5d1	03					.byte 3	;wh_CodeLength
>e5d2	0b					  .byte LinkDisplacement	; offset to previous nt
=$e5d3					XtPtr1 ::= *
=58703					WordListLink ::= Nt0 ; remember the nt of this word for later
.e5d3	20 0c e8	jsr $e80c		jsr asm_2
=3					CodeLen	.var *-XtPtr1
=$e5d6					Here1 = *	; remember here
>e5d1	03					.byte CodeLen	;patch wh_CodeLength
>e5d6	2e					.byte $2e
>e5d7	72 6f 6c 2e 61			Name0:	.text "rol.a"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=58716					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e5dc	25					.byte (("rol.a"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>e5dd	10					.byte WordFlags	;wh_Flags
>e5de	03					.byte 3	;wh_CodeLength
>e5df	0d					  .byte LinkDisplacement	; offset to previous nt
=$e5e0					XtPtr1 ::= *
=58716					WordListLink ::= Nt0 ; remember the nt of this word for later
.e5e0	20 15 e8	jsr $e815		jsr asm_0
=3					CodeLen	.var *-XtPtr1
=$e5e3					Here1 = *	; remember here
>e5de	03					.byte CodeLen	;patch wh_CodeLength
>e5e3	2a					.byte $2a
>e5e4	72 6f 6c 2e 78			Name0:	.text "rol.x"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=58729					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e5e9	05					.byte (("rol.x"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>e5ea	10					.byte WordFlags	;wh_Flags
>e5eb	03					.byte 3	;wh_CodeLength
>e5ec	0d					  .byte LinkDisplacement	; offset to previous nt
=$e5ed					XtPtr1 ::= *
=58729					WordListLink ::= Nt0 ; remember the nt of this word for later
.e5ed	20 0c e8	jsr $e80c		jsr asm_2
=3					CodeLen	.var *-XtPtr1
=$e5f0					Here1 = *	; remember here
>e5eb	03					.byte CodeLen	;patch wh_CodeLength
>e5f0	3e					.byte $3e
>e5f1	72 6f 6c 2e 7a			Name0:	.text "rol.z"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=58742					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e5f6	45					.byte (("rol.z"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>e5f7	10					.byte WordFlags	;wh_Flags
>e5f8	03					.byte 3	;wh_CodeLength
>e5f9	0d					  .byte LinkDisplacement	; offset to previous nt
=$e5fa					XtPtr1 ::= *
=58742					WordListLink ::= Nt0 ; remember the nt of this word for later
.e5fa	20 fa e7	jsr $e7fa		jsr asm_1
=3					CodeLen	.var *-XtPtr1
=$e5fd					Here1 = *	; remember here
>e5f8	03					.byte CodeLen	;patch wh_CodeLength
>e5fd	26					.byte $26
>e5fe	72 6f 6c 2e 7a 78		Name0:	.text "rol.zx"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=58756					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e604	06					.byte (("rol.zx"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=14					LinkDisplacement = Nt0-WordListLink
>e605	10					.byte WordFlags	;wh_Flags
>e606	03					.byte 3	;wh_CodeLength
>e607	0e					  .byte LinkDisplacement	; offset to previous nt
=$e608					XtPtr1 ::= *
=58756					WordListLink ::= Nt0 ; remember the nt of this word for later
.e608	20 fa e7	jsr $e7fa		jsr asm_1
=3					CodeLen	.var *-XtPtr1
=$e60b					Here1 = *	; remember here
>e606	03					.byte CodeLen	;patch wh_CodeLength
>e60b	36					.byte $36
>e60c	72 6f 72			Name0:	.text "ror"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=58767					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e60f	43					.byte (("ror"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=11					LinkDisplacement = Nt0-WordListLink
>e610	10					.byte WordFlags	;wh_Flags
>e611	03					.byte 3	;wh_CodeLength
>e612	0b					  .byte LinkDisplacement	; offset to previous nt
=$e613					XtPtr1 ::= *
=58767					WordListLink ::= Nt0 ; remember the nt of this word for later
.e613	20 0c e8	jsr $e80c		jsr asm_2
=3					CodeLen	.var *-XtPtr1
=$e616					Here1 = *	; remember here
>e611	03					.byte CodeLen	;patch wh_CodeLength
>e616	6e					.byte $6e
>e617	72 6f 72 2e 61			Name0:	.text "ror.a"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=58780					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e61c	25					.byte (("ror.a"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>e61d	10					.byte WordFlags	;wh_Flags
>e61e	03					.byte 3	;wh_CodeLength
>e61f	0d					  .byte LinkDisplacement	; offset to previous nt
=$e620					XtPtr1 ::= *
=58780					WordListLink ::= Nt0 ; remember the nt of this word for later
.e620	20 15 e8	jsr $e815		jsr asm_0
=3					CodeLen	.var *-XtPtr1
=$e623					Here1 = *	; remember here
>e61e	03					.byte CodeLen	;patch wh_CodeLength
>e623	6a					.byte $6a
>e624	72 6f 72 2e 78			Name0:	.text "ror.x"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=58793					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e629	05					.byte (("ror.x"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>e62a	10					.byte WordFlags	;wh_Flags
>e62b	03					.byte 3	;wh_CodeLength
>e62c	0d					  .byte LinkDisplacement	; offset to previous nt
=$e62d					XtPtr1 ::= *
=58793					WordListLink ::= Nt0 ; remember the nt of this word for later
.e62d	20 0c e8	jsr $e80c		jsr asm_2
=3					CodeLen	.var *-XtPtr1
=$e630					Here1 = *	; remember here
>e62b	03					.byte CodeLen	;patch wh_CodeLength
>e630	7e					.byte $7e
>e631	72 6f 72 2e 7a			Name0:	.text "ror.z"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=58806					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e636	45					.byte (("ror.z"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>e637	10					.byte WordFlags	;wh_Flags
>e638	03					.byte 3	;wh_CodeLength
>e639	0d					  .byte LinkDisplacement	; offset to previous nt
=$e63a					XtPtr1 ::= *
=58806					WordListLink ::= Nt0 ; remember the nt of this word for later
.e63a	20 fa e7	jsr $e7fa		jsr asm_1
=3					CodeLen	.var *-XtPtr1
=$e63d					Here1 = *	; remember here
>e638	03					.byte CodeLen	;patch wh_CodeLength
>e63d	66					.byte $66
>e63e	72 6f 72 2e 7a 78		Name0:	.text "ror.zx"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=58820					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e644	06					.byte (("ror.zx"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=14					LinkDisplacement = Nt0-WordListLink
>e645	10					.byte WordFlags	;wh_Flags
>e646	03					.byte 3	;wh_CodeLength
>e647	0e					  .byte LinkDisplacement	; offset to previous nt
=$e648					XtPtr1 ::= *
=58820					WordListLink ::= Nt0 ; remember the nt of this word for later
.e648	20 fa e7	jsr $e7fa		jsr asm_1
=3					CodeLen	.var *-XtPtr1
=$e64b					Here1 = *	; remember here
>e646	03					.byte CodeLen	;patch wh_CodeLength
>e64b	76					.byte $76
>e64c	72 74 69			Name0:	.text "rti"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=58831					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e64f	23					.byte (("rti"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=11					LinkDisplacement = Nt0-WordListLink
>e650	10					.byte WordFlags	;wh_Flags
>e651	03					.byte 3	;wh_CodeLength
>e652	0b					  .byte LinkDisplacement	; offset to previous nt
=$e653					XtPtr1 ::= *
=58831					WordListLink ::= Nt0 ; remember the nt of this word for later
.e653	20 15 e8	jsr $e815		jsr asm_0
=3					CodeLen	.var *-XtPtr1
=$e656					Here1 = *	; remember here
>e651	03					.byte CodeLen	;patch wh_CodeLength
>e656	40					.byte $40
>e657	72 74 73			Name0:	.text "rts"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=58842					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e65a	63					.byte (("rts"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=11					LinkDisplacement = Nt0-WordListLink
>e65b	10					.byte WordFlags	;wh_Flags
>e65c	03					.byte 3	;wh_CodeLength
>e65d	0b					  .byte LinkDisplacement	; offset to previous nt
=$e65e					XtPtr1 ::= *
=58842					WordListLink ::= Nt0 ; remember the nt of this word for later
.e65e	20 15 e8	jsr $e815		jsr asm_0
=3					CodeLen	.var *-XtPtr1
=$e661					Here1 = *	; remember here
>e65c	03					.byte CodeLen	;patch wh_CodeLength
>e661	60					.byte $60
>e662	73 62 63			Name0:	.text "sbc"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=58853					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e665	63					.byte (("sbc"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=11					LinkDisplacement = Nt0-WordListLink
>e666	10					.byte WordFlags	;wh_Flags
>e667	03					.byte 3	;wh_CodeLength
>e668	0b					  .byte LinkDisplacement	; offset to previous nt
=$e669					XtPtr1 ::= *
=58853					WordListLink ::= Nt0 ; remember the nt of this word for later
.e669	20 0c e8	jsr $e80c		jsr asm_2
=3					CodeLen	.var *-XtPtr1
=$e66c					Here1 = *	; remember here
>e667	03					.byte CodeLen	;patch wh_CodeLength
>e66c	ed					.byte $ed
>e66d	73 62 63 2e 23			Name0:	.text "sbc.#"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=58866					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e672	65					.byte (("sbc.#"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>e673	10					.byte WordFlags	;wh_Flags
>e674	03					.byte 3	;wh_CodeLength
>e675	0d					  .byte LinkDisplacement	; offset to previous nt
=$e676					XtPtr1 ::= *
=58866					WordListLink ::= Nt0 ; remember the nt of this word for later
.e676	20 fa e7	jsr $e7fa		jsr asm_1
=3					CodeLen	.var *-XtPtr1
=$e679					Here1 = *	; remember here
>e674	03					.byte CodeLen	;patch wh_CodeLength
>e679	e9					.byte $e9
>e67a	73 62 63 2e 78			Name0:	.text "sbc.x"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=58879					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e67f	05					.byte (("sbc.x"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>e680	10					.byte WordFlags	;wh_Flags
>e681	03					.byte 3	;wh_CodeLength
>e682	0d					  .byte LinkDisplacement	; offset to previous nt
=$e683					XtPtr1 ::= *
=58879					WordListLink ::= Nt0 ; remember the nt of this word for later
.e683	20 0c e8	jsr $e80c		jsr asm_2
=3					CodeLen	.var *-XtPtr1
=$e686					Here1 = *	; remember here
>e681	03					.byte CodeLen	;patch wh_CodeLength
>e686	fd					.byte $fd
>e687	73 62 63 2e 79			Name0:	.text "sbc.y"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=58892					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e68c	25					.byte (("sbc.y"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>e68d	10					.byte WordFlags	;wh_Flags
>e68e	03					.byte 3	;wh_CodeLength
>e68f	0d					  .byte LinkDisplacement	; offset to previous nt
=$e690					XtPtr1 ::= *
=58892					WordListLink ::= Nt0 ; remember the nt of this word for later
.e690	20 0c e8	jsr $e80c		jsr asm_2
=3					CodeLen	.var *-XtPtr1
=$e693					Here1 = *	; remember here
>e68e	03					.byte CodeLen	;patch wh_CodeLength
>e693	f9					.byte $f9
>e694	73 62 63 2e 7a			Name0:	.text "sbc.z"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=58905					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e699	45					.byte (("sbc.z"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>e69a	10					.byte WordFlags	;wh_Flags
>e69b	03					.byte 3	;wh_CodeLength
>e69c	0d					  .byte LinkDisplacement	; offset to previous nt
=$e69d					XtPtr1 ::= *
=58905					WordListLink ::= Nt0 ; remember the nt of this word for later
.e69d	20 fa e7	jsr $e7fa		jsr asm_1
=3					CodeLen	.var *-XtPtr1
=$e6a0					Here1 = *	; remember here
>e69b	03					.byte CodeLen	;patch wh_CodeLength
>e6a0	e5					.byte $e5
>e6a1	73 62 63 2e 7a 69 79		Name0:	.text "sbc.ziy"	;  name of word as a string, ending at wh_NameLastChar
=7					NameLength = *-Name0
=58920					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e6a8	27					.byte (("sbc.ziy"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=15					LinkDisplacement = Nt0-WordListLink
>e6a9	10					.byte WordFlags	;wh_Flags
>e6aa	03					.byte 3	;wh_CodeLength
>e6ab	0f					  .byte LinkDisplacement	; offset to previous nt
=$e6ac					XtPtr1 ::= *
=58920					WordListLink ::= Nt0 ; remember the nt of this word for later
.e6ac	20 fa e7	jsr $e7fa		jsr asm_1
=3					CodeLen	.var *-XtPtr1
=$e6af					Here1 = *	; remember here
>e6aa	03					.byte CodeLen	;patch wh_CodeLength
>e6af	f1					.byte $f1
>e6b0	73 62 63 2e 7a 78		Name0:	.text "sbc.zx"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=58934					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e6b6	06					.byte (("sbc.zx"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=14					LinkDisplacement = Nt0-WordListLink
>e6b7	10					.byte WordFlags	;wh_Flags
>e6b8	03					.byte 3	;wh_CodeLength
>e6b9	0e					  .byte LinkDisplacement	; offset to previous nt
=$e6ba					XtPtr1 ::= *
=58934					WordListLink ::= Nt0 ; remember the nt of this word for later
.e6ba	20 fa e7	jsr $e7fa		jsr asm_1
=3					CodeLen	.var *-XtPtr1
=$e6bd					Here1 = *	; remember here
>e6b8	03					.byte CodeLen	;patch wh_CodeLength
>e6bd	f5					.byte $f5
>e6be	73 62 63 2e 7a 78 69		Name0:	.text "sbc.zxi"	;  name of word as a string, ending at wh_NameLastChar
=7					NameLength = *-Name0
=58949					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e6c5	27					.byte (("sbc.zxi"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=15					LinkDisplacement = Nt0-WordListLink
>e6c6	10					.byte WordFlags	;wh_Flags
>e6c7	03					.byte 3	;wh_CodeLength
>e6c8	0f					  .byte LinkDisplacement	; offset to previous nt
=$e6c9					XtPtr1 ::= *
=58949					WordListLink ::= Nt0 ; remember the nt of this word for later
.e6c9	20 fa e7	jsr $e7fa		jsr asm_1
=3					CodeLen	.var *-XtPtr1
=$e6cc					Here1 = *	; remember here
>e6c7	03					.byte CodeLen	;patch wh_CodeLength
>e6cc	e1					.byte $e1
>e6cd	73 65 63			Name0:	.text "sec"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=58960					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e6d0	63					.byte (("sec"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=11					LinkDisplacement = Nt0-WordListLink
>e6d1	10					.byte WordFlags	;wh_Flags
>e6d2	03					.byte 3	;wh_CodeLength
>e6d3	0b					  .byte LinkDisplacement	; offset to previous nt
=$e6d4					XtPtr1 ::= *
=58960					WordListLink ::= Nt0 ; remember the nt of this word for later
.e6d4	20 15 e8	jsr $e815		jsr asm_0
=3					CodeLen	.var *-XtPtr1
=$e6d7					Here1 = *	; remember here
>e6d2	03					.byte CodeLen	;patch wh_CodeLength
>e6d7	38					.byte $38
>e6d8	73 65 64			Name0:	.text "sed"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=58971					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e6db	83					.byte (("sed"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=11					LinkDisplacement = Nt0-WordListLink
>e6dc	10					.byte WordFlags	;wh_Flags
>e6dd	03					.byte 3	;wh_CodeLength
>e6de	0b					  .byte LinkDisplacement	; offset to previous nt
=$e6df					XtPtr1 ::= *
=58971					WordListLink ::= Nt0 ; remember the nt of this word for later
.e6df	20 15 e8	jsr $e815		jsr asm_0
=3					CodeLen	.var *-XtPtr1
=$e6e2					Here1 = *	; remember here
>e6dd	03					.byte CodeLen	;patch wh_CodeLength
>e6e2	f8					.byte $f8
>e6e3	73 65 69			Name0:	.text "sei"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=58982					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e6e6	23					.byte (("sei"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=11					LinkDisplacement = Nt0-WordListLink
>e6e7	10					.byte WordFlags	;wh_Flags
>e6e8	03					.byte 3	;wh_CodeLength
>e6e9	0b					  .byte LinkDisplacement	; offset to previous nt
=$e6ea					XtPtr1 ::= *
=58982					WordListLink ::= Nt0 ; remember the nt of this word for later
.e6ea	20 15 e8	jsr $e815		jsr asm_0
=3					CodeLen	.var *-XtPtr1
=$e6ed					Here1 = *	; remember here
>e6e8	03					.byte CodeLen	;patch wh_CodeLength
>e6ed	78					.byte $78
>e6ee	73 74 61			Name0:	.text "sta"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=58993					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e6f1	23					.byte (("sta"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=11					LinkDisplacement = Nt0-WordListLink
>e6f2	10					.byte WordFlags	;wh_Flags
>e6f3	03					.byte 3	;wh_CodeLength
>e6f4	0b					  .byte LinkDisplacement	; offset to previous nt
=$e6f5					XtPtr1 ::= *
=58993					WordListLink ::= Nt0 ; remember the nt of this word for later
.e6f5	20 0c e8	jsr $e80c		jsr asm_2
=3					CodeLen	.var *-XtPtr1
=$e6f8					Here1 = *	; remember here
>e6f3	03					.byte CodeLen	;patch wh_CodeLength
>e6f8	8d					.byte $8d
>e6f9	73 74 61 2e 78			Name0:	.text "sta.x"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=59006					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e6fe	05					.byte (("sta.x"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>e6ff	10					.byte WordFlags	;wh_Flags
>e700	03					.byte 3	;wh_CodeLength
>e701	0d					  .byte LinkDisplacement	; offset to previous nt
=$e702					XtPtr1 ::= *
=59006					WordListLink ::= Nt0 ; remember the nt of this word for later
.e702	20 0c e8	jsr $e80c		jsr asm_2
=3					CodeLen	.var *-XtPtr1
=$e705					Here1 = *	; remember here
>e700	03					.byte CodeLen	;patch wh_CodeLength
>e705	9d					.byte $9d
>e706	73 74 61 2e 79			Name0:	.text "sta.y"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=59019					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e70b	25					.byte (("sta.y"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>e70c	10					.byte WordFlags	;wh_Flags
>e70d	03					.byte 3	;wh_CodeLength
>e70e	0d					  .byte LinkDisplacement	; offset to previous nt
=$e70f					XtPtr1 ::= *
=59019					WordListLink ::= Nt0 ; remember the nt of this word for later
.e70f	20 0c e8	jsr $e80c		jsr asm_2
=3					CodeLen	.var *-XtPtr1
=$e712					Here1 = *	; remember here
>e70d	03					.byte CodeLen	;patch wh_CodeLength
>e712	99					.byte $99
>e713	73 74 61 2e 7a			Name0:	.text "sta.z"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=59032					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e718	45					.byte (("sta.z"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>e719	10					.byte WordFlags	;wh_Flags
>e71a	03					.byte 3	;wh_CodeLength
>e71b	0d					  .byte LinkDisplacement	; offset to previous nt
=$e71c					XtPtr1 ::= *
=59032					WordListLink ::= Nt0 ; remember the nt of this word for later
.e71c	20 fa e7	jsr $e7fa		jsr asm_1
=3					CodeLen	.var *-XtPtr1
=$e71f					Here1 = *	; remember here
>e71a	03					.byte CodeLen	;patch wh_CodeLength
>e71f	85					.byte $85
>e720	73 74 61 2e 7a 69 79		Name0:	.text "sta.ziy"	;  name of word as a string, ending at wh_NameLastChar
=7					NameLength = *-Name0
=59047					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e727	27					.byte (("sta.ziy"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=15					LinkDisplacement = Nt0-WordListLink
>e728	10					.byte WordFlags	;wh_Flags
>e729	03					.byte 3	;wh_CodeLength
>e72a	0f					  .byte LinkDisplacement	; offset to previous nt
=$e72b					XtPtr1 ::= *
=59047					WordListLink ::= Nt0 ; remember the nt of this word for later
.e72b	20 fa e7	jsr $e7fa		jsr asm_1
=3					CodeLen	.var *-XtPtr1
=$e72e					Here1 = *	; remember here
>e729	03					.byte CodeLen	;patch wh_CodeLength
>e72e	91					.byte $91
>e72f	73 74 61 2e 7a 78		Name0:	.text "sta.zx"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=59061					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e735	06					.byte (("sta.zx"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=14					LinkDisplacement = Nt0-WordListLink
>e736	10					.byte WordFlags	;wh_Flags
>e737	03					.byte 3	;wh_CodeLength
>e738	0e					  .byte LinkDisplacement	; offset to previous nt
=$e739					XtPtr1 ::= *
=59061					WordListLink ::= Nt0 ; remember the nt of this word for later
.e739	20 fa e7	jsr $e7fa		jsr asm_1
=3					CodeLen	.var *-XtPtr1
=$e73c					Here1 = *	; remember here
>e737	03					.byte CodeLen	;patch wh_CodeLength
>e73c	95					.byte $95
>e73d	73 74 61 2e 7a 78 69		Name0:	.text "sta.zxi"	;  name of word as a string, ending at wh_NameLastChar
=7					NameLength = *-Name0
=59076					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e744	27					.byte (("sta.zxi"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=15					LinkDisplacement = Nt0-WordListLink
>e745	10					.byte WordFlags	;wh_Flags
>e746	03					.byte 3	;wh_CodeLength
>e747	0f					  .byte LinkDisplacement	; offset to previous nt
=$e748					XtPtr1 ::= *
=59076					WordListLink ::= Nt0 ; remember the nt of this word for later
.e748	20 fa e7	jsr $e7fa		jsr asm_1
=3					CodeLen	.var *-XtPtr1
=$e74b					Here1 = *	; remember here
>e746	03					.byte CodeLen	;patch wh_CodeLength
>e74b	81					.byte $81
>e74c	73 74 78			Name0:	.text "stx"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=59087					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e74f	03					.byte (("stx"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=11					LinkDisplacement = Nt0-WordListLink
>e750	10					.byte WordFlags	;wh_Flags
>e751	03					.byte 3	;wh_CodeLength
>e752	0b					  .byte LinkDisplacement	; offset to previous nt
=$e753					XtPtr1 ::= *
=59087					WordListLink ::= Nt0 ; remember the nt of this word for later
.e753	20 0c e8	jsr $e80c		jsr asm_2
=3					CodeLen	.var *-XtPtr1
=$e756					Here1 = *	; remember here
>e751	03					.byte CodeLen	;patch wh_CodeLength
>e756	8e					.byte $8e
>e757	73 74 78 2e 7a			Name0:	.text "stx.z"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=59100					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e75c	45					.byte (("stx.z"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>e75d	10					.byte WordFlags	;wh_Flags
>e75e	03					.byte 3	;wh_CodeLength
>e75f	0d					  .byte LinkDisplacement	; offset to previous nt
=$e760					XtPtr1 ::= *
=59100					WordListLink ::= Nt0 ; remember the nt of this word for later
.e760	20 fa e7	jsr $e7fa		jsr asm_1
=3					CodeLen	.var *-XtPtr1
=$e763					Here1 = *	; remember here
>e75e	03					.byte CodeLen	;patch wh_CodeLength
>e763	86					.byte $86
>e764	73 74 78 2e 7a 79		Name0:	.text "stx.zy"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=59114					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e76a	26					.byte (("stx.zy"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=14					LinkDisplacement = Nt0-WordListLink
>e76b	10					.byte WordFlags	;wh_Flags
>e76c	03					.byte 3	;wh_CodeLength
>e76d	0e					  .byte LinkDisplacement	; offset to previous nt
=$e76e					XtPtr1 ::= *
=59114					WordListLink ::= Nt0 ; remember the nt of this word for later
.e76e	20 fa e7	jsr $e7fa		jsr asm_1
=3					CodeLen	.var *-XtPtr1
=$e771					Here1 = *	; remember here
>e76c	03					.byte CodeLen	;patch wh_CodeLength
>e771	96					.byte $96
>e772	73 74 79			Name0:	.text "sty"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=59125					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e775	23					.byte (("sty"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=11					LinkDisplacement = Nt0-WordListLink
>e776	10					.byte WordFlags	;wh_Flags
>e777	03					.byte 3	;wh_CodeLength
>e778	0b					  .byte LinkDisplacement	; offset to previous nt
=$e779					XtPtr1 ::= *
=59125					WordListLink ::= Nt0 ; remember the nt of this word for later
.e779	20 0c e8	jsr $e80c		jsr asm_2
=3					CodeLen	.var *-XtPtr1
=$e77c					Here1 = *	; remember here
>e777	03					.byte CodeLen	;patch wh_CodeLength
>e77c	8c					.byte $8c
>e77d	73 74 79 2e 7a			Name0:	.text "sty.z"	;  name of word as a string, ending at wh_NameLastChar
=5					NameLength = *-Name0
=59138					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e782	45					.byte (("sty.z"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=13					LinkDisplacement = Nt0-WordListLink
>e783	10					.byte WordFlags	;wh_Flags
>e784	03					.byte 3	;wh_CodeLength
>e785	0d					  .byte LinkDisplacement	; offset to previous nt
=$e786					XtPtr1 ::= *
=59138					WordListLink ::= Nt0 ; remember the nt of this word for later
.e786	20 fa e7	jsr $e7fa		jsr asm_1
=3					CodeLen	.var *-XtPtr1
=$e789					Here1 = *	; remember here
>e784	03					.byte CodeLen	;patch wh_CodeLength
>e789	84					.byte $84
>e78a	73 74 79 2e 7a 78		Name0:	.text "sty.zx"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=59152					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e790	06					.byte (("sty.zx"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=14					LinkDisplacement = Nt0-WordListLink
>e791	10					.byte WordFlags	;wh_Flags
>e792	03					.byte 3	;wh_CodeLength
>e793	0e					  .byte LinkDisplacement	; offset to previous nt
=$e794					XtPtr1 ::= *
=59152					WordListLink ::= Nt0 ; remember the nt of this word for later
.e794	20 fa e7	jsr $e7fa		jsr asm_1
=3					CodeLen	.var *-XtPtr1
=$e797					Here1 = *	; remember here
>e792	03					.byte CodeLen	;patch wh_CodeLength
>e797	94					.byte $94
>e798	74 61 78			Name0:	.text "tax"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=59163					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e79b	03					.byte (("tax"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=11					LinkDisplacement = Nt0-WordListLink
>e79c	10					.byte WordFlags	;wh_Flags
>e79d	03					.byte 3	;wh_CodeLength
>e79e	0b					  .byte LinkDisplacement	; offset to previous nt
=$e79f					XtPtr1 ::= *
=59163					WordListLink ::= Nt0 ; remember the nt of this word for later
.e79f	20 15 e8	jsr $e815		jsr asm_0
=3					CodeLen	.var *-XtPtr1
=$e7a2					Here1 = *	; remember here
>e79d	03					.byte CodeLen	;patch wh_CodeLength
>e7a2	aa					.byte $aa
>e7a3	74 61 79			Name0:	.text "tay"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=59174					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e7a6	23					.byte (("tay"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=11					LinkDisplacement = Nt0-WordListLink
>e7a7	10					.byte WordFlags	;wh_Flags
>e7a8	03					.byte 3	;wh_CodeLength
>e7a9	0b					  .byte LinkDisplacement	; offset to previous nt
=$e7aa					XtPtr1 ::= *
=59174					WordListLink ::= Nt0 ; remember the nt of this word for later
.e7aa	20 15 e8	jsr $e815		jsr asm_0
=3					CodeLen	.var *-XtPtr1
=$e7ad					Here1 = *	; remember here
>e7a8	03					.byte CodeLen	;patch wh_CodeLength
>e7ad	a8					.byte $a8
>e7ae	74 73 78			Name0:	.text "tsx"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=59185					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e7b1	03					.byte (("tsx"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=11					LinkDisplacement = Nt0-WordListLink
>e7b2	10					.byte WordFlags	;wh_Flags
>e7b3	03					.byte 3	;wh_CodeLength
>e7b4	0b					  .byte LinkDisplacement	; offset to previous nt
=$e7b5					XtPtr1 ::= *
=59185					WordListLink ::= Nt0 ; remember the nt of this word for later
.e7b5	20 15 e8	jsr $e815		jsr asm_0
=3					CodeLen	.var *-XtPtr1
=$e7b8					Here1 = *	; remember here
>e7b3	03					.byte CodeLen	;patch wh_CodeLength
>e7b8	ba					.byte $BA
>e7b9	74 78 61			Name0:	.text "txa"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=59196					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e7bc	23					.byte (("txa"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=11					LinkDisplacement = Nt0-WordListLink
>e7bd	10					.byte WordFlags	;wh_Flags
>e7be	03					.byte 3	;wh_CodeLength
>e7bf	0b					  .byte LinkDisplacement	; offset to previous nt
=$e7c0					XtPtr1 ::= *
=59196					WordListLink ::= Nt0 ; remember the nt of this word for later
.e7c0	20 15 e8	jsr $e815		jsr asm_0
=3					CodeLen	.var *-XtPtr1
=$e7c3					Here1 = *	; remember here
>e7be	03					.byte CodeLen	;patch wh_CodeLength
>e7c3	8a					.byte $8a
>e7c4	74 78 73			Name0:	.text "txs"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=59207					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e7c7	63					.byte (("txs"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=11					LinkDisplacement = Nt0-WordListLink
>e7c8	10					.byte WordFlags	;wh_Flags
>e7c9	03					.byte 3	;wh_CodeLength
>e7ca	0b					  .byte LinkDisplacement	; offset to previous nt
=$e7cb					XtPtr1 ::= *
=59207					WordListLink ::= Nt0 ; remember the nt of this word for later
.e7cb	20 15 e8	jsr $e815		jsr asm_0
=3					CodeLen	.var *-XtPtr1
=$e7ce					Here1 = *	; remember here
>e7c9	03					.byte CodeLen	;patch wh_CodeLength
>e7ce	9a					.byte $9a
>e7cf	74 79 61			Name0:	.text "tya"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=59218					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e7d2	23					.byte (("tya"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=11					LinkDisplacement = Nt0-WordListLink
>e7d3	10					.byte WordFlags	;wh_Flags
>e7d4	03					.byte 3	;wh_CodeLength
>e7d5	0b					  .byte LinkDisplacement	; offset to previous nt
=$e7d6					XtPtr1 ::= *
=59218					WordListLink ::= Nt0 ; remember the nt of this word for later
.e7d6	20 15 e8	jsr $e815		jsr asm_0
=3					CodeLen	.var *-XtPtr1
=$e7d9					Here1 = *	; remember here
>e7d4	03					.byte CodeLen	;patch wh_CodeLength
>e7d9	98					.byte $98
=59218					asm_table = WordListLink ; head of instruction word list for disassembler
.e7da					asm_r:
.e7da	68		pla			pla		; pop RTS addr
.e7db	a8		tay			tay
.e7dc	68		pla			pla
.e7dd	20 18 e8	jsr $e818		jsr asm_op	; compile opcode
.e7e0	b5 25		lda $25,x		lda DStack+1,x	; check range
.e7e2	f0 09		beq $e7ed		beq _plus
.e7e4	c9 ff		cmp #$ff		cmp #$ff
.e7e6	f0 0b		beq $e7f3		beq _minus
.e7e8	a9 f5		lda #$f5	_err:	lda #$100+err_OutOfRange
.e7ea	4c 68 c4	jmp $c468		jmp ThrowA
.e7ed	b5 24		lda $24,x	_plus:	lda DStack+0,x
.e7ef	30 f7		bmi $e7e8		bmi _err
.e7f1	10 04		bpl $e7f7		bpl _store
.e7f3	b5 24		lda $24,x	_minus:	lda DStack+0,x
.e7f5	10 f1		bpl $e7e8		bpl _err
.e7f7	4c 3b dd	jmp $dd3b	_store:	jmp C_Comma
.e7fa					asm_1:
.e7fa	68		pla			pla		; pop RTS addr
.e7fb	a8		tay			tay
.e7fc	68		pla			pla
.e7fd	20 18 e8	jsr $e818		jsr asm_op	; compile opcode
.e800	b5 25		lda $25,x		lda DStack+1,x	; compile operand
.e802	d0 03		bne $e807		bne _err
.e804	4c 3b dd	jmp $dd3b	_store:	jmp C_Comma
.e807	a9 f5		lda #$f5	_err:	lda #$100+err_OutOfRange
.e809	4c 68 c4	jmp $c468		jmp ThrowA
.e80c					asm_2:
.e80c	68		pla			pla		; pop RTS addr
.e80d	a8		tay			tay
.e80e	68		pla			pla
.e80f	20 18 e8	jsr $e818		jsr asm_op	; compile opcode
.e812	4c 52 dd	jmp $dd52		jmp Comma	; compile operand
.e815					asm_0:
.e815	68		pla			pla		; pop RTS addr
.e816	a8		tay			tay
.e817	68		pla			pla
.e818	84 14		sty $14		asm_op:	sty tmp1+0	; save RTS addr
.e81a	85 15		sta $15			sta tmp1+1
.e81c	a0 01		ldy #$01		ldy #1		; get opcode byte
.e81e	b1 14		lda ($14),y		lda (tmp1),y
.e820	4c 3e dd	jmp $dd3e		jmp C_Comma_A	; compile opcode
>e823	70 75 73 68 2d 61		Name0:	.text "push-a"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=59305					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e829	26					.byte (("push-a"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=24					WordFlags ::= IM+NN	; modifiable copy, remember for later
=87					LinkDisplacement = Nt0-WordListLink
>e82a	18					.byte WordFlags	;wh_Flags
>e82b	03					.byte 3	;wh_CodeLength
>e82c	57					  .byte LinkDisplacement	; offset to previous nt
=$e82d					XtPtr1 ::= *
=59305					WordListLink ::= Nt0 ; remember the nt of this word for later
.e82d	a9 e9		lda #$e9			lda #<PushZA
.e82f	a0 c7		ldy #$c7			ldy #>PushZA
.e831	4c 78 dd	jmp $dd78			jmp Jsr_Comma_YA
=7					CodeLen	.var *-XtPtr1
=$e834					Here1 = *	; remember here
>e82b	07					.byte CodeLen	;patch wh_CodeLength
>e834	2d 2d 3e			Name0:	.text "-->"	;  name of word as a string, ending at wh_NameLastChar
=3					NameLength = *-Name0
=59319					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e837	c3					.byte (("-->"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=24					WordFlags ::= IM+NN	; modifiable copy, remember for later
=14					LinkDisplacement = Nt0-WordListLink
=26						  WordFlags ::= WordFlags | DB
>e838	1a					.byte WordFlags	;wh_Flags
>e839	08					.byte 8	;wh_CodeLength
>e83a	0e					  .byte LinkDisplacement	; offset to previous nt
>e83b	67 da					  .word Here		; pointer to xt
=0					XtPtr1 ::= 0
=59319					WordListLink ::= Nt0 ; remember the nt of this word for later
>e83d	3c 6a				Name0:	.text "<j"	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=59327					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e83f	42					.byte (("<j"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$08					WordFlags ::= IM	; modifiable copy, remember for later
=8					LinkDisplacement = Nt0-WordListLink
>e840	08					.byte WordFlags	;wh_Flags
>e841	03					.byte 3	;wh_CodeLength
>e842	08					  .byte LinkDisplacement	; offset to previous nt
=$e843					XtPtr1 ::= *
=59327					WordListLink ::= Nt0 ; remember the nt of this word for later
=0					CodeLen	.var *-XtPtr1
=$e843					Here1 = *	; remember here
>e841	00					.byte CodeLen	;patch wh_CodeLength
.e843	60		rts				rts
>e844	3c 62				Name0:	.text "<b"	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=59334					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e846	42					.byte (("<b"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=24					WordFlags ::= IM+NN	; modifiable copy, remember for later
=7					LinkDisplacement = Nt0-WordListLink
>e847	18					.byte WordFlags	;wh_Flags
>e848	03					.byte 3	;wh_CodeLength
>e849	07					  .byte LinkDisplacement	; offset to previous nt
=$e84a					XtPtr1 ::= *
=59334					WordListLink ::= Nt0 ; remember the nt of this word for later
.e84a					asm_back_branch:
.e84a	20 67 da	jsr $da67			jsr Here		; ( addr-l addr-h )
.e84d	20 08 dc	jsr $dc08			jsr Minus		; ( offset )
.e850	a9 fe		lda #$fe			lda #$fe
.e852	4c 8a da	jmp $da8a			jmp Minus_A
=11					CodeLen	.var *-XtPtr1
=$e855					Here1 = *	; remember here
>e848	0b					.byte CodeLen	;patch wh_CodeLength
>e855	44 69 73 41 73 6d		Name0:	.text "DisAsm"	;  name of word as a string, ending at wh_NameLastChar
=6					NameLength = *-Name0
=59355					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e85b	a6					.byte (("DisAsm"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=21					LinkDisplacement = Nt0-WordListLink
>e85c	10					.byte WordFlags	;wh_Flags
>e85d	03					.byte 3	;wh_CodeLength
>e85e	15					  .byte LinkDisplacement	; offset to previous nt
=$e85f					XtPtr1 ::= *
=59355					WordListLink ::= Nt0 ; remember the nt of this word for later
.e85f	20 a7 d4	jsr $d4a7	DisAsm:		jsr Bounds		; ( addr_end addr )
.e862					_instr:
.e862	b5 24		lda $24,x			lda DStack+0,x		; addr >= addr_end?
.e864	d5 26		cmp $26,x			cmp DStack+2,x
.e866	b5 25		lda $25,x			lda DStack+1,x
.e868	f5 27		sbc $27,x			sbc DStack+3,x
.e86a	90 03		bcc $e86f			bcc +
.e86c	4c 72 d5	jmp $d572			jmp Two_drop		; discard parms & return
.e86f					+
.e86f	20 4c bb	jsr $bb4c			jsr CR			; new line
.e872	20 d2 df	jsr $dfd2			jsr Dup			; print address
.e875	20 ec b8	jsr $b8ec			jsr Dot_Hex
.e878	20 2d de	jsr $de2d			jsr Space
.e87b	a1 24		lda ($24,x)			lda (DStack+0,x)	; print opcode byte
.e87d	20 dd e9	jsr $e9dd			jsr _print_a
.e880	a1 24		lda ($24,x)			lda (DStack+0,x)	; save opcode
.e882	85 18		sta $18				sta tmp3
.e884	20 9a da	jsr $da9a			jsr One_plus
.e887	a9 52		lda #$52			lda #<asm_table		; for each asm opcode word
.e889	a0 e7		ldy #$e7			ldy #>asm_table
.e88b	85 14		sta $14				sta tmp1+0
.e88d	84 15		sty $15				sty tmp1+1
.e88f	d0 05		bne $e896			bne _WTest
.e891	20 95 82	jsr $8295	_WNext:		jsr LinkNext		;   next entry
.e894	f0 2b		beq $e8c1			beq _unknown2
.e896	20 bb cd	jsr $cdbb	_WTest:		jsr NameToIntTmp	; tmp2= xt
.e899	a0 03		ldy #$03			ldy #3			;   opcode match?
.e89b	b1 16		lda ($16),y			lda (tmp2),y
.e89d	c5 18		cmp $18				cmp tmp3
.e89f	d0 f0		bne $e891			bne _WNext
.e8a1	a5 18		lda $18				lda tmp3		; save opcode
.e8a3	48		pha				pha
.e8a4	a5 15		lda $15				lda tmp1+1		; save its nt
.e8a6	48		pha				pha
.e8a7	a5 14		lda $14				lda tmp1+0
.e8a9	48		pha				pha
.e8aa	a0 01		ldy #$01			ldy #1			; get processor routine addr lo byte from JSR
.e8ac	b1 16		lda ($16),y			lda (tmp2),y
.e8ae	c9 15		cmp #$15			cmp #<asm_0		; goto disasm processor
.e8b0	f0 1a		beq $e8cc			beq _c0
.e8b2	c9 fa		cmp #$fa			cmp #<asm_1
.e8b4	f0 4c		beq $e902			beq _c1
.e8b6	c9 0c		cmp #$0c			cmp #<asm_2
.e8b8	f0 64		beq $e91e			beq _c2
.e8ba	c9 da		cmp #$da			cmp #<asm_r
.e8bc	f0 1b		beq $e8d9			beq _cr
.e8be					_unknown:
.e8be	68		pla				pla			; RDrop nt
.e8bf	68		pla				pla
.e8c0	68		pla				pla			; RDrop opcode
.e8c1	20 be e9	jsr $e9be	_unknown2:	jsr _tab		; to source area
.e8c4	a9 3f		lda #$3f			lda #'?'
.e8c6	20 21 de	jsr $de21			jsr Emit_A
.e8c9	4c 62 e8	jmp $e862			jmp _instr
.e8cc					_c0:
.e8cc	20 be e9	jsr $e9be			jsr _tab		; to source area
.e8cf	68		pla				pla			; get opcode word nt
.e8d0	a8		tay				tay
.e8d1	68		pla				pla
.e8d2	20 c3 e9	jsr $e9c3			jsr _print_opcode
.e8d5	68		pla				pla			; discard opcode
.e8d6	4c 62 e8	jmp $e862			jmp _instr
.e8d9					_cr:
.e8d9	20 d4 e9	jsr $e9d4			jsr _get_byte		; get displacement byte
.e8dc	a0 00		ldy #$00			ldy #0			; sign extend displacement
.e8de	09 00		ora #$00			ora #0
.e8e0	10 01		bpl $e8e3			bpl +
.e8e2	88		dey				dey
.e8e3	20 ba c7	jsr $c7ba	+		jsr PushYA
.e8e6	20 d2 df	jsr $dfd2			jsr Dup			; save for TypeSymbol
.e8e9	20 be e9	jsr $e9be			jsr _tab		; to source area
.e8ec	20 21 dc	jsr $dc21			jsr Dot			; print dest address
.e8ef	68		pla				pla			; get opcode word nt
.e8f0	a8		tay				tay
.e8f1	68		pla				pla
.e8f2	20 c3 e9	jsr $e9c3			jsr _print_opcode
.e8f5	68		pla				pla			; discard opcode
.e8f6	20 a9 df	jsr $dfa9			jsr Over		; calc dest addr
.e8f9	20 ef db	jsr $dbef			jsr Plus
.e8fc	20 98 81	jsr $8198			jsr TypeSymbol		; print dest addr symbolic
.e8ff	4c 62 e8	jmp $e862			jmp _instr
.e902					_c1:
.e902	20 d4 e9	jsr $e9d4			jsr _get_byte		; get operand
.e905	20 e9 c7	jsr $c7e9			jsr PushZA
.e908	20 be e9	jsr $e9be			jsr _tab		; to source area
.e90b	20 d2 df	jsr $dfd2			jsr Dup
.e90e	20 52 dc	jsr $dc52			jsr U_Dot		; print operand
.e911	68		pla				pla			; get opcode word nt
.e912	a8		tay				tay
.e913	68		pla				pla
.e914	20 c3 e9	jsr $e9c3			jsr _print_opcode
.e917	68		pla				pla			; discard opcode
.e918	20 98 81	jsr $8198			jsr TypeSymbol
.e91b	4c 62 e8	jmp $e862			jmp _instr
.e91e					_c2:
.e91e	20 d4 e9	jsr $e9d4			jsr _get_byte		; get operand lo byte
.e921	48		pha				pha
.e922	20 d4 e9	jsr $e9d4			jsr _get_byte		; get operand hi byte
.e925	ca		dex				dex			; push operand bytes
.e926	ca		dex				dex
.e927	95 25		sta $25,x			sta DStack+1,x
.e929	68		pla				pla
.e92a	95 24		sta $24,x			sta DStack+0,x
.e92c	20 be e9	jsr $e9be			jsr _tab		; to source area
.e92f	20 d2 df	jsr $dfd2			jsr Dup
.e932	20 52 dc	jsr $dc52			jsr U_Dot		; print operand
.e935	68		pla				pla			; AY= opcode word nt
.e936	a8		tay				tay
.e937	68		pla				pla
.e938	20 c3 e9	jsr $e9c3			jsr _print_opcode
.e93b	20 d2 df	jsr $dfd2			jsr Dup
.e93e	20 98 81	jsr $8198			jsr TypeSymbol		; print operand as symbol
.e941	68		pla				pla			; get opcode
.e942	c9 20		cmp #$20			cmp #$20		;  JSR
.e944	f0 09		beq $e94f			beq _jsr
.e946	e8		inx		_jdrop:		inx			; Drop operand
.e947	e8		inx				inx
.e948	4c 62 e8	jmp $e862			jmp _instr		; ( addr_end addr )
.e94b	e8		inx		_2drop:		inx			; Drop jsr_nt
.e94c	e8		inx				inx
.e94d	d0 f7		bne $e946			bne _jdrop
.e94f					_jsr:
.e94f	20 e3 c3	jsr $c3e3			jsr PopYA		; pop JSR operand
.e952	c9 bd		cmp #$bd			cmp #<sliteral_runtime	; string literal?
.e954	d0 42		bne $e998			bne _not_sliteral
.e956	c0 c8		cpy #$c8			cpy #>sliteral_runtime
.e958	d0 3e		bne $e998			bne _not_sliteral
.e95a	20 4c bb	jsr $bb4c			jsr CR
.e95d	20 d2 df	jsr $dfd2			jsr Dup			; ( addr_end addr addr )
.e960	20 ec b8	jsr $b8ec			jsr Dot_Hex
.e963	20 2d de	jsr $de2d			jsr Space
.e966	20 d2 df	jsr $dfd2			jsr Dup			; ( addr_end ? addr )
.e969	20 d4 e9	jsr $e9d4			jsr _get_byte		; get JMP opcode
.e96c	20 d4 e9	jsr $e9d4			jsr _get_byte		; get JMP addr lo byte
.e96f	95 26		sta $26,x			sta DStack+2,x
.e971	20 d4 e9	jsr $e9d4			jsr _get_byte		; get JMP addr hi byte
.e974	95 27		sta $27,x			sta DStack+3,x		; ( addr_end string_end addr )
.e976	20 4c bb	jsr $bb4c			jsr CR
.e979	20 d2 df	jsr $dfd2			jsr Dup
.e97c	20 ec b8	jsr $b8ec			jsr Dot_Hex
.e97f	20 2d de	jsr $de2d			jsr Space
.e982	b5 24		lda $24,x	_slit_11:	lda DStack+0,x		; done with string data?
.e984	d5 26		cmp $26,x			cmp DStack+2,x
.e986	b5 25		lda $25,x			lda DStack+1,x
.e988	f5 27		sbc $27,x			sbc DStack+3,x
.e98a	b0 06		bcs $e992			bcs _slit_19
.e98c	20 d4 e9	jsr $e9d4			jsr _get_byte
.e98f	4c 82 e9	jmp $e982			jmp _slit_11
.e992					_slit_19:
.e992	20 cd d9	jsr $d9cd			jsr Nip			; ( addr_end addr )
.e995	4c 62 e8	jmp $e862			jmp _instr
.e998					_not_sliteral:
.e998	c9 48		cmp #$48			cmp #<FLiti		; float literal?
.e99a	d0 1f		bne $e9bb			bne _not_FLiti
.e99c	c0 88		cpy #$88			cpy #>FLiti
.e99e	d0 1b		bne $e9bb			bne _not_FLiti
.e9a0	20 4c bb	jsr $bb4c			jsr CR
.e9a3	20 d2 df	jsr $dfd2			jsr Dup			; ( addr_end addr addr )
.e9a6	20 ec b8	jsr $b8ec			jsr Dot_Hex
.e9a9	20 2d de	jsr $de2d			jsr Space
.e9ac	20 d4 e9	jsr $e9d4			jsr _get_byte
.e9af	20 d4 e9	jsr $e9d4			jsr _get_byte
.e9b2	20 d4 e9	jsr $e9d4			jsr _get_byte
.e9b5	20 d4 e9	jsr $e9d4			jsr _get_byte
.e9b8	20 d4 e9	jsr $e9d4			jsr _get_byte
.e9bb					_not_FLiti:
.e9bb	4c 62 e8	jmp $e862			jmp _instr
.e9be					_tab:
.e9be	a9 09		lda #$09			lda #9
.e9c0	4c 21 de	jmp $de21			jmp Emit_A
.e9c3					_print_opcode:
.e9c3	20 e4 df	jsr $dfe4			jsr PushAY		; save opcode word nt
.e9c6	20 2d de	jsr $de2d			jsr Space
.e9c9	20 f7 cd	jsr $cdf7			jsr Name_To_String	; get name string
.e9cc	4c 39 de	jmp $de39			jmp Type		; type word name
.e9cf					_get_byte_silent:
.e9cf	a1 24		lda ($24,x)			lda (DStack+0,x)
.e9d1	4c 9a da	jmp $da9a			jmp One_plus
.e9d4					_get_byte:
.e9d4	20 cf e9	jsr $e9cf			jsr _get_byte_silent
.e9d7	48		pha				pha
.e9d8	20 dd e9	jsr $e9dd			jsr _print_a
.e9db	68		pla				pla
.e9dc	60		rts				rts
.e9dd					_print_a:
.e9dd	20 e9 c7	jsr $c7e9			jsr PushZA
.e9e0	20 cb b8	jsr $b8cb			jsr C_Dot_Hex
.e9e3	4c 2d de	jmp $de2d			jmp Space
=59355					assembler_dictionary_start = WordListLink ; END of ASSEMBLER-WORDLIST
=0					WordListLink .var 0	; start wordlist
>e9e6	6c				Name0:	.text "l"	;  name of word as a string, ending at wh_NameLastChar
=1					NameLength = *-Name0
=59751					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>e9e7	81					.byte (("l"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=59751					LinkDisplacement = Nt0-WordListLink
=$11						  WordFlags ::= WordFlags | FP
>e9e8	11					.byte WordFlags	;wh_Flags
>e9e9	03					.byte 3	;wh_CodeLength
>e9ea	00 00					  .word WordListLink
=$e9ec					XtPtr1 ::= *
=59751					WordListLink ::= Nt0 ; remember the nt of this word for later
.e9ec	4c b0 b4	jmp $b4b0	Editor_l:	jmp ListScr
=3					CodeLen	.var *-XtPtr1
=$e9ef					Here1 = *	; remember here
>e9e9	03					.byte CodeLen	;patch wh_CodeLength
.e9ef					Editor_Screen_Helper:
.e9ef	20 d2 df	jsr $dfd2			jsr Dup
.e9f2	20 c2 b2	jsr $b2c2			jsr Scr
.e9f5	20 13 df	jsr $df13			jsr Store
.e9f8	4c cd b3	jmp $b3cd			jmp Buffer
>e9fb	65 6e 74 65 72 2d 73 63		Name0:	.text "enter-screen"	;  name of word as a string, ending at wh_NameLastChar
>ea03	72 65 65 6e
=12					NameLength = *-Name0
=59783					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>ea07	cc					.byte (("enter-screen"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=32					LinkDisplacement = Nt0-WordListLink
>ea08	10					.byte WordFlags	;wh_Flags
>ea09	03					.byte 3	;wh_CodeLength
>ea0a	20					  .byte LinkDisplacement	; offset to previous nt
=$ea0b					XtPtr1 ::= *
=59783					WordListLink ::= Nt0 ; remember the nt of this word for later
.ea0b					Editor_Enter_Screen:
.ea0b	20 ef e9	jsr $e9ef			jsr Editor_Screen_Helper
.ea0e	a9 00		lda #$00			lda #0			; Overwrite the lines one at a time.
.ea10	95 24		sta $24,x	_loop:		sta DStack+0,x
.ea12	20 e9 c7	jsr $c7e9			jsr PushZA		; Put the current line number on the stack.
.ea15	20 75 ea	jsr $ea75			jsr Editor_o		; prompt for overwrite.
.ea18	f6 24		inc $24,x			inc DStack+0,x		; Move on to the next line.
.ea1a	b5 24		lda $24,x			lda DStack+0,x
.ea1c	c9 10		cmp #$10			cmp #16
.ea1e	90 f0		bcc $ea10			bcc _loop
.ea20	e8		inx				inx			; Drop work area
.ea21	e8		inx				inx
=23					CodeLen	.var *-XtPtr1
=$ea22					Here1 = *	; remember here
>ea09	17					.byte CodeLen	;patch wh_CodeLength
.ea22	60		rts				rts
>ea23	6c 69 6e 65			Name0:	.text "line"	;  name of word as a string, ending at wh_NameLastChar
=4					NameLength = *-Name0
=59815					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>ea27	a4					.byte (("line"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=32					LinkDisplacement = Nt0-WordListLink
>ea28	10					.byte WordFlags	;wh_Flags
>ea29	03					.byte 3	;wh_CodeLength
>ea2a	20					  .byte LinkDisplacement	; offset to previous nt
=$ea2b					XtPtr1 ::= *
=59815					WordListLink ::= Nt0 ; remember the nt of this word for later
.ea2b					Editor_line:
.ea2b	a9 06		lda #$06			lda #6		; Multiply the TOS by 64 (chars/line) to compute offset.
.ea2d	20 8c db	jsr $db8c			jsr LShift_A	; *64 is same as left shift 6 times.
.ea30	20 c2 b2	jsr $b2c2			jsr Scr
.ea33	20 fa de	jsr $defa			jsr Fetch
.ea36	20 65 b3	jsr $b365			jsr Block
.ea39	4c ef db	jmp $dbef			jmp Plus
=17					CodeLen	.var *-XtPtr1
=$ea3c					Here1 = *	; remember here
>ea29	11					.byte CodeLen	;patch wh_CodeLength
>ea3c	65 72 61 73 65 2d 73 63		Name0:	.text "erase-screen"	;  name of word as a string, ending at wh_NameLastChar
>ea44	72 65 65 6e
=12					NameLength = *-Name0
=59848					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>ea48	cc					.byte (("erase-screen"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=33					LinkDisplacement = Nt0-WordListLink
>ea49	10					.byte WordFlags	;wh_Flags
>ea4a	03					.byte 3	;wh_CodeLength
>ea4b	21					  .byte LinkDisplacement	; offset to previous nt
=$ea4c					XtPtr1 ::= *
=59848					WordListLink ::= Nt0 ; remember the nt of this word for later
.ea4c					Editor_Erase_Screen:
.ea4c	20 ef e9	jsr $e9ef			jsr Editor_Screen_Helper
.ea4f	a9 00		lda #$00			lda #<1024
.ea51	a0 04		ldy #$04			ldy #>1024
.ea53	20 ba c7	jsr $c7ba			jsr PushYA
.ea56	20 3d ce	jsr $ce3d			jsr Blank		; Erase the entire block (fill with spaces).
.ea59	4c ba b3	jmp $b3ba			jmp Update		; Mark buffer as updated.
=16					CodeLen	.var *-XtPtr1
=$ea5c					Here1 = *	; remember here
>ea4a	10					.byte CodeLen	;patch wh_CodeLength
>ea5c	65 6c				Name0:	.text "el"	;  name of word as a string, ending at wh_NameLastChar
=2					NameLength = *-Name0
=59870					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>ea5e	82					.byte (("el"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=22					LinkDisplacement = Nt0-WordListLink
>ea5f	10					.byte WordFlags	;wh_Flags
>ea60	03					.byte 3	;wh_CodeLength
>ea61	16					  .byte LinkDisplacement	; offset to previous nt
=$ea62					XtPtr1 ::= *
=59870					WordListLink ::= Nt0 ; remember the nt of this word for later
.ea62					Editor_el:
.ea62	20 2b ea	jsr $ea2b			jsr Editor_line
.ea65	a9 40		lda #$40			lda #64			;(# of chars/line)
.ea67	20 e9 c7	jsr $c7e9			jsr PushZA
.ea6a	20 3d ce	jsr $ce3d			jsr Blank		; Fill with spaces.
.ea6d	4c ba b3	jmp $b3ba			jmp Update		; Mark buffer as updated.
=14					CodeLen	.var *-XtPtr1
=$ea70					Here1 = *	; remember here
>ea60	0e					.byte CodeLen	;patch wh_CodeLength
>ea70	6f				Name0:	.text "o"	;  name of word as a string, ending at wh_NameLastChar
=1					NameLength = *-Name0
=59889					Nt0 = *-(wh_NameLastChar+1)	; remember our nt
>ea71	e1					.byte (("o"[-1]&7)<<5)+NameLength	;wh_HashNameLen
=$10					WordFlags ::= NN	; modifiable copy, remember for later
=19					LinkDisplacement = Nt0-WordListLink
>ea72	10					.byte WordFlags	;wh_Flags
>ea73	03					.byte 3	;wh_CodeLength
>ea74	13					  .byte LinkDisplacement	; offset to previous nt
=$ea75					XtPtr1 ::= *
=59889					WordListLink ::= Nt0 ; remember the nt of this word for later
.ea75					Editor_o:
.ea75	20 4c bb	jsr $bb4c			jsr CR
.ea78	20 d2 df	jsr $dfd2			jsr Dup
.ea7b	a9 02		lda #$02			lda #2
.ea7d	20 84 dc	jsr $dc84			jsr U_Dot_R_A
.ea80	20 2d de	jsr $de2d			jsr Space
.ea83	a9 2a		lda #$2a			lda #'*'
.ea85	20 21 de	jsr $de21			jsr Emit_A
.ea88	20 2d de	jsr $de2d			jsr Space
.ea8b	20 2b ea	jsr $ea2b			jsr Editor_line
.ea8e	20 d2 df	jsr $dfd2			jsr Dup		; Save a copy of the line address for later.
.ea91	a9 40		lda #$40			lda #64		; chars/line
.ea93	20 e9 c7	jsr $c7e9			jsr PushZA
.ea96	20 de d2	jsr $d2de			jsr Accept
.ea99	20 d2 df	jsr $dfd2			jsr Dup
.ea9c	20 d8 de	jsr $ded8			jsr Not_Rot
.ea9f	20 ef db	jsr $dbef			jsr Plus
.eaa2	a9 40		lda #$40			lda #64		; chars/line
.eaa4	20 e9 c7	jsr $c7e9			jsr PushZA
.eaa7	20 b3 de	jsr $deb3			jsr Rot
.eaaa	20 08 dc	jsr $dc08			jsr Minus
.eaad	20 3d ce	jsr $ce3d			jsr Blank
.eab0	4c ba b3	jmp $b3ba			jmp Update
=62					CodeLen	.var *-XtPtr1
=$eab3					Here1 = *	; remember here
>ea73	3e					.byte CodeLen	;patch wh_CodeLength
=59889					editor_dictionary_start = WordListLink ; END of EDITOR-WORDLIST

;******  Processing file: platform/../strings.asm

>eab3	20 6f 6b 00			str_ok:         .text " ok", 0         ; note space at beginning
>eab7	20 63 6f 6d 70 69 6c 65		str_compiled:   .text " compiled", 0   ; note space at beginning
>eabf	64 00
>eac1	72 65 64 65 66 69 6e 65		str_redefined:  .text "redefined ", 0  ; note space at end
>eac9	64 20 00
>eacc	66 6c 61 67 73 3a 00		str_see_flags:  .text "flags:", 0
>ead3	6e 74 3a 20 24 00		str_see_nt:     .text "nt: $", 0
>ead9	78 74 3a 20 24 00		str_see_xt:     .text "xt: $", 0
>eadf	73 69 7a 65 3a 20 23 00		str_see_size:   .text "size: #", 0
.eae7					Exception_Text_List:
>eae7	ff 00					.text $100+err_Abort,0
>eae9	fe 00					.text $100+err_AbortQuote,0
>eaeb	fd 53 74 61 63 6b 20 4f			.text $100+err_Stack_Overflow,"Stack Overflow",0
>eaf3	76 65 72 66 6c 6f 77 00
>eafb	fc 53 74 61 63 6b 20 55			.text $100+err_Stack_Underflow,"Stack Underflow",0
>eb03	6e 64 65 72 66 6c 6f 77 00
>eb0c	f9 64 6f 2d 6c 6f 6f 70			.text $100+err_DoLoop_TooDeep,"do-loops nested too deeply during execution",0
>eb14	73 20 6e 65 73 74 65 64 20 74 6f 6f 20 64 65 65
>eb24	70 6c 79 20 64 75 72 69 6e 67 20 65 78 65 63 75
>eb34	74 69 6f 6e 00
>eb39	f6 44 69 76 69 64 65 20			.text $100+err_DivideBy0,"Divide by 0",0
>eb41	62 79 20 30 00
>eb46	f5 6f 75 74 20 6f 66 20			.text $100+err_OutOfRange,"out of range",0
>eb4e	72 61 6e 67 65 00
>eb54	f4 61 72 67 75 6d 65 6e			.text $100+err_ArgTypeMismatch,"argument type mismatch",0
>eb5c	74 20 74 79 70 65 20 6d 69 73 6d 61 74 63 68 00
>eb6c	f3 55 6e 64 65 66 69 6e			.text $100+err_UndefinedWord,"Undefined word",0
>eb74	65 64 20 77 6f 72 64 00
>eb7c	f2 49 6e 74 65 72 70 72			.text $100+err_CompileOnly,"Interpreting a Compile-only word",0
>eb84	65 74 69 6e 67 20 61 20 43 6f 6d 70 69 6c 65 2d
>eb94	6f 6e 6c 79 20 77 6f 72 64 00
>eb9e	eb 75 6e 73 75 70 70 6f			.text $100+err_Unsupported,"unsupported operation",0 ;  (e.g., AT-XY on a too-dumb terminal)
>eba6	72 74 65 64 20 6f 70 65 72 61 74 69 6f 6e 00
>ebb5	ea 63 6f 6e 74 72 6f 6c			.text $100+err_ControlMismatch,"control structure mismatch",0
>ebbd	20 73 74 72 75 63 74 75 72 65 20 6d 69 73 6d 61
>ebcd	74 63 68 00
>ebd1	e0 69 6e 76 61 6c 69 64			.text $100+err_InvalidName,"invalid name",0 ; argument (e.g., TO name)
>ebd9	20 6e 61 6d 65 00
>ebdf	df 62 6c 6f 63 6b 20 72			.text $100+err_BlockRead,"block read",0
>ebe7	65 61 64 00
>ebeb	de 62 6c 6f 63 6b 20 77			.text $100+err_BlockWrite,"block write",0
>ebf3	72 69 74 65 00
>ebf8	d6 46 50 20 64 69 76 69			.text $100+err_FPDivideBy0,"FP divide by zero",0
>ec00	64 65 20 62 79 20 7a 65 72 6f 00
>ec0b	d5 46 50 20 72 65 73 75			.text $100+err_FPOutOfRange,"FP result out of range",0
>ec13	6c 74 20 6f 75 74 20 6f 66 20 72 61 6e 67 65 00
>ec23	d4 46 50 20 73 74 61 63			.text $100+err_FPStackOverflow,"FP stack overflow",0
>ec2b	6b 20 6f 76 65 72 66 6c 6f 77 00
>ec36	d3 46 50 20 73 74 61 63			.text $100+err_FPStackUnderflow,"FP stack underflow",0
>ec3e	6b 20 75 6e 64 65 72 66 6c 6f 77 00
>ec4a	d2 46 50 20 69 6e 76 61			.text $100+err_FPInvalidArg,"FP invalid argument",0
>ec52	6c 69 64 20 61 72 67 75 6d 65 6e 74 00
>ec5f	ca 46 50 20 75 6e 64 65			.text $100+err_FPUnderflow,"FP underflow",0
>ec67	72 66 6c 6f 77 00
>ec6d	c5 41 4c 4c 4f 43 41 54			.text $100+err_Allocate,"ALLOCATE",0
>ec75	45 00
>ec77	c4 46 52 45 45 00			.text $100+err_Free,"FREE",0
>ec7d	6b 52 65 66 69 6c 6c 00			.text $100+err_Refill,"Refill",0
>ec85	6a 44 65 66 65 72 20 6e			.text $100+err_Defer,"Defer not set",0
>ec8d	6f 74 20 73 65 74 00
>ec94	69 41 6c 72 65 61 64 79			.text $100+err_AlreadyInterpreting,"Already interpreting",0
>ec9c	20 69 6e 74 65 72 70 72 65 74 69 6e 67 00
>ecaa	68 41 6c 72 65 61 64 79			.text $100+err_AlreadyCompiling,"Already compiling",0
>ecb2	20 63 6f 6d 70 69 6c 69 6e 67 00
>ecbd	66 4e 6f 20 77 6f 72 64			.text $100+err_TooManyWordlists,"No wordlists available",0
>ecc5	6c 69 73 74 73 20 61 76 61 69 6c 61 62 6c 65 00
>ecd5	00					.text 0 ; end of list

;******  Return to file: platform/../taliforth.asm


;******  Return to file: platform/platform-65816S.asm

>0766					hist_buff: .fill 8*128	; Input History for ACCEPT
.0b66					cp0:
.f100					v_nmi:
.f100					v_reset:
.f100					v_irq:
.f100					kernel_init:
.f100	78		sei		                sei             ; Disable interrupts
.f101	a2 00		ldx #$00	                ldx #0
.f103	bd 35 f1	lda $f135,x	-               lda s_kernel_id,x
.f106	f0 06		beq $f10e	                beq _done
.f108	20 20 f1	jsr $f120	                jsr kernel_putc
.f10b	e8		inx		                inx
.f10c	d0 f5		bne $f103	                bne -
.f10e					_done:
.f10e	4c 4c 80	jmp $804c	                jmp Cold
.f111					kernel_getc:
.f111	ee 35 03	inc $0335	-		inc RndState+0	; randomize
>f114	22						.byte $22	; jsl GET_BYTE_FROM_PC
>f115	33 e0						.word $e033
>f117	00						.byte 0
.f118	b0 f7		bcs $f111			bcs -
.f11a	60		rts				rts
.f11b					kernel_havekey:
.f11b	a9 eb		lda #$eb			lda #$100+err_unsupported
.f11d	4c 68 c4	jmp $c468			jmp ThrowA
.f120					kernel_putc:
>f120	22				-		.byte $22	; jsl SEND_BYTE_TO_PC
>f121	63 e0						.word $e063
>f123	00						.byte 0
.f124	b0 fa		bcs $f120			bcs -
.f126	60		rts				rts
.f127					platform_bye:
.f127	00		brk #		                brk
.f128					platform_CCAt:
.f128	ca		dex				dex
.f129	ca		dex				dex
.f12a	ca		dex				dex
.f12b	ca		dex				dex
>f12c	02 f4 24					.byte $02,$F4,DStack ; cop $f4	get 65816s simulator cycle count in DStack,x
.f12f	60		rts				rts
.f130					Platform_Block_Read:
.f130					Platform_Block_Write:
.f130	a9 eb		lda #$eb			lda #$100+err_Unsupported
.f132	20 68 c4	jsr $c468			jsr ThrowA
.f135					s_kernel_id:
>f135	54 61 6c 69 20 46 6f 72		        .text "Tali Forth 2 kernel for 65816s (31. May 2024)", AscCR,AscLF, 0
>f13d	74 68 20 32 20 6b 65 72 6e 65 6c 20 66 6f 72 20
>f14d	36 35 38 31 36 73 20 28 33 31 2e 20 4d 61 79 20
>f15d	32 30 32 34 29 0d 0a 00
>fffa	00 f1				.word v_nmi
>fffc	00 f1				.word v_reset
>fffe	00 f1				.word v_irq

;******  End of listing
