; Assembler for Tali Forth 2 
; Scot W. Stevenson <scot.stevenson@gmail.com>
; First version: 07. Nov 2014 (as tasm65c02)
; This version: 18. Dez 2018 forked

; This is the built-in assembler for Tali Forth 2. Once the assembler wordlist
; is included with

;       assembler-wordlist >order

; , the opcodes are available as normal Forth words. The format
; is Simpler Assembler Notation (SAN) which separates the opcode completely
; from the operand. In this case, the operand is entered before the opcode in
; the postfix Forth notation (for example, "20 lda.#"). See the
; assembler documenation in the manual for more detail.

; The code here was originally used in A Typist's Assembler for the 65c02
; (tasm65c02), see https://github.com/scotws/tasm65c02 for the standalone
; version. Tasm65c02 is in the public domain.

; ==========================================================
; MNEMONICS

; The assembler instructions are realized as individual Forth words with
; entries in the assembler wordlist (see header.asm). We pass the opcode in A
; & jump to the appropriate routine to handle the operand.
; Note an alterantive method would be along the lines of

;               jsr asm_common
;               .byte $EA

; where the asm_common then uses the address on the Return Stack to pick up the
; opcode and the length. Though this uses fewer resources, the current version
; makes up for this by simplifying the code of asm_common.

; The routines are organized alphabetically by SAN mnemonic, not by opcode. The
; SAN and traditional mnemonics are listed after the opcode load instruction.
; This list was generated by a Python script in the tools folder, see there
; for more detail

assembler:              ; used to calculate size of assembler code


; ==========================================================
; ASSEMBLER HELPER FUNCTIONS

asm_0byte: ; no operand, opcode in A
                pla
                ply

asm_opcode: ; compile opcode pointed to by YA+1
                sta tmp1
                sty tmp1+1
                ldy #1
                lda (tmp1),y
                jmp cmpl_a

asm_ubyte: ; 1 byte unsigned operand in TOS, opcode in A
                ldy 1,x                 ; operand must be in 0..$FF
                beq asm_1byte
                lda #err_syntax  ; TODO: get a better error code
                jsr error

asm_relative: ; 1 byte relative operand in TOS, opcode in A
asm_1byte:
                pla
                ply
                jsr asm_opcode          ; compile opcode
                jmp xt_c_comma          ; compile operand


asm_2byte: ; 2 byte operand in TOS, opcode in A
                pla
                ply
                jsr asm_opcode          ; compile opcode
                jmp xt_comma            ; compile operand
                
;------------------------------------------------------------

xt_asm_adc_h:   ; adc.# \ ADC #nn
                jsr asm_1byte
                .byte $69
z_asm_adc_h:

xt_asm_adc_x:   ; adc.x \ ADC nnnn,X
                jsr asm_2byte
                .byte $7D
z_asm_adc_x:

xt_asm_adc_y:   ; adc.y \ ADC nnnn,Y
                jsr asm_2byte
                .byte $79
z_asm_adc_y:

xt_asm_adc_z:   ; adc.z \ ADC nn
                jsr asm_ubyte
                .byte $65
z_asm_adc_z:

xt_asm_adc_zi:  ; adc.zi \ ADC (nn)
                jsr asm_ubyte
                .byte $72
z_asm_adc_zi:

xt_asm_adc_ziy: ; adc.ziy \ ADC (nn),Y
                jsr asm_ubyte
                .byte $71
z_asm_adc_ziy:

xt_asm_adc_zx:  ; adc.zx \ ADC nn,X
                jsr asm_ubyte
                .byte $75
z_asm_adc_zx:

xt_asm_adc_zxi: ; adc.zxi \ ADC (nn,X)
                jsr asm_ubyte
                .byte $61
z_asm_adc_zxi:

xt_asm_and:     ; and. \ AND nnnn
                jsr asm_2byte
                .byte $2D
z_asm_and:

xt_asm_and_h:   ; and.# \ AND #nn
                jsr asm_1byte
                .byte $29
z_asm_and_h:

xt_asm_and_x:   ; and.x \ AND nnnn,X
                jsr asm_2byte
                .byte $3D
z_asm_and_x:

xt_asm_and_y:   ; and.y \ AND nnnn,Y
                jsr asm_2byte
                .byte $39
z_asm_and_y:

xt_asm_and_z:   ; and.z \ AND nn
                jsr asm_ubyte
                .byte $25
z_asm_and_z:

xt_asm_and_zi:  ; and.zi \ AND (nn)
                jsr asm_ubyte
                .byte $32
z_asm_and_zi:

xt_asm_and_ziy: ; and.ziy \ AND (nn),Y
                jsr asm_ubyte
                .byte $31
z_asm_and_ziy:

xt_asm_and_zx:  ; and.zx \ AND nn,X
                jsr asm_ubyte
                .byte $35
z_asm_and_zx:

xt_asm_and_zxi: ; and.zxi \ AND (nn,X)
                jsr asm_ubyte
                .byte $21
z_asm_and_zxi:

xt_asm_asl:     ; asl \ ASL nnnn
                jsr asm_2byte
                .byte $0E
z_asm_asl:

xt_asm_asl_a:   ; asl.a \ ASL
                jsr asm_0byte
                .byte $0A
z_asm_asl_a:

xt_asm_asl_x:   ; asl.x \ ASL nnnn,X
                jsr asm_2byte
                .byte $1E
z_asm_asl_x:

xt_asm_asl_z:   ; asl.z \ ASL nn
                jsr asm_ubyte
                .byte $06
z_asm_asl_z:

xt_asm_asl_zx:  ; asl.zx \ ASL nn,X
                jsr asm_ubyte
                .byte $16
z_asm_asl_zx:

xt_asm_bcc:     ; bcc \ BCC
                jsr asm_relative
                .byte $90
z_asm_bcc:

xt_asm_bcs:     ; bcs \ BCS
                jsr asm_relative
                .byte $B0
z_asm_bcs:

xt_asm_beq:     ; beq \ BEQ
                jsr asm_relative
                .byte $F0
z_asm_beq:

xt_asm_bit:     ; bit \ BIT nnnn
                jsr asm_2byte
                .byte $2C
z_asm_bit:

xt_asm_bit_h:   ; bit.# \ BIT #nn
                jsr asm_1byte
                .byte $89
z_asm_bit_h:

xt_asm_bit_x:   ; bit.x \ BIT nnnn,X
                jsr asm_2byte
                .byte $3C
z_asm_bit_x:

xt_asm_bit_z:   ; bit.z \ BIT nn
                jsr asm_ubyte
                .byte $24
z_asm_bit_z:

xt_asm_bit_zx:  ; bit.zx \ BIT nn,X
                jsr asm_ubyte
                .byte $34
z_asm_bit_zx:

xt_asm_bmi:     ; bmi \ BMI
                jsr asm_relative
                .byte $30
z_asm_bmi:

xt_asm_bne:     ; bne \ BNE
                jsr asm_relative
                .byte $D0
z_asm_bne:

xt_asm_bpl:     ; bpl \ BPL
                jsr asm_relative
                .byte $10
z_asm_bpl:

xt_asm_bra:     ; bra \ BRA
                jsr asm_relative
                .byte $80
z_asm_bra:

xt_asm_brk:     ; brk \ BRK
                jsr asm_0byte
                .byte $00
z_asm_brk:

xt_asm_bvc:     ; bvc \ BVC
                jsr asm_relative
                .byte $50
z_asm_bvc:

xt_asm_bvs:     ; bvs \ BVS
                jsr asm_relative
                .byte $70
z_asm_bvs:

xt_asm_clc:     ; clc \ CLC
                jsr asm_0byte
                .byte $18
z_asm_clc:

xt_asm_cld:     ; cld \ CLD
                jsr asm_0byte
                .byte $D8
z_asm_cld:

xt_asm_cli:     ; cli \ CLI
                jsr asm_0byte
                .byte $58
z_asm_cli:

xt_asm_clv:     ; clv \ CLV
                jsr asm_0byte
                .byte $B8
z_asm_clv:

xt_asm_cmp:     ; cmp \ CMP nnnn
                jsr asm_2byte
                .byte $CD
z_asm_cmp:

xt_asm_cmp_h:   ; cmp.# \ CMP #nn
                jsr asm_1byte
                .byte $C9
z_asm_cmp_h:

xt_asm_cmp_x:   ; cmp.x \ CMP nnnn,X
                jsr asm_2byte
                .byte $DD
z_asm_cmp_x:

xt_asm_cmp_y:   ; cmp.y \ CMP nnnn,Y
                jsr asm_2byte
                .byte $D9
z_asm_cmp_y:

xt_asm_cmp_z:   ; cmp.z \ CMP nn
                jsr asm_ubyte
                .byte $C5
z_asm_cmp_z:

xt_asm_cmp_zi:  ; cmp.zi \ CMP (nn)
                jsr asm_ubyte
                .byte $D2
z_asm_cmp_zi:

xt_asm_cmp_ziy: ; cmp.ziy \ CMP (nn),Y
                jsr asm_ubyte
                .byte $D1
z_asm_cmp_ziy:

xt_asm_cmp_zx:  ; cmp.zx \ CMP nn,X
                jsr asm_ubyte
                .byte $D5
z_asm_cmp_zx:

xt_asm_cmp_zxi: ; cmp.zxi \ CMP (nn,X)
                jsr asm_ubyte
                .byte $C1
z_asm_cmp_zxi:

xt_asm_cpx:     ; cpx \ CPX nnnn
                jsr asm_2byte
                .byte $EC
z_asm_cpx:

xt_asm_cpx_h:   ; cpx.# \ CPX #nn
                jsr asm_1byte
                .byte $E0
z_asm_cpx_h:

xt_asm_cpx_z:   ; cpx.z \ CPX nn
                jsr asm_ubyte
                .byte $E4
z_asm_cpx_z:

xt_asm_cpy:     ; cpy \ CPY
                jsr asm_2byte
                .byte $CC
z_asm_cpy:

xt_asm_cpy_h:   ; cpy.# \ CPY #nn
                jsr asm_1byte
                .byte $C0
z_asm_cpy_h:

xt_asm_cpy_z:   ; cpy.z \ CPY nn
                jsr asm_ubyte
                .byte $C4
z_asm_cpy_z:

xt_asm_dec:     ; dec \ DEC nnnn
                jsr asm_2byte
                .byte $CE
z_asm_dec:

xt_asm_dec_a:   ; dec.a \ DEC
                jsr asm_0byte
                .byte $3A
z_asm_dec_a:

xt_asm_dec_x:   ; dec.x \ DEC nnnn,X
                jsr asm_2byte
                .byte $DE
z_asm_dec_x:

xt_asm_dec_z:   ; dec.z \ DEC nn
                jsr asm_ubyte
                .byte $C6
z_asm_dec_z:

xt_asm_dec_zx:  ; dec.zx \ DEC nn,X
                jsr asm_ubyte
                .byte $D6
z_asm_dec_zx:

xt_asm_dex:     ; dex \ DEX
                jsr asm_0byte
                .byte $CA
z_asm_dex:

xt_asm_dey:     ; dey \ DEY
                jsr asm_0byte
                .byte $88
z_asm_dey:

xt_asm_eor:     ; eor \ EOR nnnn
                jsr asm_2byte
                .byte $4D
z_asm_eor:

xt_asm_eor_h:   ; eor.# \ EOR #nn
                jsr asm_1byte
                .byte $49
z_asm_eor_h:

xt_asm_eor_x:   ; eor.x \ EOR nnnn,X
                jsr asm_2byte
                .byte $5D
z_asm_eor_x:

xt_asm_eor_y:   ; eor.y \ EOR nnnn,Y
                jsr asm_2byte
                .byte $59
z_asm_eor_y:

xt_asm_eor_z:   ; eor.z \ EOR nn
                jsr asm_ubyte
                .byte $45
z_asm_eor_z:

xt_asm_eor_zi:  ; eor.zi \ EOR (nn)
                jsr asm_ubyte
                .byte $52
z_asm_eor_zi:

xt_asm_eor_ziy: ; eor.ziy \ EOR (nn),Y
                jsr asm_ubyte
                .byte $51
z_asm_eor_ziy:

xt_asm_eor_zx:  ; eor.zx \ EOR nn,X
                jsr asm_ubyte
                .byte $55
z_asm_eor_zx:

xt_asm_eor_zxi: ; eor.zxi \ EOR (nn,X)
                jsr asm_ubyte
                .byte $41
z_asm_eor_zxi:

xt_asm_inc:     ; inc \ INC nnnn
                jsr asm_2byte
                .byte $EE
z_asm_inc:

xt_asm_inc_a:   ; inc.a \ INC
                jsr asm_0byte
                .byte $1A
z_asm_inc_a:

xt_asm_inc_x:   ; inc.x \ INC nnnn,X
                jsr asm_2byte
                .byte $FE
z_asm_inc_x:

xt_asm_inc_z:   ; inc.z \ INC nn
                jsr asm_ubyte
                .byte $E6
 z_asm_inc_z:

xt_asm_inc_zx:  ; inc.zx \ INC nn,X
                jsr asm_ubyte
                .byte $F6
z_asm_inc_zx:

xt_asm_inx:     ; inx \ INX
                jsr asm_0byte
                .byte $E8
z_asm_inx:

xt_asm_iny:     ; iny \ INY
                jsr asm_0byte
                .byte $C8
z_asm_iny:

xt_asm_jmp:     ; jmp \ JMP nnnn
                jsr asm_2byte
                .byte $4C
z_asm_jmp:

xt_asm_jmp_i:   ; jmp.i \ JMP (nnnn)
                jsr asm_2byte
                .byte $6C
z_asm_jmp_i:

xt_asm_jmp_xi:  ; jmp.xi \ JMP (nnnn,X)
                jsr asm_2byte
                .byte $7C
z_asm_jmp_xi:

xt_asm_jsr:     ; jsr \ JSR nnnn
                jsr asm_2byte
                .byte $20
z_asm_jsr:

xt_asm_lda:     ; lda \ LDA nnnn
                jsr asm_2byte
                .byte $AD
z_asm_lda:

xt_asm_lda_h:   ; lda.# \ LDA #nn
                jsr asm_1byte
                .byte $A9
z_asm_lda_h:

xt_asm_lda_x:   ; lda.x \ LDA nnnn,X
                jsr asm_2byte
                .byte $BD
z_asm_lda_x:

xt_asm_lda_y:   ; lda.y \ LDA nnnn,Y
                jsr asm_2byte
                .byte $B9
z_asm_lda_y:

xt_asm_lda_z:   ; lda.z \ LDA nn
                jsr asm_ubyte
                .byte $A5
z_asm_lda_z:

xt_asm_lda_zi:  ; lda.zi \ LDA (nn)
                jsr asm_ubyte
                .byte $B2
z_asm_lda_zi:

xt_asm_lda_ziy: ; lda.ziy \ LDA (nn),Y
                jsr asm_ubyte
                .byte $B1
z_asm_lda_ziy:

xt_asm_lda_zx:  ; lda.zx \ LDA nn,X
                jsr asm_ubyte
                .byte $B5
z_asm_lda_zx:

xt_asm_lda_zxi: ; lda.zxi \ LDA (nn,X)
                jsr asm_ubyte
                .byte $A1
z_asm_lda_zxi:

xt_asm_ldx:     ; ldx \ LDX nnnn
                jsr asm_2byte
                .byte $AE
z_asm_ldx:

xt_asm_ldx_h:   ; ldx.# \ LDX #nn
                jsr asm_1byte
                .byte $A2
z_asm_ldx_h:

xt_asm_ldx_y:   ; ldx.y \ LDX nnnn,Y
                jsr asm_2byte
                .byte $BE
z_asm_ldx_y:

xt_asm_ldx_z:   ; ldx.z \ LDX nn
                jsr asm_ubyte
                .byte $A6
z_asm_ldx_z:

xt_asm_ldx_zy:  ; ldx.zy \ LDX nn,Y
                jsr asm_ubyte
                .byte $B6
z_asm_ldx_zy:

xt_asm_ldy:     ; ldy \ LDY nnnn
                jsr asm_2byte
                .byte $AC
z_asm_ldy:

xt_asm_ldy_h:   ; ldy.# \ LDY #nn
                jsr asm_1byte
                .byte $A0
z_asm_ldy_h:

xt_asm_ldy_x:   ; ldy.x \ LDY nnnn,X
                jsr asm_2byte
                .byte $BC
z_asm_ldy_x:

xt_asm_ldy_z:   ; ldy.z \ LDY nn
                jsr asm_ubyte
                .byte $A4
z_asm_ldy_z:

xt_asm_ldy_zx:  ; ldy.zx \ LDY nn,X
                jsr asm_ubyte
                .byte $B4
z_asm_ldy_zx:

xt_asm_lsr:     ; lsr \ LSR nnnn
                jsr asm_2byte
                .byte $4E
z_asm_lsr:

xt_asm_lsr_a:   ; lsr.a \ LSR
                jsr asm_0byte
                .byte $4A
z_asm_lsr_a:

xt_asm_lsr_x:   ; lsr.x \ LSR nnnn,X
                jsr asm_2byte
                .byte $5E
z_asm_lsr_x:

xt_asm_lsr_z:   ; lsr.z \ LSR nn
                jsr asm_ubyte
                .byte $46
z_asm_lsr_z:

xt_asm_lsr_zx:  ; lsr.zx \ LSR nn,X
                jsr asm_ubyte
                .byte $56
z_asm_lsr_zx:

xt_asm_nop:     ; nop \ NOP
                jsr asm_0byte
                .byte $EA
z_asm_nop:

xt_asm_ora:     ; ora \ ORA nnnn
                jsr asm_2byte
                .byte $0D
z_asm_ora:

xt_asm_ora_h:   ; ora.# \ ORA #nn
                jsr asm_1byte
                .byte $09
z_asm_ora_h:

xt_asm_ora_x:   ; ora.x \ ORA nnnn,X
                jsr asm_2byte
                .byte $1D
z_asm_ora_x:

xt_asm_ora_y:   ; ora.y \ ORA nnnn,Y
                jsr asm_ubyte
                .byte $19
z_asm_ora_y:

xt_asm_ora_z:   ; ora.z \ ORA nn
                jsr asm_ubyte
                .byte $05
z_asm_ora_z:

xt_asm_ora_zi:  ; ora.zi \ ORA.ZI
                jsr asm_ubyte
                .byte $12
z_asm_ora_zi:

xt_asm_ora_ziy: ; ora.ziy \ ORA (nn),Y
                jsr asm_ubyte
                .byte $11
z_asm_ora_ziy:

xt_asm_ora_zx:  ; ora.zx \ ORA nn,X
                jsr asm_ubyte
                .byte $15
z_asm_ora_zx:

xt_asm_ora_zxi: ; ora.zxi \ ORA (nn,X)
                jsr asm_ubyte
                .byte $01
z_asm_ora_zxi:

xt_asm_pha:     ; pha \ PHA
                jsr asm_0byte
                .byte $48
z_asm_pha:

xt_asm_php:     ; php \ PHP
                jsr asm_0byte
                .byte $08
z_asm_php:

xt_asm_phx:     ; phx \ PHX
                jsr asm_0byte
                .byte $DA
z_asm_phx:

xt_asm_phy:     ; phy \ PHY
                jsr asm_0byte
                .byte $5A
z_asm_phy:

xt_asm_pla:     ; pla \ PLA
                jsr asm_0byte
                .byte $68
z_asm_pla:

xt_asm_plp:     ; plp \ PLP
                jsr asm_0byte
                .byte $28
z_asm_plp:

xt_asm_plx:     ; plx \ PLX
                jsr asm_0byte
                .byte $FA
z_asm_plx:

xt_asm_ply:     ; ply \ PLY
                jsr asm_0byte
                .byte $7A
z_asm_ply:

xt_asm_rol:     ; rol \ ROL nnnn
                jsr asm_2byte
                .byte $2E
z_asm_rol:

xt_asm_rol_a:   ; rol.a \ ROL
                jsr asm_0byte
                .byte $2A
z_asm_rol_a:

xt_asm_rol_x:   ; rol.x \ ROL nnnn,X
                jsr asm_2byte
                .byte $3E
z_asm_rol_x:

xt_asm_rol_z:   ; rol.z \ ROL nn
                jsr asm_ubyte
                .byte $26
z_asm_rol_z:

xt_asm_rol_zx:  ; rol.zx \ ROL nn,X
                jsr asm_ubyte
                .byte $36
z_asm_rol_zx:

xt_asm_ror:     ; ror \ ROR nnnn
                jsr asm_2byte
                .byte $6E
z_asm_ror:

xt_asm_ror_a:   ; ror.a \ ROR
                jsr asm_0byte
                .byte $6A
z_asm_ror_a:

xt_asm_ror_x:   ; ror.x \ ROR nnnn,X
                jsr asm_ubyte
                .byte $7E
z_asm_ror_x:

xt_asm_ror_z:   ; ror.z \ ROR nn
                jsr asm_ubyte
                .byte $66
z_asm_ror_z:

xt_asm_ror_zx:  ; ror.zx \ ROR nn,X
                jsr asm_ubyte
                .byte $76
z_asm_ror_zx:

xt_asm_rti:     ; rti \ RTI
                jsr asm_0byte
                .byte $40
z_asm_rti:

xt_asm_rts:     ; rts \ RTS
                jsr asm_0byte
                .byte $60
z_asm_rts:

xt_asm_sbc:     ; sbc \ SBC nnnn
                jsr asm_2byte
                .byte $ED
z_asm_sbc:

xt_asm_sbc_h:   ; sbc.# \ SBC #nn
                jsr asm_1byte
                .byte $E9
z_asm_sbc_h:

xt_asm_sbc_x:   ; sbc.x \ SBC nnnn,X
                jsr asm_2byte
                .byte $FD
z_asm_sbc_x:

xt_asm_sbc_y:   ; sbc.y \ SBC nnnn,Y
                jsr asm_2byte
                .byte $F9
z_asm_sbc_y:

xt_asm_sbc_z:   ; sbc.z \ SBC nn
                jsr asm_ubyte
                .byte $E5
z_asm_sbc_z:

xt_asm_sbc_zi:  ; sbc.zi \ SBC (nn)
                jsr asm_ubyte
                .byte $F2
z_asm_sbc_zi:

xt_asm_sbc_ziy: ; sbc.ziy \ SBC (nn),Y
                jsr asm_ubyte
                .byte $F1
z_asm_sbc_ziy:

xt_asm_sbc_zx:  ; sbc.zx \ SBC nn,X
                jsr asm_ubyte
                .byte $F5
z_asm_sbc_zx:

xt_asm_sbc_zxi: ; sbc.zxi \ SBC (nn,X)
                jsr asm_ubyte
                .byte $E1
z_asm_sbc_zxi:

xt_asm_sec:     ; sec \ SEC
                jsr asm_0byte
                .byte $38
z_asm_sec:

xt_asm_sed:     ; sed \ SED
                jsr asm_0byte
                .byte $F8
z_asm_sed:

xt_asm_sei:     ; sei \ SEI
                jsr asm_0byte
                .byte $78
z_asm_sei:

xt_asm_sta:     ; sta \ STA nnnn
                jsr asm_2byte
                .byte $8D
z_asm_sta:

xt_asm_sta_x:   ; sta.x \ STA nnnn,X
                jsr asm_2byte
                .byte $9D
z_asm_sta_x:

xt_asm_sta_y:   ; sta.y \ STA nnnn,Y
                jsr asm_2byte
                .byte $99
z_asm_sta_y:

xt_asm_sta_z:   ; sta.z \ STA nn
                jsr asm_ubyte
                .byte $85
z_asm_sta_z:

xt_asm_sta_zi:  ; sta.zi \ STA (nn)
                jsr asm_ubyte
                .byte $92
z_asm_sta_zi:

xt_asm_sta_ziy: ; sta.ziy \ STA (nn),Y
                jsr asm_ubyte
                .byte $91
z_asm_sta_ziy:

xt_asm_sta_zx:  ; sta.zx \ STA nn,X
                jsr asm_ubyte
                .byte $95
z_asm_sta_zx:

xt_asm_sta_zxi: ; sta.zxi \ STA (nn,X)
                jsr asm_ubyte
                .byte $81
z_asm_sta_zxi:

xt_asm_stx:     ; stx \ STX nnnn
                jsr asm_2byte
                .byte $8E
z_asm_stx:

xt_asm_stx_z:   ; stx.z \ STX nn
                jsr asm_ubyte
                .byte $86
z_asm_stx_z:

xt_asm_stx_zy:  ; stx.zy \ STX nn,Y
                jsr asm_ubyte
                .byte $96
z_asm_stx_zy:

xt_asm_sty:     ; sty \ STY nnnn
                jsr asm_2byte
                .byte $8C
z_asm_sty:

xt_asm_sty_z:   ; sty.z \ STY nn
                jsr asm_ubyte
                .byte $84
z_asm_sty_z:

xt_asm_sty_zx:  ; sty.zx \ STY nn,X
                jsr asm_ubyte
                .byte $94
z_asm_sty_zx:

xt_asm_stz:     ; stz \ STZ nnnn
                jsr asm_2byte
                .byte $9C
z_asm_stz:

xt_asm_stz_x:   ; stz.x \ STZ nnnn,X
                jsr asm_ubyte
                .byte $9E
z_asm_stz_x:

xt_asm_stz_z:   ; stz.z \ STZ nn
                jsr asm_ubyte
                .byte $64
z_asm_stz_z:

xt_asm_stz_zx:  ; stz.zx \ STZ nn,X
                jsr asm_ubyte
                .byte $74
z_asm_stz_zx:

xt_asm_tax:     ; tax \ TAX
                jsr asm_0byte
                .byte $AA
z_asm_tax:

xt_asm_tay:     ; tay \ TAY
                jsr asm_0byte
                .byte $A8
z_asm_tay:

xt_asm_trb:     ; trb \ TRB nnnn
                jsr asm_2byte
                .byte $1C
z_asm_trb:

xt_asm_trb_z:   ; trb.z \ TRB nn
                jsr asm_ubyte
                .byte $14
z_asm_trb_z:

xt_asm_tsb:     ; tsb \ TSB nnnn
                jsr asm_2byte
                .byte $0C
z_asm_tsb:

xt_asm_tsb_z:   ; tsb.z \ TSB nn
                jsr asm_ubyte
                .byte $04
z_asm_tsb_z:

xt_asm_tsx:     ; tsx \ TSX
                jsr asm_0byte
                .byte $BA
z_asm_tsx:

xt_asm_txa:     ; txa \ TXA
                jsr asm_0byte
                .byte $8A
z_asm_txa:

xt_asm_txs:     ; txs \ TXS
                jsr asm_0byte
                .byte $9A
z_asm_txs:

xt_asm_tya:     ; tya \ TYA
                jsr asm_0byte
                .byte $98
z_asm_tya:


; ==========================================================
; PSEUDO-INSTRUCTIONS AND MACROS

xt_asm_push_a:
        ; """push-a compiles code to put the content of the 65c02 Accumulator
        ; on the Forth data stack as the TOS.
        ; This is the inline version of PsuZA .
        ; """
        ; TODO if we have more than one pseudo-instruction like this, consider
        ; using a common loop for the various byte sequences
.scope
                jmp cmpl_PsuZA
z_asm_push_a:
.scend


; ==========================================================
; DIRECTIVES

; The "<J" directive (back jump) is a dummy instruction (syntactic sugar) to
; make clear that the JMP or JSR instructions are using the address that had
; been placed on the stack by "->" (the "arrow" directive).
xt_asm_back_jump:
z_asm_back_jump:
                rts
      
; The "<B" directive (back branch) takes an address that was placed on the Data
; Stack by the anonymous label directive "->" (the "arrow") and the current
; address (via HERE) to calculate a backward branch offset. This is then stored
; by a following branch instruction. 
xt_asm_back_branch:
                nop             ; so the disassembler skips it
                ; We arrive here with ( addr-l ) of the label on the stack and
                ; then subtract the current address
                jsr xt_here             ; ( addr-l addr-h )
                jsr xt_minus            ; ( offset )

                ; We subtract two more because of the branch instruction itself
                dec
                dec

z_asm_back_branch:
                rts

assembler_end:

; END
